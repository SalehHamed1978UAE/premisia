#!/usr/bin/env npx tsx
/**
 * Module Factory CLI
 * Creates all required files for a new module.
 *
 * Usage: npm run create-module
 */

import * as fs from 'fs';
import * as path from 'path';
import * as readline from 'readline';

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout,
});

function ask(question: string): Promise<string> {
  return new Promise((resolve) => rl.question(question, resolve));
}

function toCamelCase(str: string): string {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

function toPascalCase(str: string): string {
  const camel = toCamelCase(str);
  return camel.charAt(0).toUpperCase() + camel.slice(1);
}

function toSnakeCase(str: string): string {
  return str.replace(/-/g, '_');
}

async function main() {
  console.log('\nðŸ”§ Module Factory - Create a New Strategic Module\n');
  console.log('================================================\n');

  const moduleId = await ask('Module ID (kebab-case, e.g., "market-analysis-analyzer"): ');
  const displayName = await ask('Display Name (e.g., "Market Analysis"): ');
  const description = await ask('Description: ');
  const category = await ask('Category (Strategy/Growth/Competition/Customer/Operations/Execution): ');
  const duration = await ask('Estimated Duration (minutes): ');
  const difficulty = await ask('Difficulty (beginner/intermediate/advanced): ');
  const moduleType = await ask('Module Type (ai_analyzer/user_input/generator): ');

  const basePath = path.resolve(__dirname, '..');
  const frameworkKey = toSnakeCase(moduleId.replace(/-analyzer$/, '').replace(/-generator$/, ''));

  // Map moduleType (execution type) to type (manifest type)
  const typeMap: Record<string, string> = {
    'ai_analyzer': 'analyzer',
    'user_input': 'user-input',
    'generator': 'generator',
    'internal': 'processor',
  };
  const manifestType = typeMap[moduleType] || 'analyzer';

  // 1. Create manifest
  const manifestContent = `/**
 * ${displayName} Manifest
 * Auto-generated by Module Factory - ${new Date().toISOString()}
 */

import type { ModuleManifest } from '../manifest';

export const ${toCamelCase(moduleId)}Manifest: ModuleManifest = {
  id: '${moduleId}',
  name: '${displayName}',
  version: '1.0.0',
  description: '${description}',
  moduleType: '${moduleType}',
  category: '${category}',
  icon: 'chart-bar',
  status: 'implemented',
  type: '${manifestType}',
  inputs: [
    {
      id: 'context',
      name: 'strategicContext',
      type: 'strategic_context',
      required: true,
      description: 'Strategic context from previous steps',
    },
  ],
  outputs: [
    {
      id: 'output',
      name: '${toCamelCase(moduleId)}Output',
      type: '${frameworkKey}_output',
      required: true,
      description: '${displayName} results',
    },
  ],
  requires: [],
  estimatedDuration: ${duration},
  difficulty: '${difficulty}',
  isActive: true,
};
`;

  const manifestDir = path.join(basePath, 'server/modules/manifests');
  if (!fs.existsSync(manifestDir)) fs.mkdirSync(manifestDir, { recursive: true });

  const manifestPath = path.join(manifestDir, `${moduleId}.ts`);
  fs.writeFileSync(manifestPath, manifestContent);
  console.log(`âœ“ Created manifest: ${manifestPath}`);

  // 2. Create implementation (for ai_analyzer type)
  if (moduleType === 'ai_analyzer') {
    const implContent = `/**
 * ${displayName}
 * Auto-generated by Module Factory - ${new Date().toISOString()}
 */

import { aiClients } from '../ai-clients';

export class ${toPascalCase(moduleId)} {
  async analyze(input: { context: any }): Promise<any> {
    console.log('[${moduleId}] Starting analysis...');

    const prompt = \`
Analyze the following strategic context using ${displayName} methodology:

\${JSON.stringify(input.context, null, 2)}

Return a structured JSON analysis with relevant insights.
    \`;

    const response = await aiClients.callWithFallback({
      systemPrompt: 'You are a strategic analysis expert specializing in ${displayName}. Return only valid JSON.',
      userMessage: prompt,
      maxTokens: 4000,
    });

    const result = JSON.parse(response.content);
    console.log('[${moduleId}] Analysis complete');
    return result;
  }
}

export const ${toCamelCase(moduleId)} = new ${toPascalCase(moduleId)}();
`;

    const implDir = path.join(basePath, 'server/intelligence');
    if (!fs.existsSync(implDir)) fs.mkdirSync(implDir, { recursive: true });

    const implPath = path.join(implDir, `${moduleId}.ts`);
    fs.writeFileSync(implPath, implContent);
    console.log(`âœ“ Created implementation: ${implPath}`);
  }

  // 3. Update manifest index
  const indexPath = path.join(basePath, 'server/modules/manifests/index.ts');
  if (fs.existsSync(indexPath)) {
    let indexContent = fs.readFileSync(indexPath, 'utf-8');

    const importLine = `import { ${toCamelCase(moduleId)}Manifest } from './${moduleId}';`;
    if (!indexContent.includes(importLine)) {
      const lines = indexContent.split('\n');
      // Find the last import line (reverse search for compatibility)
      let lastImportIdx = -1;
      for (let i = lines.length - 1; i >= 0; i--) {
        if (lines[i].startsWith('import')) {
          lastImportIdx = i;
          break;
        }
      }
      lines.splice(lastImportIdx + 1, 0, importLine);
      indexContent = lines.join('\n');
    }

    if (!indexContent.includes(`${toCamelCase(moduleId)}Manifest`)) {
      indexContent = indexContent.replace(
        /export const allManifests\s*=\s*\[/,
        `export const allManifests = [\n  ${toCamelCase(moduleId)}Manifest,`
      );
    }

    fs.writeFileSync(indexPath, indexContent);
    console.log(`âœ“ Updated manifest index: ${indexPath}`);
  }

  // 4. Update ID mapping
  const mappingPath = path.join(basePath, 'server/modules/id-mapping.ts');
  if (fs.existsSync(mappingPath)) {
    let mappingContent = fs.readFileSync(mappingPath, 'utf-8');

    const mappingLine = `  '${frameworkKey}': '${moduleId}',`;
    if (!mappingContent.includes(mappingLine)) {
      mappingContent = mappingContent.replace(
        /export const FRAMEWORK_KEY_TO_MODULE_ID[^{]*{/,
        `export const FRAMEWORK_KEY_TO_MODULE_ID: Record<string, string> = {\n${mappingLine}`
      );
      fs.writeFileSync(mappingPath, mappingContent);
      console.log(`âœ“ Updated ID mapping: ${mappingPath}`);
    }
  }

  // 5. Add to seed (print instruction)
  console.log(`\nâš ï¸  Manual step required:`);
  console.log(`   Add this entry to FRAMEWORKS array in server/journey-builder-seed.ts:\n`);
  console.log(`  {
    frameworkKey: '${frameworkKey}',
    name: '${displayName}',
    description: '${description}',
    category: '${category}',
    estimatedDuration: ${duration},
    difficulty: '${difficulty}' as const,
    requiredInputs: ['strategic_context'],
    providedOutputs: ['${frameworkKey}_output'],
    processorPath: '/api/frameworks/${moduleId}',
  },`);

  console.log('\nâœ… Module scaffolding complete!\n');
  console.log('Next steps:');
  console.log(`  1. ${moduleType === 'ai_analyzer' ? `Implement analyze() in server/intelligence/${moduleId}.ts` : 'Create the UI component'}`);
  console.log('  2. Add the entry to journey-builder-seed.ts (shown above)');
  console.log('  3. Run: npx tsx server/journey-builder-seed.ts');
  console.log('  4. Run: npx tsx scripts/validate-modules.ts');
  console.log('  5. Restart the server\n');

  rl.close();
}

main().catch((err) => {
  console.error('Error:', err);
  rl.close();
  process.exit(1);
});
