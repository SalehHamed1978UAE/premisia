var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc21) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc21 = __getOwnPropDesc(from, key)) || desc21.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// server/utils/encryption.ts
var encryption_exports = {};
__export(encryption_exports, {
  decrypt: () => decrypt,
  decryptJSON: () => decryptJSON,
  encrypt: () => encrypt,
  encryptJSON: () => encryptJSON,
  isEncrypted: () => isEncrypted,
  validateEncryptionKey: () => validateEncryptionKey
});
import crypto from "crypto";
function getEncryptionKey() {
  const key = process.env.ENCRYPTION_KEY;
  if (!key) {
    throw new Error(`ENCRYPTION_KEY environment variable not set. Generate one with: node -e "console.log(require('crypto').randomBytes(32).toString('base64'))"`);
  }
  try {
    return Buffer.from(key, "base64");
  } catch (error) {
    throw new Error("Invalid ENCRYPTION_KEY format. Must be base64 encoded.");
  }
}
function encrypt(text2) {
  if (!text2) return null;
  try {
    const iv = crypto.randomBytes(IV_LENGTH);
    const key = getEncryptionKey();
    const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
    let encrypted = cipher.update(text2, "utf8");
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    const authTag = cipher.getAuthTag();
    return iv.toString("base64") + ":" + authTag.toString("base64") + ":" + encrypted.toString("base64");
  } catch (error) {
    console.error("Encryption error:", error);
    throw new Error("Failed to encrypt data");
  }
}
function decrypt(encryptedData) {
  if (!encryptedData) return null;
  if (!isEncrypted(encryptedData)) {
    return encryptedData;
  }
  try {
    const parts = encryptedData.split(":");
    if (parts.length !== 3) {
      console.warn("Invalid encrypted data format - returning as-is (backward compatibility)");
      return encryptedData;
    }
    const iv = Buffer.from(parts[0], "base64");
    const authTag = Buffer.from(parts[1], "base64");
    const encrypted = Buffer.from(parts[2], "base64");
    const key = getEncryptionKey();
    const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
    decipher.setAuthTag(authTag);
    let decrypted = decipher.update(encrypted);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString("utf8");
  } catch (error) {
    console.warn("Decryption failed, treating as unencrypted legacy data:", error);
    return encryptedData;
  }
}
function encryptJSON(obj) {
  if (!obj) return null;
  return encrypt(JSON.stringify(obj));
}
function decryptJSON(encryptedData) {
  if (!encryptedData) return null;
  const decrypted = decrypt(encryptedData);
  if (!decrypted) return null;
  try {
    return JSON.parse(decrypted);
  } catch (error) {
    console.error("Error parsing decrypted JSON:", error);
    return null;
  }
}
function isEncrypted(data) {
  if (!data) return false;
  const parts = data.split(":");
  if (parts.length !== 3) return false;
  try {
    const iv = Buffer.from(parts[0], "base64");
    const authTag = Buffer.from(parts[1], "base64");
    const encrypted = Buffer.from(parts[2], "base64");
    return iv.length === IV_LENGTH && authTag.length === TAG_LENGTH && encrypted.length > 0;
  } catch (error) {
    return false;
  }
}
function validateEncryptionKey() {
  try {
    const key = getEncryptionKey();
    if (key.length !== KEY_LENGTH) {
      throw new Error(`Encryption key must be ${KEY_LENGTH} bytes (256 bits). Current length: ${key.length}`);
    }
    const testData = "encryption-test";
    const encrypted = encrypt(testData);
    const decrypted = decrypt(encrypted);
    if (decrypted !== testData) {
      throw new Error("Encryption key validation failed - encrypt/decrypt cycle did not match");
    }
    console.log("\u2705 Encryption key validated successfully");
  } catch (error) {
    console.error("\u274C Encryption key validation failed:", error);
    throw error;
  }
}
var ALGORITHM, IV_LENGTH, TAG_LENGTH, KEY_LENGTH;
var init_encryption = __esm({
  "server/utils/encryption.ts"() {
    "use strict";
    ALGORITHM = "aes-256-gcm";
    IV_LENGTH = 16;
    TAG_LENGTH = 16;
    KEY_LENGTH = 32;
  }
});

// shared/schema.ts
var schema_exports = {};
__export(schema_exports, {
  aiProviderSchema: () => aiProviderSchema,
  approvalStatusEnum: () => approvalStatusEnum,
  assignmentResourceTypeEnum: () => assignmentResourceTypeEnum,
  assignmentSourceEnum: () => assignmentSourceEnum,
  authoritySourceCountries: () => authoritySourceCountries,
  authoritySourceIndustries: () => authoritySourceIndustries,
  authoritySourceLanguages: () => authoritySourceLanguages,
  authoritySources: () => authoritySources,
  backgroundJobs: () => backgroundJobs,
  benefitStatusEnum: () => benefitStatusEnum,
  benefits: () => benefits,
  benefitsRelations: () => benefitsRelations,
  betaUsageCounters: () => betaUsageCounters,
  bmcAnalyses: () => bmcAnalyses,
  bmcBlockTypeEnum: () => bmcBlockTypeEnum,
  bmcBlocks: () => bmcBlocks,
  bmcConfidenceEnum: () => bmcConfidenceEnum,
  bmcFindings: () => bmcFindings,
  builderResponseSchema: () => builderResponseSchema,
  clarificationSessions: () => clarificationSessions,
  codeArtifactSchema: () => codeArtifactSchema,
  companyStageEnum: () => companyStageEnum,
  confidenceLevelEnum: () => confidenceLevelEnum,
  confidenceLevelWorkspaceEnum: () => confidenceLevelWorkspaceEnum,
  customJourneyConfigs: () => customJourneyConfigs,
  customJourneyExecutionStatusEnum: () => customJourneyExecutionStatusEnum,
  customJourneyExecutions: () => customJourneyExecutions,
  customJourneyStatusEnum: () => customJourneyStatusEnum,
  decisionLogSchema: () => decisionLogSchema,
  difficultyEnum: () => difficultyEnum,
  discoveredByEnum: () => discoveredByEnum,
  entityTypeEnum: () => entityTypeEnum,
  entityTypeWorkspaceEnum: () => entityTypeWorkspaceEnum,
  epmPrograms: () => epmPrograms,
  epmStatusEnum: () => epmStatusEnum,
  executionPlanStatusEnum: () => executionPlanStatusEnum,
  expenses: () => expenses,
  frameworkInsights: () => frameworkInsights,
  frameworkNameEnum: () => frameworkNameEnum,
  frameworkRegistry: () => frameworkRegistry,
  frameworkRunStatusEnum: () => frameworkRunStatusEnum,
  frameworkSelections: () => frameworkSelections,
  frameworkTypeEnum: () => frameworkTypeEnum,
  fundingSources: () => fundingSources,
  gateStatusEnum: () => gateStatusEnum,
  goDecisionEnum: () => goDecisionEnum,
  goldenRecordChecks: () => goldenRecordChecks,
  goldenRecords: () => goldenRecords,
  gtmConstraintEnum: () => gtmConstraintEnum,
  initiativeTypeEnum: () => initiativeTypeEnum,
  insertAuthoritySourceCountrySchema: () => insertAuthoritySourceCountrySchema,
  insertAuthoritySourceIndustrySchema: () => insertAuthoritySourceIndustrySchema,
  insertAuthoritySourceLanguageSchema: () => insertAuthoritySourceLanguageSchema,
  insertAuthoritySourceSchema: () => insertAuthoritySourceSchema,
  insertBMCAnalysisSchema: () => insertBMCAnalysisSchema,
  insertBMCBlockSchema: () => insertBMCBlockSchema,
  insertBMCFindingSchema: () => insertBMCFindingSchema,
  insertBackgroundJobSchema: () => insertBackgroundJobSchema,
  insertBenefitSchema: () => insertBenefitSchema,
  insertBetaUsageCounterSchema: () => insertBetaUsageCounterSchema,
  insertClarificationSessionSchema: () => insertClarificationSessionSchema,
  insertCustomJourneyConfigSchema: () => insertCustomJourneyConfigSchema,
  insertCustomJourneyExecutionSchema: () => insertCustomJourneyExecutionSchema,
  insertEpmProgramSchema: () => insertEpmProgramSchema,
  insertExpenseSchema: () => insertExpenseSchema,
  insertFrameworkInsightSchema: () => insertFrameworkInsightSchema,
  insertFrameworkRegistrySchema: () => insertFrameworkRegistrySchema,
  insertFrameworkSelectionSchema: () => insertFrameworkSelectionSchema,
  insertFundingSourceSchema: () => insertFundingSourceSchema,
  insertGoldenRecordCheckSchema: () => insertGoldenRecordCheckSchema,
  insertGoldenRecordSchema: () => insertGoldenRecordSchema,
  insertJourneySessionSchema: () => insertJourneySessionSchema,
  insertJourneyTemplateSchema: () => insertJourneyTemplateSchema,
  insertKpiMeasurementSchema: () => insertKpiMeasurementSchema,
  insertKpiSchema: () => insertKpiSchema,
  insertLocationSchema: () => insertLocationSchema,
  insertOntologyCascadeImpactSchema: () => insertOntologyCascadeImpactSchema,
  insertOntologyCompletenessCheckSchema: () => insertOntologyCompletenessCheckSchema,
  insertOntologyDomainTermSchema: () => insertOntologyDomainTermSchema,
  insertOntologyEntitySchema: () => insertOntologyEntitySchema,
  insertOntologyFrameworkMappingSchema: () => insertOntologyFrameworkMappingSchema,
  insertOntologyRelationshipSchema: () => insertOntologyRelationshipSchema,
  insertOntologyValidationRuleSchema: () => insertOntologyValidationRuleSchema,
  insertProgramSchema: () => insertProgramSchema,
  insertReferenceSchema: () => insertReferenceSchema,
  insertResearchBatchSchema: () => insertResearchBatchSchema,
  insertResourceSchema: () => insertResourceSchema,
  insertRiskMitigationSchema: () => insertRiskMitigationSchema,
  insertRiskSchema: () => insertRiskSchema,
  insertSegmentDiscoveryResultSchema: () => insertSegmentDiscoveryResultSchema,
  insertSessionContextSchema: () => insertSessionContextSchema,
  insertStageGateReviewSchema: () => insertStageGateReviewSchema,
  insertStageGateSchema: () => insertStageGateSchema,
  insertStrategicDecisionSchema: () => insertStrategicDecisionSchema,
  insertStrategicEntitySchema: () => insertStrategicEntitySchema,
  insertStrategicRelationshipSchema: () => insertStrategicRelationshipSchema,
  insertStrategicUnderstandingSchema: () => insertStrategicUnderstandingSchema,
  insertStrategyDecisionSchema: () => insertStrategyDecisionSchema,
  insertStrategyInsightSchema: () => insertStrategyInsightSchema,
  insertStrategyVersionSchema: () => insertStrategyVersionSchema,
  insertSwApprovalSchema: () => insertSwApprovalSchema,
  insertSwAttachmentSchema: () => insertSwAttachmentSchema,
  insertSwAuditLogSchema: () => insertSwAuditLogSchema,
  insertSwComparisonSchema: () => insertSwComparisonSchema,
  insertSwExecutionPlanSchema: () => insertSwExecutionPlanSchema,
  insertSwFrameworkRunSchema: () => insertSwFrameworkRunSchema,
  insertSwJourneyStateSchema: () => insertSwJourneyStateSchema,
  insertSwProblemSchema: () => insertSwProblemSchema,
  insertSwStrategySchema: () => insertSwStrategySchema,
  insertTaskAssignmentSchema: () => insertTaskAssignmentSchema,
  insertTaskDependencySchema: () => insertTaskDependencySchema,
  insertTaskSchema: () => insertTaskSchema,
  insertTrendAnalysisJobSchema: () => insertTrendAnalysisJobSchema,
  insertTrendClaimsCacheSchema: () => insertTrendClaimsCacheSchema,
  insertUserJourneySchema: () => insertUserJourneySchema,
  insertUserSchema: () => insertUserSchema,
  insertWorkstreamSchema: () => insertWorkstreamSchema,
  jobStatusEnum: () => jobStatusEnum,
  jobTypeEnum: () => jobTypeEnum,
  journeyNodeStatusEnum: () => journeyNodeStatusEnum,
  journeySessions: () => journeySessions,
  journeyStatusEnum: () => journeyStatusEnum,
  journeyTemplates: () => journeyTemplates,
  journeyTypeEnum: () => journeyTypeEnum,
  kpiMeasurements: () => kpiMeasurements,
  kpis: () => kpis,
  kpisRelations: () => kpisRelations,
  locations: () => locations,
  offeringTypeEnum: () => offeringTypeEnum,
  ontologyCascadeImpacts: () => ontologyCascadeImpacts,
  ontologyCompletenessChecks: () => ontologyCompletenessChecks,
  ontologyDomainTerms: () => ontologyDomainTerms,
  ontologyEntities: () => ontologyEntities,
  ontologyFrameworkMappings: () => ontologyFrameworkMappings,
  ontologyRelationships: () => ontologyRelationships,
  ontologyValidationRules: () => ontologyValidationRules,
  orchestratorResponseSchema: () => orchestratorResponseSchema,
  orchestratorTaskSchema: () => orchestratorTaskSchema,
  problemStatusEnum: () => problemStatusEnum,
  programs: () => programs,
  programsRelations: () => programsRelations,
  qaIssueSchema: () => qaIssueSchema,
  qaReviewSchema: () => qaReviewSchema,
  referenceOriginEnum: () => referenceOriginEnum,
  referenceSourceTypeEnum: () => referenceSourceTypeEnum,
  references: () => references,
  relationshipTypeEnum: () => relationshipTypeEnum,
  requirementFulfillmentSchema: () => requirementFulfillmentSchema,
  researchBatchStatusEnum: () => researchBatchStatusEnum,
  researchBatches: () => researchBatches,
  resources: () => resources,
  resourcesRelations: () => resourcesRelations,
  riskImpactEnum: () => riskImpactEnum,
  riskLikelihoodEnum: () => riskLikelihoodEnum,
  riskMitigations: () => riskMitigations,
  riskPriorityEnum: () => riskPriorityEnum,
  riskProfileEnum: () => riskProfileEnum,
  riskStatusEnum: () => riskStatusEnum,
  riskToleranceEnum: () => riskToleranceEnum,
  risks: () => risks,
  risksRelations: () => risksRelations,
  roleEnum: () => roleEnum,
  salesMotionEnum: () => salesMotionEnum,
  segmentDiscoveryResults: () => segmentDiscoveryResults,
  segmentFlagEnum: () => segmentFlagEnum,
  sessionContext: () => sessionContext,
  sessions: () => sessions,
  stageGateReviews: () => stageGateReviews,
  stageGates: () => stageGates,
  stageGatesRelations: () => stageGatesRelations,
  strategicDecisions: () => strategicDecisions,
  strategicEntities: () => strategicEntities,
  strategicRelationships: () => strategicRelationships,
  strategicUnderstanding: () => strategicUnderstanding,
  strategyDecisions: () => strategyDecisions,
  strategyInsights: () => strategyInsights,
  strategyStatusEnum: () => strategyStatusEnum,
  strategyVersions: () => strategyVersions,
  strategyWorkspaceStatusEnum: () => strategyWorkspaceStatusEnum,
  swApprovals: () => swApprovals,
  swAttachments: () => swAttachments,
  swAuditLog: () => swAuditLog,
  swExecutionPlans: () => swExecutionPlans,
  swFrameworkRuns: () => swFrameworkRuns,
  swJourneyStates: () => swJourneyStates,
  swProblems: () => swProblems,
  swStrategies: () => swStrategies,
  swStrategyComparisons: () => swStrategyComparisons,
  swStrategyVersions: () => swStrategyVersions,
  taskAssignments: () => taskAssignments,
  taskDependencies: () => taskDependencies,
  taskStatusEnum: () => taskStatusEnum,
  tasks: () => tasks,
  tasksRelations: () => tasksRelations,
  timelinePreferenceEnum: () => timelinePreferenceEnum,
  trendAnalysisJobs: () => trendAnalysisJobs,
  trendClaimsCache: () => trendClaimsCache,
  userJourneyStatusEnum: () => userJourneyStatusEnum,
  userJourneys: () => userJourneys,
  users: () => users,
  usersRelations: () => usersRelations,
  workstreams: () => workstreams,
  workstreamsRelations: () => workstreamsRelations
});
import { sql } from "drizzle-orm";
import { pgTable, text, varchar, integer, timestamp, decimal, boolean, pgEnum, jsonb, index, vector, primaryKey, unique, date } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
var roleEnum, taskStatusEnum, riskStatusEnum, riskLikelihoodEnum, riskImpactEnum, riskPriorityEnum, gateStatusEnum, benefitStatusEnum, strategyStatusEnum, bmcBlockTypeEnum, bmcConfidenceEnum, frameworkTypeEnum, initiativeTypeEnum, entityTypeEnum, relationshipTypeEnum, confidenceLevelEnum, discoveredByEnum, journeyTypeEnum, journeyStatusEnum, frameworkNameEnum, riskToleranceEnum, timelinePreferenceEnum, goDecisionEnum, epmStatusEnum, difficultyEnum, userJourneyStatusEnum, jobStatusEnum, jobTypeEnum, researchBatchStatusEnum, assignmentSourceEnum, assignmentResourceTypeEnum, referenceSourceTypeEnum, referenceOriginEnum, offeringTypeEnum, companyStageEnum, gtmConstraintEnum, salesMotionEnum, segmentFlagEnum, sessions, users, locations, programs, workstreams, resources, stageGates, stageGateReviews, tasks, taskDependencies, kpis, kpiMeasurements, risks, riskMitigations, benefits, fundingSources, expenses, ontologyEntities, ontologyRelationships, ontologyValidationRules, ontologyCompletenessChecks, ontologyCascadeImpacts, ontologyDomainTerms, ontologyFrameworkMappings, sessionContext, strategyVersions, strategicDecisions, strategyInsights, frameworkSelections, strategicUnderstanding, journeySessions, references, strategyDecisions, epmPrograms, taskAssignments, strategicEntities, strategicRelationships, authoritySources, authoritySourceIndustries, authoritySourceCountries, authoritySourceLanguages, trendClaimsCache, trendAnalysisJobs, frameworkInsights, bmcAnalyses, bmcBlocks, bmcFindings, segmentDiscoveryResults, betaUsageCounters, usersRelations, programsRelations, workstreamsRelations, resourcesRelations, stageGatesRelations, tasksRelations, kpisRelations, risksRelations, benefitsRelations, insertUserSchema, insertLocationSchema, insertProgramSchema, insertWorkstreamSchema, insertResourceSchema, insertStageGateSchema, insertStageGateReviewSchema, insertTaskSchema, insertTaskDependencySchema, insertKpiSchema, insertKpiMeasurementSchema, insertRiskSchema, insertRiskMitigationSchema, insertBenefitSchema, insertFundingSourceSchema, insertExpenseSchema, insertOntologyEntitySchema, insertOntologyRelationshipSchema, insertOntologyValidationRuleSchema, insertOntologyCompletenessCheckSchema, insertOntologyCascadeImpactSchema, insertOntologyDomainTermSchema, insertOntologyFrameworkMappingSchema, insertSessionContextSchema, insertStrategyVersionSchema, insertStrategicDecisionSchema, insertStrategyInsightSchema, insertFrameworkSelectionSchema, insertBMCAnalysisSchema, insertBMCBlockSchema, insertBMCFindingSchema, insertStrategicUnderstandingSchema, insertJourneySessionSchema, insertReferenceSchema, insertStrategyDecisionSchema, insertEpmProgramSchema, insertTaskAssignmentSchema, insertStrategicEntitySchema, insertStrategicRelationshipSchema, insertAuthoritySourceSchema, insertAuthoritySourceIndustrySchema, insertAuthoritySourceCountrySchema, insertAuthoritySourceLanguageSchema, insertTrendClaimsCacheSchema, insertTrendAnalysisJobSchema, insertFrameworkInsightSchema, insertSegmentDiscoveryResultSchema, insertBetaUsageCounterSchema, aiProviderSchema, codeArtifactSchema, requirementFulfillmentSchema, decisionLogSchema, builderResponseSchema, qaIssueSchema, qaReviewSchema, orchestratorTaskSchema, orchestratorResponseSchema, problemStatusEnum, strategyWorkspaceStatusEnum, frameworkRunStatusEnum, executionPlanStatusEnum, riskProfileEnum, confidenceLevelWorkspaceEnum, approvalStatusEnum, entityTypeWorkspaceEnum, swProblems, swStrategies, swFrameworkRuns, swExecutionPlans, swStrategyVersions, swJourneyStates, swApprovals, swAttachments, swStrategyComparisons, swAuditLog, journeyTemplates, userJourneys, frameworkRegistry, backgroundJobs, researchBatches, goldenRecords, goldenRecordChecks, clarificationSessions, customJourneyStatusEnum, customJourneyExecutionStatusEnum, journeyNodeStatusEnum, customJourneyConfigs, customJourneyExecutions, insertSwProblemSchema, insertSwStrategySchema, insertSwFrameworkRunSchema, insertSwExecutionPlanSchema, insertSwJourneyStateSchema, insertSwApprovalSchema, insertSwAttachmentSchema, insertSwComparisonSchema, insertSwAuditLogSchema, insertJourneyTemplateSchema, insertUserJourneySchema, insertFrameworkRegistrySchema, insertBackgroundJobSchema, insertResearchBatchSchema, insertGoldenRecordSchema, insertGoldenRecordCheckSchema, insertClarificationSessionSchema, insertCustomJourneyConfigSchema, insertCustomJourneyExecutionSchema;
var init_schema = __esm({
  "shared/schema.ts"() {
    "use strict";
    roleEnum = pgEnum("role", ["Admin", "Editor", "Viewer"]);
    taskStatusEnum = pgEnum("task_status", ["Not Started", "In Progress", "Completed", "On Hold", "At Risk", "Delayed"]);
    riskStatusEnum = pgEnum("risk_status", ["Open", "Mitigated", "Closed", "Monitoring"]);
    riskLikelihoodEnum = pgEnum("risk_likelihood", ["Rare", "Unlikely", "Possible", "Likely", "Certain"]);
    riskImpactEnum = pgEnum("risk_impact", ["Very Low", "Low", "Medium", "High", "Very High"]);
    riskPriorityEnum = pgEnum("risk_priority", ["Low", "Medium", "High", "Critical"]);
    gateStatusEnum = pgEnum("gate_status", ["Pending", "In Review", "Passed", "Failed", "On Hold"]);
    benefitStatusEnum = pgEnum("benefit_status", ["Not Started", "In Progress", "Realized", "At Risk"]);
    strategyStatusEnum = pgEnum("strategy_status", ["draft", "finalized", "converting", "converted_to_program"]);
    bmcBlockTypeEnum = pgEnum("bmc_block_type", [
      "customer_segments",
      "value_propositions",
      "revenue_streams",
      "channels",
      "customer_relationships",
      "key_resources",
      "key_activities",
      "key_partnerships",
      "cost_structure"
    ]);
    bmcConfidenceEnum = pgEnum("bmc_confidence", ["weak", "moderate", "strong"]);
    frameworkTypeEnum = pgEnum("framework_type", ["porters_five_forces", "business_model_canvas", "user_choice"]);
    initiativeTypeEnum = pgEnum("initiative_type", [
      "physical_business_launch",
      // Opening coffee shop, restaurant, retail store
      "software_development",
      // Building SaaS, mobile app, platform
      "digital_transformation",
      // Adding digital capabilities to existing business
      "market_expansion",
      // Expanding existing business to new markets
      "product_launch",
      // Launching new product line
      "service_launch",
      // Launching new service offering
      "process_improvement",
      // Operational efficiency, restructuring
      "other"
      // Catch-all
    ]);
    entityTypeEnum = pgEnum("entity_type", [
      "explicit_assumption",
      "implicit_implication",
      "inferred_reasoning",
      "research_finding",
      "business_model_gap",
      "root_cause",
      "competitive_force",
      "risk",
      "opportunity",
      "constraint"
    ]);
    relationshipTypeEnum = pgEnum("relationship_type", [
      "contradicts",
      "supports",
      "implies",
      "causes",
      "blocks",
      "enables",
      "validates",
      "challenges",
      "relates_to"
    ]);
    confidenceLevelEnum = pgEnum("confidence_level", ["high", "medium", "low"]);
    discoveredByEnum = pgEnum("discovered_by", [
      "user_input",
      "bmc_agent",
      "5whys_agent",
      "porters_agent",
      "trends_agent",
      "system"
    ]);
    journeyTypeEnum = pgEnum("journey_type", [
      "market_entry",
      "business_model_innovation",
      "competitive_strategy",
      "digital_transformation",
      "crisis_recovery",
      "growth_strategy",
      "custom"
    ]);
    journeyStatusEnum = pgEnum("journey_status", [
      "queued",
      "initializing",
      "in_progress",
      "paused",
      "completed",
      "failed"
    ]);
    frameworkNameEnum = pgEnum("framework_name", [
      "five_whys",
      "bmc",
      "porters",
      "pestle",
      "swot",
      "ansoff",
      "blue_ocean"
    ]);
    riskToleranceEnum = pgEnum("risk_tolerance", ["conservative", "balanced", "aggressive"]);
    timelinePreferenceEnum = pgEnum("timeline_preference", ["fast_growth", "sustainable_pace", "deliberate"]);
    goDecisionEnum = pgEnum("go_decision", ["proceed", "pivot", "abandon"]);
    epmStatusEnum = pgEnum("epm_status", ["draft", "finalized"]);
    difficultyEnum = pgEnum("difficulty", ["beginner", "intermediate", "advanced"]);
    userJourneyStatusEnum = pgEnum("user_journey_status", ["in_progress", "completed", "paused", "abandoned"]);
    jobStatusEnum = pgEnum("job_status", ["pending", "running", "completed", "failed"]);
    jobTypeEnum = pgEnum("job_type", [
      "epm_generation",
      "bmc_analysis",
      "five_whys_generation",
      "porters_analysis",
      "pestle_analysis",
      "web_research",
      "strategic_understanding",
      "document_enrichment",
      "journey_execution",
      "framework_execution",
      "research_enrichment"
    ]);
    researchBatchStatusEnum = pgEnum("research_batch_status", ["captured", "enriched", "failed"]);
    assignmentSourceEnum = pgEnum("assignment_source", ["ai_generated", "manual", "bulk_import"]);
    assignmentResourceTypeEnum = pgEnum("assignment_resource_type", ["internal_team", "external_resource"]);
    referenceSourceTypeEnum = pgEnum("reference_source_type", ["article", "report", "document", "dataset", "manual_entry"]);
    referenceOriginEnum = pgEnum("reference_origin", ["web_search", "manual_upload", "document_extract", "manual_entry"]);
    offeringTypeEnum = pgEnum("offering_type", [
      "b2b_software",
      "b2c_software",
      "professional_services",
      "physical_product",
      "marketplace_platform",
      "content_education",
      "other"
    ]);
    companyStageEnum = pgEnum("company_stage", [
      "idea_stage",
      "built_no_users",
      "early_users",
      "growing",
      "scaling"
    ]);
    gtmConstraintEnum = pgEnum("gtm_constraint", [
      "solo_founder",
      "small_team",
      "funded_startup",
      "established_company"
    ]);
    salesMotionEnum = pgEnum("sales_motion", [
      "self_serve",
      "light_touch",
      "enterprise",
      "partner_channel"
    ]);
    segmentFlagEnum = pgEnum("segment_flag", [
      "high_potential",
      "worth_exploring",
      "deprioritize"
    ]);
    sessions = pgTable(
      "sessions",
      {
        sid: varchar("sid").primaryKey(),
        sess: jsonb("sess").notNull(),
        expire: timestamp("expire").notNull()
      },
      (table) => [index("IDX_session_expire").on(table.expire)]
    );
    users = pgTable("users", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      email: varchar("email").unique(),
      role: roleEnum("role").notNull().default("Viewer"),
      createdAt: timestamp("created_at").defaultNow(),
      firstName: varchar("first_name"),
      lastName: varchar("last_name"),
      profileImageUrl: varchar("profile_image_url"),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    locations = pgTable("locations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      rawQuery: text("raw_query").notNull(),
      // Original query (e.g., "Portland")
      displayName: text("display_name").notNull(),
      // Full name (e.g., "Portland, Oregon, USA")
      lat: decimal("lat", { precision: 10, scale: 7 }).notNull(),
      lon: decimal("lon", { precision: 10, scale: 7 }).notNull(),
      countryCode: varchar("country_code", { length: 2 }).notNull(),
      // ISO 3166-1 alpha-2
      adminLevels: jsonb("admin_levels"),
      // { country, state, county, city }
      createdAt: timestamp("created_at").defaultNow(),
      // Manual entry fields
      isManualEntry: boolean("is_manual_entry").default(false),
      validationStatus: varchar("validation_status"),
      // "validated", "unvalidated", "failed"
      originalUserInput: text("original_user_input")
    });
    programs = pgTable("programs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      ownerId: varchar("owner_id").references(() => users.id),
      startDate: timestamp("start_date"),
      endDate: timestamp("end_date"),
      status: text("status").default("Active"),
      createdAt: timestamp("created_at").defaultNow()
    });
    workstreams = pgTable("workstreams", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      programId: varchar("program_id").notNull().references(() => programs.id),
      name: text("name").notNull(),
      description: text("description"),
      leadId: varchar("lead_id").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    resources = pgTable("resources", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      role: text("role"),
      department: text("department"),
      email: text("email"),
      userId: varchar("user_id").references(() => users.id),
      programId: varchar("program_id").references(() => programs.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    stageGates = pgTable("stage_gates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      code: text("code").notNull(),
      // G0, G1, G2, etc.
      name: text("name").notNull(),
      description: text("description"),
      successCriteria: text("success_criteria"),
      programId: varchar("program_id").references(() => programs.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    stageGateReviews = pgTable("stage_gate_reviews", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      stageGateId: varchar("stage_gate_id").notNull().references(() => stageGates.id),
      programId: varchar("program_id").notNull().references(() => programs.id),
      reviewDate: timestamp("review_date"),
      status: gateStatusEnum("status").notNull().default("Pending"),
      approverId: varchar("approver_id").references(() => users.id),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    });
    tasks = pgTable("tasks", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      workstreamId: varchar("workstream_id").references(() => workstreams.id),
      ownerId: varchar("owner_id").references(() => resources.id),
      stageGateId: varchar("stage_gate_id").references(() => stageGates.id),
      startDate: timestamp("start_date"),
      endDate: timestamp("end_date"),
      status: taskStatusEnum("status").notNull().default("Not Started"),
      progress: integer("progress").default(0),
      // 0-100
      priority: text("priority").default("Medium"),
      createdAt: timestamp("created_at").defaultNow()
    });
    taskDependencies = pgTable("task_dependencies", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      taskId: varchar("task_id").notNull().references(() => tasks.id),
      dependsOnTaskId: varchar("depends_on_task_id").notNull().references(() => tasks.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    kpis = pgTable("kpis", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      programId: varchar("program_id").notNull().references(() => programs.id),
      name: text("name").notNull(),
      description: text("description"),
      targetValue: decimal("target_value", { precision: 12, scale: 2 }),
      currentValue: decimal("current_value", { precision: 12, scale: 2 }),
      unit: text("unit"),
      frequency: text("frequency").default("Monthly"),
      ownerId: varchar("owner_id").references(() => resources.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    kpiMeasurements = pgTable("kpi_measurements", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      kpiId: varchar("kpi_id").notNull().references(() => kpis.id),
      value: decimal("value", { precision: 12, scale: 2 }).notNull(),
      measurementDate: timestamp("measurement_date").notNull(),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow()
    });
    risks = pgTable("risks", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      programId: varchar("program_id").notNull().references(() => programs.id),
      riskId: text("risk_id").notNull(),
      // R-001, R-002, etc.
      description: text("description").notNull(),
      category: text("category"),
      likelihood: riskLikelihoodEnum("likelihood").notNull(),
      impact: riskImpactEnum("impact").notNull(),
      priority: riskPriorityEnum("priority").notNull(),
      mitigationPlan: text("mitigation_plan"),
      ownerId: varchar("owner_id").references(() => resources.id),
      status: riskStatusEnum("status").notNull().default("Open"),
      createdAt: timestamp("created_at").defaultNow()
    });
    riskMitigations = pgTable("risk_mitigations", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      riskId: varchar("risk_id").notNull().references(() => risks.id),
      action: text("action").notNull(),
      actionDate: timestamp("action_date").notNull(),
      result: text("result"),
      status: text("status").default("Planned"),
      createdAt: timestamp("created_at").defaultNow()
    });
    benefits = pgTable("benefits", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      programId: varchar("program_id").notNull().references(() => programs.id),
      name: text("name").notNull(),
      description: text("description"),
      category: text("category"),
      targetValue: decimal("target_value", { precision: 12, scale: 2 }),
      realizedValue: decimal("realized_value", { precision: 12, scale: 2 }).default(sql`0`),
      unit: text("unit"),
      ownerId: varchar("owner_id").references(() => resources.id),
      status: benefitStatusEnum("status").notNull().default("Not Started"),
      realizationDate: timestamp("realization_date"),
      createdAt: timestamp("created_at").defaultNow()
    });
    fundingSources = pgTable("funding_sources", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      programId: varchar("program_id").notNull().references(() => programs.id),
      sourceName: text("source_name").notNull(),
      allocatedAmount: decimal("allocated_amount", { precision: 12, scale: 2 }).notNull(),
      dateReceived: timestamp("date_received"),
      createdAt: timestamp("created_at").defaultNow()
    });
    expenses = pgTable("expenses", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      programId: varchar("program_id").notNull().references(() => programs.id),
      description: text("description").notNull(),
      amount: decimal("amount", { precision: 12, scale: 2 }).notNull(),
      category: text("category"),
      vendor: text("vendor"),
      expenseDate: timestamp("expense_date").notNull(),
      approvedById: varchar("approved_by_id").references(() => users.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    ontologyEntities = pgTable("ontology_entities", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      entityName: text("entity_name").notNull().unique(),
      definition: text("definition").notNull(),
      purpose: text("purpose").notNull(),
      data: jsonb("data").notNull(),
      version: integer("version").default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      versionIdx: index("idx_ontology_entities_version").on(table.version)
    }));
    ontologyRelationships = pgTable("ontology_relationships", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      fromEntity: text("from_entity").notNull(),
      toEntity: text("to_entity").notNull(),
      relationshipType: text("relationship_type").notNull(),
      cardinality: text("cardinality").notNull(),
      required: boolean("required").default(false),
      data: jsonb("data").notNull(),
      version: integer("version").default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      fromEntityIdx: index("idx_ontology_rels_from_entity").on(table.fromEntity),
      toEntityIdx: index("idx_ontology_rels_to_entity").on(table.toEntity),
      typeIdx: index("idx_ontology_rels_type").on(table.relationshipType),
      fromToIdx: index("idx_ontology_rels_from_to").on(table.fromEntity, table.toEntity)
    }));
    ontologyValidationRules = pgTable("ontology_validation_rules", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      ruleId: text("rule_id").notNull().unique(),
      entity: text("entity").notNull(),
      category: text("category").notNull(),
      severity: text("severity").notNull(),
      rule: text("rule").notNull(),
      validation: text("validation").notNull(),
      data: jsonb("data").notNull(),
      enabled: boolean("enabled").default(true),
      version: integer("version").default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      entityIdx: index("idx_ontology_rules_entity").on(table.entity),
      categoryIdx: index("idx_ontology_rules_category").on(table.category),
      severityIdx: index("idx_ontology_rules_severity").on(table.severity),
      enabledIdx: index("idx_ontology_rules_enabled").on(table.enabled),
      entityCategoryIdx: index("idx_ontology_rules_entity_category").on(table.entity, table.category)
    }));
    ontologyCompletenessChecks = pgTable("ontology_completeness_checks", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      checkId: text("check_id").notNull().unique(),
      entity: text("entity").notNull(),
      checkType: text("check_type").notNull(),
      importance: text("importance").notNull(),
      description: text("description").notNull(),
      validation: text("validation").notNull(),
      data: jsonb("data").notNull(),
      enabled: boolean("enabled").default(true),
      version: integer("version").default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      entityIdx: index("idx_ontology_checks_entity").on(table.entity),
      checkTypeIdx: index("idx_ontology_checks_type").on(table.checkType),
      importanceIdx: index("idx_ontology_checks_importance").on(table.importance),
      enabledIdx: index("idx_ontology_checks_enabled").on(table.enabled),
      entityImportanceIdx: index("idx_ontology_checks_entity_importance").on(table.entity, table.importance)
    }));
    ontologyCascadeImpacts = pgTable("ontology_cascade_impacts", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      trigger: text("trigger").notNull(),
      automationPotential: text("automation_potential").notNull(),
      impactDescription: text("impact_description").notNull(),
      data: jsonb("data").notNull(),
      version: integer("version").default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      triggerIdx: index("idx_ontology_cascades_trigger").on(table.trigger),
      automationIdx: index("idx_ontology_cascades_automation").on(table.automationPotential)
    }));
    ontologyDomainTerms = pgTable("ontology_domain_terms", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      term: text("term").notNull().unique(),
      definition: text("definition").notNull(),
      context: text("context").notNull(),
      data: jsonb("data").notNull(),
      version: integer("version").default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    ontologyFrameworkMappings = pgTable("ontology_framework_mappings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      framework: text("framework").notNull(),
      concept: text("concept").notNull(),
      epmEntity: text("epm_entity").notNull(),
      mapping: text("mapping").notNull(),
      data: jsonb("data").notNull(),
      version: integer("version").default(1),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      frameworkIdx: index("idx_ontology_mappings_framework").on(table.framework),
      entityIdx: index("idx_ontology_mappings_entity").on(table.epmEntity),
      frameworkEntityIdx: index("idx_ontology_mappings_framework_entity").on(table.framework, table.epmEntity)
    }));
    sessionContext = pgTable("session_context", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      goal: text("goal").notNull(),
      successCriteria: text("success_criteria").array().notNull().default(sql`ARRAY[]::text[]`),
      decisionsLog: jsonb("decisions_log").notNull().default(sql`'[]'::jsonb`),
      currentPhase: text("current_phase"),
      isActive: boolean("is_active").default(true),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      isActiveIdx: index("idx_session_context_is_active").on(table.isActive)
    }));
    strategyVersions = pgTable("strategy_versions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id),
      sessionId: varchar("session_id").references(() => sessionContext.id),
      versionNumber: integer("version_number").notNull(),
      versionLabel: varchar("version_label", { length: 100 }),
      inputSummary: text("input_summary"),
      analysisData: jsonb("analysis_data"),
      decisionsData: jsonb("decisions_data"),
      selectedDecisions: jsonb("selected_decisions"),
      strategicApproach: varchar("strategic_approach", { length: 100 }),
      marketContext: varchar("market_context", { length: 100 }),
      costMin: integer("cost_min"),
      costMax: integer("cost_max"),
      timelineMonths: integer("timeline_months"),
      teamSizeMin: integer("team_size_min"),
      teamSizeMax: integer("team_size_max"),
      decisions: jsonb("decisions").notNull().default(sql`'[]'::jsonb`),
      programStructure: jsonb("program_structure"),
      status: strategyStatusEnum("status").notNull().default("draft"),
      convertedProgramId: varchar("converted_program_id").references(() => epmPrograms.id, { onDelete: "set null" }),
      finalizedAt: timestamp("finalized_at"),
      archived: boolean("archived").notNull().default(false),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdBy: varchar("created_by").notNull()
    }, (table) => ({
      userIdIdx: index("idx_strategy_versions_user_id").on(table.userId),
      statusIdx: index("idx_strategy_versions_status").on(table.status),
      sessionVersionIdx: index("idx_strategy_versions_session_version").on(table.sessionId, table.versionNumber),
      archivedIdx: index("idx_strategy_versions_archived").on(table.archived)
    }));
    strategicDecisions = pgTable("strategic_decisions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyVersionId: varchar("strategy_version_id").notNull().references(() => strategyVersions.id),
      decisionPoint: varchar("decision_point", { length: 200 }).notNull(),
      optionSelected: varchar("option_selected", { length: 100 }).notNull(),
      rationale: text("rationale"),
      createdAt: timestamp("created_at").defaultNow()
    });
    strategyInsights = pgTable("strategy_insights", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      context: jsonb("context").notNull(),
      observation: text("observation").notNull(),
      patternDetected: varchar("pattern_detected", { length: 200 }),
      confidence: decimal("confidence", { precision: 3, scale: 2 }),
      validated: boolean("validated").default(false),
      createdFromSession: varchar("created_from_session").references(() => strategyVersions.id),
      createdAt: timestamp("created_at").defaultNow()
    });
    frameworkSelections = pgTable("framework_selections", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      sessionId: varchar("session_id").notNull().references(() => sessionContext.id),
      userId: varchar("user_id").notNull().references(() => users.id),
      selectedFramework: frameworkTypeEnum("selected_framework").notNull(),
      confidence: decimal("confidence", { precision: 3, scale: 2 }),
      signals: jsonb("signals").notNull(),
      // Keywords, business stage, query type
      reasoning: text("reasoning").notNull(),
      userOverride: boolean("user_override").default(false),
      alternativeFramework: frameworkTypeEnum("alternative_framework"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      sessionIdx: index("idx_framework_selections_session").on(table.sessionId),
      userIdx: index("idx_framework_selections_user").on(table.userId)
    }));
    strategicUnderstanding = pgTable("strategic_understanding", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      sessionId: varchar("session_id").notNull().unique(),
      userInput: text("user_input").notNull(),
      title: varchar("title", { length: 200 }),
      // Initiative classification fields
      initiativeType: initiativeTypeEnum("initiative_type"),
      initiativeDescription: text("initiative_description"),
      userConfirmed: boolean("user_confirmed").default(false),
      classificationConfidence: decimal("classification_confidence", { precision: 3, scale: 2 }),
      companyContext: jsonb("company_context"),
      graphVersion: integer("graph_version").default(1),
      lastEnrichedBy: varchar("last_enriched_by", { length: 50 }),
      lastEnrichedAt: timestamp("last_enriched_at"),
      archived: boolean("archived").notNull().default(false),
      // Strategy readiness metadata cache
      strategyMetadata: jsonb("strategy_metadata").default(sql`'{}'::jsonb`),
      // Format: { availableEntities: number, availableReferences: number, completedFrameworks: string[], clarificationsProvided: {}, confidence: number, lastUpdated: timestamp }
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      sessionIdx: index("idx_strategic_understanding_session").on(table.sessionId),
      archivedIdx: index("idx_strategic_understanding_archived").on(table.archived),
      initiativeTypeIdx: index("idx_strategic_understanding_initiative_type").on(table.initiativeType)
    }));
    journeySessions = pgTable("journey_sessions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      understandingId: varchar("understanding_id").notNull().references(() => strategicUnderstanding.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id),
      journeyType: journeyTypeEnum("journey_type").notNull(),
      status: journeyStatusEnum("status").notNull().default("initializing"),
      currentFrameworkIndex: integer("current_framework_index").default(0),
      completedFrameworks: frameworkNameEnum("completed_frameworks").array().default(sql`ARRAY[]::framework_name[]`),
      accumulatedContext: jsonb("accumulated_context").notNull().default(sql`'{}'::jsonb`),
      // Versioning and background execution fields
      versionNumber: integer("version_number").notNull().default(1),
      startedAt: timestamp("started_at").defaultNow(),
      background: boolean("background").notNull().default(false),
      // Custom journey metadata (stores framework sequence, templateId for custom journeys)
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      completedAt: timestamp("completed_at"),
      summary: jsonb("summary")
    }, (table) => ({
      understandingIdx: index("idx_journey_sessions_understanding").on(table.understandingId),
      userIdx: index("idx_journey_sessions_user").on(table.userId),
      statusIdx: index("idx_journey_sessions_status").on(table.status),
      uniqueVersionConstraint: unique("unique_understanding_version").on(table.understandingId, table.versionNumber)
    }));
    references = pgTable("references", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      // Link to artifacts (at least one required)
      understandingId: varchar("understanding_id").references(() => strategicUnderstanding.id, { onDelete: "cascade" }),
      sessionId: varchar("session_id").references(() => journeySessions.id, { onDelete: "cascade" }),
      programId: varchar("program_id").references(() => epmPrograms.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id),
      // Source metadata
      sourceType: referenceSourceTypeEnum("source_type").notNull(),
      title: text("title").notNull(),
      url: text("url"),
      // Nullable for manual uploads/documents
      description: text("description"),
      topics: text("topics").array().default(sql`ARRAY[]::text[]`),
      confidence: decimal("confidence", { precision: 3, scale: 2 }),
      // 0.00-1.00
      // Usage tracking
      extractedQuotes: jsonb("extracted_quotes").default(sql`'[]'::jsonb`),
      // Format: [{ snippet: "text", page?: number, usedIn?: "BMC.customerSegments" }]
      usedInComponents: text("used_in_components").array().default(sql`ARRAY[]::text[]`),
      // Format: ["BMC.customerSegments", "RiskRegister[2]", "Porter.buyerPower"]
      // Provenance
      origin: referenceOriginEnum("origin").notNull(),
      lastValidated: timestamp("last_validated"),
      // Metadata
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      understandingIdx: index("idx_references_understanding").on(table.understandingId),
      sessionIdx: index("idx_references_session").on(table.sessionId),
      programIdx: index("idx_references_program").on(table.programId),
      sourceTypeIdx: index("idx_references_source_type").on(table.sourceType),
      confidenceIdx: index("idx_references_confidence").on(table.confidence),
      userIdx: index("idx_references_user").on(table.userId)
    }));
    strategyDecisions = pgTable("strategy_decisions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyVersionId: varchar("strategy_version_id").notNull().references(() => strategyVersions.id, { onDelete: "cascade" }),
      userId: varchar("user_id").notNull().references(() => users.id),
      // Strategic Choices
      primaryCustomerSegment: text("primary_customer_segment"),
      revenueModel: text("revenue_model"),
      channelPriorities: text("channel_priorities").array().default(sql`ARRAY[]::text[]`),
      partnershipStrategy: text("partnership_strategy"),
      // Risk & Investment
      riskTolerance: riskToleranceEnum("risk_tolerance").notNull().default("balanced"),
      investmentCapacityMin: integer("investment_capacity_min"),
      investmentCapacityMax: integer("investment_capacity_max"),
      timelinePreference: timelinePreferenceEnum("timeline_preference").notNull().default("sustainable_pace"),
      successMetricsPriority: text("success_metrics_priority").array().default(sql`ARRAY[]::text[]`),
      // Assumptions
      validatedAssumptions: jsonb("validated_assumptions").default(sql`'[]'::jsonb`),
      concerns: text("concerns").array().default(sql`ARRAY[]::text[]`),
      // Priorities & Decision
      topPriorities: text("top_priorities").array().default(sql`ARRAY[]::text[]`),
      goDecision: goDecisionEnum("go_decision").notNull(),
      decisionRationale: text("decision_rationale"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      strategyVersionIdx: index("idx_strategy_decisions_version").on(table.strategyVersionId),
      userIdx: index("idx_strategy_decisions_user").on(table.userId)
    }));
    epmPrograms = pgTable("epm_programs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyVersionId: varchar("strategy_version_id").notNull().references(() => strategyVersions.id, { onDelete: "cascade" }),
      strategyDecisionId: varchar("strategy_decision_id").references(() => strategyDecisions.id, { onDelete: "set null" }),
      userId: varchar("user_id").notNull().references(() => users.id),
      frameworkType: varchar("framework_type", { length: 50 }).notNull(),
      // 14 EPM Components (JSONB for flexibility)
      executiveSummary: jsonb("executive_summary").notNull(),
      workstreams: jsonb("workstreams").notNull(),
      timeline: jsonb("timeline").notNull(),
      resourcePlan: jsonb("resource_plan").notNull(),
      financialPlan: jsonb("financial_plan").notNull(),
      benefitsRealization: jsonb("benefits_realization").notNull(),
      riskRegister: jsonb("risk_register").notNull(),
      stageGates: jsonb("stage_gates").notNull(),
      kpis: jsonb("kpis").notNull(),
      stakeholderMap: jsonb("stakeholder_map").notNull(),
      governance: jsonb("governance").notNull(),
      qaPlan: jsonb("qa_plan").notNull(),
      procurement: jsonb("procurement").notNull(),
      exitStrategy: jsonb("exit_strategy").notNull(),
      // Confidence tracking
      componentConfidence: jsonb("component_confidence").notNull(),
      overallConfidence: decimal("overall_confidence", { precision: 5, scale: 4 }).notNull(),
      // Edit tracking
      editTracking: jsonb("edit_tracking").notNull().default(sql`'{}'::jsonb`),
      status: epmStatusEnum("status").notNull().default("draft"),
      archived: boolean("archived").notNull().default(false),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      finalizedAt: timestamp("finalized_at")
    }, (table) => ({
      strategyVersionIdx: index("idx_epm_programs_version").on(table.strategyVersionId),
      strategyDecisionIdx: index("idx_epm_programs_decision").on(table.strategyDecisionId),
      userIdx: index("idx_epm_programs_user").on(table.userId),
      statusIdx: index("idx_epm_programs_status").on(table.status),
      archivedIdx: index("idx_epm_programs_archived").on(table.archived)
    }));
    taskAssignments = pgTable("task_assignments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      epmProgramId: varchar("epm_program_id").notNull().references(() => epmPrograms.id, { onDelete: "cascade" }),
      taskId: varchar("task_id").notNull(),
      taskName: varchar("task_name", { length: 255 }),
      // Deliverable name for display
      resourceId: varchar("resource_id").notNull(),
      resourceName: varchar("resource_name", { length: 100 }),
      // Resource display name
      resourceRole: varchar("resource_role", { length: 100 }),
      // Role title
      resourceType: assignmentResourceTypeEnum("resource_type").notNull(),
      assignedAt: timestamp("assigned_at").defaultNow(),
      assignedFrom: date("assigned_from"),
      // Assignment start date
      assignedTo: date("assigned_to"),
      // Assignment end date
      allocationPercent: integer("allocation_percent").default(100),
      // Percentage allocation (0-100)
      estimatedHours: integer("estimated_hours"),
      actualHours: integer("actual_hours"),
      status: varchar("status", { length: 20 }).notNull().default("assigned"),
      // 'assigned' | 'in_progress' | 'completed'
      assignmentSource: assignmentSourceEnum("assignment_source").notNull().default("ai_generated"),
      notes: text("notes"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      programIdx: index("idx_task_assignments_program").on(table.epmProgramId),
      taskIdx: index("idx_task_assignments_task").on(table.taskId),
      resourceIdx: index("idx_task_assignments_resource").on(table.resourceId)
    }));
    strategicEntities = pgTable("strategic_entities", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      understandingId: varchar("understanding_id").notNull().references(() => strategicUnderstanding.id, { onDelete: "cascade" }),
      type: entityTypeEnum("type").notNull(),
      claim: text("claim").notNull(),
      confidence: confidenceLevelEnum("confidence"),
      embedding: vector("embedding", { dimensions: 1536 }),
      source: text("source").notNull(),
      evidence: text("evidence"),
      category: text("category"),
      subcategory: text("subcategory"),
      investmentAmount: integer("investment_amount"),
      discoveredBy: discoveredByEnum("discovered_by").notNull(),
      discoveredAt: timestamp("discovered_at").defaultNow(),
      validFrom: timestamp("valid_from").defaultNow(),
      validTo: timestamp("valid_to"),
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      understandingIdx: index("idx_strategic_entities_understanding").on(table.understandingId),
      typeIdx: index("idx_strategic_entities_type").on(table.type),
      discoveredByIdx: index("idx_strategic_entities_discovered_by").on(table.discoveredBy),
      validFromIdx: index("idx_strategic_entities_valid_from").on(table.validFrom),
      embeddingIdx: index("idx_strategic_entities_embedding").using(
        "ivfflat",
        table.embedding.op("vector_cosine_ops")
      ).with({ lists: 100 }),
      textSearchIdx: index("idx_strategic_entities_text_search").using(
        "gin",
        sql`to_tsvector('english', ${table.claim} || ' ' || COALESCE(${table.source}, '') || ' ' || COALESCE(${table.evidence}, ''))`
      )
    }));
    strategicRelationships = pgTable("strategic_relationships", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      fromEntityId: varchar("from_entity_id").notNull().references(() => strategicEntities.id, { onDelete: "cascade" }),
      toEntityId: varchar("to_entity_id").notNull().references(() => strategicEntities.id, { onDelete: "cascade" }),
      relationshipType: relationshipTypeEnum("relationship_type").notNull(),
      confidence: confidenceLevelEnum("confidence"),
      evidence: text("evidence"),
      discoveredBy: discoveredByEnum("discovered_by").notNull(),
      discoveredAt: timestamp("discovered_at").defaultNow(),
      validFrom: timestamp("valid_from").defaultNow(),
      validTo: timestamp("valid_to"),
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    }, (table) => ({
      fromEntityIdx: index("idx_strategic_relationships_from").on(table.fromEntityId),
      toEntityIdx: index("idx_strategic_relationships_to").on(table.toEntityId),
      relationshipTypeIdx: index("idx_strategic_relationships_type").on(table.relationshipType),
      discoveredByIdx: index("idx_strategic_relationships_discovered_by").on(table.discoveredBy)
    }));
    authoritySources = pgTable("authority_sources", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull().unique(),
      url: text("url"),
      tier: integer("tier").notNull(),
      // 1 = high, 2 = medium, 3 = low authority
      lastSeen: timestamp("last_seen").notNull().defaultNow(),
      hits: integer("hits").notNull().default(0),
      corroborations: integer("corroborations").notNull().default(0),
      createdAt: timestamp("created_at").notNull().defaultNow()
    }, (table) => ({
      nameIdx: index("idx_authority_sources_name").on(table.name),
      tierIdx: index("idx_authority_sources_tier").on(table.tier)
    }));
    authoritySourceIndustries = pgTable("authority_source_industries", {
      authorityId: varchar("authority_id").notNull().references(() => authoritySources.id, { onDelete: "cascade" }),
      industry: text("industry").notNull()
    }, (table) => ({
      pk: primaryKey({ columns: [table.authorityId, table.industry] }),
      industryIdx: index("idx_auth_industry").on(table.industry)
    }));
    authoritySourceCountries = pgTable("authority_source_countries", {
      authorityId: varchar("authority_id").notNull().references(() => authoritySources.id, { onDelete: "cascade" }),
      countryIso2: varchar("country_iso2", { length: 2 }).notNull()
    }, (table) => ({
      pk: primaryKey({ columns: [table.authorityId, table.countryIso2] }),
      countryIdx: index("idx_auth_country").on(table.countryIso2)
    }));
    authoritySourceLanguages = pgTable("authority_source_languages", {
      authorityId: varchar("authority_id").notNull().references(() => authoritySources.id, { onDelete: "cascade" }),
      language: text("language").notNull()
    }, (table) => ({
      pk: primaryKey({ columns: [table.authorityId, table.language] }),
      languageIdx: index("idx_auth_language").on(table.language)
    }));
    trendClaimsCache = pgTable("trend_claims_cache", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      claimText: text("claim_text").notNull(),
      pestleDomain: varchar("pestle_domain", { length: 50 }).notNull(),
      industries: text("industries").array().notNull(),
      geographies: text("geographies").array().notNull(),
      metrics: jsonb("metrics"),
      evidence: jsonb("evidence").notNull(),
      agreement: varchar("agreement", { length: 20 }).notNull(),
      confidence: varchar("confidence", { length: 20 }).notNull(),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      expiresAt: timestamp("expires_at").notNull()
    }, (table) => ({
      geographiesIdx: index("idx_claims_cache_geo").using("gin", table.geographies),
      expiresAtIdx: index("idx_claims_cache_expires").on(table.expiresAt)
    }));
    trendAnalysisJobs = pgTable("trend_analysis_jobs", {
      jobId: varchar("job_id").primaryKey().default(sql`gen_random_uuid()`),
      idempotencyKey: text("idempotency_key").notNull().unique(),
      understandingId: varchar("understanding_id").notNull(),
      status: varchar("status", { length: 20 }).notNull(),
      data: jsonb("data"),
      result: jsonb("result"),
      error: text("error"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      startedAt: timestamp("started_at"),
      completedAt: timestamp("completed_at")
    }, (table) => ({
      idempotencyKeyIdx: index("idx_trend_jobs_idempotency").on(table.idempotencyKey),
      understandingIdx: index("idx_trend_jobs_understanding").on(table.understandingId),
      statusIdx: index("idx_trend_jobs_status").on(table.status)
    }));
    frameworkInsights = pgTable("framework_insights", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      understandingId: varchar("understanding_id").notNull().references(() => strategicUnderstanding.id, { onDelete: "cascade" }),
      sessionId: varchar("session_id").references(() => journeySessions.id, { onDelete: "cascade" }),
      frameworkName: varchar("framework_name", { length: 50 }).notNull(),
      frameworkVersion: varchar("framework_version", { length: 20 }),
      insights: jsonb("insights").notNull(),
      telemetry: jsonb("telemetry"),
      createdAt: timestamp("created_at").notNull().defaultNow()
    }, (table) => ({
      understandingIdx: index("idx_framework_insights_understanding").on(table.understandingId),
      sessionIdx: index("idx_framework_insights_session").on(table.sessionId),
      frameworkIdx: index("idx_framework_insights_framework").on(table.frameworkName)
    }));
    bmcAnalyses = pgTable("bmc_analyses", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyVersionId: varchar("strategy_version_id").notNull().references(() => strategyVersions.id),
      viability: varchar("viability", { length: 20 }).notNull(),
      // strong, moderate, weak
      overallConfidence: decimal("overall_confidence", { precision: 3, scale: 2 }),
      keyInsights: text("key_insights").array().notNull().default(sql`ARRAY[]::text[]`),
      criticalGaps: text("critical_gaps").array().notNull().default(sql`ARRAY[]::text[]`),
      consistencyChecks: jsonb("consistency_checks").notNull().default(sql`'[]'::jsonb`),
      recommendations: jsonb("recommendations").notNull().default(sql`'[]'::jsonb`),
      researchSources: jsonb("research_sources").notNull().default(sql`'[]'::jsonb`),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      strategyVersionIdx: index("idx_bmc_analyses_strategy_version").on(table.strategyVersionId)
    }));
    bmcBlocks = pgTable("bmc_blocks", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bmcAnalysisId: varchar("bmc_analysis_id").notNull().references(() => bmcAnalyses.id),
      blockType: bmcBlockTypeEnum("block_type").notNull(),
      description: text("description").notNull(),
      confidence: bmcConfidenceEnum("confidence").notNull(),
      strategicImplications: text("strategic_implications"),
      gaps: text("gaps").array().notNull().default(sql`ARRAY[]::text[]`),
      researchQueries: text("research_queries").array().notNull().default(sql`ARRAY[]::text[]`),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      bmcAnalysisIdx: index("idx_bmc_blocks_analysis").on(table.bmcAnalysisId),
      blockTypeIdx: index("idx_bmc_blocks_type").on(table.blockType)
    }));
    bmcFindings = pgTable("bmc_findings", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      bmcBlockId: varchar("bmc_block_id").notNull().references(() => bmcBlocks.id),
      finding: text("finding").notNull(),
      validationStrength: varchar("validation_strength", { length: 20 }).notNull(),
      // STRONG, MODERATE, WEAK
      validationDetails: text("validation_details").notNull(),
      sources: jsonb("sources").notNull().default(sql`'[]'::jsonb`),
      contradictsInput: boolean("contradicts_input").default(false),
      contradictionDetails: text("contradiction_details"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      blockIdx: index("idx_bmc_findings_block").on(table.bmcBlockId)
    }));
    segmentDiscoveryResults = pgTable("segment_discovery_results", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id),
      // Input fields (encrypted for sensitive business data)
      offeringDescription: text("offering_description").notNull(),
      // encrypted
      offeringType: offeringTypeEnum("offering_type").notNull(),
      stage: companyStageEnum("stage").notNull(),
      gtmConstraint: gtmConstraintEnum("gtm_constraint").notNull(),
      salesMotion: salesMotionEnum("sales_motion").notNull(),
      existingHypothesis: text("existing_hypothesis"),
      // optional, encrypted if present
      // Clarifications from user
      clarifications: jsonb("clarifications"),
      // encrypted
      // Document metadata (if uploaded)
      documentMetadata: jsonb("document_metadata"),
      // Generated results (encrypted - sensitive competitive intelligence)
      geneLibrary: jsonb("gene_library"),
      // encrypted
      genomes: jsonb("genomes"),
      // encrypted - array of 100 genomes with scores
      synthesis: jsonb("synthesis"),
      // encrypted - beachhead, backup, validation plan
      // LLM-generated summary for Strategic Consultant handoff (encrypted)
      strategicSummary: text("strategic_summary"),
      // encrypted - cached summary for strategic analysis
      // Status tracking
      status: jobStatusEnum("status").notNull().default("pending"),
      progressMessage: text("progress_message"),
      errorMessage: text("error_message"),
      // Timestamps
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      completedAt: timestamp("completed_at")
    }, (table) => ({
      userIdx: index("idx_segment_discovery_user").on(table.userId),
      statusIdx: index("idx_segment_discovery_status").on(table.status)
    }));
    betaUsageCounters = pgTable("beta_usage_counters", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      featureName: varchar("feature_name", { length: 100 }).notNull().unique(),
      currentCount: integer("current_count").notNull().default(0),
      maxCount: integer("max_count").notNull(),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow()
    });
    usersRelations = relations(users, ({ many }) => ({
      programs: many(programs),
      resources: many(resources),
      stageGateReviews: many(stageGateReviews),
      expenses: many(expenses)
    }));
    programsRelations = relations(programs, ({ one, many }) => ({
      owner: one(users, {
        fields: [programs.ownerId],
        references: [users.id]
      }),
      workstreams: many(workstreams),
      resources: many(resources),
      stageGates: many(stageGates),
      stageGateReviews: many(stageGateReviews),
      kpis: many(kpis),
      risks: many(risks),
      benefits: many(benefits),
      fundingSources: many(fundingSources),
      expenses: many(expenses)
    }));
    workstreamsRelations = relations(workstreams, ({ one, many }) => ({
      program: one(programs, {
        fields: [workstreams.programId],
        references: [programs.id]
      }),
      lead: one(users, {
        fields: [workstreams.leadId],
        references: [users.id]
      }),
      tasks: many(tasks)
    }));
    resourcesRelations = relations(resources, ({ one, many }) => ({
      user: one(users, {
        fields: [resources.userId],
        references: [users.id]
      }),
      program: one(programs, {
        fields: [resources.programId],
        references: [programs.id]
      }),
      tasks: many(tasks),
      kpis: many(kpis),
      risks: many(risks),
      benefits: many(benefits)
    }));
    stageGatesRelations = relations(stageGates, ({ one, many }) => ({
      program: one(programs, {
        fields: [stageGates.programId],
        references: [programs.id]
      }),
      reviews: many(stageGateReviews),
      tasks: many(tasks)
    }));
    tasksRelations = relations(tasks, ({ one, many }) => ({
      workstream: one(workstreams, {
        fields: [tasks.workstreamId],
        references: [workstreams.id]
      }),
      owner: one(resources, {
        fields: [tasks.ownerId],
        references: [resources.id]
      }),
      stageGate: one(stageGates, {
        fields: [tasks.stageGateId],
        references: [stageGates.id]
      }),
      dependencies: many(taskDependencies),
      dependents: many(taskDependencies)
    }));
    kpisRelations = relations(kpis, ({ one, many }) => ({
      program: one(programs, {
        fields: [kpis.programId],
        references: [programs.id]
      }),
      owner: one(resources, {
        fields: [kpis.ownerId],
        references: [resources.id]
      }),
      measurements: many(kpiMeasurements)
    }));
    risksRelations = relations(risks, ({ one, many }) => ({
      program: one(programs, {
        fields: [risks.programId],
        references: [programs.id]
      }),
      owner: one(resources, {
        fields: [risks.ownerId],
        references: [resources.id]
      }),
      mitigations: many(riskMitigations)
    }));
    benefitsRelations = relations(benefits, ({ one }) => ({
      program: one(programs, {
        fields: [benefits.programId],
        references: [programs.id]
      }),
      owner: one(resources, {
        fields: [benefits.ownerId],
        references: [resources.id]
      })
    }));
    insertUserSchema = createInsertSchema(users).omit({ id: true, createdAt: true, updatedAt: true });
    insertLocationSchema = createInsertSchema(locations).omit({ id: true, createdAt: true });
    insertProgramSchema = createInsertSchema(programs).omit({ id: true, createdAt: true });
    insertWorkstreamSchema = createInsertSchema(workstreams).omit({ id: true, createdAt: true });
    insertResourceSchema = createInsertSchema(resources).omit({ id: true, createdAt: true });
    insertStageGateSchema = createInsertSchema(stageGates).omit({ id: true, createdAt: true });
    insertStageGateReviewSchema = createInsertSchema(stageGateReviews).omit({ id: true, createdAt: true });
    insertTaskSchema = createInsertSchema(tasks).omit({ id: true, createdAt: true });
    insertTaskDependencySchema = createInsertSchema(taskDependencies).omit({ id: true, createdAt: true });
    insertKpiSchema = createInsertSchema(kpis).omit({ id: true, createdAt: true });
    insertKpiMeasurementSchema = createInsertSchema(kpiMeasurements).omit({ id: true, createdAt: true });
    insertRiskSchema = createInsertSchema(risks).omit({ id: true, createdAt: true });
    insertRiskMitigationSchema = createInsertSchema(riskMitigations).omit({ id: true, createdAt: true });
    insertBenefitSchema = createInsertSchema(benefits).omit({ id: true, createdAt: true });
    insertFundingSourceSchema = createInsertSchema(fundingSources).omit({ id: true, createdAt: true });
    insertExpenseSchema = createInsertSchema(expenses).omit({ id: true, createdAt: true });
    insertOntologyEntitySchema = createInsertSchema(ontologyEntities).omit({ id: true, createdAt: true, updatedAt: true });
    insertOntologyRelationshipSchema = createInsertSchema(ontologyRelationships).omit({ id: true, createdAt: true, updatedAt: true });
    insertOntologyValidationRuleSchema = createInsertSchema(ontologyValidationRules).omit({ id: true, createdAt: true, updatedAt: true });
    insertOntologyCompletenessCheckSchema = createInsertSchema(ontologyCompletenessChecks).omit({ id: true, createdAt: true, updatedAt: true });
    insertOntologyCascadeImpactSchema = createInsertSchema(ontologyCascadeImpacts).omit({ id: true, createdAt: true, updatedAt: true });
    insertOntologyDomainTermSchema = createInsertSchema(ontologyDomainTerms).omit({ id: true, createdAt: true, updatedAt: true });
    insertOntologyFrameworkMappingSchema = createInsertSchema(ontologyFrameworkMappings).omit({ id: true, createdAt: true, updatedAt: true });
    insertSessionContextSchema = createInsertSchema(sessionContext).omit({ id: true, createdAt: true, updatedAt: true });
    insertStrategyVersionSchema = createInsertSchema(strategyVersions).omit({ id: true, createdAt: true, updatedAt: true });
    insertStrategicDecisionSchema = createInsertSchema(strategicDecisions).omit({ id: true, createdAt: true });
    insertStrategyInsightSchema = createInsertSchema(strategyInsights).omit({ id: true, createdAt: true });
    insertFrameworkSelectionSchema = createInsertSchema(frameworkSelections).omit({ id: true, createdAt: true });
    insertBMCAnalysisSchema = createInsertSchema(bmcAnalyses).omit({ id: true, createdAt: true });
    insertBMCBlockSchema = createInsertSchema(bmcBlocks).omit({ id: true, createdAt: true });
    insertBMCFindingSchema = createInsertSchema(bmcFindings).omit({ id: true, createdAt: true });
    insertStrategicUnderstandingSchema = createInsertSchema(strategicUnderstanding).omit({ id: true, createdAt: true, updatedAt: true });
    insertJourneySessionSchema = createInsertSchema(journeySessions).omit({ id: true, createdAt: true, updatedAt: true });
    insertReferenceSchema = createInsertSchema(references).omit({ id: true, createdAt: true, updatedAt: true });
    insertStrategyDecisionSchema = createInsertSchema(strategyDecisions).omit({ id: true, createdAt: true, updatedAt: true });
    insertEpmProgramSchema = createInsertSchema(epmPrograms).omit({ id: true, createdAt: true, updatedAt: true });
    insertTaskAssignmentSchema = createInsertSchema(taskAssignments).omit({ id: true, createdAt: true, updatedAt: true });
    insertStrategicEntitySchema = createInsertSchema(strategicEntities).omit({ id: true, createdAt: true, updatedAt: true, discoveredAt: true });
    insertStrategicRelationshipSchema = createInsertSchema(strategicRelationships).omit({ id: true, createdAt: true, updatedAt: true, discoveredAt: true });
    insertAuthoritySourceSchema = createInsertSchema(authoritySources).omit({ id: true, createdAt: true });
    insertAuthoritySourceIndustrySchema = createInsertSchema(authoritySourceIndustries);
    insertAuthoritySourceCountrySchema = createInsertSchema(authoritySourceCountries);
    insertAuthoritySourceLanguageSchema = createInsertSchema(authoritySourceLanguages);
    insertTrendClaimsCacheSchema = createInsertSchema(trendClaimsCache).omit({ id: true, createdAt: true });
    insertTrendAnalysisJobSchema = createInsertSchema(trendAnalysisJobs).omit({ jobId: true, createdAt: true });
    insertFrameworkInsightSchema = createInsertSchema(frameworkInsights).omit({ id: true, createdAt: true });
    insertSegmentDiscoveryResultSchema = createInsertSchema(segmentDiscoveryResults).omit({ id: true, createdAt: true, updatedAt: true, completedAt: true });
    insertBetaUsageCounterSchema = createInsertSchema(betaUsageCounters).omit({ id: true, createdAt: true, updatedAt: true });
    aiProviderSchema = z.enum(["openai", "anthropic", "gemini"]);
    codeArtifactSchema = z.object({
      filePath: z.string(),
      content: z.string(),
      description: z.string()
    });
    requirementFulfillmentSchema = z.object({
      requirement: z.string(),
      satisfied: z.boolean(),
      notes: z.string()
    });
    decisionLogSchema = z.object({
      decision: z.string(),
      rationale: z.string(),
      alternatives: z.array(z.string()).optional(),
      confidence: z.number().min(0).max(100)
    });
    builderResponseSchema = z.object({
      approach: z.string(),
      artifacts: z.array(codeArtifactSchema),
      confidence: z.number().min(0).max(100),
      requirements: z.array(requirementFulfillmentSchema),
      unmetRequirements: z.array(z.string()),
      decisions: z.array(decisionLogSchema)
    });
    qaIssueSchema = z.object({
      category: z.enum(["gap", "bug", "edge-case", "security", "quality"]),
      severity: z.enum(["critical", "major", "minor"]),
      description: z.string(),
      location: z.string().optional(),
      recommendation: z.string()
    });
    qaReviewSchema = z.object({
      verdict: z.enum(["PASS", "FAIL"]),
      confidence: z.number().min(0).max(100),
      requirementsVerification: z.array(requirementFulfillmentSchema),
      issues: z.array(qaIssueSchema),
      criticalBlockers: z.array(z.string()),
      recommendations: z.array(z.string()),
      summary: z.string()
    });
    orchestratorTaskSchema = z.object({
      taskDescription: z.string(),
      requirements: z.array(z.string()),
      entity: z.string().optional(),
      constraints: z.array(z.string()).optional(),
      preferredProvider: aiProviderSchema.optional(),
      maxRetries: z.number().min(0).max(5).default(2)
    });
    orchestratorResponseSchema = z.object({
      taskId: z.string(),
      builderResponse: builderResponseSchema,
      qaReview: qaReviewSchema,
      verdict: z.enum(["PASS", "FAIL"]),
      iterations: z.number(),
      finalCode: z.array(codeArtifactSchema).optional(),
      provider: aiProviderSchema,
      error: z.string().optional(),
      timestamp: z.string()
    });
    problemStatusEnum = pgEnum("problem_status", ["active", "on_hold", "archived", "completed"]);
    strategyWorkspaceStatusEnum = pgEnum("strategy_workspace_status", ["draft", "in_progress", "analyzed", "approved", "rejected", "archived"]);
    frameworkRunStatusEnum = pgEnum("framework_run_status", ["pending", "running", "complete", "failed", "skipped"]);
    executionPlanStatusEnum = pgEnum("execution_plan_status", ["draft", "pending_approval", "approved", "in_execution", "completed", "cancelled"]);
    riskProfileEnum = pgEnum("risk_profile", ["low", "medium", "high", "critical"]);
    confidenceLevelWorkspaceEnum = pgEnum("confidence_level_workspace", ["very_low", "low", "medium", "high", "very_high"]);
    approvalStatusEnum = pgEnum("approval_status", ["pending", "approved", "rejected", "conditionally_approved"]);
    entityTypeWorkspaceEnum = pgEnum("entity_type_workspace", ["problem", "strategy", "execution_plan", "framework_run"]);
    swProblems = pgTable("sw_problems", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      title: text("title").notNull(),
      description: text("description").notNull(),
      context: jsonb("context"),
      userId: varchar("user_id").notNull().references(() => users.id),
      status: problemStatusEnum("status").notNull().default("active"),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdBy: varchar("created_by").notNull(),
      updatedBy: varchar("updated_by")
    }, (table) => ({
      userIdx: index("idx_sw_problems_user").on(table.userId),
      statusIdx: index("idx_sw_problems_status").on(table.status)
    }));
    swStrategies = pgTable("sw_strategies", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      problemId: varchar("problem_id").notNull().references(() => swProblems.id, { onDelete: "cascade" }),
      title: text("title").notNull(),
      approachType: journeyTypeEnum("approach_type").notNull(),
      versionNumber: integer("version_number").notNull().default(1),
      decisionRationale: text("decision_rationale"),
      status: strategyWorkspaceStatusEnum("status").notNull().default("draft"),
      confidenceScore: decimal("confidence_score", { precision: 5, scale: 2 }),
      createdAt: timestamp("created_at").defaultNow(),
      updatedAt: timestamp("updated_at").defaultNow(),
      createdBy: varchar("created_by").notNull(),
      updatedBy: varchar("updated_by")
    }, (table) => ({
      problemIdx: index("idx_sw_strategies_problem").on(table.problemId),
      statusIdx: index("idx_sw_strategies_status").on(table.status),
      approachIdx: index("idx_sw_strategies_approach").on(table.approachType)
    }));
    swFrameworkRuns = pgTable("sw_framework_runs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyId: varchar("strategy_id").notNull().references(() => swStrategies.id, { onDelete: "cascade" }),
      frameworkType: frameworkNameEnum("framework_type").notNull(),
      sequenceOrder: integer("sequence_order").notNull(),
      status: frameworkRunStatusEnum("status").notNull().default("pending"),
      inputParameters: jsonb("input_parameters"),
      rawResults: jsonb("raw_results"),
      errorLogs: text("error_logs"),
      startedAt: timestamp("started_at"),
      completedAt: timestamp("completed_at"),
      runBy: varchar("run_by").notNull(),
      metadata: jsonb("metadata")
    }, (table) => ({
      strategyIdx: index("idx_sw_framework_runs_strategy").on(table.strategyId),
      statusIdx: index("idx_sw_framework_runs_status").on(table.status),
      typeIdx: index("idx_sw_framework_runs_type").on(table.frameworkType)
    }));
    swExecutionPlans = pgTable("sw_execution_plans", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyId: varchar("strategy_id").notNull().references(() => swStrategies.id, { onDelete: "cascade" }),
      status: executionPlanStatusEnum("status").notNull().default("draft"),
      riskProfile: riskProfileEnum("risk_profile").notNull(),
      costEstimateLow: decimal("cost_estimate_low", { precision: 12, scale: 2 }),
      costEstimateHigh: decimal("cost_estimate_high", { precision: 12, scale: 2 }),
      timelineMonths: integer("timeline_months"),
      npvEstimate: decimal("npv_estimate", { precision: 12, scale: 2 }),
      roiEstimate: decimal("roi_estimate", { precision: 5, scale: 2 }),
      paybackMonths: integer("payback_months"),
      confidenceLevel: confidenceLevelWorkspaceEnum("confidence_level").notNull(),
      benefitsRealizationCurve: jsonb("benefits_realization_curve"),
      extractionRationale: text("extraction_rationale"),
      epmProgram: jsonb("epm_program").notNull(),
      createdAt: timestamp("created_at").defaultNow(),
      createdBy: varchar("created_by").notNull(),
      approvedBy: varchar("approved_by"),
      approvedAt: timestamp("approved_at")
    }, (table) => ({
      strategyIdx: index("idx_sw_execution_plans_strategy").on(table.strategyId),
      statusIdx: index("idx_sw_execution_plans_status").on(table.status),
      riskIdx: index("idx_sw_execution_plans_risk").on(table.riskProfile)
    }));
    swStrategyVersions = pgTable("sw_strategy_versions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyId: varchar("strategy_id").notNull().references(() => swStrategies.id, { onDelete: "cascade" }),
      versionNumber: integer("version_number").notNull(),
      changesMade: text("changes_made"),
      snapshotData: jsonb("snapshot_data").notNull(),
      createdBy: varchar("created_by").notNull(),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      strategyIdx: index("idx_sw_strategy_versions_strategy").on(table.strategyId),
      versionIdx: index("idx_sw_strategy_versions_version").on(table.versionNumber)
    }));
    swJourneyStates = pgTable("sw_journey_states", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      strategyId: varchar("strategy_id").notNull().references(() => swStrategies.id, { onDelete: "cascade" }),
      currentStep: text("current_step").notNull(),
      journeyType: journeyTypeEnum("journey_type").notNull(),
      stateData: jsonb("state_data").notNull(),
      lastSaved: timestamp("last_saved").defaultNow(),
      expiresAt: timestamp("expires_at"),
      userId: varchar("user_id").notNull().references(() => users.id)
    }, (table) => ({
      strategyIdx: index("idx_sw_journey_states_strategy").on(table.strategyId),
      userIdx: index("idx_sw_journey_states_user").on(table.userId),
      expiresIdx: index("idx_sw_journey_states_expires").on(table.expiresAt)
    }));
    swApprovals = pgTable("sw_approvals", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      entityType: entityTypeWorkspaceEnum("entity_type").notNull(),
      entityId: varchar("entity_id").notNull(),
      approverId: varchar("approver_id").notNull().references(() => users.id),
      status: approvalStatusEnum("status").notNull().default("pending"),
      comments: text("comments"),
      conditions: text("conditions"),
      decidedAt: timestamp("decided_at"),
      createdAt: timestamp("created_at").defaultNow()
    }, (table) => ({
      entityIdx: index("idx_sw_approvals_entity").on(table.entityType, table.entityId),
      approverIdx: index("idx_sw_approvals_approver").on(table.approverId),
      statusIdx: index("idx_sw_approvals_status").on(table.status)
    }));
    swAttachments = pgTable("sw_attachments", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      entityType: entityTypeWorkspaceEnum("entity_type").notNull(),
      entityId: varchar("entity_id").notNull(),
      fileName: text("file_name").notNull(),
      fileUrl: text("file_url").notNull(),
      fileType: text("file_type"),
      fileSize: integer("file_size"),
      uploadedBy: varchar("uploaded_by").notNull().references(() => users.id),
      uploadedAt: timestamp("uploaded_at").defaultNow()
    }, (table) => ({
      entityIdx: index("idx_sw_attachments_entity").on(table.entityType, table.entityId),
      uploaderIdx: index("idx_sw_attachments_uploader").on(table.uploadedBy)
    }));
    swStrategyComparisons = pgTable("sw_strategy_comparisons", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      problemId: varchar("problem_id").notNull().references(() => swProblems.id, { onDelete: "cascade" }),
      comparedStrategyIds: text("compared_strategy_ids").array().notNull(),
      comparisonCriteria: jsonb("comparison_criteria"),
      comparisonMatrix: jsonb("comparison_matrix").notNull(),
      recommendedStrategyId: varchar("recommended_strategy_id"),
      recommendationRationale: text("recommendation_rationale"),
      createdAt: timestamp("created_at").defaultNow(),
      createdBy: varchar("created_by").notNull()
    }, (table) => ({
      problemIdx: index("idx_sw_comparisons_problem").on(table.problemId),
      createdByIdx: index("idx_sw_comparisons_created_by").on(table.createdBy)
    }));
    swAuditLog = pgTable("sw_audit_log", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      entityType: entityTypeWorkspaceEnum("entity_type").notNull(),
      entityId: varchar("entity_id").notNull(),
      action: text("action").notNull(),
      changes: jsonb("changes"),
      userId: varchar("user_id").notNull().references(() => users.id),
      timestamp: timestamp("timestamp").defaultNow(),
      ipAddress: text("ip_address")
    }, (table) => ({
      entityIdx: index("idx_sw_audit_log_entity").on(table.entityType, table.entityId),
      userIdx: index("idx_sw_audit_log_user").on(table.userId),
      timestampIdx: index("idx_sw_audit_log_timestamp").on(table.timestamp),
      actionIdx: index("idx_sw_audit_log_action").on(table.action)
    }));
    journeyTemplates = pgTable("journey_templates", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: text("name").notNull(),
      description: text("description"),
      isSystemTemplate: boolean("is_system_template").notNull().default(false),
      createdBy: varchar("created_by").references(() => users.id),
      steps: jsonb("steps").notNull(),
      // JourneyStep[]
      category: text("category"),
      tags: jsonb("tags").default(sql`'[]'::jsonb`),
      // string[]
      estimatedDuration: integer("estimated_duration_minutes"),
      difficulty: difficultyEnum("difficulty"),
      usageCount: integer("usage_count").notNull().default(0),
      version: integer("version").notNull().default(1),
      isPublished: boolean("is_published").notNull().default(true),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow()
    }, (table) => ({
      createdByIdx: index("idx_journey_templates_created_by").on(table.createdBy),
      categoryIdx: index("idx_journey_templates_category").on(table.category),
      systemIdx: index("idx_journey_templates_system").on(table.isSystemTemplate),
      publishedIdx: index("idx_journey_templates_published").on(table.isPublished)
    }));
    userJourneys = pgTable("user_journeys", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id),
      sessionId: text("session_id").notNull().unique(),
      templateId: varchar("template_id").references(() => journeyTemplates.id),
      name: text("name").notNull(),
      steps: jsonb("steps").notNull(),
      // JourneyStep[]
      currentStepIndex: integer("current_step_index").notNull().default(0),
      status: userJourneyStatusEnum("status").notNull().default("in_progress"),
      completedSteps: jsonb("completed_steps").notNull().default(sql`'[]'::jsonb`),
      // string[]
      stepResults: jsonb("step_results").notNull().default(sql`'{}'::jsonb`),
      // Record<string, any>
      journeyContext: jsonb("journey_context").notNull().default(sql`'{}'::jsonb`),
      // Record<string, any>
      startedAt: timestamp("started_at").notNull().defaultNow(),
      completedAt: timestamp("completed_at"),
      lastActivityAt: timestamp("last_activity_at").notNull().defaultNow()
    }, (table) => ({
      userIdx: index("idx_user_journeys_user").on(table.userId),
      sessionIdx: index("idx_user_journeys_session").on(table.sessionId),
      templateIdx: index("idx_user_journeys_template").on(table.templateId),
      statusIdx: index("idx_user_journeys_status").on(table.status)
    }));
    frameworkRegistry = pgTable("framework_registry", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      frameworkKey: text("framework_key").notNull().unique(),
      name: text("name").notNull(),
      description: text("description"),
      category: text("category"),
      estimatedDuration: integer("estimated_duration_minutes"),
      difficulty: difficultyEnum("difficulty"),
      requiredInputs: jsonb("required_inputs").notNull().default(sql`'[]'::jsonb`),
      // string[]
      providedOutputs: jsonb("provided_outputs").notNull().default(sql`'[]'::jsonb`),
      // string[]
      isActive: boolean("is_active").notNull().default(true),
      version: text("version").notNull().default("1.0"),
      processorPath: text("processor_path"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow()
    }, (table) => ({
      keyIdx: index("idx_framework_registry_key").on(table.frameworkKey),
      categoryIdx: index("idx_framework_registry_category").on(table.category),
      activeIdx: index("idx_framework_registry_active").on(table.isActive)
    }));
    backgroundJobs = pgTable("background_jobs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      userId: varchar("user_id").notNull().references(() => users.id),
      jobType: jobTypeEnum("job_type").notNull(),
      status: jobStatusEnum("status").notNull().default("pending"),
      progress: integer("progress").notNull().default(0),
      progressMessage: text("progress_message"),
      inputData: jsonb("input_data"),
      resultData: jsonb("result_data"),
      errorMessage: text("error_message"),
      errorStack: text("error_stack"),
      sessionId: text("session_id"),
      relatedEntityId: varchar("related_entity_id"),
      relatedEntityType: text("related_entity_type"),
      startedAt: timestamp("started_at"),
      completedAt: timestamp("completed_at"),
      failedAt: timestamp("failed_at"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow()
    }, (table) => ({
      userIdx: index("idx_background_jobs_user").on(table.userId),
      statusIdx: index("idx_background_jobs_status").on(table.status),
      sessionIdx: index("idx_background_jobs_session").on(table.sessionId),
      typeIdx: index("idx_background_jobs_type").on(table.jobType),
      relatedEntityIdx: index("idx_background_jobs_related_entity").on(table.relatedEntityId, table.relatedEntityType)
    }));
    researchBatches = pgTable("research_batches", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      sessionId: varchar("session_id").notNull(),
      understandingId: varchar("understanding_id"),
      journeyType: journeyTypeEnum("journey_type"),
      requestedAt: timestamp("requested_at").notNull().defaultNow(),
      query: text("query").notNull(),
      rawDataPath: text("raw_data_path").notNull(),
      status: researchBatchStatusEnum("status").notNull().default("captured"),
      sourcesCount: integer("sources_count").default(0),
      dataSizeKb: integer("data_size_kb").default(0),
      enrichedAt: timestamp("enriched_at"),
      errorMessage: text("error_message"),
      createdAt: timestamp("created_at").notNull().defaultNow()
    }, (table) => ({
      sessionIdx: index("idx_research_batches_session").on(table.sessionId),
      understandingIdx: index("idx_research_batches_understanding").on(table.understandingId),
      statusIdx: index("idx_research_batches_status").on(table.status),
      requestedIdx: index("idx_research_batches_requested").on(table.requestedAt)
    }));
    goldenRecords = pgTable("golden_records", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      journeyType: journeyTypeEnum("journey_type").notNull(),
      flowVariant: varchar("flow_variant", { length: 50 }).notNull().default("strategic_consultant"),
      // Flow variants: 'strategic_consultant' (v1 baseline with Five Whys) or 'strategies_hub' (follow-on without Five Whys)
      version: integer("version").notNull(),
      parentVersion: integer("parent_version"),
      isCurrent: boolean("is_current").notNull().default(false),
      metadata: jsonb("metadata"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      notes: text("notes"),
      steps: jsonb("steps").notNull()
    }, (table) => ({
      journeyTypeIdx: index("idx_golden_records_journey_type").on(table.journeyType),
      flowVariantIdx: index("idx_golden_records_flow_variant").on(table.flowVariant),
      versionIdx: index("idx_golden_records_version").on(table.journeyType, table.flowVariant, table.version),
      currentIdx: index("idx_golden_records_current").on(table.journeyType, table.flowVariant, table.isCurrent),
      uniqueVersionPerFlow: unique("unique_golden_record_version_flow").on(table.journeyType, table.flowVariant, table.version)
      // Note: "Only one current record per journey type + flow variant" constraint enforced in application layer
    }));
    goldenRecordChecks = pgTable("golden_record_checks", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      goldenRecordId: varchar("golden_record_id").notNull().references(() => goldenRecords.id),
      sessionId: varchar("session_id").notNull(),
      status: text("status").notNull(),
      diffSummary: jsonb("diff_summary"),
      stepResults: jsonb("step_results").notNull(),
      exitCode: integer("exit_code").notNull(),
      executedAt: timestamp("executed_at").notNull().defaultNow(),
      executedBy: varchar("executed_by").references(() => users.id)
    }, (table) => ({
      goldenRecordIdx: index("idx_golden_record_checks_record").on(table.goldenRecordId),
      sessionIdx: index("idx_golden_record_checks_session").on(table.sessionId),
      statusIdx: index("idx_golden_record_checks_status").on(table.status),
      executedAtIdx: index("idx_golden_record_checks_executed").on(table.executedAt)
    }));
    clarificationSessions = pgTable("clarification_sessions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      journeySessionId: varchar("journey_session_id").notNull(),
      userId: varchar("user_id").notNull().references(() => users.id),
      originalInput: text("original_input").notNull(),
      questionsAsked: jsonb("questions_asked").notNull().default(sql`'[]'::jsonb`),
      // Array of question definitions
      answersCollected: jsonb("answers_collected").notNull().default(sql`'{}'::jsonb`),
      // Map of field -> answer
      enrichedContext: jsonb("enriched_context"),
      // Derived strategic context from answers
      status: text("status").notNull().default("in_progress"),
      // in_progress, completed, skipped
      completedAt: timestamp("completed_at"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow()
    }, (table) => ({
      journeySessionIdx: index("idx_clarification_sessions_journey").on(table.journeySessionId),
      userIdx: index("idx_clarification_sessions_user").on(table.userId),
      statusIdx: index("idx_clarification_sessions_status").on(table.status)
    }));
    customJourneyStatusEnum = pgEnum("custom_journey_status", [
      "draft",
      "published",
      "archived"
    ]);
    customJourneyExecutionStatusEnum = pgEnum("custom_journey_execution_status", [
      "pending",
      "running",
      "paused",
      "completed",
      "failed"
    ]);
    journeyNodeStatusEnum = pgEnum("journey_node_status", [
      "pending",
      "running",
      "completed",
      "failed",
      "skipped"
    ]);
    customJourneyConfigs = pgTable("custom_journey_configs", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      name: varchar("name", { length: 255 }).notNull(),
      description: text("description"),
      createdBy: varchar("created_by").notNull().references(() => users.id),
      status: customJourneyStatusEnum("status").notNull().default("draft"),
      nodes: jsonb("nodes").notNull().default(sql`'[]'::jsonb`),
      // Array of {id, moduleId, position, config}
      edges: jsonb("edges").notNull().default(sql`'[]'::jsonb`),
      // Array of {id, sourceNodeId, sourcePortId, targetNodeId, targetPortId}
      metadata: jsonb("metadata"),
      // Optional UI state, tags, category
      estimatedDurationMinutes: integer("estimated_duration_minutes"),
      version: integer("version").notNull().default(1),
      publishedAt: timestamp("published_at"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow()
    }, (table) => ({
      createdByIdx: index("idx_custom_journey_configs_created_by").on(table.createdBy),
      statusIdx: index("idx_custom_journey_configs_status").on(table.status),
      nameIdx: index("idx_custom_journey_configs_name").on(table.name)
    }));
    customJourneyExecutions = pgTable("custom_journey_executions", {
      id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
      configId: varchar("config_id").notNull().references(() => customJourneyConfigs.id),
      userId: varchar("user_id").notNull().references(() => users.id),
      status: customJourneyExecutionStatusEnum("status").notNull().default("pending"),
      currentNodeId: varchar("current_node_id"),
      // Currently executing node
      nodeStates: jsonb("node_states").notNull().default(sql`'{}'::jsonb`),
      // Map of nodeId -> {status, startedAt, completedAt, output, error}
      inputData: jsonb("input_data"),
      // Initial input provided by user
      aggregatedOutputs: jsonb("aggregated_outputs").notNull().default(sql`'{}'::jsonb`),
      // Map of nodeId -> output for passing between modules
      progress: integer("progress").notNull().default(0),
      // 0-100
      progressMessage: text("progress_message"),
      errorMessage: text("error_message"),
      startedAt: timestamp("started_at"),
      pausedAt: timestamp("paused_at"),
      completedAt: timestamp("completed_at"),
      createdAt: timestamp("created_at").notNull().defaultNow(),
      updatedAt: timestamp("updated_at").notNull().defaultNow()
    }, (table) => ({
      configIdx: index("idx_custom_journey_executions_config").on(table.configId),
      userIdx: index("idx_custom_journey_executions_user").on(table.userId),
      statusIdx: index("idx_custom_journey_executions_status").on(table.status)
    }));
    insertSwProblemSchema = createInsertSchema(swProblems).omit({ id: true, createdAt: true, updatedAt: true });
    insertSwStrategySchema = createInsertSchema(swStrategies).omit({ id: true, createdAt: true, updatedAt: true });
    insertSwFrameworkRunSchema = createInsertSchema(swFrameworkRuns).omit({ id: true, startedAt: true, completedAt: true });
    insertSwExecutionPlanSchema = createInsertSchema(swExecutionPlans).omit({ id: true, createdAt: true, approvedAt: true });
    insertSwJourneyStateSchema = createInsertSchema(swJourneyStates).omit({ id: true, lastSaved: true });
    insertSwApprovalSchema = createInsertSchema(swApprovals).omit({ id: true, createdAt: true, decidedAt: true });
    insertSwAttachmentSchema = createInsertSchema(swAttachments).omit({ id: true, uploadedAt: true });
    insertSwComparisonSchema = createInsertSchema(swStrategyComparisons).omit({ id: true, createdAt: true });
    insertSwAuditLogSchema = createInsertSchema(swAuditLog).omit({ id: true, timestamp: true });
    insertJourneyTemplateSchema = createInsertSchema(journeyTemplates).omit({ id: true, createdAt: true, updatedAt: true });
    insertUserJourneySchema = createInsertSchema(userJourneys).omit({ id: true, startedAt: true, lastActivityAt: true });
    insertFrameworkRegistrySchema = createInsertSchema(frameworkRegistry).omit({ id: true, createdAt: true, updatedAt: true });
    insertBackgroundJobSchema = createInsertSchema(backgroundJobs).omit({ id: true, createdAt: true, updatedAt: true, startedAt: true, completedAt: true, failedAt: true });
    insertResearchBatchSchema = createInsertSchema(researchBatches).omit({ id: true, createdAt: true, enrichedAt: true });
    insertGoldenRecordSchema = createInsertSchema(goldenRecords).omit({ id: true, createdAt: true });
    insertGoldenRecordCheckSchema = createInsertSchema(goldenRecordChecks).omit({ id: true, executedAt: true });
    insertClarificationSessionSchema = createInsertSchema(clarificationSessions).omit({ id: true, createdAt: true, updatedAt: true, completedAt: true });
    insertCustomJourneyConfigSchema = createInsertSchema(customJourneyConfigs).omit({ id: true, createdAt: true, updatedAt: true, publishedAt: true });
    insertCustomJourneyExecutionSchema = createInsertSchema(customJourneyExecutions).omit({ id: true, createdAt: true, updatedAt: true, startedAt: true, pausedAt: true, completedAt: true });
  }
});

// server/db.ts
var db_exports = {};
__export(db_exports, {
  db: () => db,
  pool: () => pool
});
import { Pool, neonConfig } from "@neondatabase/serverless";
import { drizzle } from "drizzle-orm/neon-serverless";
import ws from "ws";
var pool, db;
var init_db = __esm({
  "server/db.ts"() {
    "use strict";
    init_schema();
    neonConfig.webSocketConstructor = ws;
    if (!process.env.DATABASE_URL) {
      throw new Error(
        "DATABASE_URL must be set. Did you forget to provision a database?"
      );
    }
    pool = new Pool({ connectionString: process.env.DATABASE_URL });
    db = drizzle({ client: pool, schema: schema_exports });
  }
});

// server/db-connection-manager.ts
import { drizzle as drizzle2 } from "drizzle-orm/neon-serverless";
var DBConnectionManager, dbConnectionManager;
var init_db_connection_manager = __esm({
  "server/db-connection-manager.ts"() {
    "use strict";
    init_db();
    init_schema();
    DBConnectionManager = class {
      defaultRetryOptions = {
        maxRetries: 3,
        baseDelayMs: 1e3,
        maxDelayMs: 1e4,
        onRetry: (attempt, error) => {
          console.log(`[DBConnectionManager] Retry attempt ${attempt} after error:`, error.message);
        }
      };
      /**
       * Execute a database operation with a fresh connection.
       * Connection is automatically acquired before operation and released after.
       * 
       * Use this for SHORT database operations (queries, inserts, updates).
       * Do NOT use during long AI/web operations.
       */
      async withFreshConnection(operation) {
        const client2 = await pool.connect();
        try {
          const db2 = drizzle2({ client: client2, schema: schema_exports });
          const result = await operation(db2);
          return result;
        } finally {
          client2.release();
        }
      }
      /**
       * Execute a database operation with automatic retry and exponential backoff.
       * Handles transient connection errors (timeouts, connection killed, etc.)
       * 
       * Use this for SAVING RESULTS after long operations.
       */
      async retryWithBackoff(operation, options) {
        const opts = { ...this.defaultRetryOptions, ...options };
        let lastError;
        for (let attempt = 1; attempt <= opts.maxRetries; attempt++) {
          try {
            return await this.withFreshConnection(operation);
          } catch (error) {
            lastError = error;
            if (!this.isRetryableError(error)) {
              throw error;
            }
            if (attempt === opts.maxRetries) {
              console.error(`[DBConnectionManager] All ${opts.maxRetries} retry attempts failed`);
              throw error;
            }
            const delay = Math.min(
              opts.baseDelayMs * Math.pow(2, attempt - 1),
              opts.maxDelayMs
            );
            opts.onRetry(attempt, error);
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
        throw lastError;
      }
      /**
       * Check if an error is retryable (connection-related).
       * Returns true for errors that might be resolved by reconnecting.
       */
      isRetryableError(error) {
        if (!(error instanceof Error)) return false;
        const message = error.message.toLowerCase();
        const retryablePatterns = [
          "terminating connection",
          "connection terminated",
          "connection closed",
          "connection timeout",
          "connection lost",
          "econnreset",
          "econnrefused",
          "etimedout",
          "administrator command"
          // Neon-specific: connection killed by admin
        ];
        return retryablePatterns.some((pattern) => message.includes(pattern));
      }
      /**
       * Execute multiple database operations in a transaction with retry.
       * All operations succeed or all fail together.
       * 
       * Use this when you need atomic updates across multiple tables.
       */
      async transactionWithRetry(operations, options) {
        return this.retryWithBackoff(async (db2) => {
          return await operations(db2);
        }, options);
      }
    };
    dbConnectionManager = new DBConnectionManager();
  }
});

// server/ai-clients.ts
import OpenAI from "openai";
import Anthropic from "@anthropic-ai/sdk";
import { GoogleGenAI } from "@google/genai";
var OPENAI_MODEL, ANTHROPIC_MODEL, GEMINI_MODEL, OLLAMA_MODEL, OLLAMA_BASE_URL, AIClients, aiClients;
var init_ai_clients = __esm({
  "server/ai-clients.ts"() {
    "use strict";
    OPENAI_MODEL = "gpt-5";
    ANTHROPIC_MODEL = "claude-sonnet-4-20250514";
    GEMINI_MODEL = "gemini-2.5-pro";
    OLLAMA_MODEL = process.env.OLLAMA_MODEL || "llama3.1:8b";
    OLLAMA_BASE_URL = process.env.OLLAMA_BASE_URL || "http://localhost:11434/v1";
    AIClients = class {
      openai = null;
      anthropic = null;
      gemini = null;
      ollama = null;
      constructor() {
      }
      getOpenAI() {
        if (!this.openai) {
          const apiKey = process.env.OPENAI_API_KEY;
          if (!apiKey) {
            throw new Error("OPENAI_API_KEY environment variable is not set");
          }
          this.openai = new OpenAI({ apiKey });
        }
        return this.openai;
      }
      getAnthropic() {
        if (!this.anthropic) {
          const apiKey = process.env.ANTHROPIC_API_KEY;
          if (!apiKey) {
            throw new Error("ANTHROPIC_API_KEY environment variable is not set");
          }
          this.anthropic = new Anthropic({ apiKey });
        }
        return this.anthropic;
      }
      getGemini() {
        if (!this.gemini) {
          const apiKey = process.env.GEMINI_API_KEY;
          if (!apiKey) {
            throw new Error("GEMINI_API_KEY environment variable is not set");
          }
          this.gemini = new GoogleGenAI({ apiKey });
        }
        return this.gemini;
      }
      getOllama() {
        if (!this.ollama) {
          this.ollama = new OpenAI({
            baseURL: OLLAMA_BASE_URL,
            apiKey: "ollama"
            // Ollama doesn't need a real key
          });
        }
        return this.ollama;
      }
      async callOpenAI(request) {
        const { systemPrompt, userMessage, maxTokens = 8192 } = request;
        const openai = this.getOpenAI();
        const response = await openai.chat.completions.create({
          model: OPENAI_MODEL,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userMessage }
          ],
          response_format: { type: "json_object" },
          max_completion_tokens: maxTokens
        });
        return {
          content: response.choices[0].message.content || "",
          provider: "openai",
          model: OPENAI_MODEL
        };
      }
      async callAnthropic(request) {
        const { systemPrompt, userMessage, maxTokens = 8192 } = request;
        const anthropic2 = this.getAnthropic();
        const response = await anthropic2.messages.create({
          model: ANTHROPIC_MODEL,
          system: systemPrompt,
          max_tokens: maxTokens,
          messages: [
            { role: "user", content: userMessage }
          ]
        });
        const textBlock = response.content.find((block) => block.type === "text");
        const content = textBlock && "text" in textBlock ? textBlock.text : "";
        return {
          content,
          provider: "anthropic",
          model: ANTHROPIC_MODEL
        };
      }
      async callGemini(request) {
        const { systemPrompt, userMessage, responseSchema } = request;
        const gemini = this.getGemini();
        const config = {
          systemInstruction: systemPrompt
        };
        if (responseSchema) {
          config.responseMimeType = "application/json";
          config.responseSchema = responseSchema;
        }
        const response = await gemini.models.generateContent({
          model: GEMINI_MODEL,
          contents: userMessage,
          config
        });
        return {
          content: response.text || "",
          provider: "gemini",
          model: GEMINI_MODEL
        };
      }
      async callOllama(request) {
        const { systemPrompt, userMessage, maxTokens = 8192 } = request;
        const ollama = this.getOllama();
        const response = await ollama.chat.completions.create({
          model: OLLAMA_MODEL,
          messages: [
            { role: "system", content: systemPrompt },
            { role: "user", content: userMessage }
          ],
          max_tokens: maxTokens
        });
        return {
          content: response.choices[0].message.content || "",
          provider: "ollama",
          model: OLLAMA_MODEL
        };
      }
      async call(provider, request) {
        switch (provider) {
          case "openai":
            return this.callOpenAI(request);
          case "anthropic":
            return this.callAnthropic(request);
          case "gemini":
            return this.callGemini(request);
          case "ollama":
            return this.callOllama(request);
          default:
            throw new Error(`Unknown AI provider: ${provider}`);
        }
      }
      isProviderAvailable(provider) {
        switch (provider) {
          case "openai":
            return !!process.env.OPENAI_API_KEY;
          case "anthropic":
            return !!process.env.ANTHROPIC_API_KEY;
          case "gemini":
            return !!process.env.GEMINI_API_KEY;
          case "ollama":
            return process.env.USE_OLLAMA === "true";
          default:
            return false;
        }
      }
      getAvailableProviders() {
        const providers = [];
        if (this.isProviderAvailable("ollama")) providers.push("ollama");
        if (this.isProviderAvailable("openai")) providers.push("openai");
        if (this.isProviderAvailable("anthropic")) providers.push("anthropic");
        if (this.isProviderAvailable("gemini")) providers.push("gemini");
        return providers;
      }
      selectProvider(preferredProvider) {
        const available = this.getAvailableProviders();
        if (available.length === 0) {
          throw new Error("No AI providers available. Please configure at least one API key.");
        }
        if (preferredProvider && this.isProviderAvailable(preferredProvider)) {
          return preferredProvider;
        }
        if (this.isProviderAvailable("openai")) return "openai";
        if (this.isProviderAvailable("anthropic")) return "anthropic";
        return "gemini";
      }
      async callWithFallback(request, preferredProvider) {
        const defaultOrder = process.env.USE_OLLAMA === "true" ? ["ollama", "anthropic", "openai", "gemini"] : ["anthropic", "openai", "gemini"];
        const providerOrder = preferredProvider ? [preferredProvider, ...defaultOrder.filter((p) => p !== preferredProvider)] : defaultOrder;
        const errors = [];
        for (const provider of providerOrder) {
          if (!this.isProviderAvailable(provider)) {
            continue;
          }
          try {
            console.log(`[AIClients] Attempting provider: ${provider}`);
            const response = await this.call(provider, request);
            console.log(`[AIClients] \u2713 Success with provider: ${provider} (model: ${response.model})`);
            return response;
          } catch (error) {
            const errorMsg = error.message || String(error);
            console.warn(`[AIClients] \u2717 Provider ${provider} failed: ${errorMsg}`);
            errors.push({ provider, error: errorMsg });
            continue;
          }
        }
        const errorDetails = errors.map((e) => `${e.provider}: ${e.error}`).join("; ");
        throw new Error(`All AI providers failed. Errors: ${errorDetails}`);
      }
    };
    aiClients = new AIClients();
  }
});

// server/utils/kms-encryption.ts
var kms_encryption_exports = {};
__export(kms_encryption_exports, {
  decryptDataKey: () => decryptDataKey,
  decryptJSONKMS: () => decryptJSONKMS,
  decryptKMS: () => decryptKMS,
  decryptWithKMS: () => decryptWithKMS,
  encryptJSONKMS: () => encryptJSONKMS,
  encryptKMS: () => encryptKMS,
  encryptWithDataKey: () => encryptWithDataKey,
  generateDataKey: () => generateDataKey,
  validateKMSSetup: () => validateKMSSetup
});
import crypto2 from "crypto";
import { KMSClient, GenerateDataKeyCommand, DecryptCommand } from "@aws-sdk/client-kms";
function isDevMode() {
  return process.env.NODE_ENV === "development" && process.env.SKIP_ENCRYPTION !== "false" && (!process.env.AWS_ACCESS_KEY_ID || !process.env.PREMISIA_KMS_KEY_ID);
}
function devModeEncode(data) {
  return DEV_PREFIX + Buffer.from(data, "utf-8").toString("base64");
}
function devModeDecode(encoded) {
  if (!encoded.startsWith(DEV_PREFIX)) {
    return encoded;
  }
  return Buffer.from(encoded.slice(DEV_PREFIX.length), "base64").toString("utf-8");
}
function isDevEncoded(data) {
  return data.startsWith(DEV_PREFIX);
}
function getKMSClient() {
  if (!kmsClient) {
    const region = process.env.AWS_REGION;
    const accessKeyId = process.env.AWS_ACCESS_KEY_ID;
    const secretAccessKey = process.env.AWS_SECRET_ACCESS_KEY;
    if (!region || !accessKeyId || !secretAccessKey) {
      throw new Error("AWS credentials not configured. Required: AWS_REGION, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY");
    }
    kmsClient = new KMSClient({
      region,
      credentials: {
        accessKeyId,
        secretAccessKey
      }
    });
    console.log("\u2705 KMS client initialized for region:", region);
  }
  return kmsClient;
}
function getKMSKeyId() {
  const keyId = process.env.PREMISIA_KMS_KEY_ID;
  if (!keyId) {
    throw new Error("PREMISIA_KMS_KEY_ID environment variable not set");
  }
  return keyId;
}
async function generateDataKey() {
  try {
    const client2 = getKMSClient();
    const keyId = getKMSKeyId();
    const command = new GenerateDataKeyCommand({
      KeyId: keyId,
      KeySpec: "AES_256"
    });
    const response = await client2.send(command);
    if (!response.Plaintext || !response.CiphertextBlob) {
      throw new Error("KMS GenerateDataKey returned incomplete response");
    }
    const plaintextKey = Buffer.from(response.Plaintext);
    const encryptedKey = Buffer.from(response.CiphertextBlob);
    if (plaintextKey.length !== KEY_LENGTH2) {
      throw new Error(`Generated data key has invalid length: ${plaintextKey.length} (expected ${KEY_LENGTH2})`);
    }
    return { plaintextKey, encryptedKey };
  } catch (error) {
    console.error("\u274C KMS GenerateDataKey failed:", error);
    throw new Error(`Failed to generate data key: ${error instanceof Error ? error.message : String(error)}`);
  }
}
function encryptWithDataKey(plaintext, dataKey) {
  try {
    if (dataKey.length !== KEY_LENGTH2) {
      throw new Error(`Invalid data key length: ${dataKey.length} (expected ${KEY_LENGTH2})`);
    }
    const iv = crypto2.randomBytes(IV_LENGTH2);
    const cipher = crypto2.createCipheriv(ALGORITHM2, dataKey, iv);
    let encrypted = cipher.update(plaintext, "utf8");
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    const authTag = cipher.getAuthTag();
    return {
      dataKeyCiphertext: "",
      iv: iv.toString("base64"),
      authTag: authTag.toString("base64"),
      ciphertext: encrypted.toString("base64")
    };
  } catch (error) {
    console.error("\u274C Encryption with data key failed:", error);
    throw new Error(`Failed to encrypt with data key: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function decryptDataKey(encryptedKey) {
  try {
    const client2 = getKMSClient();
    const command = new DecryptCommand({
      CiphertextBlob: encryptedKey
    });
    const response = await client2.send(command);
    if (!response.Plaintext) {
      throw new Error("KMS Decrypt returned no plaintext");
    }
    const plaintextKey = Buffer.from(response.Plaintext);
    if (plaintextKey.length !== KEY_LENGTH2) {
      throw new Error(`Decrypted data key has invalid length: ${plaintextKey.length} (expected ${KEY_LENGTH2})`);
    }
    return plaintextKey;
  } catch (error) {
    console.error("\u274C KMS Decrypt failed:", error);
    throw new Error(`Failed to decrypt data key: ${error instanceof Error ? error.message : String(error)}`);
  }
}
async function decryptWithKMS(payload) {
  let dataKey = null;
  try {
    const encryptedKey = Buffer.from(payload.dataKeyCiphertext, "base64");
    dataKey = await decryptDataKey(encryptedKey);
    const iv = Buffer.from(payload.iv, "base64");
    const authTag = Buffer.from(payload.authTag, "base64");
    const ciphertext = Buffer.from(payload.ciphertext, "base64");
    const decipher = crypto2.createDecipheriv(ALGORITHM2, dataKey, iv);
    decipher.setAuthTag(authTag);
    let decrypted = decipher.update(ciphertext);
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString("utf8");
  } catch (error) {
    console.error("\u274C Decryption with KMS failed:", error);
    throw new Error(`Failed to decrypt with KMS: ${error instanceof Error ? error.message : String(error)}`);
  } finally {
    if (dataKey) {
      dataKey.fill(0);
      dataKey = null;
    }
  }
}
function isKMSEncryptedFormat(data) {
  try {
    const parsed = JSON.parse(data);
    return typeof parsed === "object" && parsed !== null && "dataKeyCiphertext" in parsed && "iv" in parsed && "authTag" in parsed && "ciphertext" in parsed;
  } catch {
    return false;
  }
}
function isLegacyEncryptedFormat(data) {
  if (typeof data !== "string") return false;
  const parts = data.split(":");
  if (parts.length !== 3) return false;
  try {
    const iv = Buffer.from(parts[0], "base64");
    const authTag = Buffer.from(parts[1], "base64");
    const encrypted = Buffer.from(parts[2], "base64");
    return iv.length === IV_LENGTH2 && authTag.length > 0 && encrypted.length > 0;
  } catch {
    return false;
  }
}
async function encryptKMS(text2) {
  if (!text2) return null;
  if (isDevMode()) {
    console.log("\u26A0\uFE0F  [DEV MODE] Using unencrypted storage (no KMS)");
    return devModeEncode(text2);
  }
  let plaintextKey = null;
  try {
    const { plaintextKey: key, encryptedKey } = await generateDataKey();
    plaintextKey = key;
    const payload = encryptWithDataKey(text2, plaintextKey);
    payload.dataKeyCiphertext = encryptedKey.toString("base64");
    return JSON.stringify(payload);
  } catch (error) {
    console.error("\u274C KMS encryption failed:", error);
    throw new Error(`Failed to encrypt with KMS: ${error instanceof Error ? error.message : String(error)}`);
  } finally {
    if (plaintextKey) {
      plaintextKey.fill(0);
      plaintextKey = null;
    }
  }
}
async function decryptKMS(encryptedData) {
  if (!encryptedData) return null;
  if (typeof encryptedData === "string" && isDevEncoded(encryptedData)) {
    return devModeDecode(encryptedData);
  }
  let dataToCheck;
  if (typeof encryptedData === "object") {
    const obj = encryptedData;
    if ("dataKeyCiphertext" in obj && "iv" in obj && "authTag" in obj && "ciphertext" in obj) {
      try {
        return await decryptWithKMS(obj);
      } catch (error) {
        console.error("\u274C KMS decryption failed:", error);
        throw error;
      }
    }
    console.warn("\u26A0\uFE0F  Unencrypted object data detected, returning as-is");
    return JSON.stringify(encryptedData);
  }
  dataToCheck = encryptedData;
  if (isKMSEncryptedFormat(dataToCheck)) {
    try {
      const payload = JSON.parse(dataToCheck);
      return await decryptWithKMS(payload);
    } catch (error) {
      console.error("\u274C KMS decryption failed:", error);
      throw error;
    }
  }
  if (isLegacyEncryptedFormat(dataToCheck)) {
    console.warn("\u26A0\uFE0F  Legacy encryption format detected. This data should be re-encrypted with KMS.");
    const { decrypt: decrypt2 } = await Promise.resolve().then(() => (init_encryption(), encryption_exports));
    return decrypt2(dataToCheck);
  }
  console.warn("\u26A0\uFE0F  Unencrypted data detected, returning as-is");
  return dataToCheck;
}
async function encryptJSONKMS(obj) {
  if (!obj) return null;
  return encryptKMS(JSON.stringify(obj));
}
async function decryptJSONKMS(encryptedData) {
  if (!encryptedData) return null;
  const decrypted = await decryptKMS(encryptedData);
  if (!decrypted) return null;
  if (typeof decrypted === "object" && decrypted !== null) {
    return decrypted;
  }
  try {
    return JSON.parse(decrypted);
  } catch (error) {
    console.error("\u274C Error parsing decrypted JSON:", error);
    return null;
  }
}
async function validateKMSSetup() {
  try {
    const client2 = getKMSClient();
    const keyId = getKMSKeyId();
    console.log("\u{1F510} Validating KMS setup...");
    console.log("  Region:", process.env.AWS_REGION);
    console.log("  Key ID:", keyId);
    const testData = "kms-encryption-test";
    const encrypted = await encryptKMS(testData);
    if (!encrypted) {
      throw new Error("Encryption returned null");
    }
    const decrypted = await decryptKMS(encrypted);
    if (decrypted !== testData) {
      throw new Error("Encryption/decryption cycle did not match");
    }
    console.log("\u2705 KMS encryption validated successfully");
  } catch (error) {
    console.error("\u274C KMS validation failed:", error);
    throw error;
  }
}
var ALGORITHM2, IV_LENGTH2, KEY_LENGTH2, DEV_PREFIX, kmsClient;
var init_kms_encryption = __esm({
  "server/utils/kms-encryption.ts"() {
    "use strict";
    ALGORITHM2 = "aes-256-gcm";
    IV_LENGTH2 = 16;
    KEY_LENGTH2 = 32;
    DEV_PREFIX = "DEV_UNENCRYPTED:";
    kmsClient = null;
  }
});

// server/services/secure-data-service.ts
var secure_data_service_exports = {};
__export(secure_data_service_exports, {
  getEPMProgram: () => getEPMProgram,
  getEPMProgramsByUser: () => getEPMProgramsByUser,
  getJourneySession: () => getJourneySession,
  getJourneySessionByUnderstandingSessionId: () => getJourneySessionByUnderstandingSessionId,
  getStrategicEntitiesByUnderstanding: () => getStrategicEntitiesByUnderstanding,
  getStrategicUnderstanding: () => getStrategicUnderstanding,
  getStrategicUnderstandingBySession: () => getStrategicUnderstandingBySession,
  getStrategyVersion: () => getStrategyVersion,
  saveEPMProgram: () => saveEPMProgram,
  saveJourneySession: () => saveJourneySession,
  saveStrategicEntity: () => saveStrategicEntity,
  saveStrategicRelationship: () => saveStrategicRelationship,
  saveStrategicUnderstanding: () => saveStrategicUnderstanding,
  saveStrategyVersion: () => saveStrategyVersion,
  updateEPMProgram: () => updateEPMProgram,
  updateJourneySession: () => updateJourneySession,
  updateStrategicUnderstanding: () => updateStrategicUnderstanding,
  updateStrategyVersion: () => updateStrategyVersion
});
import { eq, and } from "drizzle-orm";
async function saveStrategicUnderstanding(data) {
  const encrypted = {
    ...data,
    userInput: await encryptKMS(data.userInput),
    companyContext: data.companyContext ? await encryptJSONKMS(data.companyContext) : null,
    initiativeDescription: data.initiativeDescription ? await encryptKMS(data.initiativeDescription) : null
  };
  const result = await db.insert(strategicUnderstanding).values(encrypted).returning();
  return await decryptStrategicUnderstanding(result[0]);
}
async function updateStrategicUnderstanding(id, data) {
  const encrypted = { ...data };
  if (data.userInput !== void 0) {
    encrypted.userInput = await encryptKMS(data.userInput);
  }
  if (data.companyContext !== void 0) {
    encrypted.companyContext = await encryptJSONKMS(data.companyContext);
  }
  if (data.initiativeDescription !== void 0) {
    encrypted.initiativeDescription = await encryptKMS(data.initiativeDescription);
  }
  encrypted.updatedAt = /* @__PURE__ */ new Date();
  const result = await db.update(strategicUnderstanding).set(encrypted).where(eq(strategicUnderstanding.id, id)).returning();
  return result[0] ? await decryptStrategicUnderstanding(result[0]) : null;
}
async function getStrategicUnderstanding(id) {
  const result = await db.select().from(strategicUnderstanding).where(eq(strategicUnderstanding.id, id)).limit(1);
  return result[0] ? await decryptStrategicUnderstanding(result[0]) : null;
}
async function getStrategicUnderstandingBySession(sessionId) {
  const result = await db.select().from(strategicUnderstanding).where(eq(strategicUnderstanding.sessionId, sessionId)).limit(1);
  return result[0] ? await decryptStrategicUnderstanding(result[0]) : null;
}
async function decryptStrategicUnderstanding(record) {
  return {
    ...record,
    userInput: await decryptKMS(record.userInput) || record.userInput,
    companyContext: record.companyContext ? await decryptJSONKMS(record.companyContext) || record.companyContext : null,
    initiativeDescription: record.initiativeDescription ? await decryptKMS(record.initiativeDescription) || record.initiativeDescription : null
  };
}
async function saveJourneySession(data) {
  const encrypted = {
    ...data,
    accumulatedContext: data.accumulatedContext ? await encryptJSONKMS(data.accumulatedContext) : null
  };
  const result = await db.insert(journeySessions).values(encrypted).returning();
  return await decryptJourneySession(result[0]);
}
async function updateJourneySession(id, data) {
  const encrypted = { ...data };
  if (data.accumulatedContext !== void 0) {
    encrypted.accumulatedContext = await encryptJSONKMS(data.accumulatedContext);
  }
  encrypted.updatedAt = /* @__PURE__ */ new Date();
  const result = await db.update(journeySessions).set(encrypted).where(eq(journeySessions.id, id)).returning();
  return result[0] ? await decryptJourneySession(result[0]) : null;
}
async function getJourneySession(id) {
  const result = await db.select().from(journeySessions).where(eq(journeySessions.id, id)).limit(1);
  return result[0] ? await decryptJourneySession(result[0]) : null;
}
async function getJourneySessionByUnderstandingSessionId(understandingSessionId) {
  const understanding = await getStrategicUnderstandingBySession(understandingSessionId);
  if (!understanding) {
    return null;
  }
  const result = await db.select().from(journeySessions).where(eq(journeySessions.understandingId, understanding.id)).limit(1);
  return result[0] ? await decryptJourneySession(result[0]) : null;
}
async function decryptJourneySession(record) {
  return {
    ...record,
    accumulatedContext: record.accumulatedContext ? await decryptJSONKMS(record.accumulatedContext) || record.accumulatedContext : null,
    metadata: record.metadata
    // Pass through metadata (not encrypted)
  };
}
async function saveStrategicEntity(data) {
  const encrypted = {
    ...data,
    claim: await encryptKMS(data.claim),
    source: await encryptKMS(data.source),
    evidence: data.evidence ? await encryptKMS(data.evidence) : null,
    category: data.category ? await encryptKMS(data.category) : null,
    subcategory: data.subcategory ? await encryptKMS(data.subcategory) : null,
    metadata: data.metadata ? await encryptJSONKMS(data.metadata) : null
  };
  const result = await db.insert(strategicEntities).values(encrypted).returning();
  return await decryptStrategicEntity(result[0]);
}
async function getStrategicEntitiesByUnderstanding(understandingId) {
  const result = await db.select().from(strategicEntities).where(eq(strategicEntities.understandingId, understandingId));
  return Promise.all(result.map(decryptStrategicEntity));
}
async function decryptStrategicEntity(record) {
  return {
    ...record,
    claim: await decryptKMS(record.claim) || record.claim,
    source: await decryptKMS(record.source) || record.source,
    evidence: record.evidence ? await decryptKMS(record.evidence) || record.evidence : null,
    category: record.category ? await decryptKMS(record.category) || record.category : null,
    subcategory: record.subcategory ? await decryptKMS(record.subcategory) || record.subcategory : null,
    metadata: record.metadata ? await decryptJSONKMS(record.metadata) || record.metadata : null
  };
}
async function saveStrategicRelationship(data) {
  const encrypted = {
    ...data,
    evidence: data.evidence ? await encryptKMS(data.evidence) : null,
    metadata: data.metadata ? await encryptJSONKMS(data.metadata) : null
  };
  const result = await db.insert(strategicRelationships).values(encrypted).returning();
  return await decryptStrategicRelationship(result[0]);
}
async function decryptStrategicRelationship(record) {
  return {
    ...record,
    evidence: record.evidence ? await decryptKMS(record.evidence) || record.evidence : null,
    metadata: record.metadata ? await decryptJSONKMS(record.metadata) || record.metadata : null
  };
}
async function saveEPMProgram(data) {
  const encrypted = {
    ...data,
    programName: data.programName ? await encryptKMS(data.programName) : null,
    executiveSummary: data.executiveSummary ? await encryptKMS(data.executiveSummary) : null,
    workstreams: data.workstreams ? await encryptJSONKMS(data.workstreams) : null,
    timeline: data.timeline ? await encryptJSONKMS(data.timeline) : null,
    resourcePlan: data.resourcePlan ? await encryptJSONKMS(data.resourcePlan) : null,
    financialPlan: data.financialPlan ? await encryptJSONKMS(data.financialPlan) : null,
    benefitsRealization: data.benefitsRealization ? await encryptJSONKMS(data.benefitsRealization) : null,
    riskRegister: data.riskRegister ? await encryptJSONKMS(data.riskRegister) : null,
    stakeholderMap: data.stakeholderMap ? await encryptJSONKMS(data.stakeholderMap) : null,
    governance: data.governance ? await encryptJSONKMS(data.governance) : null,
    qaPlan: data.qaPlan ? await encryptJSONKMS(data.qaPlan) : null,
    procurement: data.procurement ? await encryptJSONKMS(data.procurement) : null,
    exitStrategy: data.exitStrategy ? await encryptJSONKMS(data.exitStrategy) : null,
    kpis: data.kpis ? await encryptJSONKMS(data.kpis) : null
  };
  const result = await db.insert(epmPrograms).values(encrypted).returning();
  return await decryptEPMProgram(result[0]);
}
async function updateEPMProgram(id, data) {
  const encrypted = { ...data };
  if (data.programName !== void 0) encrypted.programName = await encryptKMS(data.programName);
  if (data.executiveSummary !== void 0) encrypted.executiveSummary = await encryptKMS(data.executiveSummary);
  if (data.workstreams !== void 0) encrypted.workstreams = await encryptJSONKMS(data.workstreams);
  if (data.timeline !== void 0) encrypted.timeline = await encryptJSONKMS(data.timeline);
  if (data.resourcePlan !== void 0) encrypted.resourcePlan = await encryptJSONKMS(data.resourcePlan);
  if (data.financialPlan !== void 0) encrypted.financialPlan = await encryptJSONKMS(data.financialPlan);
  if (data.benefitsRealization !== void 0) encrypted.benefitsRealization = await encryptJSONKMS(data.benefitsRealization);
  if (data.riskRegister !== void 0) encrypted.riskRegister = await encryptJSONKMS(data.riskRegister);
  if (data.stakeholderMap !== void 0) encrypted.stakeholderMap = await encryptJSONKMS(data.stakeholderMap);
  if (data.governance !== void 0) encrypted.governance = await encryptJSONKMS(data.governance);
  if (data.qaPlan !== void 0) encrypted.qaPlan = await encryptJSONKMS(data.qaPlan);
  if (data.procurement !== void 0) encrypted.procurement = await encryptJSONKMS(data.procurement);
  if (data.exitStrategy !== void 0) encrypted.exitStrategy = await encryptJSONKMS(data.exitStrategy);
  if (data.kpis !== void 0) encrypted.kpis = await encryptJSONKMS(data.kpis);
  const result = await db.update(epmPrograms).set(encrypted).where(eq(epmPrograms.id, id)).returning();
  return result[0] ? await decryptEPMProgram(result[0]) : null;
}
async function getEPMProgram(id) {
  const result = await db.select().from(epmPrograms).where(eq(epmPrograms.id, id)).limit(1);
  return result[0] ? await decryptEPMProgram(result[0]) : null;
}
async function getEPMProgramsByUser(userId) {
  const result = await db.select().from(epmPrograms).where(eq(epmPrograms.userId, userId));
  return Promise.all(result.map(decryptEPMProgram));
}
async function decryptEPMProgram(record) {
  return {
    ...record,
    programName: record.programName ? await decryptKMS(record.programName) || record.programName : null,
    executiveSummary: record.executiveSummary ? await decryptKMS(record.executiveSummary) || record.executiveSummary : null,
    workstreams: record.workstreams ? await decryptJSONKMS(record.workstreams) || record.workstreams : null,
    timeline: record.timeline ? await decryptJSONKMS(record.timeline) || record.timeline : null,
    resourcePlan: record.resourcePlan ? await decryptJSONKMS(record.resourcePlan) || record.resourcePlan : null,
    financialPlan: record.financialPlan ? await decryptJSONKMS(record.financialPlan) || record.financialPlan : null,
    benefitsRealization: record.benefitsRealization ? await decryptJSONKMS(record.benefitsRealization) || record.benefitsRealization : null,
    riskRegister: record.riskRegister ? await decryptJSONKMS(record.riskRegister) || record.riskRegister : null,
    stakeholderMap: record.stakeholderMap ? await decryptJSONKMS(record.stakeholderMap) || record.stakeholderMap : null,
    governance: record.governance ? await decryptJSONKMS(record.governance) || record.governance : null,
    qaPlan: record.qaPlan ? await decryptJSONKMS(record.qaPlan) || record.qaPlan : null,
    procurement: record.procurement ? await decryptJSONKMS(record.procurement) || record.procurement : null,
    exitStrategy: record.exitStrategy ? await decryptJSONKMS(record.exitStrategy) || record.exitStrategy : null,
    kpis: record.kpis ? await decryptJSONKMS(record.kpis) || record.kpis : null
  };
}
async function saveStrategyVersion(data) {
  const encrypted = {
    ...data,
    inputSummary: data.inputSummary ? await encryptKMS(data.inputSummary) : null,
    analysisData: data.analysisData ? await encryptJSONKMS(data.analysisData) : null,
    decisionsData: data.decisionsData ? await encryptJSONKMS(data.decisionsData) : null
  };
  const result = await db.insert(strategyVersions).values(encrypted).returning();
  return await decryptStrategyVersion(result[0]);
}
async function updateStrategyVersion(id, data) {
  const encrypted = { ...data };
  if (data.inputSummary !== void 0) {
    encrypted.inputSummary = data.inputSummary ? await encryptKMS(data.inputSummary) : null;
  }
  if (data.analysisData !== void 0) {
    encrypted.analysisData = await encryptJSONKMS(data.analysisData);
  }
  if (data.decisionsData !== void 0) {
    encrypted.decisionsData = await encryptJSONKMS(data.decisionsData);
  }
  encrypted.updatedAt = /* @__PURE__ */ new Date();
  const result = await db.update(strategyVersions).set(encrypted).where(eq(strategyVersions.id, id)).returning();
  return result[0] ? await decryptStrategyVersion(result[0]) : null;
}
async function getStrategyVersion(sessionId, versionNumber) {
  const result = await db.select().from(strategyVersions).where(
    and(
      eq(strategyVersions.sessionId, sessionId),
      eq(strategyVersions.versionNumber, versionNumber)
    )
  ).limit(1);
  return result[0] ? await decryptStrategyVersion(result[0]) : null;
}
async function decryptStrategyVersion(record) {
  return {
    ...record,
    inputSummary: record.inputSummary ? await decryptKMS(record.inputSummary) || record.inputSummary : null,
    analysisData: record.analysisData ? await decryptJSONKMS(record.analysisData) || record.analysisData : null,
    decisionsData: record.decisionsData ? await decryptJSONKMS(record.decisionsData) || record.decisionsData : null
  };
}
var init_secure_data_service = __esm({
  "server/services/secure-data-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_kms_encryption();
  }
});

// server/utils/parse-ai-json.ts
function parseAIJson(aiResponse, context = "AI response") {
  try {
    let cleanJson = aiResponse.replace(/```json\n?/g, "").replace(/```\n?/g, "").trim();
    return JSON.parse(cleanJson);
  } catch (primaryError) {
    console.error(`[parseAIJson] Primary JSON parsing failed for ${context}:`, primaryError);
    console.log(`[parseAIJson] Attempting fallback extraction...`);
    const jsonMatch = aiResponse.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      try {
        const extracted = JSON.parse(jsonMatch[0]);
        console.log(`[parseAIJson] \u2713 Fallback extraction succeeded for ${context}`);
        return extracted;
      } catch (fallbackError) {
        console.error(`[parseAIJson] Fallback parsing also failed for ${context}:`, fallbackError);
        console.log(`[parseAIJson] Raw response (first 1500 chars):`, aiResponse.substring(0, 1500));
        console.log(`[parseAIJson] Raw response (last 500 chars):`, aiResponse.substring(Math.max(0, aiResponse.length - 500)));
        try {
          let repaired = jsonMatch[0];
          repaired = repaired.replace(/,\s*$/g, "");
          repaired = repaired.replace(/("[^"]*?)$/g, '$1"');
          const openBraces = (repaired.match(/\{/g) || []).length;
          const closeBraces = (repaired.match(/\}/g) || []).length;
          const openBrackets = (repaired.match(/\[/g) || []).length;
          const closeBrackets = (repaired.match(/\]/g) || []).length;
          for (let i = 0; i < openBrackets - closeBrackets; i++) {
            repaired += "]";
          }
          for (let i = 0; i < openBraces - closeBraces; i++) {
            repaired += "}";
          }
          const repairedObj = JSON.parse(repaired);
          console.log(`[parseAIJson] \u2713 Advanced repair succeeded for ${context}`);
          return repairedObj;
        } catch (repairError) {
          console.error(`[parseAIJson] Advanced repair also failed:`, repairError);
        }
      }
    } else {
      console.error(`[parseAIJson] No JSON object found in response for ${context}`);
      console.log(`[parseAIJson] Raw response (first 500 chars):`, aiResponse.substring(0, 500));
    }
    throw new Error(`Failed to parse AI response for ${context}: ${primaryError instanceof Error ? primaryError.message : "Unknown error"}`);
  }
}
var init_parse_ai_json = __esm({
  "server/utils/parse-ai-json.ts"() {
    "use strict";
  }
});

// server/services/title-generator.ts
var title_generator_exports = {};
__export(title_generator_exports, {
  generateTitle: () => generateTitle
});
async function generateTitle(statement) {
  const systemPrompt = `You are a strategic summarization expert. Your job is to create concise, descriptive titles for strategic questions and business scenarios.

Rules:
- Generate a title that is 5-8 words long
- Capture the core essence of the strategic question
- Use clear, professional language
- Focus on the key decision or scenario
- Return ONLY the title text, nothing else
- Do not use quotes around the title
- Make it actionable and specific`;
  const userMessage = `Create a concise 5-8 word title for this strategic statement:

"${statement}"`;
  try {
    const response = await aiClients.callWithFallback({
      systemPrompt,
      userMessage,
      maxTokens: 100
    });
    let title = response.content.trim();
    title = title.replace(/^["']|["']$/g, "");
    if (title.length > 200) {
      title = title.substring(0, 197) + "...";
    }
    return title;
  } catch (error) {
    console.error("[TitleGenerator] Failed to generate title:", error);
    const fallbackTitle = statement.substring(0, 60).trim();
    return fallbackTitle.length < statement.length ? fallbackTitle + "..." : fallbackTitle;
  }
}
var init_title_generator = __esm({
  "server/services/title-generator.ts"() {
    "use strict";
    init_ai_clients();
  }
});

// server/strategic-understanding-service.ts
import OpenAI2 from "openai";
import { z as z2 } from "zod";
import { sql as sql2, desc } from "drizzle-orm";
var EMBEDDING_MODEL, EMBEDDING_DIMENSIONS, entityExtractionSchema, StrategicUnderstandingService, strategicUnderstandingService;
var init_strategic_understanding_service = __esm({
  "server/strategic-understanding-service.ts"() {
    "use strict";
    init_db_connection_manager();
    init_schema();
    init_ai_clients();
    init_secure_data_service();
    init_encryption();
    init_parse_ai_json();
    EMBEDDING_MODEL = "text-embedding-3-small";
    EMBEDDING_DIMENSIONS = 1536;
    entityExtractionSchema = z2.object({
      entities: z2.array(z2.object({
        type: z2.enum([
          "explicit_assumption",
          "implicit_implication",
          "inferred_reasoning",
          "constraint",
          "opportunity",
          "risk"
        ]),
        claim: z2.string(),
        source: z2.string(),
        confidence: z2.enum(["high", "medium", "low"]),
        category: z2.string().optional(),
        subcategory: z2.string().optional(),
        investmentAmount: z2.number().optional(),
        evidence: z2.string().optional()
      }))
    });
    StrategicUnderstandingService = class {
      openai = null;
      embeddingCache = /* @__PURE__ */ new Map();
      constructor() {
      }
      getOpenAI() {
        if (!this.openai) {
          const apiKey = process.env.OPENAI_API_KEY;
          if (!apiKey) {
            throw new Error("OPENAI_API_KEY environment variable is not set");
          }
          this.openai = new OpenAI2({ apiKey });
        }
        return this.openai;
      }
      normalizeText(text2) {
        return text2.toLowerCase().trim().replace(/\s+/g, " ");
      }
      validateSource(source, userInput) {
        const normalizedSource = this.normalizeText(source);
        const normalizedInput = this.normalizeText(userInput);
        if (normalizedSource.length === 0) {
          return false;
        }
        return normalizedInput.includes(normalizedSource);
      }
      async getOrCreateUnderstanding(sessionId, userInput, companyContext) {
        const existing = await getStrategicUnderstandingBySession(sessionId);
        if (existing) {
          return existing;
        }
        let title = null;
        try {
          const { generateTitle: generateTitle2 } = await Promise.resolve().then(() => (init_title_generator(), title_generator_exports));
          title = await generateTitle2(userInput);
        } catch (error) {
          console.warn("[StrategicUnderstanding] Failed to generate title:", error);
          title = userInput.substring(0, 60).trim() + (userInput.length > 60 ? "..." : "");
        }
        const understanding = {
          sessionId,
          userInput,
          title,
          companyContext: companyContext || null,
          graphVersion: 1,
          lastEnrichedBy: null,
          lastEnrichedAt: null
        };
        console.log("[StrategicUnderstanding] \u{1F510} Encrypting and saving Strategic Understanding...");
        const saved = await saveStrategicUnderstanding(understanding);
        console.log("[StrategicUnderstanding] \u2713 Strategic Understanding saved with encryption");
        return saved;
      }
      async extractUnderstanding(options) {
        const { sessionId, userInput, companyContext } = options;
        const understanding = await this.getOrCreateUnderstanding(sessionId, userInput, companyContext);
        const systemPrompt = `You are a strategic insight extraction expert. Your ONLY job is to extract verifiable insights from user input. Return ONLY valid JSON (no markdown, no explanation).

CRITICAL JSON FORMATTING RULES:
- ALL string values must have quotes properly escaped (use \\" for quotes inside strings)
- Return ONLY valid, parseable JSON
- Do not include any text outside the JSON object

CRITICAL GROUNDING RULES:
1. EXPLICIT entities: User DIRECTLY stated them - require exact quote in source field
2. IMPLICIT entities: Direct logical implications with clear reasoning chain
3. INFERRED entities: Exploratory reasoning (mark as low confidence)
4. NEVER invent facts not grounded in the input
5. Source field MUST contain actual text from input (exact substring match required)
6. If source text contains quotes, escape them properly in JSON`;
        const userMessage = `Extract strategic entities from user input using STRICT 3-tier categorization. Only extract what can be VALIDATED.

USER INPUT:
${userInput}

ENTITY TYPES & CATEGORIZATION:

**1. EXPLICIT_ASSUMPTION (confidence: high)**
- User DIRECTLY states: "We assume X", "X is critical", "We need Y", "Plan to do Z"
- Investment amounts: "$500K for Hindi" \u2192 "Hindi localization is a priority" (explicit, investment=$500000)
- Targets: "100 clients in 18 months" \u2192 "100 clients within 18 months is the goal" (explicit)
- Source: EXACT quote where user stated it

**2. IMPLICIT_IMPLICATION (confidence: medium)**
- DIRECT logical implications only:
  - "Expand to India" \u2192 "India market entry is planned" (implicit)
  - "Need Hindi localization" \u2192 "Non-Hindi speakers are potential customers" (implicit)
  - "$500K investment" \u2192 "Expects ROI from this investment" (implicit)
- Source: Quote the text that implies it
- Evidence: Explain the logical chain briefly.

**3. INFERRED_REASONING (confidence: low)**
- Exploratory/speculative insights:
  - "Target enterprises" \u2192 MIGHT imply "SMB market is deprioritized" (inferred)
  - "18-month timeline" \u2192 COULD suggest "Speed is competitive advantage" (inferred)
- Mark confidence as LOW
- Evidence: Explain the reasoning

**4. CONSTRAINT, OPPORTUNITY, RISK**
- CONSTRAINT: "Budget is $500K" (explicit limit)
- OPPORTUNITY: "Indian market is growing" (if stated)
- RISK: "Competition is intense" (if stated)

EXTRACTION RULES:
1. Extract 3-8 entities (quality over quantity)
2. Source MUST be actual text from input (will be validated)
3. Explicit entities require HIGH confidence + exact quote
4. Implicit entities need clear logical chain in evidence
5. Inferred entities have LOW confidence + reasoning explanation
6. Extract investment amounts as numbers (e.g., 500000 for "$500K")
7. Add category/subcategory for organization (e.g., "market_entry", "localization")

EXAMPLE:

Input: "We want to expand Asana to India with Hindi localization ($500K investment) to target 100 enterprise clients in 18 months."

Extract:
{
  "entities": [
    {
      "type": "explicit_assumption",
      "claim": "India market expansion is planned",
      "source": "expand Asana to India",
      "confidence": "high",
      "category": "market_entry"
    },
    {
      "type": "explicit_assumption",
      "claim": "Hindi localization requires $500K investment",
      "source": "Hindi localization ($500K investment)",
      "confidence": "high",
      "category": "localization",
      "investmentAmount": 500000
    },
    {
      "type": "explicit_assumption",
      "claim": "Target is 100 enterprise clients within 18 months",
      "source": "target 100 enterprise clients in 18 months",
      "confidence": "high",
      "category": "growth_target"
    },
    {
      "type": "implicit_implication",
      "claim": "Enterprise segment is the primary target in India",
      "source": "target 100 enterprise clients",
      "confidence": "medium",
      "evidence": "Specific focus on enterprise clients implies prioritization of this segment"
    },
    {
      "type": "implicit_implication",
      "claim": "18-month timeline is considered achievable",
      "source": "in 18 months",
      "confidence": "medium",
      "evidence": "Setting a specific timeline implies feasibility assessment"
    },
    {
      "type": "inferred_reasoning",
      "claim": "Speed to market may be a competitive factor",
      "source": "in 18 months",
      "confidence": "low",
      "evidence": "The specific 18-month timeline could suggest urgency driven by competitive pressure, but this is speculative"
    }
  ]
}

Now extract entities from the provided user input. Return ONLY valid JSON:`;
        let validated;
        let lastError = null;
        const maxRetries = 2;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`[StrategicUnderstanding] AI extraction attempt ${attempt}/${maxRetries}...`);
            const response = await aiClients.callWithFallback({
              systemPrompt,
              userMessage,
              maxTokens: 3e3
            }, "anthropic");
            let parsed;
            try {
              parsed = parseAIJson(response.content, "entity extraction");
              console.log("[StrategicUnderstanding] \u2713 JSON parsed successfully");
            } catch (parseError) {
              console.error("[StrategicUnderstanding] JSON parsing failed:", parseError);
              console.error("[StrategicUnderstanding] Raw AI response (first 500 chars):", response.content.substring(0, 500));
              throw new Error(`AI returned invalid JSON format. Please try again.`);
            }
            try {
              validated = entityExtractionSchema.parse(parsed);
              console.log("[StrategicUnderstanding] \u2713 Schema validation passed");
              break;
            } catch (validationError) {
              console.error("[StrategicUnderstanding] Schema validation failed:", validationError);
              console.error("[StrategicUnderstanding] Parsed JSON:", JSON.stringify(parsed, null, 2).substring(0, 1e3));
              if (validationError.errors) {
                const issues = validationError.errors.map(
                  (e) => `${e.path.join(".")}: ${e.message}`
                ).join("; ");
                throw new Error(`AI response structure is invalid: ${issues}`);
              }
              throw new Error(`AI response structure is invalid. Please try again.`);
            }
          } catch (error) {
            lastError = error;
            console.error(`[StrategicUnderstanding] Attempt ${attempt} failed:`, error.message);
            if (attempt < maxRetries) {
              const delay = attempt * 1e3;
              console.log(`[StrategicUnderstanding] Retrying in ${delay}ms...`);
              await new Promise((resolve) => setTimeout(resolve, delay));
            }
          }
        }
        if (!validated) {
          console.error("[StrategicUnderstanding] All retry attempts exhausted");
          throw new Error(
            `Unable to process your input after ${maxRetries} attempts. This is usually temporary - please try again in a moment. If the issue persists, try rephrasing your input.`
          );
        }
        console.log(`[StrategicUnderstanding] AI extracted ${validated.entities.length} entities, validating sources...`);
        const validEntities = [];
        const rejectedEntities = [];
        for (const entity of validated.entities) {
          if (this.validateSource(entity.source, userInput)) {
            validEntities.push(entity);
            console.log(`  \u2713 [${entity.type}] ${entity.claim.substring(0, 60)}...`);
          } else {
            rejectedEntities.push(entity);
            console.warn(`  \u2717 REJECTED [${entity.type}] ${entity.claim.substring(0, 60)}...`);
            console.warn(`    Invalid source: "${entity.source}" not found in input`);
          }
        }
        if (rejectedEntities.length > 0) {
          console.warn(`[StrategicUnderstanding] Rejected ${rejectedEntities.length} entities with invalid sources`);
        }
        console.log(`[StrategicUnderstanding] Final: ${validEntities.length} valid entities (${rejectedEntities.length} rejected)`);
        console.log(`[StrategicUnderstanding] Persisting ${validEntities.length} user input entities...`);
        const claims = validEntities.map((e) => e.claim);
        const embeddings = await this.generateEmbeddingsBatch(claims);
        const entitiesData = validEntities.map((entity, i) => ({
          understandingId: understanding.id,
          type: entity.type,
          claim: encrypt(entity.claim),
          //  Encrypted
          confidence: entity.confidence,
          embedding: embeddings[i],
          source: encrypt(entity.source),
          //  Encrypted
          evidence: entity.evidence ? encrypt(entity.evidence) : null,
          //  Encrypted if present
          category: entity.category ? encrypt(entity.category) : null,
          //  Encrypted if present
          subcategory: entity.subcategory ? encrypt(entity.subcategory) : null,
          //  Encrypted if present
          investmentAmount: entity.investmentAmount || null,
          discoveredBy: "user_input",
          validFrom: /* @__PURE__ */ new Date(),
          validTo: null,
          metadata: null
          //  Would be encrypted if present
        }));
        const persistedEntities = await dbConnectionManager.retryWithBackoff(async (db2) => {
          const inserted = [];
          for (const entityData of entitiesData) {
            const result = await db2.insert(strategicEntities).values(entityData).returning();
            inserted.push(result[0]);
          }
          return inserted;
        });
        console.log(`[StrategicUnderstanding] \u2713 Persisted ${persistedEntities.length} user entities with discovered_by='user_input'`);
        return {
          understandingId: understanding.id,
          entities: validEntities
        };
      }
      async generateEmbedding(text2) {
        const cacheKey = text2.toLowerCase().trim();
        if (this.embeddingCache.has(cacheKey)) {
          console.log(`[StrategicUnderstanding] Embedding cache hit for: ${text2.substring(0, 50)}...`);
          return this.embeddingCache.get(cacheKey);
        }
        const openai = this.getOpenAI();
        const response = await openai.embeddings.create({
          model: EMBEDDING_MODEL,
          input: text2,
          dimensions: EMBEDDING_DIMENSIONS
        });
        const embedding = response.data[0].embedding;
        this.embeddingCache.set(cacheKey, embedding);
        console.log(`[StrategicUnderstanding] Generated embedding for: ${text2.substring(0, 50)}... (dim: ${embedding.length})`);
        return embedding;
      }
      async generateEmbeddingsBatch(texts) {
        const openai = this.getOpenAI();
        const response = await openai.embeddings.create({
          model: EMBEDDING_MODEL,
          input: texts,
          dimensions: EMBEDDING_DIMENSIONS
        });
        const embeddings = response.data.map((item) => item.embedding);
        texts.forEach((text2, idx) => {
          const cacheKey = text2.toLowerCase().trim();
          this.embeddingCache.set(cacheKey, embeddings[idx]);
        });
        console.log(`[StrategicUnderstanding] Generated ${embeddings.length} embeddings in batch`);
        return embeddings;
      }
      async createEntity(understandingId, entity, discoveredBy = "system") {
        const embedding = await this.generateEmbedding(entity.claim);
        const entityData = {
          understandingId,
          type: entity.type,
          claim: encrypt(entity.claim),
          //  Encrypted
          confidence: entity.confidence,
          embedding,
          source: encrypt(entity.source),
          //  Encrypted
          evidence: entity.evidence ? encrypt(entity.evidence) : null,
          //  Encrypted if present
          category: entity.category ? encrypt(entity.category) : null,
          //  Encrypted if present
          subcategory: entity.subcategory ? encrypt(entity.subcategory) : null,
          //  Encrypted if present
          investmentAmount: entity.investmentAmount || null,
          discoveredBy,
          validFrom: /* @__PURE__ */ new Date(),
          validTo: null,
          metadata: null
          //  Would be encrypted if present
        };
        return await dbConnectionManager.retryWithBackoff(async (db2) => {
          const inserted = await db2.insert(strategicEntities).values(entityData).returning();
          const record = inserted[0];
          return {
            ...record,
            claim: decrypt(record.claim) || record.claim,
            source: decrypt(record.source) || record.source,
            evidence: record.evidence ? decrypt(record.evidence) || record.evidence : null,
            category: record.category ? decrypt(record.category) || record.category : null,
            subcategory: record.subcategory ? decrypt(record.subcategory) || record.subcategory : null,
            metadata: record.metadata ? decryptJSON(record.metadata) || record.metadata : null
          };
        });
      }
      async createRelationship(fromEntityId, toEntityId, relationshipType, confidence, evidence, discoveredBy = "system", metadata) {
        const relationshipData = {
          fromEntityId,
          toEntityId,
          relationshipType,
          confidence,
          evidence: evidence ? encrypt(evidence) : null,
          //  Encrypted if present
          discoveredBy,
          validFrom: /* @__PURE__ */ new Date(),
          validTo: null,
          metadata: metadata ? encryptJSON(metadata) : null
          //  Encrypted if present
        };
        return await dbConnectionManager.retryWithBackoff(async (db2) => {
          const inserted = await db2.insert(strategicRelationships).values(relationshipData).returning();
          return {
            ...inserted[0],
            evidence: inserted[0].evidence ? decrypt(inserted[0].evidence) || inserted[0].evidence : null,
            metadata: inserted[0].metadata ? decryptJSON(inserted[0].metadata) || inserted[0].metadata : null
          };
        });
      }
      /**
       * Create entity with pre-generated embedding (for batch operations)
       * Uses provided db connection to avoid creating new connections
       */
      async createEntityWithEmbedding(db2, understandingId, entity, embedding, discoveredBy = "system") {
        const entityData = {
          understandingId,
          type: entity.type,
          claim: encrypt(entity.claim),
          //  Encrypted
          confidence: entity.confidence,
          embedding,
          source: encrypt(entity.source),
          //  Encrypted
          evidence: entity.evidence ? encrypt(entity.evidence) : null,
          //  Encrypted if present
          category: entity.category ? encrypt(entity.category) : null,
          //  Encrypted if present
          subcategory: entity.subcategory ? encrypt(entity.subcategory) : null,
          //  Encrypted if present
          investmentAmount: entity.investmentAmount || null,
          discoveredBy,
          validFrom: /* @__PURE__ */ new Date(),
          validTo: null,
          metadata: null
          //  Would be encrypted if present
        };
        const inserted = await db2.insert(strategicEntities).values(entityData).returning();
        const record = inserted[0];
        return {
          ...record,
          claim: decrypt(record.claim) || record.claim,
          source: decrypt(record.source) || record.source,
          evidence: record.evidence ? decrypt(record.evidence) || record.evidence : null,
          category: record.category ? decrypt(record.category) || record.category : null,
          subcategory: record.subcategory ? decrypt(record.subcategory) || record.subcategory : null,
          metadata: record.metadata ? decryptJSON(record.metadata) || record.metadata : null
        };
      }
      /**
       * Create relationship directly with provided db connection (for batch operations)
       */
      async createRelationshipDirect(db2, fromEntityId, toEntityId, relationshipType, confidence, evidence, discoveredBy = "system", metadata) {
        const relationshipData = {
          fromEntityId,
          toEntityId,
          relationshipType,
          confidence,
          evidence: evidence ? encrypt(evidence) : null,
          //  Encrypted if present
          discoveredBy,
          validFrom: /* @__PURE__ */ new Date(),
          validTo: null,
          metadata: metadata ? encryptJSON(metadata) : null
          //  Encrypted if present
        };
        const inserted = await db2.insert(strategicRelationships).values(relationshipData).returning();
        const record = inserted[0];
        return {
          ...record,
          evidence: record.evidence ? decrypt(record.evidence) || record.evidence : null,
          metadata: record.metadata ? decryptJSON(record.metadata) || record.metadata : null
        };
      }
      async getEntitiesByUnderstanding(understandingId) {
        const entities = await getStrategicEntitiesByUnderstanding(understandingId);
        return entities.sort((a, b) => {
          const aTime = a.discoveredAt?.getTime() || 0;
          const bTime = b.discoveredAt?.getTime() || 0;
          return bTime - aTime;
        });
      }
      async getRelationshipsByEntity(entityId) {
        return await dbConnectionManager.withFreshConnection(async (db2) => {
          return await db2.select().from(strategicRelationships).where(
            sql2`${strategicRelationships.fromEntityId} = ${entityId} OR ${strategicRelationships.toEntityId} = ${entityId}`
          ).orderBy(desc(strategicRelationships.discoveredAt));
        });
      }
    };
    strategicUnderstandingService = new StrategicUnderstandingService();
  }
});

// server/services/document-enrichment-worker.ts
var document_enrichment_worker_exports = {};
__export(document_enrichment_worker_exports, {
  processDocumentEnrichmentJob: () => processDocumentEnrichmentJob
});
async function processDocumentEnrichmentJob(job) {
  console.log("[DocumentEnrichment] Processing job:", job.id);
  try {
    const { processedInput, sessionId, understandingId, fileName } = job.inputData;
    if (!processedInput || !sessionId) {
      throw new Error("Missing required input data: processedInput or sessionId");
    }
    if (processedInput.content.length < MIN_CONTENT_LENGTH) {
      console.log(`[DocumentEnrichment] Skipping low-signal document (${processedInput.content.length} chars)`);
      await backgroundJobService.updateJob(job.id, {
        status: "completed",
        progress: 100,
        resultData: {
          ignored: true,
          reason: "low_signal",
          contentLength: processedInput.content.length,
          fileName: fileName || "unknown"
        }
      });
      return;
    }
    await backgroundJobService.updateJob(job.id, {
      status: "running",
      progress: 10,
      progressMessage: "Analyzing document content..."
    });
    console.log("[DocumentEnrichment] Extracting knowledge from document:", fileName);
    await backgroundJobService.updateJob(job.id, {
      progress: 30,
      progressMessage: "Extracting entities and relationships..."
    });
    const understanding = await strategicUnderstandingService.extractUnderstanding({
      sessionId,
      userInput: processedInput.content
    });
    console.log("[DocumentEnrichment] Extracted understanding:", understanding.understandingId);
    await backgroundJobService.updateJob(job.id, {
      progress: 70,
      progressMessage: "Building knowledge graph..."
    });
    const finalUnderstandingId = understandingId || understanding.understandingId;
    const entityCount = understanding.entities?.length || 0;
    console.log(`[DocumentEnrichment] \u2713 Enrichment complete: ${entityCount} entities extracted`);
    await backgroundJobService.updateJob(job.id, {
      status: "completed",
      progress: 100,
      progressMessage: "Knowledge extraction complete",
      resultData: {
        understandingId: finalUnderstandingId,
        entityCount,
        fileName: fileName || "document",
        contentLength: processedInput.content.length,
        metadata: processedInput.metadata
      }
    });
  } catch (error) {
    console.error("[DocumentEnrichment] Job failed:", error);
    await backgroundJobService.failJob(job.id, error);
    throw error;
  }
}
var MIN_CONTENT_LENGTH;
var init_document_enrichment_worker = __esm({
  "server/services/document-enrichment-worker.ts"() {
    "use strict";
    init_strategic_understanding_service();
    init_background_job_service();
    MIN_CONTENT_LENGTH = 500;
  }
});

// server/journey/strategic-context-accumulator.ts
function initializeContext(understanding, journeyType) {
  return {
    understandingId: understanding.id,
    sessionId: understanding.sessionId,
    userInput: understanding.userInput,
    journeyType,
    currentFrameworkIndex: 0,
    completedFrameworks: [],
    insights: {},
    createdAt: /* @__PURE__ */ new Date(),
    updatedAt: /* @__PURE__ */ new Date(),
    status: "initializing"
  };
}
function addFrameworkResult(context, result) {
  const updatedContext = {
    ...context,
    currentFrameworkIndex: context.currentFrameworkIndex + 1,
    completedFrameworks: [...context.completedFrameworks, result.frameworkName],
    updatedAt: /* @__PURE__ */ new Date()
  };
  switch (result.frameworkName) {
    case "five_whys":
      updatedContext.insights = {
        ...updatedContext.insights,
        rootCauses: result.data.rootCauses || [result.data.rootCause],
        whysPath: result.data.whysPath || result.data.selectedPath,
        strategicImplications: result.data.strategicImplications || []
      };
      break;
    case "bmc":
      updatedContext.insights = {
        ...updatedContext.insights,
        businessModelGaps: result.data.criticalGaps || [],
        bmcBlocks: result.data.blocks || {},
        bmcContradictions: result.data.contradictions || []
      };
      break;
    case "porters":
      updatedContext.insights = {
        ...updatedContext.insights,
        portersForces: result.data.forces || {},
        competitivePressures: result.data.pressures || []
      };
      break;
    case "pestle":
      updatedContext.insights = {
        ...updatedContext.insights,
        trendFactors: result.data.factors || {},
        externalForces: result.data.forces || []
      };
      break;
    default:
      updatedContext.insights = {
        ...updatedContext.insights,
        [`${result.frameworkName}_data`]: result.data
      };
  }
  return updatedContext;
}
var init_strategic_context_accumulator = __esm({
  "server/journey/strategic-context-accumulator.ts"() {
    "use strict";
  }
});

// server/modules/manifest.ts
function validateManifest(manifest) {
  const errors = [];
  if (!manifest.id || typeof manifest.id !== "string") {
    errors.push("Module manifest must have a valid id");
  }
  if (!manifest.name || typeof manifest.name !== "string") {
    errors.push("Module manifest must have a valid name");
  }
  if (!manifest.version || typeof manifest.version !== "string") {
    errors.push("Module manifest must have a valid version");
  }
  if (!manifest.type || !["analyzer", "generator", "processor", "exporter", "user-input"].includes(manifest.type)) {
    errors.push("Module manifest must have a valid type (analyzer, generator, processor, exporter, user-input)");
  }
  if (!manifest.category || !["input", "analysis", "strategy", "customer", "execution", "output"].includes(manifest.category)) {
    errors.push("Module manifest must have a valid category (input, analysis, strategy, customer, execution, output)");
  }
  if (!manifest.icon || typeof manifest.icon !== "string") {
    errors.push("Module manifest must have a valid icon");
  }
  if (!manifest.status || !["implemented", "stub"].includes(manifest.status)) {
    errors.push("Module manifest must have a valid status (implemented, stub)");
  }
  if (manifest.type !== "user-input" && (!manifest.serviceClass || typeof manifest.serviceClass !== "string")) {
    errors.push("Module manifest must have a valid serviceClass (except for user-input types)");
  }
  if (!Array.isArray(manifest.inputs)) {
    errors.push("Module manifest must have an inputs array");
  } else {
    manifest.inputs.forEach((input, index2) => {
      if (!input.id || typeof input.id !== "string") {
        errors.push(`Input port at index ${index2} must have a valid id`);
      }
    });
  }
  if (!Array.isArray(manifest.outputs)) {
    errors.push("Module manifest must have an outputs array");
  } else {
    manifest.outputs.forEach((output, index2) => {
      if (!output.id || typeof output.id !== "string") {
        errors.push(`Output port at index ${index2} must have a valid id`);
      }
    });
  }
  if (!Array.isArray(manifest.requires)) {
    errors.push("Module manifest must have a requires array");
  }
  return { valid: errors.length === 0, errors };
}
var init_manifest = __esm({
  "server/modules/manifest.ts"() {
    "use strict";
  }
});

// server/modules/journey-config.ts
function validateJourneyConfig(config, registeredModuleIds) {
  const errors = [];
  const warnings = [];
  if (!config.id || typeof config.id !== "string") {
    errors.push("Journey config must have a valid id");
  }
  if (!config.name || typeof config.name !== "string") {
    errors.push("Journey config must have a valid name");
  }
  if (!config.version || typeof config.version !== "string") {
    errors.push("Journey config must have a valid version");
  }
  if (!Array.isArray(config.modules)) {
    errors.push("Journey config must have a modules array");
  } else {
    for (const mod of config.modules) {
      if (!mod.moduleId) {
        errors.push("Each module instance must have a moduleId");
      } else if (!registeredModuleIds.includes(mod.moduleId)) {
        errors.push(`Module "${mod.moduleId}" is not registered in the module registry`);
      }
    }
  }
  if (!Array.isArray(config.pageSequence)) {
    errors.push("Journey config must have a pageSequence array");
  } else {
    for (const page of config.pageSequence) {
      if (!page.path) {
        errors.push("Each page sequence entry must have a path");
      }
      if (!page.module) {
        errors.push("Each page sequence entry must have a module");
      }
    }
  }
  if (!Array.isArray(config.transitions)) {
    errors.push("Journey config must have a transitions array");
  }
  if (config.available === void 0) {
    warnings.push('Journey config should have an "available" flag, defaulting to false');
  }
  return { valid: errors.length === 0, errors, warnings };
}
function yamlToJourneyConfig(yaml2) {
  return {
    id: yaml2.id,
    name: yaml2.name,
    version: yaml2.version,
    description: yaml2.description,
    modules: yaml2.modules.map((m) => ({ moduleId: m.id, config: m.config })),
    pageSequence: yaml2.page_sequence.map((p) => ({
      path: p.path,
      module: p.module,
      condition: p.condition
    })),
    transitions: yaml2.transitions.map((t) => ({
      from: t.from,
      to: t.to,
      condition: t.condition
    })),
    estimatedDuration: yaml2.estimated_duration,
    available: yaml2.available ?? false,
    summaryBuilder: yaml2.summary_builder,
    defaultReadiness: yaml2.default_readiness ? {
      minReferences: yaml2.default_readiness.min_references,
      minEntities: yaml2.default_readiness.min_entities,
      requiredModules: yaml2.default_readiness.required_modules
    } : void 0,
    insightsConfig: yaml2.insights_config ? {
      requiresFiveWhys: yaml2.insights_config.requires_five_whys,
      requiresBmc: yaml2.insights_config.requires_bmc,
      requiresPorters: yaml2.insights_config.requires_porters,
      requiresPestle: yaml2.insights_config.requires_pestle
    } : void 0,
    tags: yaml2.tags
  };
}
var init_journey_config = __esm({
  "server/modules/journey-config.ts"() {
    "use strict";
  }
});

// server/modules/registry.ts
var ModuleRegistry, moduleRegistry;
var init_registry = __esm({
  "server/modules/registry.ts"() {
    "use strict";
    init_manifest();
    init_journey_config();
    ModuleRegistry = class {
      modules = /* @__PURE__ */ new Map();
      journeys = /* @__PURE__ */ new Map();
      registerModule(manifest) {
        const validation = validateManifest(manifest);
        if (!validation.valid) {
          console.warn(`[ModuleRegistry] Failed to register module: ${validation.errors.join(", ")}`);
          return { success: false, errors: validation.errors };
        }
        if (this.modules.has(manifest.id)) {
          console.warn(`[ModuleRegistry] Overwriting existing module: ${manifest.id}`);
        }
        this.modules.set(manifest.id, manifest);
        console.log(`[ModuleRegistry] Registered module: ${manifest.id} (${manifest.type})`);
        return { success: true, errors: [] };
      }
      loadJourney(config) {
        const registeredModuleIds = Array.from(this.modules.keys());
        const validation = validateJourneyConfig(config, registeredModuleIds);
        if (!validation.valid) {
          console.warn(`[ModuleRegistry] Failed to load journey: ${validation.errors.join(", ")}`);
          return { success: false, errors: validation.errors, warnings: validation.warnings };
        }
        if (validation.warnings.length > 0) {
          console.warn(`[ModuleRegistry] Journey warnings for ${config.id}: ${validation.warnings.join(", ")}`);
        }
        if (this.journeys.has(config.id)) {
          console.warn(`[ModuleRegistry] Overwriting existing journey: ${config.id}`);
        }
        this.journeys.set(config.id, config);
        console.log(`[ModuleRegistry] Loaded journey: ${config.id} with ${config.modules.length} modules`);
        return { success: true, errors: [], warnings: validation.warnings };
      }
      getModule(id) {
        return this.modules.get(id);
      }
      listModules() {
        return Array.from(this.modules.values());
      }
      listModulesByType(type) {
        return Array.from(this.modules.values()).filter((m) => m.type === type);
      }
      getJourney(id) {
        return this.journeys.get(id);
      }
      listJourneys() {
        return Array.from(this.journeys.values());
      }
      listAvailableJourneys() {
        return Array.from(this.journeys.values()).filter((j) => j.available);
      }
      hasModule(id) {
        return this.modules.has(id);
      }
      hasJourney(id) {
        return this.journeys.has(id);
      }
      getStats() {
        return {
          moduleCount: this.modules.size,
          journeyCount: this.journeys.size,
          availableJourneys: this.listAvailableJourneys().length
        };
      }
      clear() {
        this.modules.clear();
        this.journeys.clear();
        console.log("[ModuleRegistry] Registry cleared");
      }
    };
    moduleRegistry = new ModuleRegistry();
  }
});

// server/journey/journey-registry.ts
function configToDefinition(config) {
  const frameworkMap = {
    "five-whys-analyzer": "five_whys",
    "bmc-analyzer": "bmc",
    "porters-analyzer": "porters",
    "pestle-analyzer": "pestle"
  };
  const frameworks = config.modules.map((m) => frameworkMap[m.moduleId]).filter((f) => f !== void 0);
  return {
    type: config.id,
    name: config.name,
    description: config.description,
    frameworks,
    pageSequence: config.pageSequence.map((p) => p.path),
    estimatedDuration: config.estimatedDuration || "20-30 minutes",
    available: config.available,
    summaryBuilder: config.summaryBuilder || "default",
    defaultReadiness: {
      minReferences: config.defaultReadiness?.minReferences ?? 0,
      minEntities: config.defaultReadiness?.minEntities ?? 0
    },
    insightsConfig: {
      requiresFiveWhys: config.insightsConfig?.requiresFiveWhys,
      requiresBmc: config.insightsConfig?.requiresBmc
    },
    dependencies: config.transitions.filter((t) => t.from && t.to).map((t) => ({
      from: frameworkMap[t.from] || t.from,
      to: frameworkMap[t.to] || t.to
    }))
  };
}
function getJourney(type) {
  const configJourney = moduleRegistry.getJourney(type);
  if (configJourney) {
    console.log(`[JourneyRegistry] Using config-based journey: ${type}`);
    return configToDefinition(configJourney);
  }
  return JOURNEYS[type];
}
function getAvailableJourneys() {
  const configJourneys = moduleRegistry.listAvailableJourneys();
  const configIds = new Set(configJourneys.map((j) => j.id));
  const fromConfig = configJourneys.map(configToDefinition);
  const fromHardcoded = Object.values(JOURNEYS).filter((j) => j.available && !configIds.has(j.type));
  return [...fromConfig, ...fromHardcoded];
}
function getAllJourneys() {
  const configJourneys = moduleRegistry.listJourneys();
  const configIds = new Set(configJourneys.map((j) => j.id));
  const fromConfig = configJourneys.map(configToDefinition);
  const fromHardcoded = Object.values(JOURNEYS).filter((j) => !configIds.has(j.type));
  return [...fromConfig, ...fromHardcoded];
}
function isJourneyAvailable(type) {
  const configJourney = moduleRegistry.getJourney(type);
  if (configJourney) {
    return configJourney.available;
  }
  return JOURNEYS[type]?.available ?? false;
}
function getJourneyConfig(id) {
  return moduleRegistry.getJourney(id);
}
var JOURNEYS, journeyRegistry;
var init_journey_registry = __esm({
  "server/journey/journey-registry.ts"() {
    "use strict";
    init_registry();
    JOURNEYS = {
      /**
       * Business Model Innovation Journey
       * For rethinking business models, revenue streams, and value creation
       * AVAILABLE: Strategic Understanding  Five Whys  BMC  Strategic Decisions  Prioritization  EPM (complete workflow)
       */
      business_model_innovation: {
        type: "business_model_innovation",
        name: "Business Model Innovation",
        description: "Reimagine your business model by identifying root causes of problems, then designing innovative value propositions, revenue streams, and partnerships",
        frameworks: ["five_whys", "bmc"],
        pageSequence: [
          "/strategic-consultant/input",
          "/strategic-consultant/whys-tree/:understandingId",
          "/strategic-consultant/research/:sessionId",
          "/bmc/results/:sessionId/:versionNumber",
          "/strategy-workspace/decisions/:sessionId/:versionNumber",
          "/strategy-workspace/prioritization/:sessionId/:versionNumber"
        ],
        estimatedDuration: "30-35 minutes",
        available: true,
        // FULLY IMPLEMENTED - includes input & decisions workflow
        summaryBuilder: "fiveWhysBmc",
        defaultReadiness: {
          minReferences: 0,
          minEntities: 0
        },
        insightsConfig: {
          requiresFiveWhys: true,
          requiresBmc: true
        },
        dependencies: [
          { from: "five_whys", to: "bmc" }
        ]
      },
      /**
       * Market Entry Strategy Journey
       * For entering new markets or launching new products
       * AVAILABLE: Strategic Research  PESTLE  Porter's  SWOT  Strategic Decisions  Prioritization  EPM
       */
      market_entry: {
        type: "market_entry",
        name: "Market Entry Strategy",
        description: "Analyze market dynamics, competitive forces, and trends to craft a successful market entry plan",
        frameworks: ["pestle", "porters", "swot"],
        pageSequence: [
          "/strategic-consultant/input",
          "/strategic-consultant/pestle-results/:sessionId/:versionNumber",
          // Step 1: PESTLE analysis
          "/strategic-consultant/porters-results/:sessionId/:versionNumber",
          // Step 2: Porter's Five Forces
          "/strategic-consultant/swot-results/:sessionId/:versionNumber",
          // Step 3: SWOT analysis
          "/strategy-workspace/decisions/:sessionId/:versionNumber",
          // Step 4: Strategic decisions
          "/strategy-workspace/prioritization/:sessionId/:versionNumber"
          // Step 5: Prioritization
        ],
        estimatedDuration: "15-20 minutes",
        available: true,
        // FULLY IMPLEMENTED - Sequential PESTLE  Porter's  SWOT workflow
        summaryBuilder: "pestlePorters",
        defaultReadiness: {
          minReferences: 0,
          minEntities: 0
        },
        insightsConfig: {},
        dependencies: [
          { from: "pestle", to: "porters" },
          { from: "porters", to: "swot" }
        ]
      },
      /**
       * Competitive Strategy Journey
       * For competitive positioning and differentiation
       * IMPLEMENTED: Porter's  BMC  Blue Ocean sequential workflow
       */
      competitive_strategy: {
        type: "competitive_strategy",
        name: "Competitive Strategy",
        description: "Understand competitive forces, identify strategic gaps, and develop differentiation strategies",
        frameworks: ["porters", "bmc", "blue_ocean"],
        pageSequence: [
          "/strategic-consultant/input",
          "/strategic-consultant/porters-results/:sessionId/:versionNumber",
          // Porter's results page
          "/bmc/results/:sessionId/:versionNumber",
          // BMC results page
          "/strategic-consultant/blue-ocean/:sessionId/:versionNumber",
          // Blue Ocean results
          "/strategy-workspace/decisions/:sessionId/:versionNumber",
          // Strategic decisions
          "/strategy-workspace/prioritization/:sessionId/:versionNumber"
          // Prioritization
        ],
        estimatedDuration: "15-22 minutes",
        available: true,
        // IMPLEMENTED - Porter's  BMC  Blue Ocean workflow
        summaryBuilder: "portersBmc",
        defaultReadiness: {
          minReferences: 3,
          minEntities: 5
        },
        insightsConfig: {
          requiresBmc: true
        },
        dependencies: [
          { from: "porters", to: "bmc" },
          { from: "bmc", to: "blue_ocean" }
        ]
      },
      /**
       * Digital Transformation Journey
       * For technology-driven change initiatives
       * IMPLEMENTED: PESTLE  BMC  Ansoff sequential workflow
       */
      digital_transformation: {
        type: "digital_transformation",
        name: "Digital Transformation",
        description: "Navigate digital disruption by analyzing tech trends, redesigning operating models, and planning growth",
        frameworks: ["pestle", "bmc", "ansoff"],
        pageSequence: [
          "/strategic-consultant/input",
          "/strategic-consultant/pestle-results/:sessionId/:versionNumber",
          // PESTLE results page
          "/bmc/results/:sessionId/:versionNumber",
          // BMC results page
          "/strategic-consultant/ansoff-results/:sessionId/:versionNumber",
          // Ansoff results page
          "/strategy-workspace/decisions/:sessionId/:versionNumber",
          // Strategic decisions
          "/strategy-workspace/prioritization/:sessionId/:versionNumber"
          // Prioritization
        ],
        estimatedDuration: "18-25 minutes",
        available: true,
        // IMPLEMENTED - PESTLE  BMC  Ansoff workflow
        summaryBuilder: "pestleBmc",
        defaultReadiness: {
          minReferences: 3,
          minEntities: 5
        },
        insightsConfig: {
          requiresBmc: true
        },
        dependencies: [
          { from: "pestle", to: "bmc" },
          { from: "bmc", to: "ansoff" }
        ]
      },
      /**
       * Crisis Recovery Journey
       * For turnaround and crisis management
       * IMPLEMENTED: Five Whys  SWOT  BMC sequential workflow
       */
      crisis_recovery: {
        type: "crisis_recovery",
        name: "Crisis Recovery",
        description: "Diagnose root causes of crisis, assess internal strengths/weaknesses, and rebuild business model",
        frameworks: ["five_whys", "swot", "bmc"],
        pageSequence: [
          "/strategic-consultant/input",
          "/strategic-consultant/whys-tree/:understandingId",
          // Step 1: Five Whys analysis
          "/strategic-consultant/research/:sessionId",
          // Step 2: Research phase
          "/strategic-consultant/swot-results/:sessionId/:versionNumber",
          // Step 3: SWOT results
          "/bmc/results/:sessionId/:versionNumber",
          // Step 4: BMC results
          "/strategy-workspace/decisions/:sessionId/:versionNumber",
          // Step 5: Strategic decisions
          "/strategy-workspace/prioritization/:sessionId/:versionNumber"
          // Step 6: Prioritization
        ],
        estimatedDuration: "14-20 minutes",
        available: true,
        // IMPLEMENTED - Five Whys  SWOT  BMC workflow
        summaryBuilder: "fiveWhysSwot",
        defaultReadiness: {
          minReferences: 2,
          minEntities: 4
        },
        insightsConfig: {
          requiresFiveWhys: true
        },
        dependencies: [
          { from: "five_whys", to: "swot" },
          { from: "swot", to: "bmc" }
        ]
      },
      /**
       * Growth Strategy Journey
       * For expansion and scaling strategies
       * IMPLEMENTED: PESTLE  Ansoff  BMC sequential workflow
       */
      growth_strategy: {
        type: "growth_strategy",
        name: "Growth Strategy",
        description: "Explore growth opportunities through market trends, expansion options, and business model optimization",
        frameworks: ["pestle", "ansoff", "bmc"],
        pageSequence: [
          "/strategic-consultant/input",
          "/strategic-consultant/pestle-results/:sessionId/:versionNumber",
          // PESTLE results page
          "/strategic-consultant/ansoff-results/:sessionId/:versionNumber",
          // Ansoff results page
          "/bmc/results/:sessionId/:versionNumber",
          // BMC results page
          "/strategy-workspace/decisions/:sessionId/:versionNumber",
          // Strategic decisions
          "/strategy-workspace/prioritization/:sessionId/:versionNumber"
          // Prioritization
        ],
        estimatedDuration: "16-23 minutes",
        available: true,
        // IMPLEMENTED - PESTLE  Ansoff  BMC workflow
        summaryBuilder: "pestleAnsoff",
        defaultReadiness: {
          minReferences: 3,
          minEntities: 5
        },
        insightsConfig: {},
        dependencies: [
          { from: "pestle", to: "ansoff" },
          { from: "ansoff", to: "bmc" }
        ]
      },
      /**
       * Market Segmentation Discovery Journey (Marketing Consultant)
       * For discovering and validating ideal customer segments
       * AVAILABLE: Uses genetic algorithm-inspired exploration
       */
      market_segmentation: {
        type: "market_segmentation",
        name: "Market Segmentation Discovery",
        description: "Discover and validate your ideal customer segments using genetic algorithm-inspired exploration with 100 segment genomes",
        frameworks: ["segment_discovery"],
        pageSequence: [
          "/marketing-consultant",
          "/marketing-consultant/classification",
          "/marketing-consultant/discovery",
          "/marketing-consultant/results"
        ],
        estimatedDuration: "3-5 minutes",
        available: true,
        // FULLY IMPLEMENTED via Marketing Consultant
        summaryBuilder: "segmentDiscovery",
        defaultReadiness: {
          minReferences: 0,
          // No external research needed
          minEntities: 0
        },
        insightsConfig: {
          requiresFiveWhys: false,
          requiresBmc: false
        },
        dependencies: []
        // No dependencies on other frameworks
      },
      /**
       * Custom Journey (Wizard-Created)
       * Dynamic journey with custom framework sequence stored in session metadata
       */
      custom: {
        type: "custom",
        name: "Custom Journey",
        description: "User-created journey with custom framework sequence",
        frameworks: [],
        // Frameworks are loaded from session metadata at runtime
        pageSequence: [],
        // Dynamic based on frameworks
        estimatedDuration: "Varies",
        available: true,
        summaryBuilder: "custom",
        defaultReadiness: {
          minReferences: 0,
          minEntities: 0
        },
        insightsConfig: {},
        dependencies: []
      }
    };
    journeyRegistry = {
      getJourney,
      getAvailableJourneys,
      getAllJourneys,
      isJourneyAvailable,
      getJourneyConfig,
      JOURNEYS
    };
  }
});

// server/utils/whys-path.ts
var normalizeWhysPathSteps, whysPathToText, buildLinearWhysTree;
var init_whys_path = __esm({
  "server/utils/whys-path.ts"() {
    "use strict";
    normalizeWhysPathSteps = (path3) => {
      if (!Array.isArray(path3)) return [];
      return path3.map((step, idx) => {
        if (typeof step === "string") {
          return { question: `Why ${idx + 1}?`, answer: step };
        }
        if (step && typeof step === "object") {
          const answer = typeof step.answer === "string" && step.answer || typeof step.option === "string" && step.option || typeof step.label === "string" && step.label || typeof step.why === "string" && step.why || "";
          const question = typeof step.question === "string" && step.question || typeof step.prompt === "string" && step.prompt || `Why ${idx + 1}?`;
          if (!answer) return null;
          return { question, answer };
        }
        return null;
      }).filter((step) => Boolean(step));
    };
    whysPathToText = (path3) => normalizeWhysPathSteps(path3).map((step) => step.answer).filter(Boolean);
    buildLinearWhysTree = (path3) => {
      const steps = normalizeWhysPathSteps(path3);
      if (steps.length === 0) return null;
      const rootQuestion = steps[0].question || "Why?";
      const tree = {
        rootQuestion,
        branches: [],
        maxDepth: steps.length
      };
      let currentBranches = tree.branches;
      steps.forEach((step, idx) => {
        const nextQuestion = steps[idx + 1]?.question || void 0;
        const node = {
          id: `path-${idx + 1}`,
          option: step.answer,
          question: nextQuestion,
          branches: []
        };
        currentBranches.push(node);
        currentBranches = node.branches;
      });
      return tree;
    };
  }
});

// server/journey/bridges/whys-to-bmc-bridge.ts
function transformWhysToBMC(input) {
  const { rootCauses, whysPath, strategicImplications, userInput } = input;
  const whysText = whysPathToText(whysPath);
  const problemsToSolve = rootCauses.map((cause) => {
    if (cause.toLowerCase().startsWith("the ") || cause.toLowerCase().startsWith("we ")) {
      return cause;
    }
    return `The business model must address: ${cause}`;
  });
  const mustHaveCapabilities = extractCapabilities(whysText, strategicImplications);
  const designPrinciples = strategicImplications.map((implication) => {
    if (implication.toLowerCase().includes("must")) {
      return implication;
    }
    return `Design principle: ${implication}`;
  });
  const contextualBackground = `
Original Challenge: ${userInput}

Root Cause Analysis:
${whysText.map((why, i) => `Level ${i + 1}: ${why}`).join("\n")}

Identified Root Causes:
${rootCauses.map((cause, i) => `${i + 1}. ${cause}`).join("\n")}

Strategic Implications:
${strategicImplications.map((impl, i) => `${i + 1}. ${impl}`).join("\n")}
`.trim();
  return {
    problemsToSolve,
    mustHaveCapabilities,
    designPrinciples,
    contextualBackground
  };
}
function extractCapabilities(whysPath, implications) {
  const capabilities = [];
  const capabilityKeywords = [
    "differentiate",
    "compete",
    "scale",
    "deliver",
    "provide",
    "support",
    "enable",
    "improve",
    "optimize",
    "measure",
    "integrate",
    "automate",
    "customize",
    "localize"
  ];
  for (const why of whysPath) {
    const lowerWhy = why.toLowerCase();
    for (const keyword of capabilityKeywords) {
      if (lowerWhy.includes(keyword)) {
        const sentences = why.split(/[.!?]/);
        for (const sentence of sentences) {
          if (sentence.toLowerCase().includes(keyword)) {
            capabilities.push(`Must be able to: ${sentence.trim()}`);
            break;
          }
        }
      }
    }
  }
  for (const implication of implications) {
    const lowerImpl = implication.toLowerCase();
    if (lowerImpl.includes("need") || lowerImpl.includes("require") || lowerImpl.includes("must")) {
      capabilities.push(implication);
    }
  }
  return Array.from(new Set(capabilities)).slice(0, 5);
}
function applyWhysToBMCBridge(context) {
  const rootCauses = context.insights.rootCauses || [];
  const whysPath = context.insights.whysPath || [];
  const strategicImplications = context.insights.strategicImplications || [];
  const bmcConstraints = transformWhysToBMC({
    rootCauses,
    whysPath,
    strategicImplications,
    userInput: context.userInput
  });
  const enrichedContext = {
    ...context,
    insights: {
      ...context.insights,
      // Store ALL BMC constraints for BMC executor to use
      bmcDesignConstraints: {
        problemsToSolve: bmcConstraints.problemsToSolve,
        mustHaveCapabilities: bmcConstraints.mustHaveCapabilities,
        designPrinciples: bmcConstraints.designPrinciples,
        contextualBackground: bmcConstraints.contextualBackground
      }
    }
  };
  return {
    context: enrichedContext,
    bmcConstraints
  };
}
var init_whys_to_bmc_bridge = __esm({
  "server/journey/bridges/whys-to-bmc-bridge.ts"() {
    "use strict";
    init_whys_path();
  }
});

// server/journey/bridges/output-normalizer.ts
function normalizePESTLEOutput(raw) {
  if (!raw) return null;
  const data = raw?.data?.output || raw?.data?.pestleResults || raw?.output?.pestleResults || raw?.output || raw?.pestleResults || raw;
  if (data?.factors || data?.political || data?.economic) {
    return data;
  }
  const factors = data?.factors || {
    political: data?.political || [],
    economic: data?.economic || [],
    social: data?.social || [],
    technological: data?.technological || [],
    legal: data?.legal || [],
    environmental: data?.environmental || []
  };
  return {
    ...data,
    factors
  };
}
function normalizePortersOutput(raw) {
  if (!raw) return null;
  const data = raw?.data?.output || raw?.data?.portersResults || raw?.output?.portersResults || raw?.output || raw?.portersResults || raw;
  if (data?.forces || data?.threatOfNewEntrants || data?.competitiveRivalry) {
    if (data?.threatOfNewEntrants && !data?.forces) {
      return {
        ...data,
        forces: {
          threatOfNewEntrants: data.threatOfNewEntrants,
          supplierPower: data.supplierPower || data.bargainingPowerOfSuppliers,
          buyerPower: data.buyerPower || data.bargainingPowerOfBuyers,
          threatOfSubstitutes: data.threatOfSubstitutes,
          competitiveRivalry: data.competitiveRivalry
        }
      };
    }
    return data;
  }
  return data;
}
var init_output_normalizer = __esm({
  "server/journey/bridges/output-normalizer.ts"() {
    "use strict";
  }
});

// server/journey/bridges/pestle-to-porters-bridge.ts
function transformPESTLEToPorters(rawPestleOutput) {
  const pestleOutput = normalizePESTLEOutput(rawPestleOutput);
  const result = {
    regulatoryBarriers: [],
    buyerPowerIndicators: [],
    substituteEnablers: [],
    supplierPowerFactors: [],
    growthSignals: [],
    pestleScope: pestleOutput?.scope || "",
    pestleConfidence: pestleOutput?.confidenceLevel || "medium"
  };
  if (!pestleOutput?.factors) return result;
  const factors = pestleOutput.factors;
  if (factors.legal && Array.isArray(factors.legal)) {
    for (const f of factors.legal) {
      const lower = (f.factor || "").toLowerCase();
      if (lower.includes("license") || lower.includes("regulation") || lower.includes("permit") || lower.includes("compliance")) {
        result.regulatoryBarriers.push({
          factor: f.factor,
          severity: f.magnitude || "medium",
          interpretation: `Legal requirement "${f.factor}" creates regulatory barrier to entry`,
          source: "PESTLE Legal"
        });
      }
    }
  }
  if (factors.economic && Array.isArray(factors.economic)) {
    for (const f of factors.economic) {
      const lower = (f.factor || "").toLowerCase();
      if (lower.includes("income") || lower.includes("spending") || lower.includes("disposable") || lower.includes("purchasing")) {
        result.buyerPowerIndicators.push({
          factor: f.factor,
          direction: f.impact === "opportunity" ? "decreases" : "increases",
          interpretation: `Economic factor "${f.factor}" affects buyer price sensitivity`
        });
      }
      if (lower.includes("growth") || lower.includes("market size") || lower.includes("expansion")) {
        const growthMatch = (f.evidence || "").match(/(\d+(?:\.\d+)?)\s*%/);
        result.growthSignals.push({
          factor: f.factor,
          growthRate: growthMatch ? growthMatch[1] + "%" : null,
          implication: f.impact === "opportunity" ? "Growing market attracts new entrants, may reduce rivalry intensity" : "Stagnant market intensifies rivalry for market share"
        });
      }
    }
  }
  if (factors.social && Array.isArray(factors.social)) {
    for (const f of factors.social) {
      const lower = (f.factor || "").toLowerCase();
      if (lower.includes("trend") || lower.includes("culture") || lower.includes("community") || lower.includes("lifestyle")) {
        result.buyerPowerIndicators.push({
          factor: f.factor,
          direction: f.impact === "opportunity" ? "decreases" : "increases",
          interpretation: `Social trend "${f.factor}" affects buyer preferences and loyalty`
        });
      }
    }
  }
  if (factors.technological && Array.isArray(factors.technological)) {
    for (const f of factors.technological) {
      const lower = (f.factor || "").toLowerCase();
      if (lower.includes("platform") || lower.includes("online") || lower.includes("digital") || lower.includes("app") || lower.includes("e-commerce")) {
        result.substituteEnablers.push({
          factor: f.factor,
          substituteType: "digital_channel",
          interpretation: `Technology "${f.factor}" enables alternative channels and substitutes`
        });
      }
    }
  }
  if (factors.political && Array.isArray(factors.political)) {
    for (const f of factors.political) {
      const lower = (f.factor || "").toLowerCase();
      if (lower.includes("trade") || lower.includes("import") || lower.includes("tariff") || lower.includes("agreement")) {
        result.supplierPowerFactors.push({
          factor: f.factor,
          direction: f.impact === "opportunity" ? "decreases" : "increases",
          interpretation: `Trade policy "${f.factor}" affects supplier access and options`
        });
      }
    }
  }
  return result;
}
function applyPESTLEToPortersBridge(pestleOutput, positioning) {
  const enhancement = transformPESTLEToPorters(pestleOutput);
  console.log("[PESTLE\u2192Porter's Bridge] Transformation complete:", {
    regulatoryBarriers: enhancement.regulatoryBarriers.length,
    buyerPowerIndicators: enhancement.buyerPowerIndicators.length,
    substituteEnablers: enhancement.substituteEnablers.length,
    supplierPowerFactors: enhancement.supplierPowerFactors.length,
    growthSignals: enhancement.growthSignals.length
  });
  return Promise.resolve(enhancement);
}
var init_pestle_to_porters_bridge = __esm({
  "server/journey/bridges/pestle-to-porters-bridge.ts"() {
    "use strict";
    init_output_normalizer();
  }
});

// server/journey/bridges/porters-to-swot-bridge.ts
function getLevelMagnitude(level) {
  if (level === "very_low" || level === "low") return "high";
  if (level === "very_high" || level === "high") return "high";
  return "medium";
}
function getForceScore(force) {
  if (typeof force === "number") return force;
  if (force?.score) return force.score;
  return 5;
}
function getForceLevel(force) {
  if (force?.level) return force.level;
  const score = getForceScore(force);
  if (score <= 2) return "very_low";
  if (score <= 4) return "low";
  if (score <= 6) return "medium";
  if (score <= 8) return "high";
  return "very_high";
}
function transformPortersToSWOT(rawPortersOutput, rawPestleOutput) {
  const portersOutput = normalizePortersOutput(rawPortersOutput);
  const pestleOutput = rawPestleOutput ? normalizePESTLEOutput(rawPestleOutput) : void 0;
  const opportunities = [];
  const threats = [];
  const porterForcesUsed = [];
  const pestleFactorsUsed = [];
  const forces = portersOutput?.forces || portersOutput?.portersResults;
  if (forces) {
    const newEntrants = forces.threatOfNewEntrants;
    if (newEntrants) {
      const level = getForceLevel(newEntrants);
      const score = getForceScore(newEntrants);
      if (level === "very_low" || level === "low") {
        opportunities.push({
          item: "Protected market position",
          description: `Low threat of new entrants (${score}/10) means high barriers protect market position once established. First-mover advantage is defensible.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Threat of New Entrants: ${score}/10 (${level})`,
          priority: level === "very_low" ? 1 : 2,
          priorityRationale: "High barriers create sustainable competitive advantage"
        });
        porterForcesUsed.push("threatOfNewEntrants");
      } else if (level === "very_high" || level === "high") {
        threats.push({
          item: "Vulnerable to new competitors",
          description: `High threat of new entrants (${score}/10) means low barriers allow competitors to easily enter. Market position vulnerable to disruption.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Threat of New Entrants: ${score}/10 (${level})`,
          priority: level === "very_high" ? 1 : 2,
          priorityRationale: "Low barriers require rapid differentiation"
        });
        porterForcesUsed.push("threatOfNewEntrants");
      }
    }
    const supplierPower = forces.supplierPower || forces.bargainingPowerOfSuppliers;
    if (supplierPower) {
      const level = getForceLevel(supplierPower);
      const score = getForceScore(supplierPower);
      if (level === "very_low" || level === "low") {
        opportunities.push({
          item: "Favorable supplier negotiations",
          description: `Low supplier power (${score}/10) means multiple options available. Favorable negotiating position for cost optimization.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Supplier Power: ${score}/10 (${level})`,
          priority: 3,
          priorityRationale: "Cost advantages from supplier competition"
        });
        porterForcesUsed.push("supplierPower");
      } else if (level === "very_high" || level === "high") {
        threats.push({
          item: "Supplier dependency risk",
          description: `High supplier power (${score}/10) means limited options. Vulnerable to price increases and supply constraints.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Supplier Power: ${score}/10 (${level})`,
          priority: 2,
          priorityRationale: "Supply chain vulnerability requires mitigation"
        });
        porterForcesUsed.push("supplierPower");
      }
    }
    const buyerPower = forces.buyerPower || forces.bargainingPowerOfBuyers;
    if (buyerPower) {
      const level = getForceLevel(buyerPower);
      const score = getForceScore(buyerPower);
      if (level === "very_low" || level === "low") {
        opportunities.push({
          item: "Premium pricing sustainable",
          description: `Low buyer power (${score}/10) means customers have limited alternatives. Premium pricing sustainable without significant pushback.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Buyer Power: ${score}/10 (${level})`,
          priority: 2,
          priorityRationale: "Pricing flexibility enables margin expansion"
        });
        porterForcesUsed.push("buyerPower");
      } else if (level === "very_high" || level === "high") {
        threats.push({
          item: "Price pressure from buyers",
          description: `High buyer power (${score}/10) means customers have many alternatives. Price pressure and commoditization risk.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Buyer Power: ${score}/10 (${level})`,
          priority: 2,
          priorityRationale: "Margin pressure requires differentiation"
        });
        porterForcesUsed.push("buyerPower");
      }
    }
    const substitutes = forces.threatOfSubstitutes;
    if (substitutes) {
      const level = getForceLevel(substitutes);
      const score = getForceScore(substitutes);
      if (level === "very_low" || level === "low") {
        opportunities.push({
          item: "Unique value proposition",
          description: `Low substitute threat (${score}/10) means few alternatives solve the same problem. Value proposition is defensible.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Threat of Substitutes: ${score}/10 (${level})`,
          priority: 2,
          priorityRationale: "Limited alternatives strengthen market position"
        });
        porterForcesUsed.push("threatOfSubstitutes");
      } else if (level === "very_high" || level === "high") {
        threats.push({
          item: "Strong substitute competition",
          description: `High substitute threat (${score}/10) means alternative solutions compete for same customers. Must clearly differentiate.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Threat of Substitutes: ${score}/10 (${level})`,
          priority: 2,
          priorityRationale: "Substitutes require clear differentiation strategy"
        });
        porterForcesUsed.push("threatOfSubstitutes");
      }
    }
    const rivalry = forces.competitiveRivalry;
    if (rivalry) {
      const level = getForceLevel(rivalry);
      const score = getForceScore(rivalry);
      if (level === "very_low" || level === "low") {
        opportunities.push({
          item: "First-mover opportunity",
          description: `Low rivalry (${score}/10) means limited direct competition. Market share available for capture without aggressive price wars.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Competitive Rivalry: ${score}/10 (${level})`,
          priority: 1,
          priorityRationale: "Low competition enables rapid market capture"
        });
        porterForcesUsed.push("competitiveRivalry");
      } else if (level === "very_high" || level === "high") {
        threats.push({
          item: "Intense competitive pressure",
          description: `High rivalry (${score}/10) means many competitors fighting for same customers. Margin pressure from price wars.`,
          magnitude: getLevelMagnitude(level),
          sourceAnalysis: "porters",
          sourceReference: `Porter's Competitive Rivalry: ${score}/10 (${level})`,
          priority: 1,
          priorityRationale: "Competition requires strategic positioning"
        });
        porterForcesUsed.push("competitiveRivalry");
      }
    }
  }
  if (pestleOutput?.opportunities && Array.isArray(pestleOutput.opportunities)) {
    for (const o of pestleOutput.opportunities.slice(0, 3)) {
      opportunities.push({
        item: o.opportunity || o.item,
        description: o.description || "",
        magnitude: o.magnitude || "medium",
        sourceAnalysis: "pestle",
        sourceReference: "PESTLE Analysis",
        priority: 3,
        priorityRationale: "Macro-environmental opportunity"
      });
    }
    pestleFactorsUsed.push(...pestleOutput.opportunities.map((o) => o.opportunity || o.item));
  }
  if (pestleOutput?.threats && Array.isArray(pestleOutput.threats)) {
    for (const t of pestleOutput.threats.slice(0, 3)) {
      threats.push({
        item: t.threat || t.item,
        description: t.description || "",
        magnitude: t.magnitude || "medium",
        sourceAnalysis: "pestle",
        sourceReference: "PESTLE Analysis",
        priority: 3,
        priorityRationale: "Macro-environmental threat"
      });
    }
    pestleFactorsUsed.push(...pestleOutput.threats.map((t) => t.threat || t.item));
  }
  opportunities.sort((a, b) => a.priority - b.priority);
  threats.sort((a, b) => a.priority - b.priority);
  return {
    derivedOpportunities: opportunities.slice(0, 5),
    derivedThreats: threats.slice(0, 5),
    pestleFactorsUsed: Array.from(new Set(pestleFactorsUsed)),
    porterForcesUsed: Array.from(new Set(porterForcesUsed)),
    competitorInsights: {
      namedCompetitors: portersOutput?.competitorsIdentified || [],
      competitorStrengths: [],
      competitorWeaknesses: []
    },
    marketContext: {
      attractivenessScore: portersOutput?.overallAttractiveness?.score || 5,
      assessment: portersOutput?.overallAttractiveness?.assessment || "moderate",
      rationale: portersOutput?.overallAttractiveness?.rationale || ""
    }
  };
}
function applyPortersToSWOTBridge(portersOutput, pestleOutput, positioning) {
  const enhancement = transformPortersToSWOT(portersOutput, pestleOutput);
  console.log("[Porter's\u2192SWOT Bridge] Transformation complete:", {
    derivedOpportunities: enhancement.derivedOpportunities.length,
    derivedThreats: enhancement.derivedThreats.length,
    pestleFactorsUsed: enhancement.pestleFactorsUsed.length,
    porterForcesUsed: enhancement.porterForcesUsed.length,
    competitors: enhancement.competitorInsights.namedCompetitors.length
  });
  return Promise.resolve(enhancement);
}
var init_porters_to_swot_bridge = __esm({
  "server/journey/bridges/porters-to-swot-bridge.ts"() {
    "use strict";
    init_output_normalizer();
  }
});

// server/services/context-foundry-client.ts
function groundAnalysis(userQuestion, context, analysisType = "strategic") {
  const entityFacts = context.confirmedEntities.map((e) => {
    const confMarker = e.confidence >= 0.8 ? "\u2713" : "~";
    return `  ${confMarker} ${e.type}: ${e.name} (confidence: ${Math.round(e.confidence * 100)}%)`;
  });
  const relationshipFacts = context.inferredRelationships.map(
    (r) => `  - ${r.sourceEntity} --[${r.relationshipType}]--> ${r.targetEntity}`
  );
  const boundaryNotes = [];
  if (context.boundaries.frontierNodes.length > 0) {
    boundaryNotes.push(`  - Knowledge boundary at: ${context.boundaries.frontierNodes.slice(0, 5).join(", ")}`);
  }
  if (context.boundaries.lowCoverageAreas.length > 0) {
    boundaryNotes.push(`  - Limited data on: ${context.boundaries.lowCoverageAreas.slice(0, 3).join(", ")}`);
  }
  return `You are a ${analysisType} consultant using Premisia. Answer the following question using ONLY the verified organizational context provided below. Do not hallucinate or invent facts.

## User Question
${userQuestion}

## Verified Context from Organization's Knowledge Graph
**Overall Confidence: ${Math.round(context.confidence * 100)}% (${context.confidenceLevel})**

### Context Foundry's Answer
${context.answer || "No direct answer available"}

### Confirmed Entities (${context.confirmedEntities.length} found)
${entityFacts.length > 0 ? entityFacts.join("\n") : "  No entities found"}

### Relationships
${relationshipFacts.length > 0 ? relationshipFacts.join("\n") : "  No relationships found"}

### Knowledge Boundaries (what we don't know)
${boundaryNotes.length > 0 ? boundaryNotes.join("\n") : "  No significant gaps identified"}

### Sources
${context.sources.length > 0 ? context.sources.join(", ") : "No sources available"}

## Instructions
1. Base your analysis on the verified context above
2. If confidence is below 80%, note the uncertainty
3. If the knowledge boundary limits your answer, say so explicitly
4. Do not invent facts not present in the context
5. Cite sources when making specific claims

## Your Analysis:`;
}
function formatForReport(context, sectionTitle) {
  const title = sectionTitle || "Findings from Organizational Knowledge Graph";
  const lines = [
    `## ${title}`,
    "",
    `**Query:** ${context.query}`,
    `**Confidence:** ${Math.round(context.confidence * 100)}%`,
    ""
  ];
  if (context.confirmedEntities.length > 0) {
    lines.push("### Verified Entities");
    const highConfEntities = context.confirmedEntities.filter((e) => e.confidence >= 0.8);
    for (const e of highConfEntities) {
      lines.push(`- **${e.name}** (${e.type})`);
      for (const [key, val] of Object.entries(e.properties)) {
        if (key !== "name" && val) {
          lines.push(`  - ${key}: ${val}`);
        }
      }
    }
    lines.push("");
  }
  if (context.sources.length > 0) {
    lines.push("### Sources");
    for (const src of context.sources) {
      lines.push(`- ${src}`);
    }
    lines.push("");
  }
  if (context.boundaries.lowCoverageAreas.length > 0) {
    lines.push("### Data Limitations");
    lines.push(`Limited information available on: ${context.boundaries.lowCoverageAreas.join(", ")}`);
    lines.push("");
  }
  return lines.join("\n");
}
function getContextFoundryClient() {
  if (clientInstance) {
    return clientInstance;
  }
  const apiKey = process.env.CONTEXT_FOUNDRY_API_KEY;
  if (!apiKey) {
    console.warn("[ContextFoundry] API key not configured. Set CONTEXT_FOUNDRY_API_KEY environment variable.");
    return null;
  }
  clientInstance = new ContextFoundryClient({ apiKey });
  return clientInstance;
}
async function queryContext(rawText, analysisType = "root_cause", sessionContext3) {
  const client2 = getContextFoundryClient();
  if (!client2) {
    return null;
  }
  console.log(`[Orchestrator] Querying Context Foundry with raw text: "${rawText.substring(0, 100)}..."`);
  return client2.query(rawText, analysisType, sessionContext3);
}
var DEFAULT_CONFIDENCE_THRESHOLD, ContextFoundryClient, clientInstance;
var init_context_foundry_client = __esm({
  "server/services/context-foundry-client.ts"() {
    "use strict";
    DEFAULT_CONFIDENCE_THRESHOLD = 0.6;
    ContextFoundryClient = class {
      apiKey;
      baseUrl;
      timeout;
      confidenceThreshold;
      constructor(config) {
        this.apiKey = config.apiKey;
        this.baseUrl = config.baseUrl || "https://1ccacfa5-76d6-4bc8-b11c-e8a59e39c1f1-00-i16a1ywb4a3m.riker.replit.dev";
        this.timeout = config.timeout || 3e4;
        this.confidenceThreshold = config.confidenceThreshold || DEFAULT_CONFIDENCE_THRESHOLD;
      }
      /**
       * Query Context Foundry for grounded context using the new /api/v1/query endpoint
       * @param rawText - Raw user text (CF handles entity extraction internally)
       * @param analysisType - Type of analysis being performed
       * @param sessionContext - Optional session context for tracking
       * @returns ContextBundle with verified facts
       */
      async query(rawText, analysisType = "root_cause", sessionContext3) {
        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.timeout);
          const payload = {
            query: rawText,
            analysis_type: analysisType,
            context: {
              app_id: "premisia",
              user_id: sessionContext3?.userId || "anonymous",
              session_id: sessionContext3?.sessionId || "default"
            }
          };
          console.log(`[ContextFoundry] Querying /api/v1/query with raw text: "${rawText.substring(0, 100)}..."`);
          const response = await fetch(`${this.baseUrl}/api/v1/query`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CF-API-Key": this.apiKey
            },
            body: JSON.stringify(payload),
            signal: controller.signal
          });
          clearTimeout(timeoutId);
          if (!response.ok) {
            const errorText = await response.text();
            console.error("[ContextFoundry] API error:", response.status, errorText);
            return this.createEmptyContext(rawText);
          }
          const data = await response.json();
          return this.parseV1Response(rawText, data);
        } catch (error) {
          console.error("[ContextFoundry] Query failed:", error);
          return this.createEmptyContext(rawText);
        }
      }
      /**
       * Verify a factual claim against the knowledge graph
       */
      async verify(statement, context) {
        try {
          const payload = { statement };
          if (context) {
            payload.context = context;
          }
          const response = await fetch(`${this.baseUrl}/api/verify`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CF-API-Key": this.apiKey
            },
            body: JSON.stringify(payload)
          });
          if (response.status === 404) {
            return { verified: null, confidence: 0, note: "verify endpoint not available" };
          }
          if (!response.ok) {
            return { verified: null, confidence: 0, note: `API error: ${response.status}` };
          }
          return await response.json();
        } catch (error) {
          console.error("[ContextFoundry] Verify failed:", error);
          return { verified: null, confidence: 0, note: error instanceof Error ? error.message : "Unknown error" };
        }
      }
      /**
       * Check if the API key is valid
       */
      async validateApiKey() {
        try {
          const response = await fetch(`${this.baseUrl}/api/v1/query`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-CF-API-Key": this.apiKey
            },
            body: JSON.stringify({
              query: "test connection",
              analysis_type: "root_cause",
              context: { app_id: "premisia" }
            })
          });
          return response.ok || response.status !== 401;
        } catch {
          return false;
        }
      }
      /**
       * Parse V1 API response format
       */
      parseV1Response(query, data) {
        const status = data.status || "NO_MATCHES";
        const confidence = data.confidence || 0;
        let confidenceLevel;
        if (confidence >= 0.8) {
          confidenceLevel = "high";
        } else if (confidence >= 0.6) {
          confidenceLevel = "medium";
        } else {
          confidenceLevel = "low";
        }
        const resolvedEntity = data.entity_resolution?.selected || null;
        const groundedFacts = data.answer?.grounded_facts || [];
        const gaps = data.answer?.gaps || [];
        const entities = [];
        if (resolvedEntity) {
          entities.push({
            id: resolvedEntity.entity_id,
            type: "resolved_entity",
            name: resolvedEntity.name,
            properties: {},
            confidence: resolvedEntity.confidence || confidence,
            source: "context_foundry"
          });
        }
        for (const fact of groundedFacts) {
          if (fact.entity_id && fact.name) {
            entities.push({
              id: String(fact.entity_id),
              type: String(fact.type || "fact"),
              name: String(fact.name),
              properties: fact,
              confidence: Number(fact.confidence) || confidence,
              source: "context_foundry"
            });
          }
        }
        const isGrounded = status === "RESOLVED" && confidence >= this.confidenceThreshold;
        console.log(`[ContextFoundry] V1 Response: status=${status}, confidence=${confidence}, resolvedEntity=${resolvedEntity?.name || "none"}, isGrounded=${isGrounded}`);
        return {
          query,
          answer: resolvedEntity ? `Resolved entity: ${resolvedEntity.name}` : "",
          confidence,
          confidenceLevel,
          confirmedEntities: entities,
          inferredRelationships: [],
          boundaries: {
            frontierNodes: [],
            missingTypes: [],
            lowCoverageAreas: gaps
          },
          evidenceChain: groundedFacts,
          sources: ["context_foundry"],
          isGrounded,
          resolvedEntity,
          resolutionStatus: status,
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
      createEmptyContext(query) {
        return {
          query,
          answer: "",
          confidence: 0,
          confidenceLevel: "low",
          confirmedEntities: [],
          inferredRelationships: [],
          boundaries: {
            frontierNodes: [],
            missingTypes: [],
            lowCoverageAreas: []
          },
          evidenceChain: [],
          sources: [],
          isGrounded: false,
          resolvedEntity: null,
          resolutionStatus: "NO_MATCHES",
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        };
      }
    };
    clientInstance = null;
  }
});

// server/services/grounded-analysis-service.ts
var grounded_analysis_service_exports = {};
__export(grounded_analysis_service_exports, {
  ClaimClassifier: () => ClaimClassifier,
  groundStrategicAnalysis: () => groundStrategicAnalysis,
  isContextFoundryConfigured: () => isContextFoundryConfigured,
  mapAnalysisType: () => mapAnalysisType,
  orchestrateAnalysis: () => orchestrateAnalysis,
  prepareGroundedAnalysis: () => prepareGroundedAnalysis,
  validateContextFoundryConnection: () => validateContextFoundryConnection
});
function isContextFoundryConfigured() {
  return !!process.env.CONTEXT_FOUNDRY_API_KEY;
}
async function prepareGroundedAnalysis(request) {
  if (!isContextFoundryConfigured()) {
    console.log("[GroundedAnalysis] Context Foundry not configured, proceeding without grounding");
    return {
      groundedPrompt: request.originalInput,
      context: null,
      isGrounded: false,
      reportSection: null
    };
  }
  try {
    const analysisTypeMap = {
      "five_whys": "root_cause",
      "porters": "competitive",
      "bmc": "business_model",
      "pestle": "environmental",
      "swot": "strategic",
      "general": "root_cause"
    };
    const cfAnalysisType = analysisTypeMap[request.analysisType] || "root_cause";
    const context = await queryContext(request.originalInput, cfAnalysisType, request.sessionContext);
    if (!context || !context.isGrounded) {
      console.log("[GroundedAnalysis] No grounded context found. Status:", context?.resolutionStatus || "NO_RESPONSE");
      return {
        groundedPrompt: request.originalInput,
        context,
        isGrounded: false,
        reportSection: null
      };
    }
    const groundedPrompt = groundAnalysis(request.originalInput, context);
    const reportSection = formatForReport(context, `Grounded Context: ${request.analysisType.toUpperCase()}`);
    console.log(`[GroundedAnalysis] Successfully grounded analysis - status: ${context.resolutionStatus}, entities: ${context.confirmedEntities.length}, resolvedEntity: ${context.resolvedEntity?.name || "none"}`);
    return {
      groundedPrompt,
      context,
      isGrounded: true,
      reportSection
    };
  } catch (error) {
    console.error("[GroundedAnalysis] Error preparing grounded analysis:", error);
    return {
      groundedPrompt: request.originalInput,
      context: null,
      isGrounded: false,
      reportSection: null
    };
  }
}
function mapAnalysisType(analysisType) {
  const mapping = {
    "five_whys": "root_cause",
    "porters": "competitive",
    "bmc": "business_model",
    "pestle": "environmental",
    "swot": "strategic",
    "general": "root_cause"
  };
  return mapping[analysisType] || "root_cause";
}
async function validateContextFoundryConnection() {
  if (!isContextFoundryConfigured()) {
    return {
      configured: false,
      connected: false,
      error: "CONTEXT_FOUNDRY_API_KEY not set"
    };
  }
  try {
    const client2 = getContextFoundryClient();
    if (!client2) {
      return {
        configured: true,
        connected: false,
        error: "Failed to initialize client"
      };
    }
    const isValid = await client2.validateApiKey();
    return {
      configured: true,
      connected: isValid,
      error: isValid ? void 0 : "API key validation failed"
    };
  } catch (error) {
    return {
      configured: true,
      connected: false,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
}
async function groundStrategicAnalysis(userInput, analysisType, sessionContext3) {
  const result = await prepareGroundedAnalysis({
    query: userInput,
    analysisType,
    originalInput: userInput,
    sessionContext: sessionContext3
  });
  return {
    prompt: result.groundedPrompt,
    context: result.context,
    grounded: result.isGrounded
  };
}
async function orchestrateAnalysis(userInput, analysisType, sessionContext3) {
  console.log(`
[Orchestrator] ========== STARTING ORCHESTRATION ==========`);
  console.log(`[Orchestrator] Analysis type: ${analysisType}`);
  console.log(`[Orchestrator] Input length: ${userInput.length} chars`);
  console.log(`[Orchestrator] Querying Context Foundry with raw text: "${userInput.substring(0, 100)}..."`);
  const classifier = new ClaimClassifier();
  const classifications = classifier.classifyClaims(userInput);
  const internalClaims = classifications.filter((c) => c.claimType === "internal");
  const externalClaims = classifications.filter((c) => c.claimType === "external");
  const frameworkClaims = classifications.filter((c) => c.claimType === "framework");
  console.log(`[Orchestrator] Classified claims: ${internalClaims.length} internal, ${externalClaims.length} external, ${frameworkClaims.length} framework`);
  for (const claim of classifications) {
    console.log(`[Orchestrator] - ${claim.claimType.toUpperCase()}: "${claim.topic}" | entities: [${claim.entities.join(", ")}]`);
  }
  let cfContext = null;
  const flaggedAssumptions = [];
  const externalClaimsForWebSearch = [];
  console.log(`[Orchestrator] Context Foundry configured: ${isContextFoundryConfigured()}`);
  if (internalClaims.length > 0 && isContextFoundryConfigured()) {
    const cfAnalysisType = mapAnalysisType(analysisType);
    cfContext = await queryContext(userInput, cfAnalysisType, sessionContext3);
    console.log(`[Orchestrator] CF Response received:`);
    console.log(`[Orchestrator] - isGrounded: ${cfContext?.isGrounded}`);
    console.log(`[Orchestrator] - confidence: ${cfContext?.confidence}`);
    console.log(`[Orchestrator] - confirmedEntities: ${cfContext?.confirmedEntities?.length || 0}`);
    console.log(`[Orchestrator] - inferredRelationships: ${cfContext?.inferredRelationships?.length || 0}`);
    if (cfContext?.confirmedEntities?.length) {
      for (const entity of cfContext.confirmedEntities.slice(0, 5)) {
        console.log(`[Orchestrator]   * ${entity.type}: ${entity.name} (${Math.round(entity.confidence * 100)}%)`);
      }
    }
    if (cfContext?.inferredRelationships?.length) {
      for (const rel of cfContext.inferredRelationships.slice(0, 5)) {
        console.log(`[Orchestrator]   * ${rel.sourceEntity} --[${rel.relationshipType}]--> ${rel.targetEntity}`);
      }
    }
    if (cfContext && cfContext.isGrounded) {
      for (const claim of internalClaims) {
        const hasMatchingEntity = claim.entities.some(
          (entity) => cfContext.confirmedEntities.some(
            (ce) => ce.name.toLowerCase().includes(entity.toLowerCase()) || entity.toLowerCase().includes(ce.name.toLowerCase())
          )
        );
        if (!hasMatchingEntity && claim.originalText) {
          flaggedAssumptions.push(`[Unverified] ${claim.originalText}`);
        }
      }
      if (cfContext.boundaries.lowCoverageAreas.length > 0) {
        flaggedAssumptions.push(
          `[Knowledge Gap] Limited data on: ${cfContext.boundaries.lowCoverageAreas.join(", ")}`
        );
      }
    } else {
      for (const claim of internalClaims) {
        if (claim.originalText) {
          flaggedAssumptions.push(`[No CF Data] ${claim.originalText}`);
        }
      }
    }
  } else if (internalClaims.length > 0) {
    for (const claim of internalClaims) {
      if (claim.originalText) {
        flaggedAssumptions.push(`[CF Not Configured] ${claim.originalText}`);
      }
    }
  }
  for (const claim of externalClaims) {
    if (claim.originalText) {
      externalClaimsForWebSearch.push(claim.originalText);
    }
  }
  const groundedPrompt = buildOrchestatedPrompt(
    userInput,
    analysisType,
    classifications,
    cfContext,
    flaggedAssumptions,
    externalClaimsForWebSearch
  );
  return {
    groundedPrompt,
    classifications,
    cfContext,
    flaggedAssumptions,
    externalClaimsForWebSearch
  };
}
function buildOrchestatedPrompt(originalInput, analysisType, classifications, cfContext, flaggedAssumptions, externalClaimsForWebSearch) {
  const sections = [];
  sections.push(`## User Request
${originalInput}`);
  sections.push(`
## Analysis Type: ${analysisType.toUpperCase()}`);
  sections.push(`
## Claim Classification Summary`);
  sections.push(`- Internal claims (organizational): ${classifications.filter((c) => c.claimType === "internal").length}`);
  sections.push(`- External claims (market/industry): ${classifications.filter((c) => c.claimType === "external").length}`);
  sections.push(`- Framework claims (analytical): ${classifications.filter((c) => c.claimType === "framework").length}`);
  if (cfContext && cfContext.isGrounded) {
    sections.push(`
## Verified Organizational Context (from Context Foundry)`);
    sections.push(`**Confidence: ${Math.round(cfContext.confidence * 100)}%**`);
    if (cfContext.confirmedEntities.length > 0) {
      sections.push(`
### Confirmed Entities`);
      for (const entity of cfContext.confirmedEntities.slice(0, 10)) {
        sections.push(`- ${entity.type}: ${entity.name} (${Math.round(entity.confidence * 100)}% confidence)`);
      }
    }
    if (cfContext.inferredRelationships.length > 0) {
      sections.push(`
### Relationships`);
      for (const rel of cfContext.inferredRelationships.slice(0, 10)) {
        sections.push(`- ${rel.sourceEntity} \u2192 ${rel.relationshipType} \u2192 ${rel.targetEntity}`);
      }
    }
    if (cfContext.answer) {
      sections.push(`
### Context Foundry Answer`);
      sections.push(cfContext.answer);
    }
  }
  if (flaggedAssumptions.length > 0) {
    sections.push(`
## \u26A0\uFE0F Flagged Assumptions (require verification)`);
    for (const assumption of flaggedAssumptions) {
      sections.push(`- ${assumption}`);
    }
    sections.push(`
*These claims about internal operations could not be verified against organizational data. Treat as assumptions until confirmed.*`);
  }
  if (externalClaimsForWebSearch.length > 0) {
    sections.push(`
## \u{1F50D} External Claims (marked for web search)`);
    for (const claim of externalClaimsForWebSearch) {
      sections.push(`- ${claim}`);
    }
    sections.push(`
*These claims about markets, competitors, or industry trends require external validation. Web search recommended.*`);
  }
  sections.push(`
## Instructions for Analysis`);
  sections.push(`1. Use the verified organizational context above when available`);
  sections.push(`2. Clearly mark unverified assumptions in your analysis`);
  sections.push(`3. Note where external data would strengthen the analysis`);
  sections.push(`4. Apply ${analysisType} framework methodology to structure insights`);
  sections.push(`5. Cite sources when making specific claims`);
  return sections.join("\n");
}
var INTERNAL_KEYWORDS, INTERNAL_PHRASES, EXTERNAL_KEYWORDS, EXTERNAL_PHRASES, FRAMEWORK_KEYWORDS, FRAMEWORK_PHRASES, ClaimClassifier;
var init_grounded_analysis_service = __esm({
  "server/services/grounded-analysis-service.ts"() {
    "use strict";
    init_context_foundry_client();
    INTERNAL_KEYWORDS = [
      "team",
      "department",
      "process",
      "system",
      "workflow",
      "employee",
      "manager",
      "role",
      "internal",
      "our",
      "we",
      "staff",
      "personnel",
      "procedure",
      "policy",
      "protocol",
      "organization",
      "organisational",
      "organizational",
      "division",
      "unit",
      "group",
      "colleague",
      "supervisor",
      "stakeholder",
      "budget",
      "resource",
      "capacity",
      "infrastructure",
      // Technical infrastructure terms (should trigger CF for service topology)
      "service",
      "services",
      "api",
      "gateway",
      "dependency",
      "dependencies",
      "microservice",
      "microservices",
      "backend",
      "frontend",
      "database",
      "server",
      "servers",
      "cluster",
      "deployment",
      "architecture",
      "component",
      "components",
      "module",
      "modules",
      "integration",
      "endpoint",
      "endpoints",
      "circuit",
      "breaker",
      "failover",
      "redundancy",
      "downtime",
      "uptime",
      "availability",
      "reliability",
      "latency",
      "timeout",
      "retry",
      "cascade",
      "cascading",
      "interconnected"
    ];
    INTERNAL_PHRASES = [
      "how we do",
      "our approach",
      "we currently",
      "our team",
      "our process",
      "we have",
      "we use",
      "our system",
      "our workflow",
      "internally",
      "in-house",
      "our department",
      "our organization",
      "our company",
      "depends on",
      "reports to",
      "managed by",
      "owned by",
      "responsible for",
      // Technical infrastructure phrases
      "api gateway",
      "service mesh",
      "load balancer",
      "circuit breaker",
      "cascading failure",
      "dependent service",
      "downstream service",
      "upstream service",
      "service topology",
      "system architecture",
      "service dependency",
      "interconnected system",
      "failure cascade"
    ];
    EXTERNAL_KEYWORDS = [
      "market",
      "competitor",
      "industry",
      "customer",
      "trend",
      "regulation",
      "economy",
      "economic",
      "pricing",
      "segment",
      "share",
      "consumer",
      "demand",
      "supply",
      "vendor",
      "supplier",
      "partner",
      "external",
      "benchmark",
      "landscape",
      "sector",
      "growth",
      "decline",
      "forecast",
      "regulatory",
      "compliance",
      "legislation",
      "law",
      "government",
      "technology",
      "innovation",
      "disruption",
      "digital",
      "ai",
      "automation"
    ];
    EXTERNAL_PHRASES = [
      "market share",
      "competitive landscape",
      "industry trend",
      "customer segment",
      "market conditions",
      "economic factors",
      "regulatory environment",
      "technology trend",
      "market growth",
      "competitive pressure",
      "market position",
      "customer needs",
      "consumer behavior",
      "market opportunity",
      "market threat",
      "price point",
      "pricing strategy",
      "competitive advantage",
      "market leader"
    ];
    FRAMEWORK_KEYWORDS = [
      "swot",
      "porter",
      "pestle",
      "pestel",
      "pest",
      "five whys",
      "5 whys",
      "root cause",
      "analysis",
      "framework",
      "matrix",
      "model",
      "canvas",
      "strategy",
      "strategic",
      "assessment",
      "evaluation",
      "diagnostic",
      "force",
      "strength",
      "weakness",
      "opportunity",
      "threat",
      "factor",
      "driver",
      "barrier",
      "enabler",
      "constraint",
      "assumption",
      "hypothesis"
    ];
    FRAMEWORK_PHRASES = [
      "business model",
      "value proposition",
      "competitive force",
      "five forces",
      "root cause analysis",
      "cause and effect",
      "why did",
      "because of",
      "leads to",
      "results in",
      "contributes to",
      "analyze the",
      "assess the",
      "evaluate the",
      "compare and contrast",
      "pros and cons",
      "trade-off",
      "strategic option",
      "decision criteria",
      "critical success factor"
    ];
    ClaimClassifier = class {
      internalKeywords;
      externalKeywords;
      frameworkKeywords;
      constructor() {
        this.internalKeywords = new Set(INTERNAL_KEYWORDS.map((k) => k.toLowerCase()));
        this.externalKeywords = new Set(EXTERNAL_KEYWORDS.map((k) => k.toLowerCase()));
        this.frameworkKeywords = new Set(FRAMEWORK_KEYWORDS.map((k) => k.toLowerCase()));
      }
      /**
       * Analyze input text and classify claims
       */
      classifyClaims(input) {
        const classifications = [];
        const sentences = this.splitIntoSentences(input);
        for (const sentence of sentences) {
          const classification = this.classifySentence(sentence);
          if (classification) {
            classifications.push(classification);
          }
        }
        if (classifications.length === 0) {
          classifications.push({
            claimType: "framework",
            topic: "general analysis",
            entities: [],
            requiresValidation: false,
            source: "llm_reasoning",
            originalText: input
          });
        }
        return classifications;
      }
      splitIntoSentences(input) {
        return input.split(/[.!?]+/).map((s) => s.trim()).filter((s) => s.length > 10);
      }
      classifySentence(sentence) {
        const lowerSentence = sentence.toLowerCase();
        const words = lowerSentence.split(/\s+/);
        const internalScore = this.scoreInternal(lowerSentence, words);
        const externalScore = this.scoreExternal(lowerSentence, words);
        const frameworkScore = this.scoreFramework(lowerSentence, words);
        const maxScore = Math.max(internalScore, externalScore, frameworkScore);
        if (maxScore < 0.5) {
          return null;
        }
        const entities = this.extractEntities(sentence);
        const topic = this.extractTopic(sentence);
        if (internalScore === maxScore) {
          return {
            claimType: "internal",
            topic,
            entities,
            requiresValidation: true,
            source: "context_foundry",
            originalText: sentence
          };
        } else if (externalScore === maxScore) {
          return {
            claimType: "external",
            topic,
            entities,
            requiresValidation: true,
            source: "web_search",
            originalText: sentence
          };
        } else {
          return {
            claimType: "framework",
            topic,
            entities,
            requiresValidation: false,
            source: "llm_reasoning",
            originalText: sentence
          };
        }
      }
      scoreInternal(sentence, words) {
        let score = 0;
        const totalPossible = INTERNAL_KEYWORDS.length + INTERNAL_PHRASES.length;
        for (const word of words) {
          if (this.internalKeywords.has(word)) {
            score += 1;
          }
        }
        for (const phrase of INTERNAL_PHRASES) {
          if (sentence.includes(phrase.toLowerCase())) {
            score += 2;
          }
        }
        return Math.min(score / 3, 1);
      }
      scoreExternal(sentence, words) {
        let score = 0;
        for (const word of words) {
          if (this.externalKeywords.has(word)) {
            score += 1;
          }
        }
        for (const phrase of EXTERNAL_PHRASES) {
          if (sentence.includes(phrase.toLowerCase())) {
            score += 2;
          }
        }
        return Math.min(score / 3, 1);
      }
      scoreFramework(sentence, words) {
        let score = 0;
        for (const word of words) {
          if (this.frameworkKeywords.has(word)) {
            score += 1;
          }
        }
        for (const phrase of FRAMEWORK_PHRASES) {
          if (sentence.includes(phrase.toLowerCase())) {
            score += 2;
          }
        }
        return Math.min(score / 3, 1);
      }
      extractEntities(sentence) {
        const entities = [];
        const capitalizedWords = sentence.match(/\b[A-Z][a-zA-Z]*(?:\s+[A-Z][a-zA-Z]*)*\b/g) || [];
        for (const word of capitalizedWords) {
          if (word.length > 2 && !["The", "This", "That", "They", "We", "Our", "Their"].includes(word)) {
            entities.push(word);
          }
        }
        return Array.from(new Set(entities)).slice(0, 5);
      }
      extractTopic(sentence) {
        const words = sentence.split(/\s+/).slice(0, 8);
        return words.join(" ") + (words.length >= 8 ? "..." : "");
      }
    };
  }
});

// shared/contracts/positioning.schema.ts
import { z as z3 } from "zod";
var PositioningInputSchema, PositioningOutputSchema;
var init_positioning_schema = __esm({
  "shared/contracts/positioning.schema.ts"() {
    "use strict";
    PositioningInputSchema = z3.object({
      /** Raw user description of the business */
      userInput: z3.string().min(1, "User input required"),
      /** Clarifications from ambiguity resolution */
      clarifications: z3.object({
        targetMarket: z3.string().optional(),
        customerSegment: z3.string().optional(),
        geographicScope: z3.string().optional(),
        timeHorizon: z3.string().optional()
      }).optional()
    });
    PositioningOutputSchema = z3.object({
      businessConcept: z3.object({
        /** e.g., "Premium Basketball Sneaker Store" */
        name: z3.string().min(1),
        /** One paragraph summary */
        description: z3.string().min(10),
        /** e.g., "Specialty Retail" */
        category: z3.string().min(1)
      }),
      market: z3.object({
        /** e.g., "Athletic Footwear Retail" */
        industry: z3.string().min(1),
        /** e.g., "Premium/Collector Sneakers" */
        industryNarrow: z3.string().optional(),
        /** e.g., "Abu Dhabi, UAE" */
        geography: z3.string().min(1),
        geographyScope: z3.enum(["city", "country", "region", "global"])
      }),
      customer: z3.object({
        /** e.g., "Sneaker collectors and enthusiasts" */
        primarySegment: z3.string().min(1),
        /** e.g., ["Athletes", "Fashion-conscious youth"] */
        secondarySegments: z3.array(z3.string()).optional(),
        /** e.g., "Males 18-35, middle-to-high income" */
        demographicProfile: z3.string().optional()
      }),
      valueProposition: z3.object({
        /** e.g., "Authentic limited-edition sneakers with verification" */
        hypothesis: z3.string().min(1),
        /** e.g., ["Authentication", "Exclusive releases", "Expert curation"] */
        keyDifferentiators: z3.array(z3.string())
      }),
      /** e.g., "Should we enter this market and how?" */
      strategicQuestion: z3.string().min(1),
      analysisScope: z3.object({
        /** e.g., ["UAE market", "Physical retail", "E-commerce"] */
        inScope: z3.array(z3.string()),
        /** e.g., ["Wholesale", "Manufacturing"] */
        outOfScope: z3.array(z3.string()),
        /** e.g., "12-month launch plan" */
        timeHorizon: z3.string()
      }),
      /** Critical for S/W assessment in SWOT */
      ventureType: z3.enum(["new_venture", "existing_business"])
    });
  }
});

// shared/contracts/five-whys.schema.ts
import { z as z4 } from "zod";
var FiveWhysInputSchema, WhyLevelSchema, WhyChainSchema, AssumptionSchema, RootCauseSchema, ValidationPrioritySchema, FiveWhysOutputSchema, FIVE_WHYS_SYSTEM_PROMPT;
var init_five_whys_schema = __esm({
  "shared/contracts/five-whys.schema.ts"() {
    "use strict";
    init_positioning_schema();
    FiveWhysInputSchema = z4.object({
      positioning: PositioningOutputSchema,
      /** User's belief about success (optional starting point) */
      initialStatement: z4.string().optional()
    });
    WhyLevelSchema = z4.object({
      level: z4.number().min(1).max(5),
      question: z4.string(),
      answer: z4.string(),
      assumptionSurfaced: z4.string()
    });
    WhyChainSchema = z4.object({
      startingPoint: z4.string(),
      whys: z4.array(WhyLevelSchema),
      rootCause: z4.string()
    });
    AssumptionSchema = z4.object({
      assumption: z4.string(),
      category: z4.enum(["validated", "testable", "untestable"]),
      evidence: z4.string().optional(),
      riskIfWrong: z4.enum(["high", "medium", "low"])
    });
    RootCauseSchema = z4.object({
      cause: z4.string(),
      chainId: z4.number(),
      implications: z4.array(z4.string())
    });
    ValidationPrioritySchema = z4.object({
      assumption: z4.string(),
      testMethod: z4.string(),
      priority: z4.enum(["critical", "important", "nice-to-have"]),
      estimatedCost: z4.string().optional(),
      estimatedTime: z4.string().optional()
    });
    FiveWhysOutputSchema = z4.object({
      successHypothesis: z4.string(),
      whyChains: z4.array(WhyChainSchema),
      assumptions: z4.array(AssumptionSchema),
      rootCauses: z4.array(RootCauseSchema),
      /** If wrong, business fails */
      criticalAssumptions: z4.array(AssumptionSchema),
      validationPriorities: z4.array(ValidationPrioritySchema)
    });
    FIVE_WHYS_SYSTEM_PROMPT = `You are conducting a Five Whys analysis for a NEW VENTURE. Your goal is to surface hidden assumptions about why this business would succeed.

CRITICAL RULES:
1. Stay BUSINESS-FOCUSED. Every "why" should relate to:
   - Customer value
   - Competitive advantage
   - Market opportunity
   - Business viability

2. DO NOT drift into generic life philosophy. Bad example:
   - "Why make money?" \u2192 "To be financially independent" \u2192 "To have freedom"
   
3. DO stay focused on business success. Good example:
   - "Why would collectors buy from your store?" \u2192 "Because we offer authenticated limited editions"
   - "Why can't they find authenticated editions elsewhere?" \u2192 "UAE market lacks trusted authentication"

4. Surface SPECIFIC, TESTABLE assumptions at each level.

5. Explore 2-4 PARALLEL chains from different starting points:
   - Chain 1: Why would customers choose us?
   - Chain 2: Why would our business model work?
   - Chain 3: Why would we win against competitors?
   - Chain 4: Why would this timing work?

6. Go DEEP (5 levels) to reach genuine root causes.`;
  }
});

// server/strategic-consultant-legacy/whys-tree-generator.ts
import { randomUUID } from "crypto";
var SESSION_BRANCH_CACHE, CACHE_TTL, CACHE_METADATA, WhysTreeGenerator;
var init_whys_tree_generator = __esm({
  "server/strategic-consultant-legacy/whys-tree-generator.ts"() {
    "use strict";
    init_ai_clients();
    init_grounded_analysis_service();
    init_five_whys_schema();
    SESSION_BRANCH_CACHE = /* @__PURE__ */ new Map();
    CACHE_TTL = 30 * 60 * 1e3;
    CACHE_METADATA = /* @__PURE__ */ new Map();
    setInterval(() => {
      const now = Date.now();
      const entries = Array.from(CACHE_METADATA.entries());
      for (const [key, meta] of entries) {
        if (now - meta.timestamp > CACHE_TTL) {
          SESSION_BRANCH_CACHE.delete(key);
          CACHE_METADATA.delete(key);
          console.log(`[Cache] Cleaned up stale entry: ${key}`);
        }
      }
    }, 5 * 60 * 1e3);
    WhysTreeGenerator = class {
      maxDepth = 5;
      groundingContext = null;
      cfContextPrompt = "";
      summaryMaxChars = 180;
      summaryMinWords = 4;
      summaryMaxWords = 22;
      /**
       * Build a context prompt section from Context Foundry data
       */
      buildCFContextPrompt(orchestration) {
        const sections = [];
        if (orchestration.cfContext && orchestration.cfContext.isGrounded) {
          sections.push(`
## Verified Organizational Context (from Knowledge Graph)`);
          sections.push(`**Confidence: ${Math.round(orchestration.cfContext.confidence * 100)}%**`);
          if (orchestration.cfContext.confirmedEntities.length > 0) {
            sections.push(`
### Confirmed Entities - USE THESE FACTS:`);
            for (const entity of orchestration.cfContext.confirmedEntities.slice(0, 10)) {
              sections.push(`- ${entity.type}: **${entity.name}** (${Math.round(entity.confidence * 100)}% confidence)`);
            }
          }
          if (orchestration.cfContext.inferredRelationships.length > 0) {
            sections.push(`
### Known Relationships - USE THESE FACTS:`);
            for (const rel of orchestration.cfContext.inferredRelationships.slice(0, 10)) {
              sections.push(`- ${rel.sourceEntity} \u2192 ${rel.relationshipType} \u2192 ${rel.targetEntity}`);
            }
          }
          if (orchestration.cfContext.answer) {
            sections.push(`
### Context Foundry Analysis:`);
            sections.push(orchestration.cfContext.answer);
          }
          sections.push(`
**IMPORTANT: Reference these verified entities and relationships in your analysis. Mark any claims NOT from this list as [ASSUMED].**`);
        }
        if (orchestration.flaggedAssumptions.length > 0) {
          sections.push(`
## \u26A0\uFE0F Flagged Assumptions (unverified claims):`);
          for (const assumption of orchestration.flaggedAssumptions.slice(0, 5)) {
            sections.push(`- ${assumption}`);
          }
        }
        return sections.join("\n");
      }
      extractJSON(response, context, fallback) {
        console.log(`[WhysTreeGenerator] ${context} - AI provider:`, response.provider, "model:", response.model);
        console.log(`[WhysTreeGenerator] ${context} - Response length:`, response.content.length);
        console.log(`[WhysTreeGenerator] ${context} - Response preview:`, response.content.substring(0, 200));
        if (!response.content || response.content.trim().length === 0) {
          console.warn(`[WhysTreeGenerator] ${context} - Empty response from ${response.provider}, using fallback`);
          if (fallback) return fallback;
          throw new Error(`Empty response from ${response.provider} ${context}`);
        }
        let cleanedContent = response.content.trim();
        const codeBlockMatch = cleanedContent.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
        if (codeBlockMatch) {
          console.log(`[WhysTreeGenerator] ${context} - Extracted from code block`);
          cleanedContent = codeBlockMatch[1];
        }
        const jsonMatch = cleanedContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          console.error(`[WhysTreeGenerator] ${context} - Failed to extract JSON from AI response`);
          console.error(`[WhysTreeGenerator] ${context} - Provider:`, response.provider);
          console.error(`[WhysTreeGenerator] ${context} - Full response:`, response.content);
          if (fallback) {
            console.warn(`[WhysTreeGenerator] ${context} - Using fallback value`);
            return fallback;
          }
          throw new Error(`Failed to extract JSON from ${response.provider} ${context}. Response was: ${response.content.substring(0, 300)}`);
        }
        try {
          const parsed = JSON.parse(jsonMatch[0]);
          console.log(`[WhysTreeGenerator] ${context} - Successfully parsed JSON`);
          return parsed;
        } catch (parseError) {
          console.error(`[WhysTreeGenerator] ${context} - JSON parse error:`, parseError.message);
          console.error(`[WhysTreeGenerator] ${context} - Attempted to parse:`, jsonMatch[0].substring(0, 300));
          if (fallback) {
            console.warn(`[WhysTreeGenerator] ${context} - Using fallback value due to parse error`);
            return fallback;
          }
          throw new Error(`Failed to parse JSON from ${response.provider} ${context}: ${parseError.message}`);
        }
      }
      async generateTree(input, sessionId) {
        let groundingMetadata;
        if (isContextFoundryConfigured()) {
          try {
            console.log("[WhysTreeGenerator] Querying Context Foundry for grounding...");
            this.groundingContext = await orchestrateAnalysis(input, "five_whys");
            this.cfContextPrompt = this.buildCFContextPrompt(this.groundingContext);
            console.log(`[WhysTreeGenerator] CF grounding result: isGrounded=${this.groundingContext.cfContext?.isGrounded}, entities=${this.groundingContext.cfContext?.confirmedEntities?.length || 0}, relationships=${this.groundingContext.cfContext?.inferredRelationships?.length || 0}`);
            if (this.groundingContext.cfContext) {
              groundingMetadata = {
                isGrounded: this.groundingContext.cfContext.isGrounded,
                confidence: this.groundingContext.cfContext.confidence,
                confirmedEntities: this.groundingContext.cfContext.confirmedEntities.map((e) => ({
                  name: e.name,
                  type: e.type,
                  confidence: e.confidence
                })),
                relationships: this.groundingContext.cfContext.inferredRelationships.map((r) => ({
                  source: r.sourceEntity,
                  type: r.relationshipType,
                  target: r.targetEntity
                })),
                flaggedAssumptions: this.groundingContext.flaggedAssumptions,
                externalClaimsForWebSearch: this.groundingContext.externalClaimsForWebSearch
              };
            }
          } catch (error) {
            console.warn("[WhysTreeGenerator] Context Foundry grounding failed, proceeding without:", error);
            this.groundingContext = null;
            this.cfContextPrompt = "";
          }
        } else {
          console.log("[WhysTreeGenerator] Context Foundry not configured, proceeding without grounding");
          this.groundingContext = null;
          this.cfContextPrompt = "";
        }
        const rootQuestion = await this.generateRootQuestion(input);
        const level1Branches = await this.generateLevelInParallel(
          rootQuestion,
          { input, history: [] },
          1
        );
        const level2BranchesPromises = level1Branches.map(
          (level1Node) => this.generateLevelInParallel(
            level1Node.question,
            { input, history: [{ question: rootQuestion, answer: level1Node.option }] },
            2,
            level1Node.id
          ).then((level2Branches) => {
            level1Node.branches = level2Branches;
            return level1Node;
          })
        );
        const level1WithLevel2 = await Promise.all(level2BranchesPromises);
        return {
          rootQuestion,
          branches: level1WithLevel2,
          maxDepth: this.maxDepth,
          sessionId,
          groundingMetadata
        };
      }
      async generateRootQuestion(input) {
        let systemPrompt = FIVE_WHYS_SYSTEM_PROMPT;
        if (this.cfContextPrompt) {
          systemPrompt += `

You have access to verified organizational data. Use specific entity names and relationships from this data when forming your questions.`;
        }
        let userMessage = `Business challenge: ${input}
${this.cfContextPrompt}

Generate the opening question for this Five Whys analysis.

The question must:
- Focus on a critical business success factor (customer value, competitive advantage, market opportunity, or business viability)
- Be specific and interrogative (not vague or philosophical)
- Lead directly toward business mechanisms and evidence
${this.cfContextPrompt ? "- Reference specific entities or relationships from the verified context above when relevant" : ""}

GOOD examples:
- "Why would customers choose your solution over existing alternatives?"
- "Why can't competitors easily replicate this advantage?"
- "Why would this business model generate sustainable revenue?"

BAD examples:
- "Why do you want to start a business?" (too philosophical)
- "Why is this important to you?" (personal, not business-focused)

Return JSON:
{
  "question": "Why [specific business mechanism]?"
}`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 1e3
        });
        const parsed = this.extractJSON(response, "generateRootQuestion");
        return parsed.question || response.content.trim();
      }
      calculateTextSimilarity(text1, text2) {
        const normalize = (text3) => text3.toLowerCase().replace(/[^a-z0-9\s]/g, "").trim();
        const words1 = new Set(normalize(text1).split(/\s+/));
        const words2 = new Set(normalize(text2).split(/\s+/));
        const words1Array = Array.from(words1);
        const words2Array = Array.from(words2);
        const intersection = new Set(words1Array.filter((word) => words2.has(word)));
        const union = /* @__PURE__ */ new Set([...words1Array, ...words2Array]);
        return union.size > 0 ? intersection.size / union.size : 0;
      }
      validateAnswerQuality(option, question) {
        const normalizedOption = option.toLowerCase().trim();
        const normalizedQuestion = question.toLowerCase().trim();
        if (option.length < 15) {
          return { valid: false, reason: "Answer too short (less than 15 characters)" };
        }
        const similarity = this.calculateTextSimilarity(option, question);
        if (similarity > 0.85) {
          return { valid: false, reason: `Answer is too similar to question (${Math.round(similarity * 100)}% similarity)` };
        }
        const questionWords = normalizedQuestion.replace(/^why\s+/i, "").replace(/\?$/, "").split(/\s+/);
        const optionWords = normalizedOption.split(/\s+/);
        if (optionWords.length > 5) {
          const consecutiveMatches = questionWords.filter(
            (word) => word.length > 3 && normalizedOption.includes(word)
          ).length;
          if (consecutiveMatches > questionWords.length * 0.8 && optionWords.length < 18) {
            return { valid: false, reason: "Answer repeats too many words from question" };
          }
        }
        const startsWithQuestion = normalizedOption.startsWith(normalizedQuestion.replace(/^why\s+/i, "").replace(/\?$/, "").substring(0, 30));
        if (startsWithQuestion) {
          return { valid: false, reason: "Answer starts by repeating the question" };
        }
        return { valid: true };
      }
      normalizeSummary(summary) {
        let cleaned = summary.replace(/\s+/g, " ").trim();
        cleaned = cleaned.replace(/[.!?]+$/g, "").trim();
        if (!cleaned.endsWith(".")) {
          cleaned = `${cleaned}.`;
        }
        return cleaned;
      }
      validateSummary(summary) {
        const cleaned = summary.replace(/\s+/g, " ").trim();
        if (cleaned.length === 0) {
          return { valid: false, reason: "Summary is empty" };
        }
        if (cleaned.includes("...") || cleaned.includes("\u2026")) {
          return { valid: false, reason: "Summary contains ellipsis" };
        }
        if (!cleaned.endsWith(".")) {
          return { valid: false, reason: "Summary does not end with a period" };
        }
        if (cleaned.length > this.summaryMaxChars) {
          return { valid: false, reason: `Summary too long (${cleaned.length} chars)` };
        }
        const words = cleaned.split(/\s+/).filter(Boolean);
        if (words.length < this.summaryMinWords) {
          return { valid: false, reason: `Summary too short (${words.length} words)` };
        }
        if (words.length > this.summaryMaxWords) {
          return { valid: false, reason: `Summary too long (${words.length} words)` };
        }
        const sentenceCount = cleaned.split(/[.!?]/).filter(Boolean).length;
        if (sentenceCount > 1) {
          return { valid: false, reason: "Summary has multiple sentences" };
        }
        return { valid: true };
      }
      fallbackSummary(option) {
        let summary = option.replace(/\s+/g, " ").trim();
        summary = summary.split(/[.!?]/)[0]?.trim() || summary;
        const cutTokens = [" due to ", " because ", " which ", " where ", " while ", " that ", " through "];
        for (const token of cutTokens) {
          const idx = summary.toLowerCase().indexOf(token);
          if (idx > 40) {
            summary = summary.slice(0, idx).trim();
            break;
          }
        }
        if (summary.length > this.summaryMaxChars) {
          summary = summary.slice(0, this.summaryMaxChars);
          summary = summary.replace(/\s+\S*$/, "").trim();
        }
        return this.normalizeSummary(summary);
      }
      async generateOptionSummary(option) {
        const systemPrompt = `You are a business analyst. Summarize the reason into ONE sentence.`;
        const maxRetries = 3;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          const userMessage = `Summarize the following business reason into ONE sentence.

Rules:
- End with a period.
- No ellipsis, no trailing fragments.
- Keep the main subject and key causal mechanism.
- Max ${this.summaryMaxChars} characters.
- Between ${this.summaryMinWords} and ${this.summaryMaxWords} words.

Reason:
${option}

Return JSON:
{ "summary": "..." }`;
          try {
            const response = await aiClients.callWithFallback({
              systemPrompt,
              userMessage,
              maxTokens: 200
            });
            const parsed = this.extractJSON(response, "generateOptionSummary", { summary: "" });
            const raw = typeof parsed.summary === "string" ? parsed.summary : "";
            const candidate = this.normalizeSummary(raw);
            const validation = this.validateSummary(candidate);
            if (validation.valid) {
              return candidate;
            }
            console.warn(`[Summary QC] Invalid summary attempt ${attempt}/${maxRetries}: ${validation.reason}`);
          } catch (error) {
            console.warn(`[Summary QC] Summary generation failed attempt ${attempt}/${maxRetries}:`, error.message || error);
          }
        }
        return this.fallbackSummary(option);
      }
      async buildNodesFromBranches(branches, depth, isLeaf, parentId) {
        const summaries = await Promise.all(
          branches.map((branch) => this.generateOptionSummary(branch.option))
        );
        return branches.map((branch, idx) => ({
          id: randomUUID(),
          question: branch.next_question,
          option: branch.option,
          summary: summaries[idx],
          depth,
          isLeaf,
          parentId,
          branches: isLeaf ? void 0 : [],
          supporting_evidence: branch.supporting_evidence || [],
          counter_arguments: branch.counter_arguments || [],
          consideration: branch.consideration || ""
        }));
      }
      async generateLevelInParallel(question, context, depth, parentId) {
        const isLeaf = depth >= this.maxDepth;
        const maxRetries = 3;
        const targetCount = 3;
        const seenOptions = /* @__PURE__ */ new Set();
        const validBranches = [];
        const rejectedBranches = [];
        let systemPrompt = `${FIVE_WHYS_SYSTEM_PROMPT}

CRITICAL: Every "why" answer must include:
1. MECHANISM: What drives this (cause \u2192 effect relationship)
2. OBSERVABLE SIGNAL: What data would prove this
3. DISCONFIRMING SIGNAL: What would falsify this claim

BUSINESS DOMAINS ONLY:
- Market dynamics, Customer behavior, Competition, Economics
- Distribution, Regulation, Resources

ANTI-PATTERNS (Reject):
\u2717 "You think/feel" \u2717 "Because it's important" \u2717 "Because it's new"`;
        if (this.cfContextPrompt) {
          systemPrompt += "\n\nIMPORTANT: You have verified organizational data available. When making claims about the organization's systems, services, or relationships, use the specific entity names and facts provided. Mark claims as [VERIFIED] when they match the provided context, or [ASSUMED] when they go beyond it.";
        }
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          const response = await aiClients.callWithFallback({
            systemPrompt,
            userMessage: `Business challenge: ${context.input}
${this.cfContextPrompt}

Current question: ${question}

${context.history.length > 0 ? `Path so far:
${context.history.map((step, i) => `${i + 1}. Q: ${step.question}
   A: ${step.answer}`).join("\n\n")}` : ""}

Depth: ${depth}/${this.maxDepth}

Generate exactly 3 possible answers explaining WHY.

EACH ANSWER REQUIRES:
- MECHANISM: Causal relationship (X \u2192 Y through Z)
- OBSERVABLE SIGNAL: Specific evidence/data
- DISCONFIRMING SIGNAL: What would prove this wrong
- BUSINESS LENS: Tie to market/customer/competition/economics

NO vague statements. Use specific numbers when possible.
NO invented facts unless marked [ASSUMPTION].

EXAMPLES:
\u2713 "Customer acquisition cost ($450/customer) exceeds customer lifetime value ($280) due to 60% annual churn"
\u2713 "UAE regulatory framework requires AED 50K minimum capital + DFSA license (6-month approval process)"
\u2713 "Market leader (40% share) has locked 80% of enterprise customers into 3-year contracts"
${this.cfContextPrompt ? '\u2713 "API Gateway (verified entity) handles 2M requests/day and has 3 dependent services that cascade on failure"' : ""}

\u2717 "Because it's important to customers" (no mechanism, no signal)
\u2717 "The market is growing" (no numbers, no evidence)
\u2717 "People value authenticity" (vague, untestable)

**CRITICAL: next_question must interrogate THIS answer**
If answer is "Traditional cafes have 40% lower operational overhead due to simpler supply chains"
\u2192 next_question: "Why do traditional cafes have lower operational overhead?"
NOT: "What are customer preferences in Dubai?" (different topic!)

Return JSON:
{
  "branches": [
    {
      "option": "Mechanism explaining why (cause \u2192 effect)",
      "next_question": "Why [interrogate this specific answer]?",
      "supporting_evidence": ["Observable signal 1", "Observable signal 2"],
      "counter_arguments": ["Disconfirming signal 1", "Disconfirming signal 2"],
      "consideration": "Neutral comparison insight"
    }
  ]
}`,
            maxTokens: 2e3
          });
          const parsed = this.extractJSON(response, "generateLevelInParallel");
          if (context.history.length > 0) {
            console.log(`[generateLevelInParallel] Depth ${depth} - Q&A history sent to AI:`, context.history);
          }
          const invalidBranches = [];
          for (const branch of parsed.branches) {
            if (seenOptions.has(branch.option)) {
              continue;
            }
            seenOptions.add(branch.option);
            const qualityCheck = this.validateAnswerQuality(branch.option, question);
            if (qualityCheck.valid) {
              validBranches.push(branch);
            } else {
              invalidBranches.push({ option: branch.option, reason: qualityCheck.reason || "Unknown" });
              rejectedBranches.push(branch);
              console.warn(`[Quality Control] Rejected answer (attempt ${attempt}/${maxRetries}): "${branch.option}" - Reason: ${qualityCheck.reason}`);
            }
          }
          if (validBranches.length >= targetCount) {
            console.log(`[Quality Control] \u2713 Generated ${validBranches.length} valid answers on attempt ${attempt}/${maxRetries}`);
            const nodes = await this.buildNodesFromBranches(validBranches.slice(0, targetCount), depth, isLeaf, parentId);
            return nodes;
          }
          if (attempt < maxRetries) {
            console.log(`[Quality Control] Only ${validBranches.length} valid answers. Retrying... (attempt ${attempt + 1}/${maxRetries})`);
            if (invalidBranches.length > 0) {
              console.log(`[Quality Control] Rejected answers:`, invalidBranches);
            }
          } else {
            console.warn(`[Quality Control] Failed to generate 3+ valid answers after ${maxRetries} attempts. Using best available (${validBranches.length} valid answers)`);
            let finalBranches = [...validBranches];
            if (finalBranches.length < targetCount) {
              const missing = targetCount - finalBranches.length;
              const repairBranches = await this.generateMissingBranches(
                question,
                context,
                missing,
                finalBranches.map((b) => b.option)
              );
              for (const branch of repairBranches) {
                if (finalBranches.length >= targetCount) break;
                if (seenOptions.has(branch.option)) continue;
                const qualityCheck = this.validateAnswerQuality(branch.option, question);
                if (qualityCheck.valid) {
                  finalBranches.push(branch);
                  seenOptions.add(branch.option);
                } else {
                  rejectedBranches.push(branch);
                }
              }
            }
            if (finalBranches.length < targetCount && rejectedBranches.length > 0) {
              for (const branch of rejectedBranches) {
                if (finalBranches.length >= targetCount) break;
                if (seenOptions.has(branch.option)) continue;
                finalBranches.push(branch);
                seenOptions.add(branch.option);
              }
            }
            if (finalBranches.length === 0) {
              throw new Error(`Failed to generate any usable answers after ${maxRetries} attempts and repair.`);
            }
            const nodes = await this.buildNodesFromBranches(finalBranches.slice(0, targetCount), depth, isLeaf, parentId);
            return nodes;
          }
        }
        throw new Error("Unexpected error in generateLevelInParallel - should not reach here");
      }
      async generateMissingBranches(question, context, missingCount, existingOptions) {
        if (missingCount <= 0) return [];
        let systemPrompt = `${FIVE_WHYS_SYSTEM_PROMPT}

You are generating additional distinct answers to complete a set of 3.`;
        if (this.cfContextPrompt) {
          systemPrompt += `

${this.cfContextPrompt}`;
        }
        const userMessage = `Business challenge: ${context.input}

Current question: ${question}

Existing answers (do NOT repeat or rephrase these):
${existingOptions.map((opt, i) => `${i + 1}. ${opt}`).join("\n")}

Generate exactly ${missingCount} NEW answers explaining WHY.

Rules:
- Must be different in meaning from the existing answers.
- Focus on business mechanisms with evidence.
- Provide next_question that interrogates THIS answer.

Return JSON:
{
  "branches": [
    {
      "option": "Mechanism explaining why (cause \u2192 effect)",
      "next_question": "Why [interrogate this specific answer]?",
      "supporting_evidence": ["Observable signal 1", "Observable signal 2"],
      "counter_arguments": ["Disconfirming signal 1", "Disconfirming signal 2"],
      "consideration": "Neutral comparison insight"
    }
  ]
}`;
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt,
            userMessage,
            maxTokens: 1200
          });
          const parsed = this.extractJSON(response, "generateMissingBranches", { branches: [] });
          return Array.isArray(parsed.branches) ? parsed.branches : [];
        } catch (error) {
          console.warn("[generateMissingBranches] Failed to generate missing branches:", error.message || error);
          return [];
        }
      }
      async expandBranch(nodeId, selectedPath, input, sessionId, currentDepth, parentQuestion) {
        if (currentDepth >= this.maxDepth) {
          throw new Error("Cannot expand beyond maximum depth");
        }
        const history = Array.isArray(selectedPath) && selectedPath.length > 0 && typeof selectedPath[0] === "string" ? selectedPath.map((answer, idx) => ({
          question: `Step ${idx + 1}`,
          // Placeholder for old format
          answer
        })) : selectedPath;
        const nextDepth = currentDepth + 1;
        const branches = await this.generateLevelInParallel(
          parentQuestion,
          { input, history },
          nextDepth,
          nodeId
        );
        return branches;
      }
      // =============================================================================
      // CACHE METHODS
      // =============================================================================
      getCachedBranches(sessionId, nodeId, depth) {
        const cacheKey = `${sessionId}:${nodeId}:${depth}`;
        const cached = SESSION_BRANCH_CACHE.get(cacheKey);
        if (cached) {
          console.log(`[Cache HIT] ${cacheKey}`);
          return cached;
        }
        return null;
      }
      setCachedBranches(sessionId, nodeId, depth, branches) {
        const cacheKey = `${sessionId}:${nodeId}:${depth}`;
        SESSION_BRANCH_CACHE.set(cacheKey, branches);
        CACHE_METADATA.set(cacheKey, { timestamp: Date.now() });
        console.log(`[Cache SET] ${cacheKey} - ${branches.length} branches`);
      }
      // =============================================================================
      // PREFETCH METHODS
      // =============================================================================
      async expandBranchWithPrefetch(nodeId, selectedPath, input, sessionId, currentDepth, parentQuestion, allSiblings) {
        const cached = this.getCachedBranches(sessionId, nodeId, currentDepth);
        if (cached) {
          return { expandedBranches: cached };
        }
        const expandedBranches = await this.expandBranch(
          nodeId,
          selectedPath,
          input,
          sessionId,
          currentDepth,
          parentQuestion
        );
        this.setCachedBranches(sessionId, nodeId, currentDepth, expandedBranches);
        let prefetchPromises = [];
        if (allSiblings && allSiblings.length > 1 && currentDepth <= 3 && currentDepth < this.maxDepth - 1) {
          const otherSiblings = allSiblings.filter((s) => s.id !== nodeId);
          console.log(`[Prefetch START] Session ${sessionId}, depth ${currentDepth}, prefetching ${otherSiblings.length} siblings`);
          prefetchPromises = otherSiblings.map(
            (sibling) => this.prefetchBranch(sibling, input, selectedPath, currentDepth, sessionId).catch((err) => {
              console.warn(`[Prefetch FAILED] Node ${sibling.id}:`, err.message);
            })
          );
          Promise.allSettled(prefetchPromises).then(() => {
            console.log(`[Prefetch COMPLETE] Session ${sessionId}, depth ${currentDepth}`);
          });
        }
        return { expandedBranches, prefetchPromises };
      }
      async prefetchBranch(sibling, input, selectedPath, currentDepth, sessionId) {
        const cached = this.getCachedBranches(sessionId, sibling.id, currentDepth);
        if (cached) {
          console.log(`[Prefetch SKIP] ${sibling.id} - already cached`);
          return;
        }
        const hypotheticalPath = [...selectedPath, { question: sibling.question, answer: sibling.option }];
        try {
          const nextDepth = currentDepth + 1;
          const branches = await this.generateLevelInParallel(
            sibling.question,
            { input, history: hypotheticalPath },
            nextDepth,
            sibling.id
          );
          this.setCachedBranches(sessionId, sibling.id, currentDepth, branches);
          console.log(`[Prefetch SUCCESS] Node ${sibling.id} - cached ${branches.length} branches`);
        } catch (error) {
          console.error(`[Prefetch ERROR] Node ${sibling.id}:`, error.message);
          throw error;
        }
      }
      async generateCustomBranches(customOption, selectedPath, input, sessionId, currentDepth) {
        if (currentDepth >= this.maxDepth) {
          throw new Error("Cannot expand beyond maximum depth");
        }
        console.log("[generateCustomBranches] Received selectedPath:", selectedPath);
        console.log("[generateCustomBranches] Received customOption:", customOption);
        console.log("[generateCustomBranches] Custom option already in path - using selectedPath directly");
        const history = Array.isArray(selectedPath) && selectedPath.length > 0 && typeof selectedPath[0] === "string" ? selectedPath.map((answer, idx) => ({
          question: `Step ${idx + 1}`,
          // Placeholder for old format
          answer
        })) : selectedPath;
        const nextQuestion = `Why is this? (${customOption})`;
        const nextDepth = currentDepth + 1;
        const branches = await this.generateLevelInParallel(
          nextQuestion,
          { input, history },
          nextDepth
        );
        return branches;
      }
      async generateFullPath(input, sessionId, selectedOptions) {
        if (selectedOptions.length === 0) {
          throw new Error("At least one selected option is required");
        }
        const rootQuestion = await this.generateRootQuestion(input);
        const path3 = [];
        let currentQuestion = rootQuestion;
        let history = [];
        for (let depth = 1; depth <= Math.min(selectedOptions.length + 1, this.maxDepth); depth++) {
          const branches = await this.generateLevelInParallel(
            currentQuestion,
            { input, history },
            depth,
            path3.length > 0 ? path3[path3.length - 1].id : void 0
          );
          if (depth <= selectedOptions.length) {
            const selectedOption = selectedOptions[depth - 1];
            const selectedNode = branches.find((b) => b.option === selectedOption);
            if (!selectedNode) {
              throw new Error(`Selected option not found at depth ${depth}`);
            }
            path3.push(selectedNode);
            history.push({ question: currentQuestion, answer: selectedNode.option });
            currentQuestion = selectedNode.question;
          } else {
            path3.push(...branches);
            break;
          }
        }
        return path3;
      }
      extractRootCause(path3) {
        if (path3.length === 0) {
          return "No path analyzed";
        }
        const finalNode = path3[path3.length - 1];
        return `After ${path3.length} levels of analysis, the root cause appears to be: ${finalNode.option}`;
      }
      async analyzePathInsights(input, path3) {
        const pathDescription = path3.map((node, i) => `Level ${node.depth}:
  Q: ${node.question}
  A: ${node.option}`).join("\n\n");
        const response = await aiClients.callWithFallback({
          systemPrompt: "You're helping someone understand what their 5 Whys analysis revealed. Explain it clearly in everyday language, like you're talking to a friend.",
          userMessage: `Here's what they started with:
${input}

And here's the path we took to get to the bottom of it (showing the question asked and answer selected at each level):
${pathDescription}

Okay, time to wrap this up! Based on everything we uncovered, I need you to:

1. Sum up the real core issue we found (the root cause)
2. Explain what this means for their business (3-5 implications - keep them practical)
3. Suggest what they should actually do about it (3-5 concrete actions)

Write this in a friendly, conversational way. No corporate jargon - just clear, helpful advice.

Return ONLY valid JSON (no markdown, no extra text):

{
  "root_cause": "Clear, plain-language explanation of the real issue",
  "strategic_implications": [
    "What this means for your business (be specific)",
    "Another implication (keep it real)",
    "Third one if relevant"
  ],
  "recommended_actions": [
    "Something concrete you can do",
    "Another practical step",
    "Third action if you've got one"
  ]
}`,
          maxTokens: 2e3
        });
        return this.extractJSON(response, "analyzePathInsights");
      }
      async validateRootCause(rootCauseText) {
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a safety check for harmful stereotypes. Be VERY permissive - only flag obvious ethnic, racial, or national stereotypes. When in doubt, approve it.",
            userMessage: `Does this root cause contain an ethnic, racial, or national stereotype? "${rootCauseText}"

Default to VALID unless it's an OBVIOUS stereotype like:
\u274C "Asian cultures avoid confrontation"
\u274C "Western executives take more risks than Eastern ones"  
\u274C "Middle Eastern business culture prioritizes relationships over contracts"

Everything else is VALID, including:
\u2713 Psychological patterns (fear, risk aversion, blame, reputation concerns)
\u2713 Organizational behavior (bureaucracy, hierarchy, decision paralysis)
\u2713 Market/business dynamics (any analysis of markets, customers, competition, pricing)
\u2713 Industry patterns (sales cycles, buyer conservatism, proof requirements)
\u2713 Resource/capability issues (gaps, constraints, skills, expertise)

When in doubt \u2192 mark as valid. Only flag EXPLICIT stereotypes about ethnic/racial/national groups.

Respond with ONLY valid JSON:
{
  "isValid": true or false,
  "reason": "why it's a stereotype OR why it's valid"
}`,
            maxTokens: 300
          });
          const validation = this.extractJSON(response, "validateRootCause");
          console.log(`[validateRootCause] AI validation result: ${validation.isValid ? "valid" : "invalid"} - "${rootCauseText}"`);
          return {
            valid: validation.isValid,
            message: validation.isValid ? void 0 : `I'm not convinced this gets to the business side of things yet. ${validation.reason} Maybe try a different branch - look for signals about what's happening with customers, the market, or your competitive position?`
          };
        } catch (error) {
          console.error("LLM validation failed, allowing root cause through:", error);
          return { valid: true };
        }
      }
    };
  }
});

// server/strategic-consultant-legacy/bmc-query-generator.ts
var BMCQueryGenerator;
var init_bmc_query_generator = __esm({
  "server/strategic-consultant-legacy/bmc-query-generator.ts"() {
    "use strict";
    init_ai_clients();
    init_parse_ai_json();
    BMCQueryGenerator = class {
      constructor() {
      }
      async generateQueriesForAllBlocks(input) {
        const [
          customerQueries,
          valueQueries,
          revenueQueries,
          channelsQueries,
          relationshipsQueries,
          resourcesQueries,
          activitiesQueries,
          partnersQueries,
          costQueries
        ] = await Promise.all([
          this.generateBlockQueries("customer_segments", input),
          this.generateBlockQueries("value_propositions", input),
          this.generateBlockQueries("revenue_streams", input),
          this.generateBlockQueries("channels", input),
          this.generateBlockQueries("customer_relationships", input),
          this.generateBlockQueries("key_resources", input),
          this.generateBlockQueries("key_activities", input),
          this.generateBlockQueries("key_partnerships", input),
          this.generateBlockQueries("cost_structure", input)
        ]);
        return {
          customer_segments: customerQueries,
          value_propositions: valueQueries,
          revenue_streams: revenueQueries,
          channels: channelsQueries,
          customer_relationships: relationshipsQueries,
          key_resources: resourcesQueries,
          key_activities: activitiesQueries,
          key_partnerships: partnersQueries,
          cost_structure: costQueries
        };
      }
      async generateBlockQueries(blockType, input) {
        const blockPrompts = {
          customer_segments: {
            focus: "Customer Segments - WHO are the target customers",
            examples: [
              "Market size and demographics for [target market] [industry]",
              "[Industry] customer pain points and needs 2025",
              "Target audience behavior patterns [market/industry]"
            ],
            guidance: `
Generate 5-6 queries to identify:
- WHO the target customers are (demographics, firmographics)
- What PROBLEMS they face (pain points, unmet needs)
- How they currently BEHAVE (buying patterns, decision criteria)
- Market SEGMENTS and their characteristics

Balance:
- 2 baseline queries: General market and customer research
- 2 validating queries: Evidence supporting target customer assumptions in input
- 2 challenging queries: Alternative customer segments or contradictory market data`
          },
          value_propositions: {
            focus: "Value Propositions - WHAT value solves customer problems",
            examples: [
              "[Product/service type] benefits and differentiation [industry]",
              "Successful [product category] features and value drivers",
              "[Industry] customer priorities and valued outcomes"
            ],
            guidance: `
Generate 5-6 queries to understand:
- WHAT value customers seek (desired outcomes, benefits)
- Which FEATURES matter most (must-haves vs nice-to-haves)
- How competitors DIFFERENTIATE (unique value props in market)
- What truly DRIVES purchase decisions

Balance:
- 2 baseline queries: General value proposition research for the industry
- 2 validating queries: Evidence supporting claimed differentiation/value
- 2 challenging queries: Counter-evidence showing different value drivers or failed differentiations`
          },
          revenue_streams: {
            focus: "Revenue Streams - HOW the business makes money",
            examples: [
              "[Industry] pricing models and revenue strategies 2025",
              "Successful monetization approaches [product/service category]",
              "[Market] customer willingness to pay and pricing sensitivity"
            ],
            guidance: `
Generate 5-6 queries to discover:
- HOW customers prefer to pay (pricing models, payment terms)
- WHAT they're willing to pay (price points, pricing sensitivity)
- Which MONETIZATION models work (subscription, usage-based, one-time, freemium)
- Revenue BENCHMARKS in the industry

Balance:
- 2 baseline queries: General pricing and monetization research
- 2 validating queries: Evidence supporting proposed pricing/revenue model
- 2 challenging queries: Alternative monetization approaches or pricing sensitivity data`
          },
          channels: {
            focus: "Channels - HOW the company reaches and delivers value to customer segments",
            examples: [
              "Best distribution channels [industry] 2025",
              "[Market] online vs offline sales effectiveness",
              "Successful customer acquisition channels [business type]"
            ],
            guidance: `
Generate 5-6 queries to understand:
- HOW to reach customers (distribution channels, sales channels)
- Which channels are most EFFECTIVE (online/offline mix, channel performance)
- What WORKS in the industry (successful channel strategies)
- Customer PREFERENCES for discovery and purchase

Balance:
- 2 baseline queries: General channel and distribution research
- 2 validating queries: Evidence supporting proposed channel strategy
- 2 challenging queries: Alternative channels or channel effectiveness data`
          },
          customer_relationships: {
            focus: "Customer Relationships - TYPE of relationships established with customer segments",
            examples: [
              "Customer retention strategies [industry] 2025",
              "B2B vs B2C support models and engagement",
              "[Industry] community building and self-service trends"
            ],
            guidance: `
Generate 5-6 queries to discover:
- WHAT type of relationships customers expect (personal, automated, community)
- HOW to engage and retain (support levels, engagement models)
- Which MODELS work (self-service, dedicated support, community-driven)
- Retention and loyalty STRATEGIES in the industry

Balance:
- 2 baseline queries: General relationship and engagement research
- 2 validating queries: Evidence supporting proposed relationship strategy
- 2 challenging queries: Alternative engagement models or retention challenges`
          },
          key_resources: {
            focus: "Key Resources - CRITICAL assets required to make the business model work",
            examples: [
              "Critical resources [industry] startups need",
              "Technology infrastructure requirements [business type]",
              "[Industry] talent and IP requirements 2025"
            ],
            guidance: `
Generate 5-6 queries to identify:
- WHAT assets are essential (talent, technology, IP, capital)
- Which resources are CRITICAL vs nice-to-have
- Industry-specific REQUIREMENTS (infrastructure, expertise)
- Resource BENCHMARKS and standards

Balance:
- 2 baseline queries: General resource requirements research
- 2 validating queries: Evidence supporting proposed resource needs
- 2 challenging queries: Underestimated resources or resource alternatives`
          },
          key_activities: {
            focus: "Key Activities - MOST important actions required to operate successfully",
            examples: [
              "Essential activities [business type] operations",
              "Operational priorities [industry] companies 2025",
              "Core activities successful [product category] businesses"
            ],
            guidance: `
Generate 5-6 queries to understand:
- WHAT activities are must-do for success
- Which operations are CRITICAL vs supporting
- What successful companies PRIORITIZE
- Industry-specific operational REQUIREMENTS

Balance:
- 2 baseline queries: General operational activities research
- 2 validating queries: Evidence supporting proposed key activities
- 2 challenging queries: Overlooked activities or different operational priorities`
          },
          key_partnerships: {
            focus: "Key Partners - NETWORK of suppliers and partners",
            examples: [
              "Strategic partnerships [industry] ecosystem",
              "Supplier requirements [business type] 2025",
              "[Industry] partnership models and collaboration"
            ],
            guidance: `
Generate 5-6 queries to discover:
- WHO are critical partners (suppliers, strategic allies, ecosystem players)
- WHAT partnerships are essential vs optional
- How partnerships WORK in the industry
- Partnership MODELS and collaboration patterns

Balance:
- 2 baseline queries: General partnership and supplier research
- 2 validating queries: Evidence supporting proposed partnerships
- 2 challenging queries: Alternative partner strategies or partnership risks`
          },
          cost_structure: {
            focus: "Cost Structure - ALL costs incurred to operate the business model",
            examples: [
              "Cost structure [industry] businesses 2025",
              "Operating costs [business type] breakdown",
              "[Industry] fixed vs variable costs and drivers"
            ],
            guidance: `
Generate 5-6 queries to understand:
- WHAT are the major cost drivers (fixed vs variable)
- HOW costs break down in the industry (benchmarks, ratios)
- Which costs are CRITICAL and unavoidable
- Cost OPTIMIZATION opportunities and risks

Balance:
- 2 baseline queries: General cost structure research
- 2 validating queries: Evidence supporting proposed cost assumptions
- 2 challenging queries: Hidden costs or different cost structures`
          }
        };
        const blockConfig = blockPrompts[blockType];
        const response = await aiClients.callWithFallback({
          systemPrompt: `You are a Business Model Canvas research specialist generating search queries for the "${blockConfig.focus}" block.

CRITICAL RULES:
1. Avoid confirmation bias - Generate queries that BOTH validate AND challenge assumptions
2. PRESERVE CONTEXT - Keep specific entities, numbers, timelines, and details from the user's claim
3. DO NOT abstract or generalize - If user mentions "Asana for 25 employees in 2-4 weeks", query should include "Asana", "25 employees", "2-4 weeks"`,
          userMessage: `BUSINESS CONTEXT:
${input.substring(0, 1500)}

RESEARCH FOCUS: ${blockConfig.focus}

${blockConfig.guidance}

Example queries for this block:
${blockConfig.examples.map((ex, i) => `${i + 1}. ${ex}`).join("\n")}

Each query should:
- Be specific and actionable for web search
- Include current year (2025) where relevant for recent data
- Be concise (5-10 words)
- Focus on the specific block: ${blockConfig.focus}

Return ONLY valid JSON with this structure (no markdown, no explanation):

{
  "queries": [
    {
      "query": "specific search query text",
      "purpose": "what this query aims to discover",
      "type": "baseline|validating|challenging"
    }
  ]
}

Generate 5-6 queries following the baseline/validating/challenging balance specified above.`,
          maxTokens: 2e3
        });
        const textContent = response.content;
        const parsed = parseAIJson(textContent, `BMC ${blockType} query generation`);
        const queries = parsed.queries.map((q) => ({
          ...q,
          blockType
        }));
        return queries;
      }
      async generateQueriesForBlock(blockType, input) {
        return this.generateBlockQueries(blockType, input);
      }
    };
  }
});

// server/strategic-consultant-legacy/source-validator.ts
import crypto3 from "crypto";
var API_BASE, SourceValidator;
var init_source_validator = __esm({
  "server/strategic-consultant-legacy/source-validator.ts"() {
    "use strict";
    API_BASE = process.env.API_BASE_URL || "http://localhost:5000";
    SourceValidator = class {
      cache;
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
      }
      async validateFindings(findings, sources) {
        const claims = this.extractClaims(findings);
        const validationPromises = claims.map(async (claim) => {
          const cacheKey = this.generateFingerprint(claim.text);
          if (this.cache.has(cacheKey)) {
            return this.cache.get(cacheKey);
          }
          const result = await this.validate(claim, sources);
          this.cache.set(cacheKey, result);
          return result;
        });
        return Promise.all(validationPromises);
      }
      extractClaims(findings) {
        const claims = [];
        for (const finding of findings) {
          const text2 = finding.fact;
          if (this.isValidatableClaim(text2)) {
            claims.push({
              text: text2,
              sources: [finding.citation],
              domain: this.detectDomain(text2)
            });
          }
        }
        return claims;
      }
      isValidatableClaim(text2) {
        const patterns = {
          quantitative: /\d+%|\d+\s*(million|billion|thousand)|\$\d+|(\d+)-(\d+)%/i,
          marketSizing: /market|revenue|growth|size|worth|valued at/i,
          competitive: /competitor|market share|dominant|leader|position/i,
          strategic: /should|recommend|must|critical|essential|key to success/i
        };
        return Object.values(patterns).some((pattern) => pattern.test(text2));
      }
      detectDomain(text2) {
        if (/\b(AI|machine learning|ML|artificial intelligence|GPT|LLM)\b/i.test(text2)) {
          return "AI";
        }
        if (/\b(market|revenue|sales|growth rate)\b/i.test(text2)) {
          return "market data";
        }
        if (/\b(regulation|compliance|law|legal|policy)\b/i.test(text2)) {
          return "regulation";
        }
        if (/\b(technology|software|platform|cloud|SaaS)\b/i.test(text2)) {
          return "technology";
        }
        return "default";
      }
      async validate(claim, allSources) {
        const [sourceCount, recency, counterEvidence] = await Promise.all([
          this.checkSourceCount(claim, allSources),
          this.checkRecency(claim, allSources),
          this.findCounterEvidence(claim)
        ]);
        const strength = this.calculateStrength(sourceCount, recency, counterEvidence);
        const details = this.buildDetails(sourceCount, recency, counterEvidence);
        return {
          claim: claim.text,
          strength,
          sourceCount,
          recencyMonths: recency.months,
          hasCounterEvidence: counterEvidence.found,
          contradicts: counterEvidence.contradicts,
          details
        };
      }
      async checkSourceCount(claim, allSources) {
        const claimSources = new Set(claim.sources);
        for (const source of allSources) {
          const sourceText = `${source.title} ${source.url}`.toLowerCase();
          const claimKeywords = claim.text.toLowerCase().split(/\s+/).filter((w) => w.length > 4);
          const matchCount = claimKeywords.filter((kw) => sourceText.includes(kw)).length;
          if (matchCount >= 3) {
            claimSources.add(source.url);
          }
        }
        return claimSources.size;
      }
      async checkRecency(claim, allSources) {
        const recencyThresholds = {
          "AI": 6,
          "technology": 12,
          "market data": 18,
          "regulation": 12,
          "default": 24
        };
        const threshold = recencyThresholds[claim.domain] || recencyThresholds["default"];
        let mostRecentDate = null;
        for (const source of allSources) {
          if (claim.sources.some((citedUrl) => source.url.includes(citedUrl) || citedUrl.includes(source.url))) {
            if (source.publication_date) {
              const pubDate = new Date(source.publication_date);
              if (!isNaN(pubDate.getTime())) {
                if (!mostRecentDate || pubDate > mostRecentDate) {
                  mostRecentDate = pubDate;
                }
              }
            }
          }
        }
        if (mostRecentDate) {
          const now = /* @__PURE__ */ new Date();
          const monthsSince2 = Math.floor((now.getTime() - mostRecentDate.getTime()) / (1e3 * 60 * 60 * 24 * 30));
          return {
            months: monthsSince2,
            threshold,
            isRecent: monthsSince2 <= threshold
          };
        }
        const yearMatch = claim.text.match(/\b(202[0-5]|201[0-9])\b/);
        if (!yearMatch) {
          return {
            months: 999,
            threshold,
            isRecent: false
          };
        }
        const year = parseInt(yearMatch[0]);
        const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        const monthsSince = (currentYear - year) * 12;
        return {
          months: monthsSince,
          threshold,
          isRecent: monthsSince <= threshold
        };
      }
      async findCounterEvidence(claim) {
        try {
          const query = this.buildCounterQuery(claim.text);
          const response = await fetch(`${API_BASE}/api/web-search`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ query })
          });
          if (!response.ok) {
            return { found: false, contradicts: false, summary: "No counter-evidence search performed" };
          }
          const data = await response.json();
          const results = data.organic || [];
          if (results.length === 0) {
            return { found: false, contradicts: false, summary: "No counter-evidence found" };
          }
          const contradictory = results.some(
            (r) => /\b(however|but|contrary|actually|incorrect|debunked|myth)\b/i.test(r.snippet || "")
          );
          return {
            found: true,
            contradicts: contradictory,
            summary: results.slice(0, 2).map((r) => r.title).join("; ")
          };
        } catch (error) {
          console.error("Counter-evidence search failed:", error);
          return { found: false, contradicts: false, summary: "Search error" };
        }
      }
      buildCounterQuery(claimText) {
        if (/\b(should|recommend|must|critical)\b/i.test(claimText)) {
          const action = claimText.match(/\b(adopt|implement|build|use|deploy)\s+(\w+)/i);
          if (action && action[2]) {
            return `risks of ${action[2]} alternatives criticism`;
          }
          return `${claimText.substring(0, 50)} risks alternatives`;
        }
        return `${claimText.substring(0, 60)} criticism rebuttal contrary evidence`;
      }
      calculateStrength(sourceCount, recency, counterEvidence) {
        let score = 0;
        if (sourceCount >= 3) score += 40;
        else if (sourceCount === 2) score += 20;
        if (recency.isRecent) score += 30;
        else if (recency.months <= recency.threshold * 2) score += 15;
        if (counterEvidence.contradicts) score -= 30;
        if (score >= 50) return "STRONG";
        if (score >= 25) return "MODERATE";
        return "WEAK";
      }
      buildDetails(sourceCount, recency, counterEvidence) {
        const parts = [];
        parts.push(`Based on ${sourceCount} source${sourceCount !== 1 ? "s" : ""}`);
        if (recency.months < 999) {
          const years = Math.floor(recency.months / 12);
          if (years > 0) {
            parts.push(`published ~${years} year${years !== 1 ? "s" : ""} ago`);
          } else {
            parts.push("recent data");
          }
        } else {
          parts.push("publication date unclear");
        }
        if (counterEvidence.found) {
          if (counterEvidence.contradicts) {
            parts.push("\u26A0\uFE0F contradictory evidence found");
          } else {
            parts.push("counter-evidence reviewed");
          }
        }
        return parts.join(", ");
      }
      generateFingerprint(text2) {
        const normalized = text2.toLowerCase().replace(/[^\w\s]/g, "").replace(/\s+/g, " ").trim();
        return crypto3.createHash("md5").update(normalized).digest("hex").substring(0, 16);
      }
    };
  }
});

// server/services/research-batch-service.ts
import { eq as eq3 } from "drizzle-orm";
import { promises as fs2 } from "fs";
import { join } from "path";
var ResearchBatchService, researchBatchService;
var init_research_batch_service = __esm({
  "server/services/research-batch-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    ResearchBatchService = class {
      STORAGE_ROOT = join(process.cwd(), "storage", "research");
      /**
       * Capture raw research batch to filesystem and database
       */
      async captureRawBatch(params) {
        const { sessionId, understandingId, journeyType, query, rawPayload } = params;
        const timestamp2 = Date.now();
        const sessionDir = join(this.STORAGE_ROOT, sessionId);
        await fs2.mkdir(sessionDir, { recursive: true });
        const filename = `${timestamp2}_${this.sanitizeFilename(query)}.json`;
        const rawDataPath = join(sessionDir, filename);
        const jsonContent = JSON.stringify(rawPayload, null, 2);
        await fs2.writeFile(rawDataPath, jsonContent, "utf8");
        const dataSizeKb = Math.ceil(Buffer.byteLength(jsonContent, "utf8") / 1024);
        const [batch] = await db.insert(researchBatches).values({
          sessionId,
          understandingId: understandingId || null,
          journeyType: journeyType || null,
          query,
          rawDataPath,
          sourcesCount: rawPayload.metadata?.sourcesCount || 0,
          dataSizeKb,
          status: "captured"
        }).returning();
        console.log(`[ResearchBatch] Captured batch ${batch.id} - Query: "${query.substring(0, 50)}..." (${dataSizeKb} KB, ${batch.sourcesCount} sources)`);
        return batch;
      }
      /**
       * Load raw research payload from filesystem
       */
      async loadRawBatch(batchId) {
        const [batch] = await db.select().from(researchBatches).where(eq3(researchBatches.id, batchId)).limit(1);
        if (!batch) {
          console.warn(`[ResearchBatch] Batch ${batchId} not found`);
          return null;
        }
        try {
          const content = await fs2.readFile(batch.rawDataPath, "utf8");
          return JSON.parse(content);
        } catch (error) {
          console.error(`[ResearchBatch] Failed to load batch ${batchId}:`, error);
          return null;
        }
      }
      /**
       * Mark batch as enriched
       */
      async markEnriched(batchId) {
        await db.update(researchBatches).set({
          status: "enriched",
          enrichedAt: /* @__PURE__ */ new Date()
        }).where(eq3(researchBatches.id, batchId));
        console.log(`[ResearchBatch] Marked batch ${batchId} as enriched`);
      }
      /**
       * Mark batch as failed
       */
      async markFailed(batchId, errorMessage) {
        await db.update(researchBatches).set({
          status: "failed",
          errorMessage
        }).where(eq3(researchBatches.id, batchId));
        console.error(`[ResearchBatch] Marked batch ${batchId} as failed: ${errorMessage}`);
      }
      /**
       * Get batch by ID
       */
      async getBatch(batchId) {
        const [batch] = await db.select().from(researchBatches).where(eq3(researchBatches.id, batchId)).limit(1);
        return batch || null;
      }
      /**
       * Get all batches for a session
       */
      async getBatchesForSession(sessionId) {
        return db.select().from(researchBatches).where(eq3(researchBatches.sessionId, sessionId)).orderBy(researchBatches.requestedAt);
      }
      /**
       * Sanitize filename for safe filesystem storage
       */
      sanitizeFilename(text2) {
        return text2.toLowerCase().replace(/[^a-z0-9]+/g, "_").substring(0, 50);
      }
    };
    researchBatchService = new ResearchBatchService();
  }
});

// server/services/research-capture-wrapper.ts
var ResearchCaptureWrapper, researchCaptureWrapper;
var init_research_capture_wrapper = __esm({
  "server/services/research-capture-wrapper.ts"() {
    "use strict";
    init_research_batch_service();
    ResearchCaptureWrapper = class {
      /**
       * Wrap a web search call with raw capture
       */
      async captureWebSearch(query, context, searchFn) {
        const startTime = Date.now();
        try {
          const result = await searchFn();
          const responseTimeMs = Date.now() - startTime;
          const sourcesCount = result.organic?.length || result.results?.length || 0;
          const rawPayload = {
            query,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            response: result,
            metadata: {
              sourcesCount,
              responseTimeMs
            }
          };
          const batch = await researchBatchService.captureRawBatch({
            ...context,
            query,
            rawPayload
          });
          console.log(`[Capture] Batch ${batch.id}: "${query.substring(0, 40)}..." \u2192 ${sourcesCount} sources (${responseTimeMs}ms)`);
          return {
            result,
            batchId: batch.id
          };
        } catch (error) {
          const rawPayload = {
            query,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            response: {
              error: error instanceof Error ? error.message : String(error),
              stack: error instanceof Error ? error.stack : void 0
            }
          };
          try {
            const batch = await researchBatchService.captureRawBatch({
              ...context,
              query,
              rawPayload
            });
            await researchBatchService.markFailed(batch.id, `Search failed: ${error instanceof Error ? error.message : String(error)}`);
            console.error(`[Capture] Batch ${batch.id} failed:`, error);
            return {
              result: { organic: [] },
              batchId: batch.id
            };
          } catch (captureError) {
            console.error(`[Capture] Failed to capture error batch:`, captureError);
            throw error;
          }
        }
      }
      /**
       * Wrap content fetch with raw capture
       */
      async captureContentFetch(url, context, fetchFn) {
        const startTime = Date.now();
        try {
          const result = await fetchFn();
          const responseTimeMs = Date.now() - startTime;
          const rawPayload = {
            query: `[FETCH] ${url}`,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            response: result,
            metadata: {
              sourcesCount: 1,
              responseTimeMs
            }
          };
          const batch = await researchBatchService.captureRawBatch({
            ...context,
            query: `Content: ${url}`,
            rawPayload
          });
          console.log(`[Capture] Batch ${batch.id}: Fetched ${url.substring(0, 50)}... (${responseTimeMs}ms)`);
          return {
            result,
            batchId: batch.id
          };
        } catch (error) {
          const rawPayload = {
            query: `[FETCH] ${url}`,
            timestamp: (/* @__PURE__ */ new Date()).toISOString(),
            response: {
              error: error instanceof Error ? error.message : String(error)
            }
          };
          try {
            const batch = await researchBatchService.captureRawBatch({
              ...context,
              query: `Content: ${url}`,
              rawPayload
            });
            await researchBatchService.markFailed(batch.id, `Fetch failed: ${error instanceof Error ? error.message : String(error)}`);
            console.error(`[Capture] Batch ${batch.id} fetch failed:`, error);
            return {
              result: { content: "" },
              batchId: batch.id
            };
          } catch (captureError) {
            console.error(`[Capture] Failed to capture error batch:`, captureError);
            throw error;
          }
        }
      }
    };
    researchCaptureWrapper = new ResearchCaptureWrapper();
  }
});

// server/strategic-consultant-legacy/market-researcher.ts
import pLimit from "p-limit";
var API_BASE2, searchLimit, fetchLimit, MarketResearcher;
var init_market_researcher = __esm({
  "server/strategic-consultant-legacy/market-researcher.ts"() {
    "use strict";
    init_source_validator();
    init_ai_clients();
    init_parse_ai_json();
    init_research_capture_wrapper();
    init_whys_path();
    API_BASE2 = process.env.API_BASE_URL || "http://localhost:5000";
    searchLimit = pLimit(3);
    fetchLimit = pLimit(3);
    MarketResearcher = class {
      validator;
      constructor() {
        this.validator = new SourceValidator();
      }
      /**
       * Convert sources and findings to normalized references for provenance tracking
       */
      convertToReferences(sources, findings, category) {
        const references3 = [];
        const topics = /* @__PURE__ */ new Set();
        topics.add(category);
        topics.add("market research");
        for (const source of sources) {
          const confidenceMap = {
            "high": 0.85,
            "medium": 0.65,
            "low": 0.45
          };
          const relatedFindings = findings.filter((f) => f.citation === source.url);
          const avgConfidence = relatedFindings.length > 0 ? relatedFindings.reduce((sum, f) => sum + (confidenceMap[f.confidence] || 0.5), 0) / relatedFindings.length : source.relevance_score || 0.5;
          relatedFindings.forEach((f) => {
            const keywords = f.fact.toLowerCase();
            if (keywords.includes("market")) topics.add("market analysis");
            if (keywords.includes("competitive")) topics.add("competitive landscape");
            if (keywords.includes("regulatory")) topics.add("regulatory");
            if (keywords.includes("customer") || keywords.includes("buyer")) topics.add("customer behavior");
          });
          references3.push({
            title: source.title,
            url: source.url,
            sourceType: "article",
            description: relatedFindings.length > 0 ? relatedFindings[0].fact.substring(0, 200) : void 0,
            topics: Array.from(topics),
            confidence: Math.min(Math.max(avgConfidence, 0), 1),
            origin: "web_search"
          });
        }
        return references3;
      }
      async conductResearch(sessionId, rootCause, input, whysPath, captureContext) {
        const whysText = whysPathToText(whysPath);
        const queries = await this.generateResearchQueries(rootCause, input, whysText);
        const searchResults = await this.performWebSearch(queries, captureContext);
        const topSources = this.selectTopSources(searchResults);
        const sourceContents = await this.fetchSourceContent(topSources.slice(0, 3), captureContext);
        const findings = await this.synthesizeFindings(
          rootCause,
          input,
          whysText,
          searchResults,
          topSources,
          sourceContents
        );
        const allFindings = [
          ...findings.market_dynamics,
          ...findings.competitive_landscape,
          ...findings.language_preferences,
          ...findings.buyer_behavior,
          ...findings.regulatory_factors
        ];
        const validation = await this.validator.validateFindings(allFindings, findings.sources);
        return {
          ...findings,
          validation
        };
      }
      async generateResearchQueries(rootCause, input, whysPath) {
        const mentionsLanguageDiff = /arabic|language|multilingual|localization|translation/i.test(input);
        const mentionsCulturalDiff = /cultural|culture|islamic|traditional|local customs|regional preferences/i.test(input);
        const systemPrompt = `You are a critical market research specialist. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `Create UNBIASED search queries for strategic analysis.

CRITICAL: Avoid confirmation bias. For ANY claim or assumption in the input, generate queries that BOTH validate AND challenge it.

ROOT CAUSE IDENTIFIED:
${rootCause}

ORIGINAL INPUT:
${input.substring(0, 1500)}

ANALYSIS PATH:
${whysPath.map((w, i) => `${i + 1}. ${w}`).join("\n")}

Generate 6-8 targeted research queries following this structure:

1. BASELINE QUERIES (2-3 queries): General market/industry context
2. VALIDATING QUERIES (2 queries): Search for evidence that SUPPORTS any claims in the input
3. CHALLENGING QUERIES (2-3 queries): Search for evidence that CONTRADICTS or questions the input assumptions

For any differentiation claim (e.g., "Arabic language differentiation"):
- Validating query: "Arabic software demand UAE enterprises"
- Challenging query: "English vs Arabic UAE business language statistics"
- Alternative challenge: "successful English-only software UAE market"

Each query should:
- Be specific and actionable for web search
- Include current year (2025) where relevant for recent data
- Be concise (5-10 words)

Return ONLY valid JSON with this structure (no markdown, no explanation):

{
  "queries": [
    {
      "query": "specific search query text",
      "purpose": "what this query aims to discover",
      "type": "baseline|validating|challenging"
    }
  ]
}

Example for "Arabic language differentiates our enterprise software in UAE":
- {"query": "UAE enterprise software market 2025", "purpose": "market size and trends", "type": "baseline"}
- {"query": "Arabic enterprise software UAE demand", "purpose": "validate Arabic demand", "type": "validating"}
- {"query": "English vs Arabic UAE business language statistics", "purpose": "challenge language assumption", "type": "challenging"}
- {"query": "successful English-only enterprise software UAE", "purpose": "test if Arabic is necessary", "type": "challenging"}`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 2e3
        }, "anthropic");
        const textContent = response.content;
        const parsed = parseAIJson(textContent, "market-researcher query generation");
        const queries = parsed.queries;
        if (mentionsLanguageDiff) {
          const marketMatch = input.match(/\b(UAE|Saudi|Qatar|Kuwait|Bahrain|MENA|Middle East|GCC)\b/i);
          const market = marketMatch ? marketMatch[0] : "UAE";
          queries.push({
            query: `English vs Arabic ${market} business language statistics`,
            purpose: "Challenge language differentiation assumption with data",
            type: "challenging"
          });
          queries.push({
            query: `successful English-only software ${market} market`,
            purpose: "Test if language localization is necessary for success",
            type: "challenging"
          });
        }
        if (mentionsCulturalDiff) {
          const marketMatch = input.match(/\b(UAE|Saudi|Qatar|Kuwait|Bahrain|MENA|Middle East|GCC)\b/i);
          const market = marketMatch ? marketMatch[0] : "UAE";
          queries.push({
            query: `${market} enterprise software buyer preferences data`,
            purpose: "Get actual buyer behavior data vs cultural assumptions",
            type: "challenging"
          });
          queries.push({
            query: `multinational company software standards ${market}`,
            purpose: "Test if global standards override local cultural preferences",
            type: "challenging"
          });
        }
        return queries;
      }
      async performSingleWebSearch(query) {
        try {
          const response = await fetch(`${API_BASE2}/api/web-search`, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({ query: query.query })
          });
          if (!response.ok) {
            console.error(`Search failed for query "${query.query}": ${response.status}`);
            return { query: query.query, results: [] };
          }
          const data = await response.json();
          const results = (data.organic || []).map((result) => ({
            url: result.link,
            title: result.title,
            snippet: result.snippet || "",
            relevance: result.position ? 1 / result.position : 0.5
          }));
          return { query: query.query, results };
        } catch (error) {
          console.error(`Error searching for "${query.query}":`, error);
          return { query: query.query, results: [] };
        }
      }
      async performWebSearch(queries, captureContext) {
        console.log("[MarketResearcher] Starting batched web search with", queries.length, "queries (limit: 3 concurrent)");
        const searchPromises = queries.map((queryObj) => searchLimit(async () => {
          const searchFn = async () => {
            const response = await fetch(`${API_BASE2}/api/web-search`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ query: queryObj.query })
            });
            if (!response.ok) {
              console.error(`Search failed for query "${queryObj.query}": ${response.status}`);
              return { organic: [] };
            }
            return await response.json();
          };
          if (captureContext) {
            try {
              const { result: data } = await researchCaptureWrapper.captureWebSearch(
                queryObj.query,
                captureContext,
                searchFn
              );
              const results = (data.organic || []).map((result) => ({
                url: result.link,
                title: result.title,
                snippet: result.snippet || "",
                relevance: result.position ? 1 / result.position : 0.5
              }));
              return { query: queryObj.query, results };
            } catch (error) {
              console.error(`Error searching for "${queryObj.query}":`, error);
              return { query: queryObj.query, results: [] };
            }
          } else {
            try {
              const data = await searchFn();
              const results = (data.organic || []).map((result) => ({
                url: result.link,
                title: result.title,
                snippet: result.snippet || "",
                relevance: result.position ? 1 / result.position : 0.5
              }));
              return { query: queryObj.query, results };
            } catch (error) {
              console.error(`Error searching for "${queryObj.query}":`, error);
              return { query: queryObj.query, results: [] };
            }
          }
        }));
        return Promise.all(searchPromises);
      }
      async fetchSourceContent(sources, captureContext) {
        console.log("[MarketResearcher] Starting batched content fetch for", sources.length, "sources (limit: 3 concurrent)");
        const contentMap = /* @__PURE__ */ new Map();
        const fetchPromises = sources.map((source) => fetchLimit(async () => {
          const fetchFn = async () => {
            const response = await fetch(`${API_BASE2}/api/web-fetch`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ url: source.url })
            });
            if (!response.ok) {
              console.error(`Failed to fetch ${source.url}: ${response.status}`);
              return { content: "" };
            }
            return await response.json();
          };
          try {
            let data;
            if (captureContext) {
              const captured = await researchCaptureWrapper.captureContentFetch(
                source.url,
                captureContext,
                fetchFn
              );
              data = captured.result;
            } else {
              data = await fetchFn();
            }
            if (data.metadata?.publicationDate) {
              source.publication_date = data.metadata.publicationDate;
            }
            const textContent = (data.content || "").replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, "").replace(/<style\b[^<]*(?:(?!<\/style>)<[^<]*)*<\/style>/gi, "").replace(/<[^>]+>/g, " ").replace(/\s+/g, " ").trim().substring(0, 5e3);
            contentMap.set(source.url, textContent);
          } catch (error) {
            console.error(`Error fetching content from ${source.url}:`, error);
          }
        }));
        await Promise.all(fetchPromises);
        return contentMap;
      }
      selectTopSourcesPublic(searchResults) {
        return this.selectTopSources(searchResults);
      }
      async fetchSourceContentPublic(sources) {
        return this.fetchSourceContent(sources);
      }
      async synthesizeFindingsPublic(rootCause, input, whysPath, searchResults, topSources, sourceContents) {
        return this.synthesizeFindings(rootCause, input, whysPath, searchResults, topSources, sourceContents);
      }
      async validateFindingsPublic(allFindings, sources) {
        return await this.validator.validateFindings(allFindings, sources);
      }
      selectTopSources(searchResults) {
        const allResults = [];
        for (const searchResult of searchResults) {
          if (searchResult.results && Array.isArray(searchResult.results)) {
            for (const result of searchResult.results) {
              allResults.push({
                url: result.url,
                title: result.title,
                relevance_score: result.relevance || 0.5
              });
            }
          }
        }
        allResults.sort((a, b) => b.relevance_score - a.relevance_score);
        const topSources = allResults.slice(0, 6);
        return topSources;
      }
      async synthesizeFindings(rootCause, input, whysPath, searchResults, topSources, sourceContents) {
        const whysText = whysPathToText(whysPath);
        const searchSummary = searchResults.map(
          (sr) => `Query: ${sr.query}
Results: ${sr.results?.map((r) => `- ${r.title}: ${r.snippet}`).join("\n") || "No results"}`
        ).join("\n\n");
        const fullContentSummary = Array.from(sourceContents.entries()).map(([url, content]) => `URL: ${url}
Content Excerpt: ${content.substring(0, 2e3)}...`).join("\n\n---\n\n");
        const systemPrompt = `You are an OBJECTIVE market research analyst. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `Synthesize findings for a business strategy.

CRITICAL INSTRUCTIONS - ANTI-CONFIRMATION BIAS:
1. Every statement MUST cite a specific research finding from the full article content below
2. DO NOT make assumptions or use general knowledge
3. PRIORITIZE contradictory findings over confirming evidence
4. If research contradicts input assumptions, HIGHLIGHT that contradiction clearly
5. Weight disconfirming evidence HIGHER than confirming evidence
6. Only include facts that are explicitly stated in the source content
7. If sources lack information on a category, return fewer findings for that category

ANTI-BIAS EXAMPLE:
If input claims "Arabic differentiation" but research shows "English dominates UAE business (95% of contracts)", 
you MUST include the English dominance finding and give it HIGH confidence.

ROOT CAUSE:
${rootCause}

ORIGINAL INPUT:
${input.substring(0, 1500)}

ANALYSIS PATH:
${whysText.map((w, i) => `${i + 1}. ${w}`).join("\n")}

SEARCH RESULTS SNIPPETS:
${searchSummary}

FULL ARTICLE CONTENT:
${fullContentSummary}

TOP SOURCES:
${topSources.map((s) => `- ${s.title} (${s.url}) - Relevance: ${s.relevance_score}`).join("\n")}

Based on the FULL ARTICLE CONTENT above, generate findings across 5 categories. Each finding must:
- fact: Quote or paraphrase a SPECIFIC statement from the full content. If it CONTRADICTS the input, state that clearly.
- citation: The exact source URL where this fact was found
- confidence: 'high' if from article content, 'medium' if from snippets, 'low' if uncertain

PRIORITIZATION RULE: If research contradicts any claim in the input, include those contradictory findings FIRST and with HIGHEST confidence.

Generate findings ONLY for information explicitly found in sources:
1. Market Dynamics (market size, growth, trends)
2. Competitive Landscape (key players, positioning, market share)
3. Language/Cultural Preferences (business language, localization needs - INCLUDE contradictions to input claims)
4. Buyer Behavior (decision patterns, preferences, pain points)
5. Regulatory/Compliance Factors (regulations, standards, requirements)

Return ONLY valid JSON (no markdown, no explanation):

{
  "market_dynamics": [
    {
      "fact": "Specific market insight from article content",
      "citation": "https://source-url-from-top-sources.com",
      "confidence": "high"
    }
  ],
  "competitive_landscape": [
    {
      "fact": "Specific competitive insight from article content",
      "citation": "https://source-url-from-top-sources.com",
      "confidence": "high"
    }
  ],
  "language_preferences": [
    {
      "fact": "Specific language/cultural insight from article content (include contradictions to input)",
      "citation": "https://source-url-from-top-sources.com",
      "confidence": "high"
    }
  ],
  "buyer_behavior": [
    {
      "fact": "Specific buyer behavior insight from article content",
      "citation": "https://source-url-from-top-sources.com",
      "confidence": "high"
    }
  ],
  "regulatory_factors": [
    {
      "fact": "Specific regulatory insight from article content",
      "citation": "https://source-url-from-top-sources.com",
      "confidence": "high"
    }
  ]
}`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 4e3
        }, "anthropic");
        const textContent = response.content;
        const synthesized = parseAIJson(textContent, "market-researcher synthesis");
        const allFindings = [
          ...synthesized.market_dynamics || [],
          ...synthesized.competitive_landscape || [],
          ...synthesized.language_preferences || [],
          ...synthesized.buyer_behavior || [],
          ...synthesized.regulatory_factors || []
        ];
        const references3 = this.convertToReferences(topSources, allFindings, "strategic research");
        return {
          market_dynamics: synthesized.market_dynamics || [],
          competitive_landscape: synthesized.competitive_landscape || [],
          language_preferences: synthesized.language_preferences || [],
          buyer_behavior: synthesized.buyer_behavior || [],
          regulatory_factors: synthesized.regulatory_factors || [],
          sources: topSources,
          references: references3
        };
      }
    };
  }
});

// server/strategic-consultant-legacy/assumption-extractor.ts
import { z as z5 } from "zod";
var assumptionSchema, AssumptionExtractor;
var init_assumption_extractor = __esm({
  "server/strategic-consultant-legacy/assumption-extractor.ts"() {
    "use strict";
    init_ai_clients();
    init_parse_ai_json();
    assumptionSchema = z5.object({
      assumptions: z5.array(z5.object({
        claim: z5.string(),
        category: z5.enum(["product", "market", "customer", "competitive", "operational"]),
        confidence: z5.enum(["explicit", "implicit"]),
        investmentAmount: z5.string().nullable().optional(),
        source: z5.string()
      }))
    });
    AssumptionExtractor = class {
      constructor() {
      }
      async extractAssumptions(userInput) {
        const systemPrompt = `You are an assumption extraction expert. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `Extract ALL strategic assumptions from the user's input - both explicit and implicit. BE THOROUGH - aim for 5-10 assumptions when evidence supports it, but extract only genuine, testable claims.

USER INPUT:
${userInput}

TYPES OF ASSUMPTIONS TO EXTRACT:

**Explicit Assumptions** (user directly states them):
- "We assume/believe X is critical/essential/important"
- "X is necessary for Y"
- "[Group] prefer/need/want X"
- Investment breakdowns that imply priorities (e.g., "$500K for Hindi localization" \u2192 Hindi is critical)
- "Key question: Should we do X?" (implies X is under consideration as important)
- Target metrics imply achievability (e.g., "100 enterprise clients in 18 months" assumes this is achievable)

**Implicit Assumptions** (implied by the context):
- Market entry strategies assume certain market conditions
- Investment amounts suggest expected ROI/priorities
- Questions reveal underlying beliefs about what works
- Quantitative targets assume feasibility
- Geographic/demographic focus assumes opportunity
- Competitive positioning assumes market dynamics
- Timing assumptions (e.g., "within 18 months" assumes speed is possible)

**Examples of What to Extract:**

Input: "Expanding to India with Hindi localization ($500K) to target 100 enterprise clients in 18 months. Local vendors preferred."

Extract:
1. "Hindi localization is critical for Indian market success" (product, explicit, $500K)
2. "100 enterprise clients is achievable within 18 months" (market, explicit)
3. "Indian enterprises prefer local vendors over international providers" (competitive, explicit)
4. "Enterprise segment represents the primary opportunity in India" (customer, implicit)
5. "Hindi language support drives purchase decisions" (customer, implicit)
6. "$500K investment in localization will generate sufficient ROI" (operational, implicit)

CATEGORIES:
- product: Features, functionality, localization, technical decisions
- market: Market dynamics, entry strategies, expansion assumptions, growth rates
- customer: Customer preferences, behavior, needs, decision criteria
- competitive: Competitive positioning, vendor preferences, differentiation
- operational: Business operations, processes, team structure, feasibility

CRITICAL RULES:
1. Extract UP TO 10 assumptions - prioritize quality over quantity (5-10 for typical inputs, fewer for brief inputs)
2. Extract the CORE CLAIM without hedging language
3. Include investment amounts if mentioned
4. Quote the exact source text where you found it
5. Only extract claims that can be validated with research - no speculation
6. Don't miss implicit quantitative and temporal assumptions

Return ONLY valid JSON (no markdown, no explanation):

{
  "assumptions": [
    {
      "claim": "Hindi localization is critical for enterprise adoption in India",
      "category": "product",
      "confidence": "explicit",
      "investmentAmount": "$500K",
      "source": "Expanding to India with Hindi localization ($500K)"
    },
    {
      "claim": "100 enterprise clients with 500+ employees is achievable within 18 months",
      "category": "market",
      "confidence": "explicit",
      "investmentAmount": null,
      "source": "target 100 enterprise clients in 18 months"
    }
  ]
}`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 2e3
        }, "anthropic");
        const parsed = parseAIJson(response.content, "assumption extractor");
        const validated = assumptionSchema.parse(parsed);
        return validated;
      }
    };
  }
});

// server/strategic-consultant-legacy/assumption-validator.ts
import { z as z6 } from "zod";
var querySchema, contradictionSchema, AssumptionValidator;
var init_assumption_validator = __esm({
  "server/strategic-consultant-legacy/assumption-validator.ts"() {
    "use strict";
    init_ai_clients();
    init_parse_ai_json();
    querySchema = z6.object({
      queries: z6.array(z6.object({
        assumption: z6.string(),
        query: z6.string(),
        purpose: z6.enum(["validate", "contradict"])
      }))
    });
    contradictionSchema = z6.object({
      contradictions: z6.array(z6.object({
        assumption: z6.string(),
        matchedAssumptionClaim: z6.string(),
        // EXACT quote from assumptions list
        contradictedBy: z6.array(z6.string()),
        validationStrength: z6.enum(["STRONG", "MODERATE", "WEAK"]),
        impact: z6.enum(["HIGH", "MEDIUM", "LOW"]),
        recommendation: z6.string()
      })),
      validations: z6.array(z6.object({
        assumption: z6.string(),
        matchedAssumptionClaim: z6.string(),
        // EXACT quote from assumptions list
        supportedBy: z6.array(z6.string()),
        validationStrength: z6.enum(["STRONG", "MODERATE", "WEAK"])
      })),
      insufficient: z6.array(z6.string())
    });
    AssumptionValidator = class {
      constructor() {
      }
      async generateAssumptionQueries(assumptions) {
        if (assumptions.length === 0) {
          return [];
        }
        const systemPrompt = `You are a research query generator. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `For each assumption, generate 2-3 targeted web search queries designed to validate OR contradict it.

ASSUMPTIONS TO RESEARCH:
${assumptions.map((a, i) => `${i + 1}. "${a.claim}" (${a.category})`).join("\n")}

QUERY GENERATION RULES:

**For each assumption, generate:**
1. ONE validating query - looks for evidence supporting the assumption
2. TWO contradicting queries - looks for evidence that challenges or disproves it

**Query Best Practices:**
- Be specific and include key terms from the assumption
- Include geographic/market context if relevant
- Add year/recency indicators for time-sensitive claims
- Focus on data, studies, statistics, preferences, behavior
- Avoid generic queries - target the EXACT claim

**Examples:**

Assumption: "Hindi localization is critical for enterprise adoption in India"
Validating: "Hindi language requirement enterprise software India adoption"
Contradicting: "English vs Hindi Indian enterprise software preferences 2024"
Contradicting: "Indian B2B SaaS language statistics English dominance"

Assumption: "Indian enterprises prefer local vendors over Western software"
Validating: "Indian companies prefer domestic software vendors statistics"
Contradicting: "Indian enterprise international SaaS adoption rates"
Contradicting: "Western software market share India B2B 2024"

Return ONLY valid JSON (no markdown, no explanation):

{
  "queries": [
    {
      "assumption": "Hindi localization is critical for enterprise adoption in India",
      "query": "English vs Hindi Indian enterprise software preferences 2024",
      "purpose": "contradict"
    }
  ]
}`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 2e3
        }, "anthropic");
        const parsed = parseAIJson(response.content, "assumption validator query generation");
        const validated = querySchema.parse(parsed);
        return validated.queries;
      }
      async detectContradictions(assumptions, researchFindings) {
        if (assumptions.length === 0) {
          return { contradictions: [], validations: [], insufficient: [] };
        }
        const systemPrompt = `You are a contradiction detection expert. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `Compare user assumptions to research findings and identify contradictions, validations, and data gaps.

USER ASSUMPTIONS:
${assumptions.map((a, i) => `${i + 1}. "${a.claim}" (${a.category}${a.investmentAmount ? `, Investment: ${a.investmentAmount}` : ""})`).join("\n")}

RESEARCH FINDINGS:
${researchFindings.join("\n")}

YOUR TASK:

For each assumption, determine if research:
1. **CONTRADICTS** it (research shows the opposite or challenges the assumption)
2. **VALIDATES** it (research supports the assumption)
3. **INSUFFICIENT** data (not enough research to determine)

**Contradiction Detection Rules:**
- Look for research that directly challenges the assumption
- Consider statistical evidence (e.g., "75% use English" contradicts "Hindi is critical")
- Consider market data that opposes the claim
- Flag vendor-funded studies as potentially biased

**Validation Strength:**
- STRONG: Multiple independent sources, recent data, clear statistics
- MODERATE: Some sources, partial data, older studies
- WEAK: Limited sources, anecdotal evidence

**Impact Assessment:**
- HIGH: Large investment amounts ($1M+), core strategy decisions
- MEDIUM: Moderate investments ($100K-$1M), tactical decisions
- LOW: Small investments (<$100K), minor decisions

**Recommendation Rules:**
- Be specific about what to do instead
- Reference the research findings
- Consider investment amounts in recommendations

**CRITICAL: Exact Assumption Matching**
- For "assumption" field: You may rephrase/summarize for clarity
- For "matchedAssumptionClaim" field: MUST be an EXACT copy-paste from the assumptions list above
- This ensures investment amounts transfer correctly

Return ONLY valid JSON (no markdown, no explanation):

{
  "contradictions": [
    {
      "assumption": "Hindi localization is critical for enterprise adoption in India",
      "matchedAssumptionClaim": "Hindi localization is critical for enterprise adoption in India",
      "contradictedBy": [
        "English is the dominant language for enterprise software in India (75% of B2B SaaS)",
        "Indian enterprise decision-makers expect English interfaces as standard"
      ],
      "validationStrength": "STRONG",
      "impact": "HIGH",
      "recommendation": "Reconsider the $1.5M Hindi investment. Research shows English dominates Indian enterprise software. Consider redirecting funds to English product optimization and Indian English localization (local currency, tax, integrations)."
    }
  ],
  "validations": [
    {
      "assumption": "Indian market has high growth potential",
      "matchedAssumptionClaim": "Indian market has high growth potential",
      "supportedBy": [
        "Indian enterprise software market growing at 15% CAGR",
        "Digital transformation accelerating in Indian enterprises"
      ],
      "validationStrength": "STRONG"
    }
  ],
  "insufficient": [
    "Assumption about X - not enough research data found"
  ]
}`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 3e3
        }, "anthropic");
        const parsed = parseAIJson(response.content, "assumption validator contradiction detection");
        const validated = contradictionSchema.parse(parsed);
        const result = {
          contradictions: validated.contradictions.map((c) => {
            const normalizedMatch = c.matchedAssumptionClaim?.trim();
            let original = assumptions.find((a) => a.claim.trim() === normalizedMatch);
            if (!original) {
              console.warn(`[AssumptionValidator] Exact match failed for "${c.matchedAssumptionClaim}", falling back to fuzzy matching`);
              original = this.findBestAssumptionMatch(c.assumption, assumptions);
              if (original) {
                console.log(`[AssumptionValidator] Fuzzy match found: "${original.claim}"`);
              } else {
                console.error(`[AssumptionValidator] No match found for contradiction: "${c.assumption}"`);
              }
            }
            return {
              ...c,
              assumptionCategory: original?.category || "unknown",
              investmentAmount: original?.investmentAmount
            };
          }),
          validations: validated.validations,
          insufficient: validated.insufficient
        };
        return result;
      }
      // Helper: Fuzzy match to handle LLM wording variations
      findBestAssumptionMatch(contradictionText, assumptions) {
        if (assumptions.length === 0) return void 0;
        const exactMatch = assumptions.find((a) => a.claim === contradictionText);
        if (exactMatch) return exactMatch;
        const normalize = (text2) => text2.toLowerCase().replace(/[^\w\s$]/g, " ").replace(/\s+/g, " ").trim();
        const extractEntities = (text2) => {
          const entities = /* @__PURE__ */ new Set();
          const moneyMatches = text2.match(/\$[\d.,]+[KMB]?/gi);
          if (moneyMatches) moneyMatches.forEach((m) => entities.add(m.toLowerCase()));
          const geoTerms = ["india", "indian", "china", "chinese", "usa", "american", "europe", "european"];
          geoTerms.forEach((term) => {
            if (text2.toLowerCase().includes(term)) entities.add(term);
          });
          const techTerms = ["hindi", "english", "localization", "enterprise", "sme", "saas", "crm"];
          techTerms.forEach((term) => {
            if (text2.toLowerCase().includes(term)) entities.add(term);
          });
          return entities;
        };
        const normalizedTarget = normalize(contradictionText);
        const targetEntities = extractEntities(contradictionText);
        let bestMatch;
        let highestScore = 0;
        for (const assumption of assumptions) {
          const normalizedClaim = normalize(assumption.claim);
          const claimEntities = extractEntities(assumption.claim);
          let score = 0;
          if (normalizedClaim === normalizedTarget) {
            score = 1;
          } else if (normalizedClaim.includes(normalizedTarget) || normalizedTarget.includes(normalizedClaim)) {
            score = 0.8;
          } else {
            const targetWords = normalizedTarget.split(" ").filter((w) => w.length > 2);
            const claimWords = normalizedClaim.split(" ").filter((w) => w.length > 2);
            const claimWordsSet = new Set(claimWords);
            const intersection = targetWords.filter((w) => claimWordsSet.has(w));
            const union = Array.from(/* @__PURE__ */ new Set([...targetWords, ...claimWords]));
            if (union.length > 0) {
              score = intersection.length / union.length;
            }
          }
          if (targetEntities.size > 0 && claimEntities.size > 0) {
            const targetEntitiesArr = Array.from(targetEntities);
            const entityIntersection = new Set(targetEntitiesArr.filter((e) => claimEntities.has(e)));
            const entityUnion = /* @__PURE__ */ new Set([...targetEntitiesArr, ...Array.from(claimEntities)]);
            if (entityUnion.size > 0) {
              const entityScore = entityIntersection.size / entityUnion.size;
              score = score * 0.6 + entityScore * 0.4;
            }
          }
          if (score > highestScore && score >= 0.25) {
            highestScore = score;
            bestMatch = assumption;
          }
        }
        return bestMatch;
      }
    };
  }
});

// server/utils/request-throttler.ts
var RequestThrottler;
var init_request_throttler = __esm({
  "server/utils/request-throttler.ts"() {
    "use strict";
    RequestThrottler = class {
      options;
      constructor(options) {
        this.options = {
          maxConcurrent: options?.maxConcurrent || 5,
          delayBetweenBatches: options?.delayBetweenBatches || 200,
          maxRetries: options?.maxRetries || 3,
          initialRetryDelay: options?.initialRetryDelay || 1e3
        };
      }
      delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      async executeWithRetry(fn, retryCount = 0) {
        try {
          return await fn();
        } catch (error) {
          const is429 = error?.status === 429 || error?.message?.includes("429") || error?.message?.includes("Too Many Requests");
          if (is429 && retryCount < this.options.maxRetries) {
            const delayMs = this.options.initialRetryDelay * Math.pow(2, retryCount);
            console.log(`Rate limit hit, retrying in ${delayMs}ms (attempt ${retryCount + 1}/${this.options.maxRetries})`);
            await this.delay(delayMs);
            return this.executeWithRetry(fn, retryCount + 1);
          }
          throw error;
        }
      }
      async throttleAll(tasks2, fallbackFactory) {
        const results = [];
        for (let i = 0; i < tasks2.length; i += this.options.maxConcurrent) {
          const batch = tasks2.slice(i, i + this.options.maxConcurrent);
          const batchStartIndex = i;
          const batchResults = await Promise.all(
            batch.map(async (task, batchIndex) => {
              try {
                return await this.executeWithRetry(task);
              } catch (error) {
                console.error("Task failed after retries:", error.message);
                if (fallbackFactory) {
                  const taskIndex = batchStartIndex + batchIndex;
                  return fallbackFactory(taskIndex);
                }
                throw error;
              }
            })
          );
          results.push(...batchResults);
          if (i + this.options.maxConcurrent < tasks2.length) {
            await this.delay(this.options.delayBetweenBatches);
          }
        }
        return results;
      }
    };
  }
});

// server/services/reference-service.ts
var reference_service_exports = {};
__export(reference_service_exports, {
  ReferenceService: () => ReferenceService,
  referenceService: () => referenceService
});
import { eq as eq4, and as and3, sql as sql3 } from "drizzle-orm";
var ReferenceService, referenceService;
var init_reference_service = __esm({
  "server/services/reference-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    ReferenceService = class {
      /**
       * Map analyzer sourceType to database enum values
       */
      mapSourceType(sourceType) {
        const mapping = {
          "article": "article",
          "report": "report",
          "document": "document",
          "dataset": "dataset",
          "manual_entry": "manual_entry",
          // Map analyzer types to closest database types
          "website": "article",
          "book": "report",
          "interview": "document",
          "internal_doc": "document",
          "other": "document"
        };
        return mapping[sourceType || "article"] || "article";
      }
      /**
       * Map analyzer origin to database enum values
       */
      mapOrigin(origin) {
        const mapping = {
          "web_search": "web_search",
          "manual_upload": "manual_upload",
          "document_extract": "document_extract",
          "manual_entry": "manual_entry",
          // Map analyzer types to closest database types
          "user_upload": "manual_upload",
          "llm_generation": "document_extract",
          // LLM-generated counts as extracted/synthesized
          "third_party_api": "web_search"
        };
        return mapping[origin || "web_search"] || "web_search";
      }
      /**
       * Normalize a raw reference into the standard format
       */
      normalizeReference(raw, userId, usage, options) {
        if (!options.understandingId && !options.sessionId && !options.programId) {
          throw new Error("Reference must be linked to at least one artifact (understanding, session, or program)");
        }
        return {
          understandingId: options.understandingId || null,
          sessionId: options.sessionId || null,
          programId: options.programId || null,
          userId,
          sourceType: this.mapSourceType(raw.sourceType),
          title: raw.title.trim(),
          url: raw.url?.trim() || null,
          description: raw.description?.trim() || null,
          topics: raw.topics || [],
          confidence: raw.confidence !== null && raw.confidence !== void 0 ? String(Math.min(Math.max(raw.confidence, 0), 1)) : null,
          extractedQuotes: raw.snippet ? [{
            snippet: raw.snippet,
            usedIn: usage.component,
            claim: usage.claim
          }] : [],
          usedInComponents: [usage.component],
          origin: this.mapOrigin(raw.origin),
          lastValidated: /* @__PURE__ */ new Date()
        };
      }
      /**
       * Deduplicate references by URL (preferred) or title
       * Returns unique references and a map of duplicates
       */
      async deduplicateReferences(refs) {
        const seen = /* @__PURE__ */ new Map();
        const duplicates = /* @__PURE__ */ new Map();
        for (const ref of refs) {
          const key = ref.url ? ref.url.toLowerCase() : ref.title.toLowerCase();
          if (seen.has(key)) {
            const existing = seen.get(key);
            const mergedTopics = Array.from(/* @__PURE__ */ new Set([...existing.topics || [], ...ref.topics || []]));
            const mergedQuotes = [
              ...existing.extractedQuotes || [],
              ...ref.extractedQuotes || []
            ];
            const mergedComponents = Array.from(/* @__PURE__ */ new Set([
              ...existing.usedInComponents || [],
              ...ref.usedInComponents || []
            ]));
            const existingConf = existing.confidence ? parseFloat(existing.confidence) : 0;
            const refConf = ref.confidence ? parseFloat(ref.confidence) : 0;
            const mergedConfidence = Math.max(existingConf, refConf);
            seen.set(key, {
              ...existing,
              topics: mergedTopics,
              extractedQuotes: mergedQuotes,
              usedInComponents: mergedComponents,
              confidence: mergedConfidence !== null && mergedConfidence !== void 0 ? String(mergedConfidence) : null
            });
            if (!duplicates.has(key)) {
              duplicates.set(key, []);
            }
            duplicates.get(key).push(ref);
          } else {
            seen.set(key, ref);
          }
        }
        return {
          unique: Array.from(seen.values()),
          duplicates
        };
      }
      /**
       * Persist references to database
       * Handles deduplication against existing references
       */
      async persistReferences(refs, options) {
        if (refs.length === 0) {
          return { created: [], updated: [], skipped: 0 };
        }
        const { unique: uniqueRefs } = await this.deduplicateReferences(refs);
        const created = [];
        const updated = [];
        let skipped = 0;
        for (const ref of uniqueRefs) {
          try {
            const existing = await this.findExisting(ref, options);
            if (existing) {
              const mergedComponents = Array.from(/* @__PURE__ */ new Set([
                ...existing.usedInComponents || [],
                ...ref.usedInComponents || []
              ]));
              const mergedQuotes = [
                ...existing.extractedQuotes || [],
                ...ref.extractedQuotes || []
              ];
              const mergedTopics = Array.from(/* @__PURE__ */ new Set([
                ...existing.topics || [],
                ...ref.topics || []
              ]));
              const existingConf = existing.confidence ? parseFloat(existing.confidence) : 0;
              const refConf = ref.confidence ? parseFloat(ref.confidence) : 0;
              const mergedConfidence = Math.max(existingConf, refConf);
              const [updatedRef] = await db.update(references).set({
                usedInComponents: mergedComponents,
                extractedQuotes: mergedQuotes,
                topics: mergedTopics,
                confidence: mergedConfidence !== null && mergedConfidence !== void 0 ? mergedConfidence.toString() : null,
                lastValidated: /* @__PURE__ */ new Date(),
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq4(references.id, existing.id)).returning();
              updated.push(updatedRef);
            } else {
              const [newRef] = await db.insert(references).values(ref).returning();
              created.push(newRef);
            }
          } catch (error) {
            console.error("Error persisting reference:", error);
            skipped++;
          }
        }
        if (options.understandingId && (created.length > 0 || updated.length > 0)) {
          await this.updateMetadataCache(options.understandingId);
        }
        return { created, updated, skipped };
      }
      /**
       * Find existing reference by URL or title
       */
      async findExisting(ref, options) {
        const conditions = [];
        if (ref.url) {
          conditions.push(eq4(references.url, ref.url));
        } else {
          conditions.push(eq4(references.title, ref.title));
        }
        if (options.understandingId) {
          conditions.push(eq4(references.understandingId, options.understandingId));
        }
        if (options.sessionId) {
          conditions.push(eq4(references.sessionId, options.sessionId));
        }
        if (options.programId) {
          conditions.push(eq4(references.programId, options.programId));
        }
        const results = await db.select().from(references).where(and3(...conditions)).limit(1);
        return results[0] || null;
      }
      /**
       * Link a reference to a specific component/claim
       */
      async linkToComponent(referenceId, component, claim, snippet) {
        const [existing] = await db.select().from(references).where(eq4(references.id, referenceId)).limit(1);
        if (!existing) {
          throw new Error(`Reference not found: ${referenceId}`);
        }
        const components = new Set(existing.usedInComponents || []);
        components.add(component);
        const quotes = existing.extractedQuotes || [];
        if (snippet || claim) {
          quotes.push({
            snippet: snippet || void 0,
            claim: claim || void 0,
            usedIn: component
          });
        }
        await db.update(references).set({
          usedInComponents: Array.from(components),
          extractedQuotes: quotes,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq4(references.id, referenceId));
      }
      /**
       * Update strategy metadata cache with reference count
       */
      async updateMetadataCache(understandingId) {
        const refCount = await db.select({ count: sql3`count(*)` }).from(references).where(eq4(references.understandingId, understandingId));
        const count2 = Number(refCount[0]?.count || 0);
        await db.update(strategicUnderstanding).set({
          strategyMetadata: sql3`
          jsonb_set(
            COALESCE(strategy_metadata, '{}'::jsonb),
            '{availableReferences}',
            ${count2}::text::jsonb,
            true
          )
        `,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq4(strategicUnderstanding.id, understandingId));
      }
      /**
       * Get all references for an understanding
       */
      async getReferencesForUnderstanding(understandingId) {
        return await db.select().from(references).where(eq4(references.understandingId, understandingId)).orderBy(sql3`created_at DESC`);
      }
      /**
       * Get all references for a session
       */
      async getReferencesForSession(sessionId) {
        return await db.select().from(references).where(eq4(references.sessionId, sessionId)).orderBy(sql3`created_at DESC`);
      }
      /**
       * Get all references for a program
       */
      async getReferencesForProgram(programId) {
        return await db.select().from(references).where(eq4(references.programId, programId)).orderBy(sql3`created_at DESC`);
      }
    };
    referenceService = new ReferenceService();
  }
});

// server/strategic-consultant-legacy/bmc-researcher.ts
var API_BASE3, BMCResearcher;
var init_bmc_researcher = __esm({
  "server/strategic-consultant-legacy/bmc-researcher.ts"() {
    "use strict";
    init_bmc_query_generator();
    init_market_researcher();
    init_assumption_extractor();
    init_assumption_validator();
    init_ai_clients();
    init_strategic_understanding_service();
    init_request_throttler();
    init_parse_ai_json();
    init_db_connection_manager();
    init_reference_service();
    API_BASE3 = process.env.API_BASE_URL || "http://localhost:5000";
    BMCResearcher = class {
      queryGenerator;
      marketResearcher;
      assumptionExtractor;
      assumptionValidator;
      referenceService;
      constructor() {
        this.queryGenerator = new BMCQueryGenerator();
        this.marketResearcher = new MarketResearcher();
        this.assumptionExtractor = new AssumptionExtractor();
        this.assumptionValidator = new AssumptionValidator();
        this.referenceService = new ReferenceService();
      }
      /**
       * Convert BMC findings and sources to normalized references
       */
      bmcToReferences(blocks, sources) {
        const references3 = [];
        const seenUrls = /* @__PURE__ */ new Set();
        for (const block of blocks) {
          const confidenceMap = {
            "strong": 0.85,
            "moderate": 0.65,
            "weak": 0.45
          };
          const blockConfidence = confidenceMap[block.confidence] || 0.5;
          for (const finding of block.findings) {
            const url = finding.citation;
            if (url && !seenUrls.has(url)) {
              seenUrls.add(url);
              const source = sources.find((s) => s.url === url);
              references3.push({
                title: source?.title || url,
                url,
                sourceType: "article",
                description: finding.fact.substring(0, 200),
                topics: ["business model canvas", block.blockName.toLowerCase()],
                confidence: blockConfidence,
                snippet: finding.fact,
                origin: "web_search"
              });
            }
          }
        }
        return references3;
      }
      /**
       * Convert StrategicUnderstandingService entities to Assumption format for backward compatibility
       */
      entitiesToAssumptions(entities) {
        return entities.map((entity) => {
          let category = "market";
          if (entity.claim.toLowerCase().includes("localization") || entity.claim.toLowerCase().includes("feature") || entity.claim.toLowerCase().includes("product")) {
            category = "product";
          } else if (entity.claim.toLowerCase().includes("customer") || entity.claim.toLowerCase().includes("enterprise") || entity.claim.toLowerCase().includes("segment")) {
            category = "customer";
          } else if (entity.claim.toLowerCase().includes("competitive") || entity.claim.toLowerCase().includes("vendor")) {
            category = "competitive";
          } else if (entity.claim.toLowerCase().includes("timeline") || entity.claim.toLowerCase().includes("achievable") || entity.claim.toLowerCase().includes("feasible")) {
            category = "operational";
          }
          let confidence = "implicit";
          if (entity.type === "explicit_assumption") {
            confidence = "explicit";
          }
          const investmentAmount = entity.investmentAmount ? `$${entity.investmentAmount.toLocaleString()}` : null;
          return {
            claim: entity.claim,
            category,
            confidence,
            investmentAmount,
            source: entity.source
          };
        });
      }
      async conductBMCResearch(input, sessionId, sink) {
        const TOTAL_STEPS = 8;
        let currentStep = 0;
        const emitProgress = (message) => {
          currentStep++;
          const progress = Math.round(currentStep / TOTAL_STEPS * 100);
          sink?.emitProgress(message, progress);
        };
        const effectiveSessionId = sessionId || `bmc-${Date.now()}`;
        console.log(`[BMCResearcher] Using StrategicUnderstandingService for session: ${effectiveSessionId}`);
        sink?.emitContext(input.slice(0, 200));
        emitProgress("Extracting strategic understanding from input");
        const { understandingId, entities } = await strategicUnderstandingService.extractUnderstanding({
          sessionId: effectiveSessionId,
          userInput: input
        });
        console.log(`[BMCResearcher] Extracted ${entities.length} entities (knowledge graph replaces AssumptionExtractor)`);
        console.log(`[BMCResearcher] Understanding ID: ${understandingId}`);
        const assumptions = this.entitiesToAssumptions(entities);
        console.log(`[BMCResearcher] Converted to ${assumptions.length} assumptions for BMC flow`);
        emitProgress(`Generating search queries for all 9 BMC blocks`);
        const querySet = await this.queryGenerator.generateQueriesForAllBlocks(input);
        emitProgress(`Generating assumption validation queries (${assumptions.length} assumptions)`);
        const assumptionQueries = await this.assumptionValidator.generateAssumptionQueries(assumptions);
        console.log(`Generated ${assumptionQueries.length} assumption validation queries`);
        const bmcQueries = [
          ...querySet.customer_segments,
          ...querySet.value_propositions,
          ...querySet.revenue_streams,
          ...querySet.channels,
          ...querySet.customer_relationships,
          ...querySet.key_resources,
          ...querySet.key_activities,
          ...querySet.key_partnerships,
          ...querySet.cost_structure
        ];
        const assumptionOnlyQueries = assumptionQueries.map((aq) => ({
          query: aq.query,
          purpose: `Assumption check: ${aq.assumption}`,
          type: aq.purpose === "validate" ? "validating" : "challenging"
        }));
        const allQueries = [...bmcQueries, ...assumptionOnlyQueries];
        emitProgress(`Conducting web research (${allQueries.length} queries across ${Math.ceil(allQueries.length / 5)} batches)`);
        const searchResults = await this.performParallelWebSearch(allQueries, sink);
        const assumptionResults = searchResults.filter(
          (r) => assumptionOnlyQueries.some((q) => q.query === r.query)
        );
        console.log(`Found ${assumptionResults.length} assumption-related search results to share across all blocks`);
        const allSources = this.extractUniqueSources(searchResults);
        const topSources = allSources.slice(0, 10);
        const sourceContents = await this.marketResearcher.fetchSourceContentPublic(
          topSources.slice(0, 3)
        );
        emitProgress(`Validating assumptions against research findings`);
        const assumptionFindings = assumptionResults.flatMap(
          (sr) => (sr.results || []).map((r) => `${r.title}: ${r.snippet}`)
        );
        const contradictionResult = await this.assumptionValidator.detectContradictions(
          assumptions,
          assumptionFindings
          // Context-preserved findings
        );
        console.log(`Detected ${contradictionResult.contradictions.length} contradictions BEFORE block synthesis`);
        emitProgress(`Synthesizing insights for all 9 BMC blocks`);
        const blockNames = [
          "Customer Segments",
          "Value Propositions",
          "Revenue Streams",
          "Channels",
          "Customer Relationships",
          "Key Resources",
          "Key Activities",
          "Key Partnerships",
          "Cost Structure"
        ];
        for (let i = 0; i < blockNames.length; i++) {
          sink?.emitSynthesis(blockNames[i].toLowerCase().replace(/ /g, "_"), `Synthesizing ${blockNames[i]} (${i + 1}/${blockNames.length})`);
        }
        const [
          customerBlock,
          valueBlock,
          revenueBlock,
          channelsBlock,
          relationshipsBlock,
          resourcesBlock,
          activitiesBlock,
          partnersBlock,
          costBlock
        ] = await Promise.all([
          this.synthesizeBlock(
            "customer_segments",
            "Customer Segments",
            querySet.customer_segments,
            [
              ...searchResults.filter(
                (r) => querySet.customer_segments.some((q) => q.query === r.query)
              ),
              ...assumptionResults
              // Include assumption findings in all blocks
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "value_propositions",
            "Value Propositions",
            querySet.value_propositions,
            [
              ...searchResults.filter(
                (r) => querySet.value_propositions.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "revenue_streams",
            "Revenue Streams",
            querySet.revenue_streams,
            [
              ...searchResults.filter(
                (r) => querySet.revenue_streams.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "channels",
            "Channels",
            querySet.channels,
            [
              ...searchResults.filter(
                (r) => querySet.channels.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "customer_relationships",
            "Customer Relationships",
            querySet.customer_relationships,
            [
              ...searchResults.filter(
                (r) => querySet.customer_relationships.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "key_resources",
            "Key Resources",
            querySet.key_resources,
            [
              ...searchResults.filter(
                (r) => querySet.key_resources.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "key_activities",
            "Key Activities",
            querySet.key_activities,
            [
              ...searchResults.filter(
                (r) => querySet.key_activities.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "key_partnerships",
            "Key Partnerships",
            querySet.key_partnerships,
            [
              ...searchResults.filter(
                (r) => querySet.key_partnerships.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          ),
          this.synthesizeBlock(
            "cost_structure",
            "Cost Structure",
            querySet.cost_structure,
            [
              ...searchResults.filter(
                (r) => querySet.cost_structure.some((q) => q.query === r.query)
              ),
              ...assumptionResults
            ],
            sourceContents,
            input,
            contradictionResult.contradictions
          )
        ]);
        const blocks = [
          customerBlock,
          valueBlock,
          revenueBlock,
          channelsBlock,
          relationshipsBlock,
          resourcesBlock,
          activitiesBlock,
          partnersBlock,
          costBlock
        ];
        const overallConfidence = this.calculateOverallConfidence(blocks);
        emitProgress(`Generating overall Business Model Canvas synthesis`);
        const synthesis = await this.synthesizeOverallBMC(blocks, input, contradictionResult.contradictions);
        emitProgress(`Saving findings to knowledge graph`);
        await this.storeBMCFindingsInGraph(understandingId, entities, blocks, contradictionResult.contradictions, synthesis.criticalGaps);
        const references3 = this.bmcToReferences(blocks, topSources);
        emitProgress(`Finalizing research results`);
        return {
          blocks,
          sources: topSources,
          references: references3,
          overallConfidence,
          viability: synthesis.viability,
          keyInsights: synthesis.keyInsights,
          criticalGaps: synthesis.criticalGaps,
          consistencyChecks: synthesis.consistencyChecks,
          recommendations: synthesis.recommendations,
          assumptions,
          contradictions: contradictionResult.contradictions
        };
      }
      /**
       * Validate ALL contradictions upfront (prevents DB timeout by doing LLM calls separately)
       */
      async validateAllContradictions(contradictions, userInputEntities) {
        console.log(`[BMCResearcher] Validating ${contradictions.length} potential contradictions...`);
        const results = await Promise.all(
          contradictions.map(async (contradiction) => {
            const sourceEntity = userInputEntities.find((e) => {
              const entityClaim = e.claim;
              const assumptionClaim = contradiction.assumption;
              const entityLower = entityClaim.toLowerCase();
              const assumptionLower = assumptionClaim.toLowerCase();
              if (entityLower.includes(assumptionLower.substring(0, 30)) || assumptionLower.includes(entityLower.substring(0, 30))) {
                console.log(`[BMCResearcher] Matched via substring`);
                return true;
              }
              const extractConcepts = (text2) => {
                const concepts = /* @__PURE__ */ new Set();
                const numbers = text2.match(/\$?\d+[\d,]*\.?\d*[%]?/g) || [];
                numbers.forEach((n) => concepts.add(n.replace(/,/g, "").toLowerCase()));
                const timeframes = text2.match(/\d+[-]\d+\s*(week|month|year|day)s?/gi) || [];
                timeframes.forEach((t) => concepts.add(t.toLowerCase()));
                const products = text2.match(/\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*/g) || [];
                products.forEach((p) => concepts.add(p.toLowerCase()));
                const keywords = ["implementation", "deployment", "rollout", "timeline", "budget", "investment"];
                keywords.forEach((kw) => {
                  if (text2.toLowerCase().includes(kw)) {
                    concepts.add(kw);
                  }
                });
                return concepts;
              };
              const entityConcepts = extractConcepts(entityClaim);
              const assumptionConcepts = extractConcepts(assumptionClaim);
              const sharedConcepts = Array.from(entityConcepts).filter((c) => assumptionConcepts.has(c));
              if (sharedConcepts.length >= 1) {
                console.log(`[BMCResearcher] Matched via concepts: ${sharedConcepts.join(", ")}`);
                return true;
              }
              return false;
            });
            if (!sourceEntity || contradiction.contradictedBy.length === 0) {
              return {
                contradiction,
                sourceEntity: null,
                isValid: false,
                validation: { isContradiction: false, reasoning: "No matching entity found" }
              };
            }
            const validationResults = await Promise.all(
              contradiction.contradictedBy.map(
                (evidence) => this.validateContradiction(sourceEntity.claim, evidence)
              )
            );
            const anyValid = validationResults.some((v) => v.isContradiction);
            const validCount = validationResults.filter((v) => v.isContradiction).length;
            const validationReasons = validationResults.map((v) => v.reasoning);
            return {
              contradiction,
              sourceEntity,
              isValid: anyValid,
              validation: {
                isContradiction: anyValid,
                reasoning: anyValid ? `${validCount}/${validationResults.length} evidence items validated as contradictions: ${validationReasons.join("; ")}` : `No evidence items validated as contradictions: ${validationReasons.join("; ")}`,
                provider: validationResults[0]?.provider,
                model: validationResults[0]?.model
              }
            };
          })
        );
        return results;
      }
      /**
       * Semantic validation: Check if user claim and research finding contradict each other
       * Two-step check: (1) Same concept? (2) Different values?
       * Prevents false contradictions from semantically different claims (e.g., "PM software" vs "PM discipline")
       */
      async validateContradiction(userClaim, researchFinding) {
        const systemPrompt = `You are a contradiction detection expert. Your job is to determine if two statements CONTRADICT each other.

CRITICAL TWO-STEP CHECK:
Step 1: Are they about the SAME concept/topic?
Step 2: If same concept, do the values/claims DIFFER?

CONTRADICTION = SAME CONCEPT + DIFFERENT VALUES

Examples:
- "Monthly cost is $500" vs "Monthly subscription is $624.75" \u2192 SAME concept (recurring cost) + DIFFERENT values ($500 \u2260 $624.75) \u2192 CONTRADICTION \u2713
- "Implementation takes 2-4 weeks" vs "Implementation takes 6 months" \u2192 SAME concept (timeline) + DIFFERENT values (weeks vs months) \u2192 CONTRADICTION \u2713
- "PM software implementation takes 2-4 weeks" vs "PM discipline adoption takes 6 months" \u2192 DIFFERENT concepts (software vs discipline) \u2192 NOT A CONTRADICTION \u2717
- "Asana deployment takes 2 weeks" vs "Asana implementation takes 6 months" \u2192 SAME concept (Asana rollout) + DIFFERENT values (2 weeks vs 6 months) \u2192 CONTRADICTION \u2713
- "Hiring engineers costs $500" vs "Hiring process costs $1000" \u2192 DIFFERENT concepts (salaries vs recruitment process) \u2192 NOT A CONTRADICTION \u2717
- "India market entry" vs "India market research" \u2192 DIFFERENT concepts (entering vs researching) \u2192 NOT A CONTRADICTION \u2717

Return ONLY valid JSON with this exact structure:
{
  "isSameConcept": true/false,
  "valuesConflict": true/false,
  "isContradiction": true/false,
  "reasoning": "Brief explanation of your analysis"
}`;
        const userMessage = `User claimed: "${userClaim}"
Research found: "${researchFinding}"

Do these statements contradict each other?
Step 1: Same concept? Step 2: Different values?`;
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt,
            userMessage,
            maxTokens: 500
          }, "anthropic");
          const result = parseAIJson(response.content, "BMC contradiction validation");
          const status = result.isContradiction ? `CONTRADICTION (same concept, different values)` : result.isSameConcept ? `NOT CONTRADICTION (same concept, same values)` : `NOT CONTRADICTION (different concepts)`;
          console.log(`[BMCResearcher] Semantic validation: "${userClaim.substring(0, 50)}..." vs "${researchFinding.substring(0, 50)}..." \u2192 ${status}`);
          return {
            isContradiction: result.isContradiction === true,
            reasoning: result.reasoning || "No reasoning provided",
            provider: response.provider,
            model: response.model
          };
        } catch (error) {
          console.error("[BMCResearcher] Semantic validation error:", error);
          return { isContradiction: false, reasoning: `Validation error: ${error}` };
        }
      }
      /**
       * Task 17: Store BMC research findings back into the knowledge graph
       * Maps: research findings  entities, contradictions  relationships, gaps  entities
       */
      async storeBMCFindingsInGraph(understandingId, sourceEntities, blocks, contradictions, criticalGaps) {
        console.log(`[BMCResearcher] Storing BMC findings in knowledge graph for understanding: ${understandingId}`);
        try {
          const persistedUserEntities = await dbConnectionManager.withFreshConnection(async () => {
            return await strategicUnderstandingService.getEntitiesByUnderstanding(understandingId);
          });
          const userInputEntities = persistedUserEntities.filter((e) => e.discoveredBy === "user_input");
          console.log(`[BMCResearcher] Found ${userInputEntities.length} persisted user_input entities for contradiction matching`);
          console.log(`[BMCResearcher] Performing semantic validation (no DB operations)...`);
          const validatedContradictions = await this.validateAllContradictions(contradictions, userInputEntities);
          console.log(`[BMCResearcher] Validation complete: ${validatedContradictions.filter((v) => v.isValid).length}/${validatedContradictions.length} contradictions validated`);
          const findingClaims = blocks.flatMap(
            (block) => block.findings.slice(0, 3).map((finding) => finding.fact)
          );
          const contradictionClaims = validatedContradictions.filter((r) => r.isValid && r.validation.isContradiction).map((r) => r.contradiction.contradictedBy.join("; "));
          const gapClaims = criticalGaps.slice(0, 5);
          const allClaims = [...findingClaims, ...contradictionClaims, ...gapClaims];
          console.log(`[BMCResearcher] Batch-generating ${allClaims.length} embeddings...`);
          const embeddings = await strategicUnderstandingService.generateEmbeddingsBatch(allClaims);
          console.log(`[BMCResearcher] \u2713 All embeddings ready`);
          await dbConnectionManager.retryWithBackoff(async (db2) => {
            let embeddingIndex = 0;
            for (const block of blocks) {
              for (const finding of block.findings.slice(0, 3)) {
                await strategicUnderstandingService.createEntityWithEmbedding(
                  db2,
                  understandingId,
                  {
                    type: "research_finding",
                    claim: finding.fact,
                    confidence: block.confidence === "strong" ? "high" : block.confidence === "moderate" ? "medium" : "low",
                    source: finding.citation,
                    evidence: `BMC ${block.blockName} research finding`
                  },
                  embeddings[embeddingIndex++],
                  "bmc_agent"
                );
              }
            }
            console.log(`[BMCResearcher] Stored ${findingClaims.length} research findings`);
            let createdCount = 0;
            let skippedCount = 0;
            for (const result of validatedContradictions) {
              if (!result.isValid || !result.sourceEntity) {
                skippedCount++;
                continue;
              }
              const { contradiction, sourceEntity, validation } = result;
              if (validation.isContradiction) {
                console.log(`[BMCResearcher] \u2713 Creating contradiction relationship from entity ID: ${sourceEntity.id}`);
                const contradictionEntity = await strategicUnderstandingService.createEntityWithEmbedding(
                  db2,
                  understandingId,
                  {
                    type: "research_finding",
                    claim: contradiction.contradictedBy.join("; "),
                    confidence: contradiction.validationStrength === "STRONG" ? "high" : contradiction.validationStrength === "MODERATE" ? "medium" : "low",
                    source: "BMC research",
                    evidence: `Contradicts: ${contradiction.assumption}. Impact: ${contradiction.impact}`
                  },
                  embeddings[embeddingIndex++],
                  "bmc_agent"
                );
                await strategicUnderstandingService.createRelationshipDirect(
                  db2,
                  sourceEntity.id,
                  contradictionEntity.id,
                  "contradicts",
                  contradiction.validationStrength === "STRONG" ? "high" : contradiction.validationStrength === "MODERATE" ? "medium" : "low",
                  contradiction.recommendation,
                  "bmc_agent",
                  {
                    semanticValidation: {
                      reasoning: validation.reasoning,
                      provider: validation.provider,
                      model: validation.model,
                      validatedAt: (/* @__PURE__ */ new Date()).toISOString()
                    },
                    contradictionImpact: contradiction.impact,
                    contradictionRecommendation: contradiction.recommendation
                  }
                );
                createdCount++;
              } else {
                skippedCount++;
              }
            }
            console.log(`[BMCResearcher] Contradiction results: ${createdCount} created, ${skippedCount} skipped`);
            for (const gap of criticalGaps.slice(0, 5)) {
              await strategicUnderstandingService.createEntityWithEmbedding(
                db2,
                understandingId,
                {
                  type: "business_model_gap",
                  claim: gap,
                  confidence: "medium",
                  source: "BMC analysis synthesis",
                  evidence: "Identified during Business Model Canvas research and synthesis"
                },
                embeddings[embeddingIndex++],
                "bmc_agent"
              );
            }
            console.log(`[BMCResearcher] Stored ${gapClaims.length} critical gaps`);
            console.log(`[BMCResearcher] \u2713 Knowledge graph enriched with BMC findings`);
          });
        } catch (error) {
          console.error(`[BMCResearcher] Error storing BMC findings in graph:`, error.message);
        }
      }
      async performParallelWebSearch(queries, sink) {
        const throttler = new RequestThrottler({
          maxConcurrent: 5,
          delayBetweenBatches: 200,
          maxRetries: 3,
          initialRetryDelay: 1e3
        });
        const searchTasks = queries.map((queryObj) => async () => {
          try {
            sink?.emitQuery(queryObj.query, queryObj.purpose || "research", queryObj.type || "baseline");
            const response = await fetch(`${API_BASE3}/api/web-search`, {
              method: "POST",
              headers: {
                "Content-Type": "application/json"
              },
              body: JSON.stringify({ query: queryObj.query })
            });
            if (!response.ok) {
              const error = new Error(`Search failed: ${response.status}`);
              error.status = response.status;
              throw error;
            }
            const data = await response.json();
            const results = (data.organic || []).map((result) => ({
              url: result.link,
              title: result.title,
              snippet: result.snippet || "",
              relevance: result.position ? 1 / result.position : 0.5
            }));
            return { query: queryObj.query, results };
          } catch (error) {
            if (error.status === 429 || error.message?.includes("429")) {
              throw error;
            }
            console.error(`Error searching for "${queryObj.query}":`, error);
            return { query: queryObj.query, results: [] };
          }
        });
        return throttler.throttleAll(
          searchTasks,
          (taskIndex) => ({ query: queries[taskIndex].query, results: [] })
        );
      }
      extractUniqueSources(searchResults) {
        const sourceMap = /* @__PURE__ */ new Map();
        for (const searchResult of searchResults) {
          if (searchResult.results && Array.isArray(searchResult.results)) {
            for (const result of searchResult.results) {
              if (!sourceMap.has(result.url)) {
                sourceMap.set(result.url, {
                  url: result.url,
                  title: result.title,
                  relevance_score: result.relevance || 0.5
                });
              }
            }
          }
        }
        const sources = Array.from(sourceMap.values());
        sources.sort((a, b) => b.relevance_score - a.relevance_score);
        return sources;
      }
      async synthesizeBlock(blockType, blockName, queries, searchResults, sourceContents, originalInput, contradictions = []) {
        const searchSummary = searchResults.map(
          (sr) => `Query: ${sr.query}
Results: ${sr.results?.map((r) => `- ${r.title}: ${r.snippet}`).join("\n") || "No results"}`
        ).join("\n\n");
        const fullContentSummary = Array.from(sourceContents.entries()).map(([url, content]) => `URL: ${url}
Content: ${content.substring(0, 1500)}...`).join("\n\n---\n\n");
        const blockContext = {
          customer_segments: {
            focus: "WHO the target customers are, their characteristics, needs, and pain points",
            outputGuidance: "Describe the target customer segments based on research evidence"
          },
          value_propositions: {
            focus: "WHAT value solves customer problems and how it differentiates from alternatives",
            outputGuidance: "Describe the key value propositions based on market research"
          },
          revenue_streams: {
            focus: "HOW the business generates revenue and monetizes value",
            outputGuidance: "Describe revenue models and pricing strategies based on research"
          },
          channels: {
            focus: "HOW the company reaches and communicates with customer segments to deliver value",
            outputGuidance: "Describe distribution/sales channels and delivery methods based on research"
          },
          customer_relationships: {
            focus: "WHAT type of relationship is established and maintained with each customer segment",
            outputGuidance: "Describe customer engagement and support models based on research"
          },
          key_resources: {
            focus: "WHAT critical assets are required to create and deliver value",
            outputGuidance: "Describe essential resources (human, intellectual, physical, financial) based on research"
          },
          key_activities: {
            focus: "WHAT key actions must be performed to operate successfully",
            outputGuidance: "Describe core operational activities and priorities based on research"
          },
          key_partnerships: {
            focus: "WHO are the key partners and suppliers needed",
            outputGuidance: "Describe strategic partnerships and supplier relationships based on research"
          },
          cost_structure: {
            focus: "WHAT are the major costs required to operate the business model",
            outputGuidance: "Describe cost drivers and structure (fixed/variable) based on research"
          }
        };
        const context = blockContext[blockType];
        const contradictionWarning = contradictions.length > 0 ? `

\u{1F6A8} CRITICAL - CONTRADICTED ASSUMPTIONS:
Research has contradicted the following user assumptions. DO NOT validate these in your synthesis:

${contradictions.map(
          (c) => `\u274C "${c.assumption}" - Research shows: ${c.contradictedBy.slice(0, 2).join("; ")}`
        ).join("\n")}

IMPORTANT: If your findings relate to these contradicted assumptions, acknowledge the contradiction rather than validating the assumption.` : "";
        const systemPrompt = `You are a Business Model Canvas analyst. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `Synthesize research for the "${blockName}" block.

BLOCK FOCUS: ${context.focus}

ORIGINAL INPUT:
${originalInput.substring(0, 1500)}

RESEARCH QUERIES USED:
${queries.map((q) => `- ${q.query} (${q.type})`).join("\n")}

SEARCH RESULTS:
${searchSummary}

FULL CONTENT FROM TOP SOURCES:
${fullContentSummary}${contradictionWarning}

Based on the research above, synthesize findings for the ${blockName} block.

${context.outputGuidance}

Return ONLY valid JSON (no markdown, no explanation):

{
  "description": "2-3 sentence summary of this BMC block based on research evidence",
  "findings": [
    {
      "fact": "Specific insight from research about ${context.focus}",
      "citation": "https://source-url.com",
      "confidence": "high|medium|low"
    }
  ],
  "confidence": "weak|moderate|strong",
  "strategicImplications": "1-2 sentences on strategic implications for this block",
  "gaps": ["identified gap 1", "identified gap 2"],
  "researchQueries": ${JSON.stringify(queries.map((q) => q.query))}
}

Include 3-6 findings. Set confidence to:
- "strong" if multiple high-quality sources confirm insights
- "moderate" if some sources support insights
- "weak" if limited or uncertain evidence`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 4096
        }, "anthropic");
        const textContent = response.content;
        const synthesized = parseAIJson(textContent, `BMC ${blockType} synthesis`);
        return {
          blockType,
          blockName,
          description: synthesized.description || "",
          findings: synthesized.findings || [],
          confidence: synthesized.confidence || "weak",
          strategicImplications: synthesized.strategicImplications || "",
          gaps: synthesized.gaps || [],
          researchQueries: synthesized.researchQueries || []
        };
      }
      calculateOverallConfidence(blocks) {
        const confidenceMap = { weak: 0.3, moderate: 0.6, strong: 0.9 };
        const scores = blocks.map((b) => confidenceMap[b.confidence]);
        const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
        return Math.round(average * 100) / 100;
      }
      async synthesizeOverallBMC(blocks, originalInput, contradictions = []) {
        const blockSummary = blocks.map(
          (b) => `${b.blockName} (${b.confidence} confidence):
${b.description}
Gaps: ${b.gaps.join(", ") || "None identified"}`
        ).join("\n\n");
        const contradictionSummary = contradictions.length > 0 ? `

\u{1F6A8} CONTRADICTED ASSUMPTIONS:
${contradictions.map(
          (c) => `- "${c.assumption}" (${c.impact} impact${c.investmentAmount ? `, Investment: ${c.investmentAmount}` : ""})
  Research found: ${c.contradictedBy.join("; ")}
  Recommendation: ${c.recommendation}`
        ).join("\n")}` : "";
        const systemPrompt = `You are a Business Model Canvas expert. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `Conduct overall viability analysis.

ORIGINAL INPUT:
${originalInput.substring(0, 1500)}

RESEARCH FINDINGS FOR ALL 9 BMC BLOCKS:
${blockSummary}${contradictionSummary}

Based on these findings, provide comprehensive BMC viability analysis:

1. **Cross-Block Consistency**: Analyze alignment across all blocks. Key relationships to check:
   - Do customer segments align with value propositions?
   - Do channels effectively reach customer segments?
   - Do customer relationships match segment expectations?
   - Do key resources and activities support value delivery?
   - Do key partners fill critical gaps?
   - Does cost structure align with revenue streams?
2. **Overall Viability**: Can this business model work based on research evidence?
3. **Key Insights**: What are the most important strategic insights across all blocks?
4. **Critical Gaps**: What critical information is missing or uncertain? PRIORITIZE contradicted assumptions!
5. **Recommendations**: What should be prioritized or validated? ALWAYS flag contradicted assumptions as HIGH priority!

Return ONLY valid JSON (no markdown, no explanation):

{
  "viability": "strong|moderate|weak",
  "keyInsights": [
    "Cross-block insight 1 (2-3 sentences)",
    "Cross-block insight 2 (2-3 sentences)",
    "Cross-block insight 3 (2-3 sentences)"
  ],
  "criticalGaps": [
    "Critical gap 1",
    "Critical gap 2"
  ],
  "consistencyChecks": [
    {
      "aspect": "Customer-Value Alignment",
      "status": "aligned|misaligned|uncertain",
      "explanation": "Brief explanation of consistency"
    },
    {
      "aspect": "Value-Revenue Alignment",
      "status": "aligned|misaligned|uncertain",
      "explanation": "Brief explanation of consistency"
    }
  ],
  "recommendations": [
    {
      "priority": "high|medium|low",
      "action": "Specific recommendation",
      "rationale": "Why this matters"
    }
  ]
}

Viability criteria:
- "strong": All blocks have moderate-strong confidence, good alignment, clear path to revenue
- "moderate": Some uncertainty but core model appears viable with validation
- "weak": Significant gaps, misalignment, or fundamental viability concerns`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 4096
        }, "anthropic");
        const textContent = response.content;
        const synthesized = parseAIJson(textContent, "BMC overall synthesis");
        return {
          viability: synthesized.viability || "weak",
          keyInsights: synthesized.keyInsights || [],
          criticalGaps: synthesized.criticalGaps || [],
          consistencyChecks: synthesized.consistencyChecks || [],
          recommendations: synthesized.recommendations || []
        };
      }
    };
  }
});

// server/services/journey-summary-service.ts
import { eq as eq5, and as and4, desc as desc2 } from "drizzle-orm";
function buildFiveWhysBmcSummary(context, sessionMeta) {
  const keyInsights = [];
  const frameworks = {};
  const strategicImplications = [];
  if (context.insights.rootCauses && context.insights.rootCauses.length > 0) {
    const rootCause = context.insights.rootCauses[0];
    keyInsights.push(`Root Cause: ${rootCause}`);
    frameworks.five_whys = {
      rootCauses: context.insights.rootCauses,
      whysPath: context.insights.whysPath || []
    };
  }
  if (context.insights.bmcBlocks) {
    const valueProps = context.insights.bmcBlocks.value_propositions;
    const customerSegments = context.insights.bmcBlocks.customer_segments;
    if (valueProps) {
      keyInsights.push(`Value Proposition: ${JSON.stringify(valueProps).substring(0, 100)}...`);
    }
    if (customerSegments) {
      keyInsights.push(`Target Customers: ${JSON.stringify(customerSegments).substring(0, 100)}...`);
    }
    frameworks.bmc = {
      valuePropositions: valueProps,
      customerSegments,
      revenueStreams: context.insights.bmcBlocks.revenue_streams,
      keyActivities: context.insights.bmcBlocks.key_activities
    };
  }
  if (context.insights.strategicImplications && context.insights.strategicImplications.length > 0) {
    strategicImplications.push(...context.insights.strategicImplications.slice(0, 3));
  } else {
    strategicImplications.push("Business model redesign needed to address root causes");
    strategicImplications.push("Focus on validated customer segments and value propositions");
    if (context.insights.businessModelGaps && context.insights.businessModelGaps.length > 0) {
      strategicImplications.push("Address critical business model gaps identified");
    }
  }
  return {
    journeyType: context.journeyType,
    completedAt: sessionMeta.completedAt,
    versionNumber: sessionMeta.versionNumber,
    keyInsights: keyInsights.slice(0, 5),
    frameworks,
    strategicImplications: strategicImplications.slice(0, 3)
  };
}
function buildPestlePortersSummary(context, sessionMeta) {
  const keyInsights = [];
  const frameworks = {};
  const strategicImplications = [];
  if (context.insights.trendFactors) {
    const factors = Object.entries(context.insights.trendFactors).slice(0, 3);
    factors.forEach(([category, data]) => {
      keyInsights.push(`${category.toUpperCase()} Trend: ${JSON.stringify(data).substring(0, 80)}...`);
    });
    frameworks.pestle = context.insights.trendFactors;
  }
  if (context.insights.portersForces) {
    const forces = Object.entries(context.insights.portersForces).slice(0, 2);
    forces.forEach(([force, data]) => {
      keyInsights.push(`Competitive Force (${force}): ${JSON.stringify(data).substring(0, 80)}...`);
    });
    frameworks.porters = context.insights.portersForces;
  }
  strategicImplications.push("Monitor identified external trends for market timing");
  strategicImplications.push("Develop strategies to counter competitive pressures");
  if (context.insights.keyOpportunities && context.insights.keyOpportunities.length > 0) {
    strategicImplications.push(`Capitalize on ${context.insights.keyOpportunities.length} identified opportunities`);
  }
  return {
    journeyType: context.journeyType,
    completedAt: sessionMeta.completedAt,
    versionNumber: sessionMeta.versionNumber,
    keyInsights: keyInsights.slice(0, 5),
    frameworks,
    strategicImplications: strategicImplications.slice(0, 3)
  };
}
function buildPortersBmcSummary(context, sessionMeta) {
  const keyInsights = [];
  const frameworks = {};
  const strategicImplications = [];
  if (context.insights.competitivePressures && context.insights.competitivePressures.length > 0) {
    context.insights.competitivePressures.slice(0, 2).forEach((pressure) => {
      keyInsights.push(`Competitive Pressure: ${pressure}`);
    });
  }
  if (context.insights.portersForces) {
    frameworks.porters = context.insights.portersForces;
  }
  if (context.insights.bmcBlocks) {
    const valueProps = context.insights.bmcBlocks.value_propositions;
    const keyResources = context.insights.bmcBlocks.key_resources;
    if (valueProps) {
      keyInsights.push(`Differentiation: ${JSON.stringify(valueProps).substring(0, 100)}...`);
    }
    frameworks.bmc = {
      valuePropositions: valueProps,
      keyResources,
      keyActivities: context.insights.bmcBlocks.key_activities
    };
  }
  strategicImplications.push("Build defensible competitive advantages");
  strategicImplications.push("Focus on unique value propositions to counter competitive forces");
  strategicImplications.push("Strengthen key resources and partnerships");
  return {
    journeyType: context.journeyType,
    completedAt: sessionMeta.completedAt,
    versionNumber: sessionMeta.versionNumber,
    keyInsights: keyInsights.slice(0, 5),
    frameworks,
    strategicImplications: strategicImplications.slice(0, 3)
  };
}
function buildPestleBmcSummary(context, sessionMeta) {
  const keyInsights = [];
  const frameworks = {};
  const strategicImplications = [];
  if (context.insights.trendFactors) {
    const factors = Object.entries(context.insights.trendFactors).slice(0, 3);
    factors.forEach(([category, data]) => {
      keyInsights.push(`${category.toUpperCase()}: ${JSON.stringify(data).substring(0, 80)}...`);
    });
    frameworks.pestle = context.insights.trendFactors;
  }
  if (context.insights.bmcBlocks) {
    const channels = context.insights.bmcBlocks.channels;
    const customerRelationships = context.insights.bmcBlocks.customer_relationships;
    if (channels) {
      keyInsights.push(`Digital Channels: ${JSON.stringify(channels).substring(0, 80)}...`);
    }
    frameworks.bmc = {
      channels,
      customerRelationships,
      keyActivities: context.insights.bmcBlocks.key_activities,
      valuePropositions: context.insights.bmcBlocks.value_propositions
    };
  }
  strategicImplications.push("Adapt business model to identified macro trends");
  strategicImplications.push("Leverage digital channels for growth");
  if (context.insights.keyOpportunities && context.insights.keyOpportunities.length > 0) {
    strategicImplications.push("Pursue growth opportunities aligned with trends");
  }
  return {
    journeyType: context.journeyType,
    completedAt: sessionMeta.completedAt,
    versionNumber: sessionMeta.versionNumber,
    keyInsights: keyInsights.slice(0, 5),
    frameworks,
    strategicImplications: strategicImplications.slice(0, 3)
  };
}
function buildFiveWhysSwotSummary(context, sessionMeta) {
  const keyInsights = [];
  const frameworks = {};
  const strategicImplications = [];
  if (context.insights.rootCauses && context.insights.rootCauses.length > 0) {
    const rootCause = context.insights.rootCauses[0];
    keyInsights.push(`Root Cause: ${rootCause}`);
    frameworks.five_whys = {
      rootCauses: context.insights.rootCauses,
      whysPath: context.insights.whysPath || []
    };
  }
  keyInsights.push("SWOT analysis: Pending implementation");
  frameworks.swot = {
    placeholder: "SWOT framework not yet implemented"
  };
  strategicImplications.push("Address identified root causes immediately");
  strategicImplications.push("Leverage internal strengths for turnaround");
  strategicImplications.push("Mitigate critical weaknesses");
  return {
    journeyType: context.journeyType,
    completedAt: sessionMeta.completedAt,
    versionNumber: sessionMeta.versionNumber,
    keyInsights: keyInsights.slice(0, 5),
    frameworks,
    strategicImplications: strategicImplications.slice(0, 3)
  };
}
function buildPestleAnsoffSummary(context, sessionMeta) {
  const keyInsights = [];
  const frameworks = {};
  const strategicImplications = [];
  if (context.insights.trendFactors) {
    const factors = Object.entries(context.insights.trendFactors).slice(0, 3);
    factors.forEach(([category, data]) => {
      keyInsights.push(`${category.toUpperCase()} Trend: ${JSON.stringify(data).substring(0, 80)}...`);
    });
    frameworks.pestle = context.insights.trendFactors;
  }
  keyInsights.push("Ansoff Matrix: Pending implementation");
  frameworks.ansoff = {
    placeholder: "Ansoff framework not yet implemented"
  };
  strategicImplications.push("Align growth strategy with identified trends");
  strategicImplications.push("Evaluate market penetration vs. diversification");
  if (context.insights.keyOpportunities && context.insights.keyOpportunities.length > 0) {
    strategicImplications.push("Prioritize expansion opportunities by risk/reward");
  }
  return {
    journeyType: context.journeyType,
    completedAt: sessionMeta.completedAt,
    versionNumber: sessionMeta.versionNumber,
    keyInsights: keyInsights.slice(0, 5),
    frameworks,
    strategicImplications: strategicImplications.slice(0, 3)
  };
}
async function saveSummary(journeySessionId, summary) {
  const encryptedSummary = await encryptJSONKMS(summary);
  await db.update(journeySessions).set({ summary: encryptedSummary }).where(eq5(journeySessions.id, journeySessionId));
  console.log(`[JourneySummaryService] \u2713 Saved encrypted summary for session ${journeySessionId}`);
}
async function getLatestSummary(understandingId, journeyType) {
  const sessions2 = await db.select().from(journeySessions).where(
    and4(
      eq5(journeySessions.understandingId, understandingId),
      eq5(journeySessions.journeyType, journeyType),
      eq5(journeySessions.status, "completed")
    )
  ).orderBy(desc2(journeySessions.versionNumber)).limit(1);
  if (sessions2.length === 0 || !sessions2[0].summary) {
    return null;
  }
  const decrypted = await decryptJSONKMS(sessions2[0].summary);
  return decrypted;
}
async function getSummaryForSession(journeySessionId) {
  const sessions2 = await db.select().from(journeySessions).where(eq5(journeySessions.id, journeySessionId)).limit(1);
  if (sessions2.length === 0 || !sessions2[0].summary) {
    return null;
  }
  const decrypted = await decryptJSONKMS(sessions2[0].summary);
  return decrypted;
}
function buildSummary(summaryBuilderType, context, sessionMeta) {
  const builder = summaryBuilders[summaryBuilderType];
  if (!builder) {
    throw new Error(`Summary builder "${summaryBuilderType}" not found in registry. Available builders: ${Object.keys(summaryBuilders).join(", ")}`);
  }
  return builder(context, sessionMeta);
}
var summaryBuilders, journeySummaryService;
var init_journey_summary_service = __esm({
  "server/services/journey-summary-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_kms_encryption();
    summaryBuilders = {
      fiveWhysBmc: buildFiveWhysBmcSummary,
      pestlePorters: buildPestlePortersSummary,
      portersBmc: buildPortersBmcSummary,
      pestleBmc: buildPestleBmcSummary,
      fiveWhysSwot: buildFiveWhysSwotSummary,
      pestleAnsoff: buildPestleAnsoffSummary
    };
    journeySummaryService = {
      buildSummary,
      saveSummary,
      getLatestSummary,
      getSummaryForSession
    };
  }
});

// server/db-init.ts
var db_init_exports = {};
__export(db_init_exports, {
  getExtensionStatus: () => getExtensionStatus,
  initializeDatabaseExtensions: () => initializeDatabaseExtensions,
  verifyDatabaseExtensions: () => verifyDatabaseExtensions
});
import { sql as sql4 } from "drizzle-orm";
async function verifyDatabaseExtensions() {
  const status = {
    pg_trgm: false,
    pgvector: false
  };
  try {
    const trgmResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'pg_trgm'
      ) as installed
    `);
    status.pg_trgm = trgmResult.rows[0]?.installed === true;
    if (status.pg_trgm) {
      console.log("[DB Extensions] \u2713 pg_trgm extension is installed");
    } else {
      console.warn("[DB Extensions] \u2717 pg_trgm extension is NOT installed");
      console.warn("[DB Extensions] Knowledge Graph insights will be disabled");
      console.warn('[DB Extensions] To enable: Run "CREATE EXTENSION IF NOT EXISTS pg_trgm;" as a database admin');
    }
  } catch (error) {
    console.error("[DB Extensions] Failed to check pg_trgm:", error.message);
  }
  try {
    const vectorResult = await db.execute(sql4`
      SELECT EXISTS (
        SELECT 1 FROM pg_extension WHERE extname = 'vector'
      ) as installed
    `);
    status.pgvector = vectorResult.rows[0]?.installed === true;
    if (status.pgvector) {
      console.log("[DB Extensions] \u2713 pgvector extension is installed");
    } else {
      console.log("[DB Extensions] \u24D8 pgvector extension not installed (optional)");
    }
  } catch (error) {
    console.log("[DB Extensions] \u24D8 pgvector not available (optional)");
  }
  return status;
}
function getExtensionStatus() {
  return _extensionStatus;
}
async function initializeDatabaseExtensions() {
  console.log("[DB Extensions] Verifying PostgreSQL extensions...");
  _extensionStatus = await verifyDatabaseExtensions();
  return _extensionStatus;
}
var _extensionStatus;
var init_db_init = __esm({
  "server/db-init.ts"() {
    "use strict";
    init_db();
    _extensionStatus = null;
    if (import.meta.url === `file://${process.argv[1]}`) {
      verifyDatabaseExtensions().then((status) => {
        console.log("\nExtension Status:", status);
        if (!status.pg_trgm) {
          console.error("\n\u274C CRITICAL: pg_trgm extension is missing!");
          console.error("Run this SQL as a database admin:");
          console.error("  CREATE EXTENSION IF NOT EXISTS pg_trgm;");
          return;
        }
        console.log("\n\u2705 All required extensions are installed");
      }).catch((error) => {
        console.error("Extension verification failed:", error);
      });
    }
  }
});

// server/config.ts
var config_exports = {};
__export(config_exports, {
  isJourneyRegistryV2Enabled: () => isJourneyRegistryV2Enabled,
  isKnowledgeGraphEnabled: () => isKnowledgeGraphEnabled,
  isNeo4jConfigured: () => isNeo4jConfigured
});
function isJourneyRegistryV2Enabled() {
  return process.env.FEATURE_JOURNEY_REGISTRY_V2 === "true";
}
function isKnowledgeGraphEnabled() {
  if (process.env.FEATURE_KNOWLEDGE_GRAPH !== "true") {
    return false;
  }
  try {
    const { getExtensionStatus: getExtensionStatus2 } = (init_db_init(), __toCommonJS(db_init_exports));
    const status = getExtensionStatus2();
    if (!status) {
      return true;
    }
    return status.pg_trgm === true;
  } catch {
    return true;
  }
}
function isNeo4jConfigured() {
  return Boolean(process.env.NEO4J_URI && process.env.NEO4J_PASSWORD);
}
var init_config = __esm({
  "server/config.ts"() {
    "use strict";
  }
});

// server/journey/framework-executor-registry.ts
var framework_executor_registry_exports = {};
__export(framework_executor_registry_exports, {
  frameworkRegistry: () => frameworkRegistry2
});
var FrameworkExecutorRegistry, frameworkRegistry2;
var init_framework_executor_registry = __esm({
  "server/journey/framework-executor-registry.ts"() {
    "use strict";
    FrameworkExecutorRegistry = class {
      executors = /* @__PURE__ */ new Map();
      /**
       * Register a framework executor
       */
      register(executor) {
        if (this.executors.has(executor.name)) {
          console.warn(`[FrameworkRegistry] Overwriting existing executor for ${executor.name}`);
        }
        this.executors.set(executor.name, executor);
        console.log(`[FrameworkRegistry] \u2713 Registered executor: ${executor.name}`);
      }
      /**
       * Execute a framework by name
       */
      async execute(frameworkName, context) {
        const startTime = Date.now();
        try {
          const executor = this.executors.get(frameworkName);
          if (!executor) {
            throw new Error(`No executor registered for framework: ${frameworkName}`);
          }
          if (executor.validate) {
            const validation = await executor.validate(context);
            if (!validation.valid) {
              throw new Error(`Framework validation failed: ${validation.errors?.join(", ")}`);
            }
          }
          console.log(`[FrameworkRegistry] Executing ${frameworkName}...`);
          const data = await executor.execute(context);
          console.log(`[FrameworkRegistry] \u2713 ${frameworkName} completed`);
          return {
            frameworkName,
            executedAt: /* @__PURE__ */ new Date(),
            duration: Date.now() - startTime,
            data
          };
        } catch (error) {
          console.error(`[FrameworkRegistry] \u274C ${frameworkName} failed:`, error);
          return {
            frameworkName,
            executedAt: /* @__PURE__ */ new Date(),
            duration: Date.now() - startTime,
            data: {},
            errors: [error instanceof Error ? error.message : "Unknown error"]
          };
        }
      }
      /**
       * Check if a framework executor is registered
       */
      has(frameworkName) {
        return this.executors.has(frameworkName);
      }
      /**
       * Get all registered framework names
       */
      getRegisteredFrameworks() {
        return Array.from(this.executors.keys());
      }
    };
    frameworkRegistry2 = new FrameworkExecutorRegistry();
  }
});

// server/ontology/strategy-ontology.json
var strategy_ontology_default;
var init_strategy_ontology = __esm({
  "server/ontology/strategy-ontology.json"() {
    strategy_ontology_default = {
      strategic_approaches: {
        cost_leadership: {
          label: "Cost Leadership",
          requires: ["operational_excellence", "scale", "process_optimization"],
          implies: { volume: "high", margins: "low", focus: "efficiency" },
          workstreams: {
            operations: 40,
            supply_chain: 20,
            technology: 20,
            sales: 15,
            admin: 5
          },
          cost_range: { min: 1e6, max: 25e5 },
          timeline_months: { min: 12, max: 18 }
        },
        differentiation_service: {
          label: "Differentiation - Service Excellence",
          requires: ["customer_success_team", "premium_positioning"],
          workstreams: {
            customer_success: 30,
            product: 25,
            marketing: 20,
            sales: 15,
            operations: 10
          },
          cost_range: { min: 2e6, max: 4e6 },
          timeline_months: { min: 6, max: 12 }
        },
        blue_ocean: {
          label: "Blue Ocean - Create New Market",
          requires: ["market_research", "innovation", "customer_development"],
          workstreams: {
            research_development: 35,
            market_testing: 25,
            product: 20,
            operations: 15,
            admin: 5
          },
          cost_range: { min: 3e6, max: 6e6 },
          timeline_months: { min: 18, max: 24 }
        }
      },
      market_contexts: {
        uae: {
          label: "United Arab Emirates",
          requirements: ["trade_license_ded", "local_sponsor", "bank_account"],
          mandatory_workstreams: ["legal_regulatory"],
          setup_timeline_months: { min: 3, max: 6 },
          setup_cost: { min: 5e4, max: 15e4 }
        },
        usa: {
          label: "United States",
          requirements: ["business_entity", "ein", "state_registration"],
          setup_timeline_months: { min: 1, max: 3 },
          setup_cost: { min: 5e3, max: 25e3 }
        }
      },
      frameworks: {
        porters_five_forces: {
          label: "Porter's Five Forces",
          analysis_areas: ["competitive_rivalry", "supplier_power", "buyer_power", "threat_of_substitution", "threat_of_new_entry"]
        },
        five_whys: {
          label: "5 Whys Root Cause Analysis",
          purpose: "Find root problem being solved"
        }
      },
      decision_rules: [
        {
          if: { approach: "cost_leadership", market: "uae" },
          then: { priority_workstream: "operations", cost_adjustment: -0.15 }
        },
        {
          if: { approach: "differentiation_service", industry: "saas" },
          then: { mandatory_workstream: "customer_success", min_allocation: 30 }
        }
      ]
    };
  }
});

// server/ontology/strategy-ontology-service.ts
var strategy_ontology_service_exports = {};
__export(strategy_ontology_service_exports, {
  strategyOntologyService: () => strategyOntologyService
});
var StrategyOntologyService, strategyOntologyService;
var init_strategy_ontology_service = __esm({
  "server/ontology/strategy-ontology-service.ts"() {
    "use strict";
    init_strategy_ontology();
    StrategyOntologyService = class {
      ontology;
      constructor() {
        this.ontology = strategy_ontology_default;
      }
      getStrategicApproaches() {
        return this.ontology.strategic_approaches;
      }
      getStrategicApproach(approachId) {
        return this.ontology.strategic_approaches[approachId] || null;
      }
      getMarketContexts() {
        return this.ontology.market_contexts;
      }
      getMarketContext(marketId) {
        return this.ontology.market_contexts[marketId] || null;
      }
      getFrameworks() {
        return this.ontology.frameworks;
      }
      getFramework(frameworkId) {
        return this.ontology.frameworks[frameworkId] || null;
      }
      calculateCostEstimate(approachId, marketId, context) {
        const approach = this.getStrategicApproach(approachId);
        const market = this.getMarketContext(marketId);
        if (!approach) {
          return null;
        }
        let costMin = approach.cost_range.min;
        let costMax = approach.cost_range.max;
        let timelineMonths = Math.floor((approach.timeline_months.min + approach.timeline_months.max) / 2);
        if (market) {
          costMin += market.setup_cost.min;
          costMax += market.setup_cost.max;
          timelineMonths += Math.floor((market.setup_timeline_months.min + market.setup_timeline_months.max) / 2);
        }
        const applicableRules = this.getApplicableDecisionRules({
          approach: approachId,
          market: marketId,
          ...context
        });
        for (const rule of applicableRules) {
          if (rule.then.cost_adjustment) {
            const adjustment = rule.then.cost_adjustment;
            costMin = Math.floor(costMin * (1 + adjustment));
            costMax = Math.floor(costMax * (1 + adjustment));
          }
        }
        const workstreams2 = this.calculateWorkstreamAllocations(approachId, marketId, context);
        const breakdown = {};
        workstreams2.forEach((ws2) => {
          breakdown[ws2.name] = Math.floor((ws2.estimated_cost.min + ws2.estimated_cost.max) / 2);
        });
        const avgCost = (costMin + costMax) / 2;
        const teamSizeMin = Math.ceil(avgCost / 2e5);
        const teamSizeMax = Math.ceil(avgCost / 12e4);
        return {
          min: costMin,
          max: costMax,
          breakdown,
          timeline_months: timelineMonths,
          team_size: { min: teamSizeMin, max: teamSizeMax }
        };
      }
      calculateWorkstreamAllocations(approachId, marketId, context) {
        const approach = this.getStrategicApproach(approachId);
        const market = this.getMarketContext(marketId);
        if (!approach) {
          return [];
        }
        const workstreams2 = [];
        const totalCostMin = approach.cost_range.min + (market?.setup_cost.min || 0);
        const totalCostMax = approach.cost_range.max + (market?.setup_cost.max || 0);
        for (const [wsName, allocation] of Object.entries(approach.workstreams)) {
          workstreams2.push({
            name: wsName,
            allocation,
            estimated_cost: {
              min: Math.floor(totalCostMin * (allocation / 100)),
              max: Math.floor(totalCostMax * (allocation / 100))
            }
          });
        }
        if (market?.mandatory_workstreams) {
          for (const mandatoryWs of market.mandatory_workstreams) {
            const exists = workstreams2.find((ws2) => ws2.name === mandatoryWs);
            if (!exists) {
              workstreams2.push({
                name: mandatoryWs,
                allocation: 10,
                estimated_cost: {
                  min: Math.floor(totalCostMin * 0.1),
                  max: Math.floor(totalCostMax * 0.1)
                }
              });
            }
          }
        }
        return workstreams2;
      }
      validateStrategicCoherence(approachId, marketId, context) {
        const warnings = [];
        const errors = [];
        const approach = this.getStrategicApproach(approachId);
        const market = this.getMarketContext(marketId);
        if (!approach) {
          errors.push(`Unknown strategic approach: ${approachId}`);
          return { valid: false, warnings, errors };
        }
        if (!market) {
          errors.push(`Unknown market context: ${marketId}`);
          return { valid: false, warnings, errors };
        }
        const applicableRules = this.getApplicableDecisionRules({
          approach: approachId,
          market: marketId,
          ...context
        });
        for (const rule of applicableRules) {
          if (rule.then.mandatory_workstream) {
            const ws2 = rule.then.mandatory_workstream;
            if (!approach.workstreams[ws2]) {
              warnings.push(`Recommended workstream '${ws2}' is not included in approach`);
            }
          }
        }
        if (approach.requires && approach.requires.length > 0) {
          warnings.push(`This approach requires: ${approach.requires.join(", ")}`);
        }
        if (market.requirements && market.requirements.length > 0) {
          warnings.push(`Market requirements: ${market.requirements.join(", ")}`);
        }
        return {
          valid: errors.length === 0,
          warnings,
          errors
        };
      }
      getApplicableDecisionRules(context) {
        return this.ontology.decision_rules.filter((rule) => {
          return Object.entries(rule.if).every(([key, value]) => context[key] === value);
        });
      }
      getDecisionOptions(approachId, marketId, context) {
        const approach = this.getStrategicApproach(approachId);
        const market = this.getMarketContext(marketId);
        if (!approach || !market) {
          return null;
        }
        const costEstimate = this.calculateCostEstimate(approachId, marketId, context);
        const workstreams2 = this.calculateWorkstreamAllocations(approachId, marketId, context);
        const coherence = this.validateStrategicCoherence(approachId, marketId, context);
        return {
          approach,
          market,
          cost_estimate: costEstimate,
          workstreams: workstreams2,
          coherence
        };
      }
      allocateWorkstreams(approachId, marketId, context) {
        const workstreams2 = this.calculateWorkstreamAllocations(approachId, marketId, context);
        const costEstimate = this.calculateCostEstimate(approachId, marketId, context);
        const avgTeamSize = costEstimate ? Math.floor((costEstimate.team_size.min + costEstimate.team_size.max) / 2) : 5;
        return workstreams2.map((ws2, index2) => {
          const avgCost = (ws2.estimated_cost.min + ws2.estimated_cost.max) / 2;
          const teamSize = Math.max(1, Math.floor(avgCost / 15e4 * avgTeamSize / workstreams2.length));
          return {
            id: `ws_${index2 + 1}`,
            label: ws2.name,
            cost_allocation: Math.floor((ws2.estimated_cost.min + ws2.estimated_cost.max) / 2),
            team_size: teamSize
          };
        });
      }
    };
    strategyOntologyService = new StrategyOntologyService();
  }
});

// server/strategic-consultant-legacy/decision-generator.ts
var decision_generator_exports = {};
__export(decision_generator_exports, {
  DecisionGenerator: () => DecisionGenerator
});
import Anthropic2 from "@anthropic-ai/sdk";
var DecisionGenerator;
var init_decision_generator = __esm({
  "server/strategic-consultant-legacy/decision-generator.ts"() {
    "use strict";
    init_strategy_ontology_service();
    DecisionGenerator = class {
      anthropic;
      constructor() {
        const apiKey = process.env.ANTHROPIC_API_KEY;
        if (!apiKey) {
          throw new Error("ANTHROPIC_API_KEY environment variable is required");
        }
        this.anthropic = new Anthropic2({ apiKey });
      }
      async generateDecisions(analysis, originalInput) {
        const approaches = strategyOntologyService.getStrategicApproaches();
        const markets = strategyOntologyService.getMarketContexts();
        const approachOptions = analysis.recommended_approaches.map((id) => {
          const approach = approaches[id];
          return {
            id,
            label: approach?.label || id,
            requires: approach?.requires || [],
            cost_range: approach?.cost_range,
            timeline: approach?.timeline_months
          };
        });
        const marketInfo = markets[analysis.recommended_market];
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 6e3,
          temperature: 0.4,
          messages: [
            {
              role: "user",
              content: `You are a strategic consultant creating decision points for executive review.

CONTEXT:
${analysis.executive_summary}

ROOT CAUSE: ${analysis.five_whys.root_cause}

RECOMMENDED APPROACHES: ${approachOptions.map((a) => a.label).join(", ")}
RECOMMENDED MARKET: ${marketInfo?.label || analysis.recommended_market}

ORIGINAL INPUT SUMMARY:
${originalInput.substring(0, 1500)}

Create 2-4 strategic decision points that an executive must choose between. Each decision should:
1. Have 2-4 options to choose from
2. Include cost estimates where relevant (in dollars)
3. Include timeline estimates where relevant (in months)
4. Show pros and cons clearly
5. Mark one option as recommended

Decision points should cover:
- Strategic approach selection
- Market entry strategy
- Implementation priorities
- Resource allocation

Return ONLY valid JSON (no markdown, no explanation):

{
  "decisions": [
    {
      "id": "decision_1",
      "title": "Decision Title",
      "question": "Clear question for executive to answer",
      "context": "Why this decision matters (2-3 sentences)",
      "options": [
        {
          "id": "option_1",
          "label": "Option Label",
          "description": "Detailed description of this option",
          "estimated_cost": { "min": 1000000, "max": 2000000 },
          "estimated_timeline_months": 12,
          "pros": ["pro 1", "pro 2", "pro 3"],
          "cons": ["con 1", "con 2"],
          "recommended": true
        }
      ],
      "impact_areas": ["area 1", "area 2"]
    }
  ],
  "decision_flow": "Brief explanation of how these decisions build on each other",
  "estimated_completion_time_minutes": 5
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("Failed to extract JSON from decision generation response");
        }
        const generated = JSON.parse(jsonMatch[0]);
        return this.enrichWithOntologyData(generated, analysis);
      }
      async generateDecisionsWithResearch(analysis, originalInput, researchFindings, portersAnalysis) {
        const approaches = strategyOntologyService.getStrategicApproaches();
        const markets = strategyOntologyService.getMarketContexts();
        const approachOptions = analysis.recommended_approaches.map((id) => {
          const approach = approaches[id];
          return {
            id,
            label: approach?.label || id,
            requires: approach?.requires || [],
            cost_range: approach?.cost_range,
            timeline: approach?.timeline_months
          };
        });
        const marketInfo = markets[analysis.recommended_market];
        const validationMap = /* @__PURE__ */ new Map();
        if (researchFindings.validation) {
          for (const v of researchFindings.validation) {
            validationMap.set(v.claim, v);
          }
        }
        const formatWithValidation = (findings) => findings.map((f) => {
          const validation2 = validationMap.get(f.fact);
          if (validation2 && validation2.strength !== "STRONG") {
            return `${f.fact} [${validation2.strength}: ${validation2.details}]`;
          }
          return f.fact;
        }).join("; ");
        const languageInsights = formatWithValidation(researchFindings.language_preferences);
        const marketDynamics = formatWithValidation(researchFindings.market_dynamics);
        const competitiveInsights = formatWithValidation(researchFindings.competitive_landscape);
        const buyerBehavior = formatWithValidation(researchFindings.buyer_behavior);
        const strategicResponses = [
          portersAnalysis.competitive_rivalry.strategic_response,
          portersAnalysis.supplier_power.strategic_response,
          portersAnalysis.buyer_power.strategic_response,
          portersAnalysis.threat_of_substitution.strategic_response,
          portersAnalysis.threat_of_new_entry.strategic_response
        ].filter(Boolean);
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 8e3,
          temperature: 0.4,
          messages: [
            {
              role: "user",
              content: `You are a strategic consultant creating decision points for executive review.

CRITICAL CONSTRAINT: You must generate decisions that are CONSISTENT WITH RESEARCH FINDINGS.

CONTEXT:
${analysis.executive_summary}

ROOT CAUSE: ${analysis.five_whys.root_cause}

RECOMMENDED APPROACHES: ${approachOptions.map((a) => a.label).join(", ")}
RECOMMENDED MARKET: ${marketInfo?.label || analysis.recommended_market}

ORIGINAL INPUT SUMMARY:
${originalInput.substring(0, 1e3)}

RESEARCH FINDINGS:
Language Preferences: ${languageInsights || "No specific insights"}
Market Dynamics: ${marketDynamics || "No specific insights"}
Competitive Landscape: ${competitiveInsights || "No specific insights"}
Buyer Behavior: ${buyerBehavior || "No specific insights"}

PORTER'S FIVE FORCES STRATEGIC RESPONSES:
${strategicResponses.join("\n")}

CRITICAL VALIDATION RULES:

\u{1F534} WEAK EVIDENCE HANDLING:
- NEVER use WEAK evidence as the PRIMARY reason to mark options as "\u274C Not Recommended"
- If a strategic option conflicts with WEAK evidence, mark it as "\u26A0\uFE0F Requires validation" or "Approach with caution"
- In the reasoning field, explicitly state: "This recommendation is based on contested data [citation]. Further validation recommended before commitment."

Example (WRONG):
Finding: "95% AI pilots fail [WEAK: Single 2021 source, contradicted by recent studies]"
Decision: \u274C Not Recommended - High risk based on 95% failure rate

Example (CORRECT):
Finding: "95% AI pilots fail [WEAK: Single 2021 source, contradicted by recent studies]"
Decision: \u26A0\uFE0F Approach with caution - Earlier studies suggested high failure rates, but this data is contested. Recent evidence shows 53-67% success rates with proper implementation. Recommend pilot program with clear success metrics.

\u{1F7E1} MODERATE EVIDENCE:
- Use as supporting evidence, but acknowledge limitations
- Example: "Research suggests X [MODERATE: 2 sources, 18 months old], though conditions may have evolved"

\u{1F7E2} STRONG EVIDENCE (no validation warning shown):
- Use confidently as primary decision basis
- Multiple recent sources, no contradictions

RULES FOR DECISION OPTIONS:
1. If research CONTRADICTS an assumption from the original input, DO NOT recommend options based on that assumption
2. Prioritize options that align with research findings and Porter's strategic responses
3. Mark as "recommended: true" ONLY options that are supported by research findings
4. If the input mentioned a strategy that research contradicted, include it as an option but mark "recommended: false" and add a "warning" field explaining why
5. Each option must include a "reasoning" field that cites specific research findings or Porter's analysis

EXAMPLE (Arabic language case):
If input said: "Arabic language differentiation"
But research found: "English dominates UAE business (78% of enterprises)"

CORRECT decision structure:
{
  "options": [
    {
      "id": "english_first",
      "label": "English-First Global Alternative",
      "description": "Position as premium English-based platform with optional multilingual support",
      "recommended": true,
      "reasoning": "Research shows English is dominant business language in 78% of UAE enterprises",
      "pros": ["Aligns with market reality", "Lower localization cost", "Faster time to market"],
      "cons": ["May miss niche Arabic-only opportunities"]
    },
    {
      "id": "arabic_focus",
      "label": "Arabic-First Cultural Pioneer",
      "description": "Differentiate through comprehensive Arabic language and cultural features",
      "recommended": false,
      "warning": "Not recommended - contradicts research findings",
      "reasoning": "Research shows English dominates UAE business communications; limited evidence of willingness-to-pay for Arabic-specific features",
      "pros": ["Potential niche differentiation"],
      "cons": ["Contradicts market research", "Higher development cost", "Smaller addressable market"]
    }
  ]
}

Create 2-4 strategic decision points that an executive must choose between. Each decision should:
1. Have 2-4 options to choose from
2. Include cost estimates where relevant (in dollars)
3. Include timeline estimates where relevant (in months)
4. Show pros and cons clearly
5. Mark one option as recommended (the one MOST ALIGNED with research findings)
6. Include reasoning field citing research findings or Porter's analysis
7. Add warning field for options contradicted by research

Decision points should cover:
- Strategic approach selection (informed by Porter's priorities)
- Market entry strategy (informed by research)
- Implementation priorities (informed by competitive landscape)
- Resource allocation (informed by buyer behavior)

Return ONLY valid JSON (no markdown, no explanation):

{
  "decisions": [
    {
      "id": "decision_1",
      "title": "Decision Title",
      "question": "Clear question for executive to answer",
      "context": "Why this decision matters (2-3 sentences)",
      "options": [
        {
          "id": "option_1",
          "label": "Option Label",
          "description": "Detailed description of this option",
          "estimated_cost": { "min": 1000000, "max": 2000000 },
          "estimated_timeline_months": 12,
          "pros": ["pro 1", "pro 2", "pro 3"],
          "cons": ["con 1", "con 2"],
          "recommended": true,
          "reasoning": "Cite specific research finding or Porter's analysis here"
        }
      ],
      "impact_areas": ["area 1", "area 2"]
    }
  ],
  "decision_flow": "Brief explanation of how these decisions build on each other",
  "estimated_completion_time_minutes": 5
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("Failed to extract JSON from research-informed decision generation response");
        }
        const generated = JSON.parse(jsonMatch[0]);
        const validation = this.validateDecisionsAgainstResearch(generated, researchFindings);
        if (!validation.valid) {
          const criticalIssues = validation.issues.filter(
            (issue) => issue.includes("recommends Arabic") || issue.includes("contradicts research")
          );
          if (criticalIssues.length > 0) {
            throw new Error(
              `Decision generation contradicts research findings:
${criticalIssues.join("\n")}

Please regenerate decisions that align with research.`
            );
          }
          console.warn("Decision validation warnings:", validation.issues);
        }
        return this.enrichWithOntologyData(generated, analysis);
      }
      validateDecisionsAgainstResearch(decisions, researchFindings) {
        const issues = [];
        const languageFacts = researchFindings.language_preferences.map((f) => f.fact.toLowerCase());
        const marketFacts = researchFindings.market_dynamics.map((f) => f.fact.toLowerCase());
        decisions.decisions.forEach((decision) => {
          decision.options.forEach((option) => {
            if (option.recommended) {
              const optionText = `${option.label} ${option.description}`.toLowerCase();
              const emphasizesArabic = /arabic|multilingual.*arabic|arabic.*first/i.test(optionText);
              const englishDominates = languageFacts.some((f) => /english.*dominat|english.*preferre|english.*78%|english.*majority/i.test(f));
              if (emphasizesArabic && englishDominates) {
                issues.push(
                  `Option "${option.label}" in decision "${decision.title}" recommends Arabic focus but research shows English dominates business communications`
                );
              }
              if (!option.reasoning) {
                issues.push(
                  `Option "${option.label}" in decision "${decision.title}" is recommended but lacks research-based reasoning`
                );
              }
            }
            if (option.recommended === false && !option.warning) {
              issues.push(
                `Option "${option.label}" in decision "${decision.title}" is not recommended but lacks warning explanation`
              );
            }
          });
        });
        return {
          valid: issues.length === 0,
          issues
        };
      }
      enrichWithOntologyData(decisions, analysis) {
        const enrichedDecisions = decisions.decisions.map((decision) => {
          const enrichedOptions = decision.options.map((option) => {
            if (option.id.includes("approach") || analysis.recommended_approaches.some((a) => option.label.includes(a))) {
              const approachId = analysis.recommended_approaches.find(
                (id) => option.label.toLowerCase().includes(id.replace("_", " "))
              );
              if (approachId) {
                const costEstimate = strategyOntologyService.calculateCostEstimate(
                  approachId,
                  analysis.recommended_market
                );
                if (costEstimate && !option.estimated_cost) {
                  option.estimated_cost = { min: costEstimate.min, max: costEstimate.max };
                  option.estimated_timeline_months = costEstimate.timeline_months;
                }
              }
            }
            return option;
          });
          return {
            ...decision,
            options: enrichedOptions
          };
        });
        return {
          ...decisions,
          decisions: enrichedDecisions
        };
      }
      async generateDecisionsFromBMC(bmcResult, originalInput) {
        const bmcBlocks2 = bmcResult.blocks || [];
        const contradictions = bmcResult.contradictions || [];
        const recommendations = bmcResult.recommendations || [];
        const keyInsights = bmcResult.keyInsights || [];
        const bmcSummary = bmcBlocks2.map(
          (block) => `${block.blockName}: ${block.description}
Findings: ${block.findings.map((f) => f.fact).slice(0, 3).join("; ")}
Confidence: ${block.confidence}`
        ).join("\n\n");
        const contradictionsSummary = contradictions.length > 0 ? `

CONTRADICTIONS FOUND:
${contradictions.map(
          (c) => `- ${c.assumption}: ${c.contradictedBy.map((cb) => cb.fact).join("; ")}`
        ).join("\n")}` : "";
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 8e3,
          temperature: 0.4,
          messages: [
            {
              role: "user",
              content: `You are a strategic consultant creating decision points based on a Business Model Canvas analysis.

ORIGINAL INPUT:
${originalInput.substring(0, 1500)}

BUSINESS MODEL CANVAS ANALYSIS:
${bmcSummary}${contradictionsSummary}

KEY INSIGHTS:
${keyInsights.join("\n")}

RECOMMENDATIONS:
${recommendations.map((r) => `${r.priority}: ${r.action} - ${r.rationale}`).slice(0, 5).join("\n")}

Create 2-4 strategic decision points that an executive must choose between based on this BMC analysis. Each decision should:
1. Have 2-4 options to choose from
2. Include cost estimates where relevant (in dollars)
3. Include timeline estimates where relevant (in months)
4. Show pros and cons clearly
5. Mark one option as recommended
6. Address contradictions found in the analysis

Decision points should cover areas like:
- Customer segment prioritization
- Value proposition differentiation
- Revenue model selection
- Channel strategy
- Resource allocation priorities

Return ONLY valid JSON (no markdown, no explanation):

{
  "decisions": [
    {
      "id": "decision_1",
      "title": "Decision Title",
      "question": "Clear question for executive to answer",
      "context": "Why this decision matters based on BMC analysis (2-3 sentences)",
      "options": [
        {
          "id": "option_1",
          "label": "Option Label",
          "description": "Detailed description of this option",
          "estimated_cost": { "min": 100000, "max": 250000 },
          "estimated_timeline_months": 6,
          "pros": ["pro 1 based on BMC findings", "pro 2", "pro 3"],
          "cons": ["con 1", "con 2"],
          "recommended": true,
          "reasoning": "Why this option is recommended based on BMC analysis"
        }
      ],
      "impact_areas": ["Customer Segments", "Revenue Streams", "etc"]
    }
  ],
  "decision_flow": "Brief explanation of how these decisions build on the BMC analysis",
  "estimated_completion_time_minutes": 5
}`
            }
          ]
        });
        const textContent = response.content.find((block) => block.type === "text");
        if (!textContent) {
          throw new Error("No text content in AI response");
        }
        let responseText = textContent.text.trim();
        const jsonMatch = responseText.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          console.error("Invalid JSON response from AI:", responseText);
          throw new Error("AI did not return valid JSON for BMC decisions");
        }
        const generated = JSON.parse(jsonMatch[0]);
        const validation = await this.validateDecisions(generated);
        if (!validation.valid) {
          console.warn("BMC decision validation warnings:", validation.issues);
        }
        return generated;
      }
      async generateDecisionsFromSWOT(swotOutput, businessContext) {
        console.log("[DecisionGenerator] Generating decisions from SWOT analysis...");
        if (!swotOutput || !Array.isArray(swotOutput.strengths) || !Array.isArray(swotOutput.weaknesses)) {
          throw new Error("Invalid SWOT output: missing required strengths/weaknesses arrays");
        }
        const strengths = swotOutput.strengths || [];
        const weaknesses = swotOutput.weaknesses || [];
        const opportunities = swotOutput.opportunities || [];
        const threats = swotOutput.threats || [];
        const strategicOptions = swotOutput.strategicOptions || { soStrategies: [], woStrategies: [], stStrategies: [], wtStrategies: [] };
        const priorityActions = swotOutput.priorityActions || [];
        console.log(`[DecisionGenerator] SWOT data: ${strengths.length} strengths, ${weaknesses.length} weaknesses, ${opportunities.length} opportunities, ${threats.length} threats`);
        const strengthsSummary = strengths.map((s) => `- ${s.factor} (${s.importance}): ${s.description}${s.evidence ? ` [Evidence: ${s.evidence}]` : ""}`).join("\n");
        const weaknessesSummary = weaknesses.map((w) => `- ${w.factor} (${w.importance}): ${w.description}${w.evidence ? ` [Evidence: ${w.evidence}]` : ""}`).join("\n");
        const opportunitiesSummary = opportunities.map((o) => `- ${o.factor} (${o.importance}): ${o.description}${o.evidence ? ` [Evidence: ${o.evidence}]` : ""}`).join("\n");
        const threatsSummary = threats.map((t) => `- ${t.factor} (${t.importance}): ${t.description}${t.evidence ? ` [Evidence: ${t.evidence}]` : ""}`).join("\n");
        const strategicOptionsSummary = `
SO Strategies (Leverage Strengths for Opportunities): ${strategicOptions.soStrategies.join("; ")}
WO Strategies (Address Weaknesses via Opportunities): ${strategicOptions.woStrategies.join("; ")}
ST Strategies (Use Strengths to Counter Threats): ${strategicOptions.stStrategies.join("; ")}
WT Strategies (Minimize Weaknesses, Avoid Threats): ${strategicOptions.wtStrategies.join("; ")}
`;
        const priorityActionsSummary = priorityActions.length > 0 ? `
PRIORITY ACTIONS:
${priorityActions.map((a, i) => `${i + 1}. ${a}`).join("\n")}` : "";
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 8e3,
          temperature: 0.4,
          messages: [
            {
              role: "user",
              content: `You are a strategic consultant creating decision points based on a comprehensive SWOT analysis.

BUSINESS CONTEXT:
${businessContext.substring(0, 1500)}

SWOT ANALYSIS RESULTS:

STRENGTHS:
${strengthsSummary || "None identified"}

WEAKNESSES:
${weaknessesSummary || "None identified"}

OPPORTUNITIES:
${opportunitiesSummary || "None identified"}

THREATS:
${threatsSummary || "None identified"}

STRATEGIC OPTIONS IDENTIFIED:
${strategicOptionsSummary}
${priorityActionsSummary}

Create 2-4 strategic decision points that an executive must choose between based on this SWOT analysis. Each decision should:
1. Have 2-4 options to choose from
2. Include cost estimates where relevant (in dollars)
3. Include timeline estimates where relevant (in months)
4. Show pros and cons that directly reference the SWOT findings
5. Mark one option as recommended based on the analysis
6. Leverage identified strengths and opportunities while addressing weaknesses and threats

Decision points should address:
- Which strategic direction to pursue (SO, WO, ST, or WT focus)
- Resource allocation priorities
- Risk mitigation approach
- Growth vs consolidation trade-offs

Return ONLY valid JSON (no markdown, no explanation):

{
  "decisions": [
    {
      "id": "decision_1",
      "title": "Strategic Direction",
      "question": "Based on the SWOT analysis, which strategic direction should we prioritize?",
      "context": "Why this decision matters based on SWOT analysis (2-3 sentences referencing specific findings)",
      "options": [
        {
          "id": "option_1",
          "label": "Option Label",
          "description": "Detailed description referencing specific SWOT findings",
          "estimated_cost": { "min": 100000, "max": 250000 },
          "estimated_timeline_months": 6,
          "pros": ["Leverages [specific strength]", "Addresses [specific opportunity]"],
          "cons": ["Exposed to [specific threat]", "Limited by [specific weakness]"],
          "recommended": true,
          "reasoning": "Why this option is recommended based on SWOT alignment"
        }
      ],
      "impact_areas": ["Market Position", "Operations", "Risk Profile"]
    }
  ],
  "decision_flow": "How these decisions connect to the SWOT strategic options",
  "estimated_completion_time_minutes": 5
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          console.error("[DecisionGenerator] Failed to extract JSON from SWOT decision generation");
          throw new Error("Failed to extract JSON from SWOT decision generation response");
        }
        const generated = JSON.parse(jsonMatch[0]);
        const validation = await this.validateDecisions(generated);
        if (!validation.valid) {
          console.warn("[DecisionGenerator] SWOT decision validation issues:", validation.issues);
        }
        console.log(`[DecisionGenerator] Generated ${generated.decisions.length} decision points from SWOT`);
        return generated;
      }
      async validateDecisions(decisions) {
        const issues = [];
        if (decisions.decisions.length < 2) {
          issues.push("Must have at least 2 decision points");
        }
        if (decisions.decisions.length > 4) {
          issues.push("Should have at most 4 decision points");
        }
        for (const decision of decisions.decisions) {
          if (decision.options.length < 2) {
            issues.push(`Decision "${decision.title}" must have at least 2 options`);
          }
          if (decision.options.length > 4) {
            issues.push(`Decision "${decision.title}" should have at most 4 options`);
          }
          const recommendedCount = decision.options.filter((o) => o.recommended).length;
          if (recommendedCount === 0) {
            issues.push(`Decision "${decision.title}" should have one recommended option`);
          }
          if (recommendedCount > 1) {
            issues.push(`Decision "${decision.title}" should have only one recommended option`);
          }
        }
        return {
          valid: issues.length === 0,
          issues
        };
      }
    };
  }
});

// server/utils/golden-record-sanitizer.ts
function isSensitiveField(fieldName) {
  const lowerField = fieldName.toLowerCase();
  const allPatterns = [
    ...SENSITIVE_PATTERNS.tokens,
    ...SENSITIVE_PATTERNS.apiKeys,
    ...SENSITIVE_PATTERNS.pii,
    ...SENSITIVE_PATTERNS.business
  ];
  return allPatterns.some((pattern) => lowerField.includes(pattern));
}
function sanitizeObject(obj, depth = 0) {
  if (depth > 10) return "[REDACTED: MAX_DEPTH]";
  if (obj === null || obj === void 0) return obj;
  if (Array.isArray(obj)) {
    return obj.map((item) => sanitizeObject(item, depth + 1));
  }
  if (typeof obj === "object") {
    const sanitized = {};
    for (const [key, value] of Object.entries(obj)) {
      if (isSensitiveField(key)) {
        sanitized[key] = "[REDACTED]";
      } else if (typeof value === "object") {
        sanitized[key] = sanitizeObject(value, depth + 1);
      } else {
        sanitized[key] = value;
      }
    }
    return sanitized;
  }
  return obj;
}
function sanitizeRequestPayload(payload) {
  if (!payload) return null;
  const sanitized = sanitizeObject(payload);
  if (sanitized.headers) {
    delete sanitized.headers.authorization;
    delete sanitized.headers.Authorization;
    delete sanitized.headers.cookie;
    delete sanitized.headers.Cookie;
  }
  return sanitized;
}
function sanitizeResponsePayload(payload) {
  if (!payload) return null;
  return sanitizeObject(payload);
}
async function sanitizeDbSnapshot(snapshot) {
  if (!snapshot) return null;
  const sanitized = sanitizeObject(snapshot);
  const encrypted = await encryptJSONKMS(sanitized);
  return encrypted;
}
async function sanitizeGoldenRecordStep(step) {
  return {
    stepName: step.stepName,
    expectedUrl: step.expectedUrl,
    screenshotPath: step.screenshotPath,
    requestPayload: step.requestPayload ? sanitizeRequestPayload(step.requestPayload) : null,
    responsePayload: step.responsePayload ? sanitizeResponsePayload(step.responsePayload) : null,
    dbSnapshot: step.dbSnapshot ? await sanitizeDbSnapshot(step.dbSnapshot) : null,
    observations: step.observations || null
  };
}
var SENSITIVE_PATTERNS;
var init_golden_record_sanitizer = __esm({
  "server/utils/golden-record-sanitizer.ts"() {
    "use strict";
    init_kms_encryption();
    SENSITIVE_PATTERNS = {
      // Auth & Secrets
      tokens: ["token", "authorization", "auth", "bearer", "jwt", "session"],
      apiKeys: ["api_key", "apikey", "api-key", "secret", "password", "pwd"],
      // Personal Data
      pii: ["email", "phone", "ssn", "social_security", "credit_card", "address"],
      // Business Sensitive
      business: ["revenue", "profit", "salary", "compensation", "pricing_strategy"]
    };
  }
});

// server/config/neo4j.ts
var neo4j_exports = {};
__export(neo4j_exports, {
  closeNeo4j: () => closeNeo4j,
  createSession: () => createSession,
  getDriver: () => getDriver,
  initializeNeo4j: () => initializeNeo4j,
  verifyConnection: () => verifyConnection
});
import neo4j from "neo4j-driver";
function initializeNeo4j(config) {
  if (driver) {
    return driver;
  }
  driver = neo4j.driver(
    config.uri,
    neo4j.auth.basic(config.username, config.password),
    {
      maxConnectionLifetime: 30 * 60 * 1e3,
      // 30 minutes
      maxConnectionPoolSize: 50,
      connectionAcquisitionTimeout: 60 * 1e3
      // 60 seconds
    }
  );
  console.log("[Neo4j] Driver initialized");
  return driver;
}
function getDriver() {
  if (!driver) {
    const config = {
      uri: process.env.NEO4J_URI || "",
      username: process.env.NEO4J_USERNAME || "neo4j",
      password: process.env.NEO4J_PASSWORD || "",
      database: process.env.NEO4J_DATABASE || "neo4j"
    };
    if (!config.uri || !config.password) {
      throw new Error("Neo4j configuration is missing. Set NEO4J_URI and NEO4J_PASSWORD environment variables.");
    }
    driver = initializeNeo4j(config);
  }
  return driver;
}
function createSession(database) {
  const db2 = database || process.env.NEO4J_DATABASE || "neo4j";
  return getDriver().session({ database: db2 });
}
async function closeNeo4j() {
  if (driver) {
    await driver.close();
    driver = null;
    console.log("[Neo4j] Driver closed");
  }
}
async function verifyConnection() {
  const session3 = createSession();
  try {
    await session3.run("RETURN 1");
    console.log("[Neo4j] Connection verified");
    return true;
  } catch (error) {
    console.error("[Neo4j] Connection failed:", error);
    return false;
  } finally {
    await session3.close();
  }
}
var driver;
var init_neo4j = __esm({
  "server/config/neo4j.ts"() {
    "use strict";
    driver = null;
  }
});

// server/services/knowledge-graph-service.ts
var knowledge_graph_service_exports = {};
__export(knowledge_graph_service_exports, {
  checkJourneySessionExists: () => checkJourneySessionExists,
  closeDriver: () => closeDriver,
  createEvidenceLinks: () => createEvidenceLinks,
  getAvailableIncentives: () => getAvailableIncentives,
  getInsightsForSession: () => getInsightsForSession,
  getSimilarJourneys: () => getSimilarJourneys,
  linkJourneyToIncentives: () => linkJourneyToIncentives,
  linkJourneyToRegulations: () => linkJourneyToRegulations,
  upsertDecision: () => upsertDecision,
  upsertDecisionOptions: () => upsertDecisionOptions,
  upsertFrameworkOutput: () => upsertFrameworkOutput,
  upsertJourneySession: () => upsertJourneySession,
  upsertNodes: () => upsertNodes,
  upsertProgram: () => upsertProgram,
  upsertRelationships: () => upsertRelationships
});
async function upsertNodes(nodes) {
  if (nodes.length === 0) return;
  const session3 = createSession();
  try {
    const nodesByLabel = nodes.reduce((acc, node) => {
      if (!acc[node.label]) acc[node.label] = [];
      acc[node.label].push(node);
      return acc;
    }, {});
    for (const [label, labelNodes] of Object.entries(nodesByLabel)) {
      const sampleNode = labelNodes[0];
      const matchKey = sampleNode.matchOn.id ? "id" : sampleNode.matchOn.extId ? "extId" : sampleNode.matchOn.sourceKey ? "sourceKey" : "id";
      const query = `
        UNWIND $batch as row
        MERGE (n:${label} {${matchKey}: row.matchValue})
        SET n += row.properties
        RETURN count(n) as created
      `;
      const batch = labelNodes.map((node) => ({
        matchValue: node.matchOn.id || node.matchOn.extId || node.matchOn.sourceKey,
        properties: node.properties
      }));
      const result = await session3.run(query, { batch });
      const created = result.records[0]?.get("created").toNumber() || 0;
      console.log(`[KG Service] Upserted ${created} ${label} nodes`);
    }
  } finally {
    await session3.close();
  }
}
async function upsertRelationships(rels) {
  if (rels.length === 0) return;
  const session3 = createSession();
  try {
    for (const rel of rels) {
      const fromKey = rel.from.matchOn.id ? "id" : rel.from.matchOn.extId ? "extId" : rel.from.matchOn.sourceKey ? "sourceKey" : "id";
      const toKey = rel.to.matchOn.id ? "id" : rel.to.matchOn.extId ? "extId" : rel.to.matchOn.sourceKey ? "sourceKey" : "id";
      const fromValue = rel.from.matchOn.id || rel.from.matchOn.extId || rel.from.matchOn.sourceKey;
      const toValue = rel.to.matchOn.id || rel.to.matchOn.extId || rel.to.matchOn.sourceKey;
      const query = `
        MATCH (from:${rel.from.label} {${fromKey}: $fromValue})
        MATCH (to:${rel.to.label} {${toKey}: $toValue})
        MERGE (from)-[r:${rel.type}]->(to)
        ${rel.properties ? "SET r += $properties" : ""}
        RETURN count(r) as created
      `;
      await session3.run(query, {
        fromValue,
        toValue,
        properties: rel.properties || {}
      });
    }
    console.log(`[KG Service] Upserted ${rels.length} relationships`);
  } finally {
    await session3.close();
  }
}
async function upsertJourneySession(data) {
  const nodes = [{
    label: "JourneySession",
    matchOn: { id: data.id },
    properties: data
  }];
  await upsertNodes(nodes);
  const rels = [];
  if (data.locationId) {
    rels.push({
      from: { label: "JourneySession", matchOn: { id: data.id } },
      type: "LOCATED_IN",
      to: { label: "Location", matchOn: { id: data.locationId } }
    });
  }
  if (data.jurisdictionId) {
    rels.push({
      from: { label: "JourneySession", matchOn: { id: data.id } },
      type: "UNDER",
      to: { label: "Jurisdiction", matchOn: { id: data.jurisdictionId } }
    });
  }
  if (data.industryId) {
    rels.push({
      from: { label: "JourneySession", matchOn: { id: data.id } },
      type: "TARGETS_INDUSTRY",
      to: { label: "Industry", matchOn: { id: data.industryId } }
    });
  }
  if (rels.length > 0) {
    await upsertRelationships(rels);
  }
}
async function upsertFrameworkOutput(data) {
  const nodes = [{
    label: "FrameworkOutput",
    matchOn: { id: data.id },
    properties: data
  }];
  await upsertNodes(nodes);
  const rels = [{
    from: { label: "JourneySession", matchOn: { id: data.journeyId } },
    type: "PRODUCED_FRAMEWORK",
    to: { label: "FrameworkOutput", matchOn: { id: data.id } }
  }];
  await upsertRelationships(rels);
}
async function upsertDecision(data) {
  const nodes = [{
    label: "Decision",
    matchOn: { id: data.id },
    properties: data
  }];
  await upsertNodes(nodes);
}
async function upsertDecisionOptions(data) {
  if (data.length === 0) return;
  const nodes = data.map((option) => ({
    label: "DecisionOption",
    matchOn: { id: option.id },
    properties: option
  }));
  await upsertNodes(nodes);
  const rels = data.map((option) => ({
    from: { label: "Decision", matchOn: { id: option.decisionId } },
    type: "HAS_CRITERION",
    to: { label: "DecisionOption", matchOn: { id: option.id } }
  }));
  await upsertRelationships(rels);
}
async function upsertProgram(data) {
  const nodes = [{
    label: "Program",
    matchOn: { id: data.id },
    properties: data
  }];
  await upsertNodes(nodes);
  const rels = [{
    from: { label: "JourneySession", matchOn: { id: data.journeyId } },
    type: "GENERATED_PROGRAM",
    to: { label: "Program", matchOn: { id: data.id } }
  }];
  if (data.locationId) {
    rels.push({
      from: { label: "Program", matchOn: { id: data.id } },
      type: "LOCATED_IN",
      to: { label: "Location", matchOn: { id: data.locationId } }
    });
  }
  await upsertRelationships(rels);
}
async function linkJourneyToIncentives(journeyId, incentiveIds) {
  if (incentiveIds.length === 0) return;
  const rels = incentiveIds.map((incentiveId) => ({
    from: { label: "Program", matchOn: { id: journeyId } },
    type: "ELIGIBLE_FOR",
    to: { label: "Incentive", matchOn: { id: incentiveId } }
  }));
  await upsertRelationships(rels);
}
async function linkJourneyToRegulations(journeyId, regulationIds) {
  if (regulationIds.length === 0) return;
  const rels = regulationIds.map((regulationId) => ({
    from: { label: "Program", matchOn: { id: journeyId } },
    type: "CONSTRAINED_BY",
    to: { label: "Regulation", matchOn: { id: regulationId } }
  }));
  await upsertRelationships(rels);
}
async function createEvidenceLinks(decisionId, evidenceList) {
  if (evidenceList.length === 0) return;
  const evidenceNodes = evidenceList.map((evidence) => ({
    label: "Evidence",
    matchOn: { id: evidence.id },
    properties: {
      ...evidence,
      createdAt: (/* @__PURE__ */ new Date()).toISOString()
    }
  }));
  await upsertNodes(evidenceNodes);
  const decisionRels = evidenceList.map((evidence) => ({
    from: { label: "Decision", matchOn: { id: decisionId } },
    type: "SUPPORTED_BY",
    to: { label: "Evidence", matchOn: { id: evidence.id } }
  }));
  await upsertRelationships(decisionRels);
  const referenceRels = evidenceList.filter((e) => e.referenceId).map((evidence) => ({
    from: { label: "Evidence", matchOn: { id: evidence.id } },
    type: "CITES",
    to: { label: "Reference", matchOn: { id: evidence.referenceId } }
  }));
  if (referenceRels.length > 0) {
    await upsertRelationships(referenceRels);
  }
}
async function getSimilarJourneys(params) {
  const { locationId, industryId, rootCause, limit = 10 } = params;
  const session3 = createSession();
  try {
    const query = `
      MATCH (j:JourneySession)
      ${locationId ? "MATCH (j)-[:LOCATED_IN]->(loc:Location {id: $locationId})" : ""}
      ${industryId ? "MATCH (j)-[:TARGETS_INDUSTRY]->(ind:Industry {id: $industryId})" : ""}
      OPTIONAL MATCH (j)-[:LOCATED_IN]->(location:Location)
      OPTIONAL MATCH (j)-[:TARGETS_INDUSTRY]->(industry:Industry)
      OPTIONAL MATCH (j)-[:GENERATED_PROGRAM]->(p:Program)
      OPTIONAL MATCH (j)-[:PRODUCED_FRAMEWORK]->(f:FrameworkOutput)
      RETURN j.id as id,
             j.journeyType as journeyType,
             j.versionNumber as versionNumber,
             j.createdAt as createdAt,
             location.name as locationName,
             industry.name as industryName,
             p.status as programStatus,
             collect(DISTINCT f.framework) as frameworks
      ORDER BY j.createdAt DESC
      LIMIT $limit
    `;
    const result = await session3.run(query, { locationId, industryId, limit });
    return result.records.map((record) => ({
      id: record.get("id"),
      journeyType: record.get("journeyType"),
      locationName: record.get("locationName"),
      industryName: record.get("industryName"),
      versionNumber: record.get("versionNumber"),
      createdAt: record.get("createdAt"),
      programStatus: record.get("programStatus"),
      frameworks: record.get("frameworks")
    }));
  } finally {
    await session3.close();
  }
}
async function getAvailableIncentives(params) {
  const { jurisdictionId, industryId, limit = 20 } = params;
  const session3 = createSession();
  try {
    const query = `
      MATCH (i:Incentive)
      ${jurisdictionId ? "MATCH (i)-[:AVAILABLE_IN]->(j:Jurisdiction {id: $jurisdictionId})" : ""}
      WHERE i.expiryDate IS NULL OR datetime(i.expiryDate) > datetime()
      RETURN i.id as id,
             i.name as name,
             i.provider as provider,
             i.description as description,
             i.eligibilitySummary as eligibilitySummary,
             i.benefits as benefits,
             i.url as url,
             i.expiryDate as expiryDate
      ORDER BY i.name
      LIMIT $limit
    `;
    const result = await session3.run(query, { jurisdictionId, limit });
    return result.records.map((record) => ({
      id: record.get("id"),
      name: record.get("name"),
      provider: record.get("provider"),
      description: record.get("description"),
      eligibilitySummary: record.get("eligibilitySummary"),
      benefits: record.get("benefits"),
      url: record.get("url"),
      expiryDate: record.get("expiryDate")
    }));
  } finally {
    await session3.close();
  }
}
async function checkJourneySessionExists(sessionId) {
  const session3 = createSession();
  try {
    const query = `
      MATCH (j:JourneySession {id: $sessionId})
      RETURN count(j) > 0 as exists
    `;
    const result = await session3.run(query, { sessionId });
    return result.records[0]?.get("exists") || false;
  } finally {
    await session3.close();
  }
}
async function getInsightsForSession(sessionId, params) {
  const { locationId, industryId, jurisdictionId, rootCause } = params;
  const [similarStrategies, incentives] = await Promise.all([
    getSimilarJourneys({
      locationId,
      industryId,
      rootCause,
      limit: 3
      // Top 3 similar strategies
    }),
    getAvailableIncentives({
      jurisdictionId,
      industryId,
      locationId,
      limit: 10
      // Top 10 incentives
    })
  ]);
  const regulations = [];
  return {
    similarStrategies,
    incentives,
    regulations
  };
}
async function closeDriver() {
  const { closeNeo4j: closeNeo4j2 } = await Promise.resolve().then(() => (init_neo4j(), neo4j_exports));
  await closeNeo4j2();
}
var init_knowledge_graph_service = __esm({
  "server/services/knowledge-graph-service.ts"() {
    "use strict";
    init_neo4j();
  }
});

// server/utils/golden-records-service.ts
var golden_records_service_exports = {};
__export(golden_records_service_exports, {
  compareSteps: () => compareSteps,
  fetchJourneySessionData: () => fetchJourneySessionData,
  fetchStrategyVersionData: () => fetchStrategyVersionData,
  generateDiffSummary: () => generateDiffSummary,
  prepareGoldenRecordForAPI: () => prepareGoldenRecordForAPI,
  pushGoldenRecordToKnowledgeGraph: () => pushGoldenRecordToKnowledgeGraph,
  sanitizeGoldenRecordData: () => sanitizeGoldenRecordData,
  saveGoldenRecordToFile: () => saveGoldenRecordToFile
});
import { eq as eq6, desc as desc3 } from "drizzle-orm";
import { mkdir, writeFile } from "fs/promises";
import { join as join2 } from "path";
async function fetchJourneySessionData(sessionId) {
  const session3 = await getJourneySession(sessionId);
  if (!session3 || !session3.id || !session3.understandingId) {
    console.error(`[Golden Records] Journey session not found or missing understandingId: ${sessionId}`);
    return null;
  }
  const understanding = await getStrategicUnderstanding(session3.understandingId);
  if (!understanding) {
    console.error(`[Golden Records] Strategic understanding not found: ${session3.understandingId}`);
    return null;
  }
  const versions = await db.select().from(strategyVersions).where(eq6(strategyVersions.sessionId, sessionId)).orderBy(desc3(strategyVersions.versionNumber));
  const epmProgram = versions.length > 0 ? await db.select().from(epmPrograms).where(eq6(epmPrograms.strategyVersionId, versions[0].id)).limit(1) : [];
  const steps = [];
  const latestVersion = versions.length > 0 ? versions[0] : null;
  const epmProgramRow = epmProgram.length > 0 ? epmProgram[0] : null;
  const detectedFrameworks = [];
  if (session3.journeyType === "business_model_innovation") {
    const fiveWhysRootCauses = session3.accumulatedContext?.insights?.rootCauses;
    const fiveWhysFromAnalysis = latestVersion?.analysisData?.five_whys;
    if (fiveWhysRootCauses || fiveWhysFromAnalysis) {
      steps.push({
        stepName: "five_whys",
        frameworkType: "five_whys",
        expectedUrl: `/strategic-consultant/whys-tree/${session3.id}`,
        responsePayload: {
          rootCauses: fiveWhysRootCauses,
          rootCause: fiveWhysFromAnalysis?.root_cause
        },
        observations: "Five Whys completed",
        completedAt: session3.completedAt ?? latestVersion?.createdAt ?? void 0
      });
      detectedFrameworks.push("five_whys");
    }
    if (latestVersion?.analysisData?.bmc_research) {
      steps.push({
        stepName: "bmc_research",
        frameworkType: "bmc",
        expectedUrl: `/strategic-consultant/research/${session3.id}`,
        responsePayload: {
          keyInsights: latestVersion.analysisData.bmc_research.keyInsights,
          criticalGaps: latestVersion.analysisData.bmc_research.criticalGaps
        },
        observations: "BMC research stream completed",
        completedAt: latestVersion.updatedAt ?? latestVersion.createdAt ?? void 0
      });
      detectedFrameworks.push("bmc");
    }
    if (latestVersion?.decisionsData?.decisions?.length) {
      steps.push({
        stepName: "strategic_decisions",
        expectedUrl: `/strategy-workspace/decisions/${session3.id}/${latestVersion.versionNumber}`,
        responsePayload: latestVersion.decisionsData.decisions.map((d) => ({
          id: d.id,
          title: d.title,
          options: d.options?.length ?? 0
        })),
        observations: "Decisions generated and ready for prioritization"
      });
    }
    if (latestVersion?.selectedDecisions) {
      steps.push({
        stepName: "prioritization",
        expectedUrl: `/strategy-workspace/prioritization/${session3.id}/${latestVersion.versionNumber}`,
        responsePayload: latestVersion.selectedDecisions,
        observations: "Prioritized initiatives saved"
      });
    }
    if (epmProgramRow) {
      steps.push({
        stepName: "epm_generation",
        expectedUrl: `/strategy-workspace/epm/${epmProgramRow.id}`,
        responsePayload: {
          programId: epmProgramRow.id,
          status: epmProgramRow.status,
          workstreams: Array.isArray(epmProgramRow.workstreams) ? epmProgramRow.workstreams.length : 0
        },
        observations: "EPM program generated successfully",
        completedAt: epmProgramRow.createdAt ?? void 0
      });
    }
  } else {
    if (session3.completedFrameworks && session3.completedFrameworks.length > 0) {
      for (const framework of session3.completedFrameworks) {
        steps.push({
          stepName: `${framework}_analysis`,
          frameworkType: framework,
          completedAt: session3.completedAt || void 0,
          observations: `Completed ${framework} framework analysis`
        });
      }
    }
    if (latestVersion) {
      steps.push({
        stepName: "strategy_version_created",
        responsePayload: {
          versionNumber: latestVersion.versionNumber,
          status: latestVersion.status
        },
        completedAt: latestVersion.createdAt || void 0,
        observations: `Strategy version ${latestVersion.versionNumber} created`
      });
    }
    if (epmProgramRow) {
      steps.push({
        stepName: "epm_generated",
        responsePayload: {
          programId: epmProgramRow.id,
          status: epmProgramRow.status,
          workstreamCount: Array.isArray(epmProgramRow.workstreams) ? epmProgramRow.workstreams.length : 0
        },
        completedAt: epmProgramRow.createdAt || void 0,
        observations: "EPM program generated successfully"
      });
    }
  }
  return {
    journeyType: session3.journeyType,
    sessionId: session3.id,
    understandingId: session3.understandingId,
    versionNumber: session3.versionNumber || 1,
    steps,
    metadata: {
      userInput: understanding.userInput,
      initiativeType: understanding.initiativeType || void 0,
      completedAt: session3.completedAt || void 0,
      frameworks: detectedFrameworks.length > 0 ? detectedFrameworks : session3.completedFrameworks || []
    }
  };
}
function isLegacySessionId(sessionId) {
  return sessionId.startsWith("session-") && /session-\d+-/.test(sessionId);
}
async function fetchLegacySessionData(version) {
  const [understanding] = await db.select().from(strategicUnderstanding).where(eq6(strategicUnderstanding.sessionId, version.sessionId)).limit(1);
  if (!understanding) {
    console.error(`[Golden Records] Strategic understanding not found for legacy session: ${version.sessionId}`);
    return null;
  }
  const epmProgram = await db.select().from(epmPrograms).where(eq6(epmPrograms.strategyVersionId, version.id)).limit(1);
  const epmProgramRow = epmProgram.length > 0 ? epmProgram[0] : null;
  const steps = [];
  const detectedFrameworks = [];
  const fiveWhysData = version.analysisData?.five_whys;
  if (fiveWhysData) {
    steps.push({
      stepName: "five_whys",
      frameworkType: "five_whys",
      expectedUrl: `/strategic-consultant/whys-tree/${version.sessionId}`,
      responsePayload: {
        rootCause: fiveWhysData.root_cause,
        whyLevels: fiveWhysData.why_levels
      },
      observations: "Five Whys completed",
      completedAt: version.createdAt ?? void 0
    });
    detectedFrameworks.push("five_whys");
  }
  const bmcResearch = version.analysisData?.bmc_research;
  if (bmcResearch) {
    steps.push({
      stepName: "bmc_research",
      frameworkType: "bmc",
      expectedUrl: `/strategic-consultant/research/${version.sessionId}`,
      responsePayload: {
        keyInsights: bmcResearch.keyInsights,
        criticalGaps: bmcResearch.criticalGaps
      },
      observations: "BMC research stream completed",
      completedAt: version.updatedAt ?? version.createdAt ?? void 0
    });
    detectedFrameworks.push("bmc");
  }
  if (version.decisionsData?.decisions?.length) {
    steps.push({
      stepName: "strategic_decisions",
      expectedUrl: `/strategy-workspace/decisions/${version.sessionId}/${version.versionNumber}`,
      responsePayload: version.decisionsData.decisions.map((d) => ({
        id: d.id,
        title: d.title,
        options: d.options?.length ?? 0
      })),
      observations: "Decisions generated and ready for prioritization"
    });
  }
  if (version.selectedDecisions) {
    steps.push({
      stepName: "prioritization",
      expectedUrl: `/strategy-workspace/prioritization/${version.sessionId}/${version.versionNumber}`,
      responsePayload: version.selectedDecisions,
      observations: "Prioritized initiatives saved"
    });
  }
  if (epmProgramRow) {
    steps.push({
      stepName: "epm_generation",
      expectedUrl: `/strategy-workspace/epm/${epmProgramRow.id}`,
      responsePayload: {
        programId: epmProgramRow.id,
        status: epmProgramRow.status,
        workstreams: Array.isArray(epmProgramRow.workstreams) ? epmProgramRow.workstreams.length : 0
      },
      observations: "EPM program generated successfully",
      completedAt: epmProgramRow.createdAt ?? void 0
    });
  }
  return {
    journeyType: "business_model_innovation",
    sessionId: version.sessionId,
    understandingId: understanding.id,
    versionNumber: version.versionNumber || 1,
    steps,
    metadata: {
      userInput: understanding.userInput,
      initiativeType: understanding.initiativeType || void 0,
      completedAt: version.finalizedAt || version.updatedAt || void 0,
      frameworks: detectedFrameworks
    }
  };
}
async function fetchStrategyVersionData(strategyVersionId) {
  const [version] = await db.select().from(strategyVersions).where(eq6(strategyVersions.id, strategyVersionId)).limit(1);
  if (!version) {
    console.error(`[Golden Records] Strategy version not found: ${strategyVersionId}`);
    return null;
  }
  if (isLegacySessionId(version.sessionId)) {
    console.log(`[Golden Records] Detected legacy session ID: ${version.sessionId}`);
    return fetchLegacySessionData(version);
  }
  return fetchJourneySessionData(version.sessionId);
}
async function sanitizeGoldenRecordData(data) {
  const sanitizedSteps = await Promise.all(
    data.steps.map((step) => sanitizeGoldenRecordStep(step))
  );
  return {
    ...data,
    steps: sanitizedSteps,
    metadata: {
      ...data.metadata,
      // Remove sensitive user input, keep only summary info
      userInput: void 0
    }
  };
}
async function saveGoldenRecordToFile(data, notes) {
  const outputDir = join2(process.cwd(), "scripts", "output", "golden-records", data.journeyType);
  await mkdir(outputDir, { recursive: true });
  const timestamp2 = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
  const filename = `v${data.versionNumber}_${timestamp2}.json`;
  const filepath = join2(outputDir, filename);
  const output = {
    ...data,
    notes,
    capturedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
  await writeFile(filepath, JSON.stringify(output, null, 2), "utf-8");
  console.log(`[Golden Records] Saved to: ${filepath}`);
  return filepath;
}
function compareSteps(step1, step2) {
  const differences = [];
  if (step1.stepName !== step2.stepName) {
    differences.push(`Step name mismatch: "${step1.stepName}" vs "${step2.stepName}"`);
  }
  if (step1.frameworkType !== step2.frameworkType) {
    differences.push(`Framework type mismatch: "${step1.frameworkType}" vs "${step2.frameworkType}"`);
  }
  if (step1.responsePayload && step2.responsePayload) {
    const keys1 = Object.keys(step1.responsePayload);
    const keys2 = Object.keys(step2.responsePayload);
    const missingKeys = keys1.filter((k) => !keys2.includes(k));
    const extraKeys = keys2.filter((k) => !keys1.includes(k));
    if (missingKeys.length > 0) {
      differences.push(`Missing keys in step2: ${missingKeys.join(", ")}`);
    }
    if (extraKeys.length > 0) {
      differences.push(`Extra keys in step2: ${extraKeys.join(", ")}`);
    }
  } else if (step1.responsePayload || step2.responsePayload) {
    differences.push("Response payload presence mismatch");
  }
  return {
    match: differences.length === 0,
    differences
  };
}
function generateDiffSummary(baseline, current) {
  const baselineSteps = baseline.steps.map((s) => s.stepName);
  const currentSteps = current.steps.map((s) => s.stepName);
  const added = currentSteps.filter((s) => !baselineSteps.includes(s));
  const removed = baselineSteps.filter((s) => !currentSteps.includes(s));
  const modified = [];
  const commonSteps = baselineSteps.filter((s) => currentSteps.includes(s));
  for (const stepName of commonSteps) {
    const step1 = baseline.steps.find((s) => s.stepName === stepName);
    const step2 = current.steps.find((s) => s.stepName === stepName);
    const comparison = compareSteps(step1, step2);
    if (!comparison.match) {
      modified.push({
        step: stepName,
        differences: comparison.differences
      });
    }
  }
  const match = added.length === 0 && removed.length === 0 && modified.length === 0;
  let summary = match ? "\u2713 Journey matches golden record" : "\u2717 Journey differs from golden record";
  if (!match) {
    summary += "\n";
    if (added.length > 0) {
      summary += `
  Added steps: ${added.join(", ")}`;
    }
    if (removed.length > 0) {
      summary += `
  Removed steps: ${removed.length}`;
    }
    if (modified.length > 0) {
      summary += `
  Modified steps: ${modified.map((m) => m.step).join(", ")}`;
    }
  }
  return {
    match,
    added,
    removed,
    modified,
    summary
  };
}
function prepareGoldenRecordForAPI(data, notes, promoteAsCurrent = false, parentVersion) {
  return {
    journeyType: data.journeyType,
    notes,
    steps: data.steps,
    metadata: {
      ...data.metadata,
      versionNumber: data.versionNumber,
      sessionId: data.sessionId,
      understandingId: data.understandingId
    },
    promoteAsCurrent,
    parentVersion
  };
}
async function pushGoldenRecordToKnowledgeGraph(data) {
  try {
    const { isKnowledgeGraphEnabled: isKnowledgeGraphEnabled2, isNeo4jConfigured: isNeo4jConfigured2 } = await Promise.resolve().then(() => (init_config(), config_exports));
    if (!isKnowledgeGraphEnabled2()) {
      console.log("[KG] Knowledge Graph feature disabled (FEATURE_KNOWLEDGE_GRAPH not set)");
      return { success: false, error: "Feature disabled" };
    }
    if (!isNeo4jConfigured2()) {
      console.log("[KG] Neo4j not configured (missing NEO4J_URI or NEO4J_PASSWORD)");
      return { success: false, error: "Neo4j not configured" };
    }
    console.log(`[KG] Pushing golden record to Knowledge Graph: ${data.journeyType} v${data.versionNumber}`);
    const kgService = await Promise.resolve().then(() => (init_knowledge_graph_service(), knowledge_graph_service_exports));
    await kgService.upsertJourneySession({
      id: data.sessionId,
      journeyType: data.journeyType,
      versionNumber: data.versionNumber,
      locationId: void 0,
      // TODO: Extract from metadata if available
      jurisdictionId: void 0,
      // TODO: Extract from metadata if available
      industryId: void 0,
      // TODO: Extract from metadata if available
      consentAggregate: false,
      consentPeerShare: false,
      consentModelTrain: false,
      createdAt: data.metadata.completedAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
    });
    console.log(`[KG] \u2713 Journey session upserted: ${data.sessionId}`);
    for (const step of data.steps) {
      if (step.frameworkType && step.responsePayload) {
        const frameworkId = `${data.sessionId}-${step.frameworkType}`;
        await kgService.upsertFrameworkOutput({
          id: frameworkId,
          journeyId: data.sessionId,
          stepId: step.stepName,
          framework: step.frameworkType,
          data: step.responsePayload,
          confidence: 0.85,
          // Default confidence
          createdAt: step.completedAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
        });
        console.log(`[KG] \u2713 Framework output upserted: ${step.frameworkType}`);
      }
    }
    const decisionsStep = data.steps.find((s) => s.stepName === "strategic_decisions");
    if (decisionsStep?.responsePayload && Array.isArray(decisionsStep.responsePayload)) {
      for (const decision of decisionsStep.responsePayload) {
        const decisionId = decision.id || `${data.sessionId}-decision-${decision.title}`;
        await kgService.upsertDecision({
          id: decisionId,
          journeyId: data.sessionId,
          question: decision.title || "Strategic Decision",
          selectedOptionId: void 0,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        });
        console.log(`[KG] \u2713 Decision upserted: ${decisionId}`);
        if (decision.options && Array.isArray(decision.options)) {
          const options = decision.options.map((opt, idx) => ({
            id: opt.id || `${decisionId}-option-${idx}`,
            decisionId,
            label: opt.label || opt.title || `Option ${idx + 1}`,
            isSelected: false,
            estimatedCost: opt.estimated_cost?.min,
            estimatedTimeline: opt.estimated_timeline_months?.toString()
          }));
          await kgService.upsertDecisionOptions(options);
          console.log(`[KG] \u2713 Decision options upserted: ${options.length} options`);
        }
      }
    }
    const epmStep = data.steps.find((s) => s.stepName === "epm_generation" || s.stepName === "epm_generated");
    if (epmStep?.responsePayload?.programId) {
      await kgService.upsertProgram({
        id: epmStep.responsePayload.programId,
        journeyId: data.sessionId,
        status: epmStep.responsePayload.status || "draft",
        workstreamCount: epmStep.responsePayload.workstreams || 0,
        timelineMonths: void 0,
        budget: void 0,
        locationId: void 0,
        createdAt: epmStep.completedAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString()
      });
      console.log(`[KG] \u2713 EPM program upserted: ${epmStep.responsePayload.programId}`);
    }
    console.log("[KG] \u26A0 Evidence links not yet implemented (requires research reference extraction)");
    console.log("[KG] \u26A0 Incentive/regulation linking not yet implemented (requires jurisdiction/industry context)");
    console.log(`[KG] \u2705 Golden record pushed successfully to Knowledge Graph`);
    return { success: true };
  } catch (error) {
    console.error("[KG] \u274C Error pushing to Knowledge Graph:", error.message);
    console.error("[KG] Stack:", error.stack);
    return { success: false, error: error.message };
  }
}
var init_golden_records_service = __esm({
  "server/utils/golden-records-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_secure_data_service();
    init_golden_record_sanitizer();
  }
});

// server/services/screenshot-capture-service.ts
var screenshot_capture_service_exports = {};
__export(screenshot_capture_service_exports, {
  ScreenshotCaptureService: () => ScreenshotCaptureService,
  screenshotCaptureService: () => screenshotCaptureService
});
import { chromium } from "playwright";
import { mkdir as mkdir2 } from "fs/promises";
import { join as join3 } from "path";
var ScreenshotCaptureService, screenshotCaptureService;
var init_screenshot_capture_service = __esm({
  "server/services/screenshot-capture-service.ts"() {
    "use strict";
    ScreenshotCaptureService = class {
      baseUrl;
      outputDir;
      constructor() {
        this.baseUrl = process.env.SCREENSHOT_BASE_URL || "http://localhost:5000";
        this.outputDir = process.env.GOLDEN_RECORD_SCREENSHOT_DIR || join3(process.cwd(), "scripts/output/golden-records-screenshots");
      }
      async captureStepScreenshots(options) {
        const {
          journeyType,
          versionNumber,
          steps,
          adminSessionCookie,
          baseUrl = this.baseUrl,
          outputDir = this.outputDir
        } = options;
        console.log(`
\u{1F4F8} [Screenshot Capture] Starting screenshot capture for ${journeyType} v${versionNumber}`);
        console.log(`   Base URL: ${baseUrl}`);
        console.log(`   Output directory: ${outputDir}`);
        console.log(`   Steps to capture: ${steps.length}`);
        let browser;
        const updatedSteps = [...steps];
        try {
          browser = await chromium.launch({
            headless: true,
            args: ["--no-sandbox", "--disable-setuid-sandbox"]
          });
          const context = await browser.newContext();
          if (adminSessionCookie) {
            await context.addCookies([{
              name: "connect.sid",
              value: adminSessionCookie,
              domain: "localhost",
              path: "/"
            }]);
          }
          const page = await context.newPage();
          for (let i = 0; i < updatedSteps.length; i++) {
            const step = updatedSteps[i];
            if (!step.expectedUrl) {
              console.log(`   \u26A0\uFE0F  Step ${i + 1} (${step.stepName}): No expectedUrl, skipping screenshot`);
              continue;
            }
            const result = await this.captureStepScreenshot({
              page,
              step,
              stepIndex: i,
              journeyType,
              versionNumber,
              baseUrl,
              outputDir
            });
            if (result.success && result.screenshotPath) {
              updatedSteps[i] = {
                ...step,
                screenshotPath: result.screenshotPath
              };
              console.log(`   \u2713 Step ${i + 1} (${step.stepName}): Screenshot saved`);
            } else {
              console.log(`   \u26A0\uFE0F  Step ${i + 1} (${step.stepName}): ${result.error}`);
            }
          }
          await browser.close();
          console.log(`
\u2705 [Screenshot Capture] Completed: ${updatedSteps.filter((s) => s.screenshotPath).length}/${steps.length} screenshots captured
`);
          return updatedSteps;
        } catch (error) {
          console.error("\n\u274C [Screenshot Capture] Fatal error:", error);
          if (browser) {
            try {
              await browser.close();
            } catch (closeError) {
              console.error("Error closing browser:", closeError);
            }
          }
          console.warn("\u26A0\uFE0F  [Screenshot Capture] Continuing without screenshots due to error");
          return steps;
        }
      }
      async captureStepScreenshot(params) {
        const { page, step, journeyType, versionNumber, baseUrl, outputDir } = params;
        try {
          const url = `${baseUrl}${step.expectedUrl}`;
          await page.goto(url, {
            waitUntil: "networkidle",
            timeout: 3e4
          });
          await page.waitForSelector("body", { timeout: 5e3 });
          await page.waitForTimeout(1e3);
          const screenshotDir = join3(outputDir, journeyType, `v${versionNumber}`);
          await mkdir2(screenshotDir, { recursive: true });
          const filename = `${step.stepName}.png`;
          const fullPath = join3(screenshotDir, filename);
          const relativePath = `golden-records-screenshots/${journeyType}/v${versionNumber}/${filename}`;
          await page.screenshot({
            path: fullPath,
            fullPage: true
          });
          return {
            success: true,
            screenshotPath: relativePath
          };
        } catch (error) {
          return {
            success: false,
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      }
      async getAdminSessionCookie() {
        return void 0;
      }
    };
    screenshotCaptureService = new ScreenshotCaptureService();
  }
});

// server/journey/journey-orchestrator.ts
import { eq as eq7, sql as sql5, desc as desc4 } from "drizzle-orm";
var USER_INPUT_FRAMEWORKS, JourneyOrchestrator, journeyOrchestrator;
var init_journey_orchestrator = __esm({
  "server/journey/journey-orchestrator.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_strategic_context_accumulator();
    init_journey_registry();
    init_whys_to_bmc_bridge();
    init_pestle_to_porters_bridge();
    init_porters_to_swot_bridge();
    init_whys_tree_generator();
    init_bmc_researcher();
    init_db_connection_manager();
    init_secure_data_service();
    init_kms_encryption();
    init_journey_summary_service();
    init_config();
    init_registry();
    init_schema();
    USER_INPUT_FRAMEWORKS = [
      "strategic_decisions",
      "strategic-decisions",
      "prioritization"
    ];
    JourneyOrchestrator = class {
      /**
       * Start a new journey execution
       */
      async startJourney(understandingId, journeyType, userId) {
        if (!isJourneyAvailable(journeyType)) {
          throw new Error(`Journey "${journeyType}" is not yet implemented`);
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          throw new Error(`Understanding ${understandingId} not found`);
        }
        const context = initializeContext(understanding, journeyType);
        if (isJourneyRegistryV2Enabled()) {
          const baselineSummary = await journeySummaryService.getLatestSummary(understandingId, journeyType);
          if (baselineSummary) {
            context.baselineSummary = baselineSummary;
            console.log(`[JourneyOrchestrator] Loaded baseline summary from previous ${journeyType} run (version ${baselineSummary.versionNumber})`);
          } else {
            console.log(`[JourneyOrchestrator] No previous ${journeyType} summary found, starting fresh`);
          }
        } else {
          console.log("[JourneyOrchestrator] Journey Registry V2 disabled, skipping summary load");
        }
        const lockId = this.hashStringToInt64(understandingId);
        return await db.transaction(async (tx) => {
          await tx.execute(sql5`SELECT pg_advisory_xact_lock(${lockId})`);
          console.log(`[JourneyOrchestrator] Acquired transaction advisory lock for understanding ${understandingId}`);
          const existingSessions = await tx.select({ versionNumber: journeySessions.versionNumber }).from(journeySessions).where(eq7(journeySessions.understandingId, understandingId)).orderBy(journeySessions.versionNumber);
          const maxVersion = existingSessions.length > 0 ? Math.max(...existingSessions.map((s) => s.versionNumber || 1)) : 0;
          const nextVersion = maxVersion + 1;
          console.log(`[JourneyOrchestrator] Creating journey session version ${nextVersion} for understanding ${understandingId}`);
          const encryptedContext = await encryptJSONKMS(context);
          const [newSession] = await tx.insert(journeySessions).values({
            understandingId,
            userId,
            journeyType,
            status: "initializing",
            currentFrameworkIndex: 0,
            completedFrameworks: [],
            accumulatedContext: encryptedContext,
            versionNumber: nextVersion,
            startedAt: /* @__PURE__ */ new Date()
          }).returning();
          console.log(`[JourneyOrchestrator] \u2713 Journey session saved with encryption (Version ${nextVersion})`);
          return {
            journeySessionId: newSession.id,
            versionNumber: nextVersion
          };
        });
      }
      /**
       * Start a custom journey with user-defined framework sequence
       * Used for wizard-created journeys from journey_templates
       */
      async startCustomJourney(params) {
        const { understandingId, userId, frameworks, allSteps, templateId } = params;
        console.log(`[JourneyOrchestrator] Starting custom journey for understanding ${understandingId}`);
        console.log(`[JourneyOrchestrator] Custom frameworks: ${frameworks.join(", ")}`);
        if (allSteps) {
          console.log(`[JourneyOrchestrator] All journey steps: ${allSteps.join(", ")}`);
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          throw new Error(`Understanding ${understandingId} not found`);
        }
        const context = initializeContext(understanding, "custom");
        const lockId = this.hashStringToInt64(understandingId);
        return await db.transaction(async (tx) => {
          await tx.execute(sql5`SELECT pg_advisory_xact_lock(${lockId})`);
          console.log(`[JourneyOrchestrator] Acquired transaction advisory lock for understanding ${understandingId}`);
          const existingSessions = await tx.select({ versionNumber: journeySessions.versionNumber }).from(journeySessions).where(eq7(journeySessions.understandingId, understandingId)).orderBy(journeySessions.versionNumber);
          const maxVersion = existingSessions.length > 0 ? Math.max(...existingSessions.map((s) => s.versionNumber || 1)) : 0;
          const nextVersion = maxVersion + 1;
          console.log(`[JourneyOrchestrator] Creating custom journey session version ${nextVersion}`);
          const encryptedContext = await encryptJSONKMS(context);
          const metadata = {
            frameworks: allSteps || frameworks,
            // Use allSteps for navigation if provided
            executableFrameworks: frameworks,
            // Keep track of which are actually executable
            templateId,
            isCustomJourney: true
          };
          const [newSession] = await tx.insert(journeySessions).values({
            understandingId,
            userId,
            journeyType: "custom",
            status: "initializing",
            currentFrameworkIndex: 0,
            completedFrameworks: [],
            accumulatedContext: encryptedContext,
            versionNumber: nextVersion,
            startedAt: /* @__PURE__ */ new Date(),
            metadata
          }).returning();
          console.log(`[JourneyOrchestrator] \u2713 Custom journey session saved (Version ${nextVersion})`);
          return {
            journeySessionId: newSession.id,
            versionNumber: nextVersion
          };
        });
      }
      /**
       * Hash a UUID string to a 64-bit integer for PostgreSQL advisory locks
       */
      hashStringToInt64(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return Math.abs(hash);
      }
      /**
       * Execute a journey step-by-step
       * Returns the updated context after each framework execution
       */
      async executeJourney(journeySessionId, progressCallback) {
        const session3 = await getJourneySession(journeySessionId);
        if (!session3) {
          throw new Error(`Journey session ${journeySessionId} not found`);
        }
        let frameworks;
        let journey;
        if (session3.journeyType === "custom" && session3.metadata) {
          const metadata = typeof session3.metadata === "string" ? JSON.parse(session3.metadata) : session3.metadata;
          frameworks = metadata.frameworks || [];
          console.log(`[JourneyOrchestrator] Executing custom journey with frameworks: ${frameworks.join(", ")}`);
          journey = {
            type: "custom",
            frameworks,
            dependencies: []
          };
        } else {
          journey = getJourney(session3.journeyType);
          frameworks = journey.frameworks;
        }
        let context = session3.accumulatedContext;
        await this.updateSessionStatus(journeySessionId, "in_progress");
        try {
          for (let i = context.currentFrameworkIndex; i < frameworks.length; i++) {
            const frameworkName = frameworks[i];
            if (progressCallback) {
              progressCallback({
                currentFramework: frameworkName,
                frameworkIndex: i,
                totalFrameworks: frameworks.length,
                percentComplete: Math.round(i / frameworks.length * 100),
                status: `Executing ${frameworkName}...`
              });
            }
            if (this.isUserInputStep(frameworkName)) {
              console.log(`[JourneyOrchestrator] User input step detected: ${frameworkName}`);
              const redirectUrl = await this.prepareUserInputStep(
                journeySessionId,
                context.understandingId,
                session3.versionNumber || 1,
                context
              );
              await updateJourneySession(journeySessionId, {
                status: "paused",
                accumulatedContext: {
                  ...context,
                  status: "paused"
                }
              });
              const currentMetadata = session3.metadata || {};
              await db.update(journeySessions).set({
                status: "paused",
                metadata: {
                  ...currentMetadata,
                  nextStepRedirectUrl: redirectUrl
                },
                updatedAt: /* @__PURE__ */ new Date()
              }).where(eq7(journeySessions.id, journeySessionId));
              console.log(`[JourneyOrchestrator] Stored redirectUrl in session metadata: ${redirectUrl}`);
              if (progressCallback) {
                progressCallback({
                  currentFramework: frameworkName,
                  frameworkIndex: i,
                  totalFrameworks: frameworks.length,
                  percentComplete: Math.round(i / frameworks.length * 100),
                  status: "Awaiting user input for strategic decisions",
                  userInputRequired: true,
                  redirectUrl
                });
              }
              console.log(`[JourneyOrchestrator] Paused journey for user input. Redirect: ${redirectUrl}`);
              return context;
            }
            const result = await this.executeFramework(frameworkName, context);
            context = addFrameworkResult(context, result);
            if (frameworkName === "five_whys" && frameworks[i + 1] === "bmc") {
              console.log("[JourneyOrchestrator] Applying Five Whys \u2192 BMC bridge");
              const { context: bridgedContext } = applyWhysToBMCBridge(context);
              context = bridgedContext;
            }
            if (frameworkName === "pestle" && frameworks[i + 1] === "porters") {
              console.log("[JourneyOrchestrator] Applying PESTLE \u2192 Porter's bridge");
              try {
                const pestleOutput = result.data;
                const positioning = {};
                const portersContext = await applyPESTLEToPortersBridge(pestleOutput, positioning);
                context.insights = {
                  ...context.insights,
                  trendFactors: pestleOutput
                };
                context.pestleToPortersBridge = portersContext;
                console.log("[JourneyOrchestrator] \u2713 PESTLE \u2192 Porter's bridge applied");
              } catch (bridgeError) {
                console.error("[JourneyOrchestrator] PESTLE \u2192 Porter's bridge error:", bridgeError);
              }
            }
            if (frameworkName === "porters" && frameworks[i + 1] === "swot") {
              console.log("[JourneyOrchestrator] Applying Porter's \u2192 SWOT bridge");
              try {
                const portersOutput = result.data;
                const pestleOutput = context.insights?.trendFactors;
                const positioning = {};
                const swotContext = await applyPortersToSWOTBridge(portersOutput, pestleOutput, positioning);
                context.insights = {
                  ...context.insights,
                  portersForces: portersOutput
                };
                context.portersToSWOTBridge = swotContext;
                console.log("[JourneyOrchestrator] \u2713 Porter's \u2192 SWOT bridge applied");
              } catch (bridgeError) {
                console.error("[JourneyOrchestrator] Porter's \u2192 SWOT bridge error:", bridgeError);
              }
            }
            await dbConnectionManager.retryWithBackoff(async (db2) => {
              console.log(`[Journey] Saving ${result.frameworkName} insights for journey session ${journeySessionId} (version ${session3.versionNumber})`);
              await db2.insert(frameworkInsights).values({
                understandingId: context.understandingId,
                sessionId: journeySessionId,
                frameworkName: result.frameworkName,
                frameworkVersion: `${session3.versionNumber}.0`,
                insights: result.data,
                telemetry: {
                  duration: result.duration,
                  executedAt: result.executedAt
                }
              });
              console.log(`[Journey] \u2713 Saved ${result.frameworkName} insights (Version ${session3.versionNumber})`);
            });
            console.log(`[Journey] \u{1F510} Encrypting and updating journey progress...`);
            await updateJourneySession(journeySessionId, {
              currentFrameworkIndex: context.currentFrameworkIndex,
              completedFrameworks: context.completedFrameworks,
              accumulatedContext: context
            });
            console.log(`[Journey] \u2713 Journey progress updated with encryption`);
            await new Promise((resolve) => setTimeout(resolve, 100));
          }
          await this.updateSessionStatus(journeySessionId, "completed");
          context.status = "completed";
          if (isJourneyRegistryV2Enabled() && session3.journeyType !== "custom") {
            const journeyDef = getJourney(session3.journeyType);
            const summary = journeySummaryService.buildSummary(
              journeyDef.summaryBuilder,
              context,
              {
                versionNumber: session3.versionNumber || 1,
                completedAt: (/* @__PURE__ */ new Date()).toISOString()
              }
            );
            await journeySummaryService.saveSummary(journeySessionId, summary);
            console.log(`[JourneyOrchestrator] \u2713 Journey summary saved for version ${session3.versionNumber}`);
          } else if (session3.journeyType === "custom") {
            console.log("[JourneyOrchestrator] Custom journey - skipping summary builder (no predefined summary format)");
          } else {
            console.log("[JourneyOrchestrator] Journey Registry V2 disabled, skipping summary save");
          }
          await this.autoCaptureGoldenRecord(journeySessionId, session3.journeyType);
          if (progressCallback) {
            progressCallback({
              currentFramework: frameworks[frameworks.length - 1],
              frameworkIndex: frameworks.length,
              totalFrameworks: frameworks.length,
              percentComplete: 100,
              status: "Journey complete!"
            });
          }
          return context;
        } catch (error) {
          await this.updateSessionStatus(journeySessionId, "failed");
          throw error;
        }
      }
      /**
       * Execute a single framework using the modular registry system
       */
      async executeFramework(frameworkName, context) {
        const { frameworkRegistry: frameworkRegistry3 } = await Promise.resolve().then(() => (init_framework_executor_registry(), framework_executor_registry_exports));
        return frameworkRegistry3.execute(frameworkName, context);
      }
      /**
       * Check if a framework/step is a user-input type that requires pausing
       */
      isUserInputStep(frameworkName) {
        if (USER_INPUT_FRAMEWORKS.includes(frameworkName)) {
          return true;
        }
        const normalizedName = frameworkName.replace(/_/g, "-");
        const module2 = moduleRegistry.getModule(normalizedName);
        if (module2 && module2.type === "user-input") {
          return true;
        }
        if (frameworkName.includes("strategic") && frameworkName.includes("decision")) {
          return true;
        }
        return false;
      }
      /**
       * Prepare for user input step by creating decision version and returning redirect URL
       *
       * FIXED: Now queries for the LAST framework in the journey instead of hard-coding SWOT.
       * For growth_strategy (PESTLE  Ansoff  BMC), this uses BMC.
       * For market_entry (PESTLE  Porter's  SWOT), this uses SWOT.
       */
      async prepareUserInputStep(journeySessionId, understandingId, versionNumber, context) {
        const existingVersions = await db.select().from(strategyVersions).where(eq7(strategyVersions.sessionId, understandingId)).orderBy(strategyVersions.versionNumber);
        if (existingVersions.length === 0) {
          const { DecisionGenerator: DecisionGenerator2 } = await Promise.resolve().then(() => (init_decision_generator(), decision_generator_exports));
          const generator = new DecisionGenerator2();
          let decisionsData;
          const journeySession = await db.select().from(journeySessions).where(eq7(journeySessions.id, journeySessionId)).limit(1);
          let lastFramework = "swot";
          if (journeySession[0]) {
            const journeyType = journeySession[0].journeyType;
            if (journeyType === "custom" && journeySession[0].metadata) {
              const metadata = typeof journeySession[0].metadata === "string" ? JSON.parse(journeySession[0].metadata) : journeySession[0].metadata;
              const frameworks = metadata.frameworks || [];
              lastFramework = frameworks[frameworks.length - 1] || "swot";
            } else if (journeyType) {
              const journey = getJourney(journeyType);
              lastFramework = journey.frameworks[journey.frameworks.length - 1] || "swot";
            }
          }
          console.log(`[JourneyOrchestrator] Journey last framework: ${lastFramework}`);
          console.log(`[JourneyOrchestrator] Looking for ${lastFramework} insights in session: ${journeySessionId}`);
          const frameworkInsightsResult = await db.select().from(frameworkInsights).where(sql5`${frameworkInsights.sessionId} = ${journeySessionId} AND ${frameworkInsights.frameworkName} = ${lastFramework}`).limit(1);
          console.log(`[JourneyOrchestrator] Found ${frameworkInsightsResult.length} ${lastFramework} insight records`);
          if (frameworkInsightsResult.length > 0) {
            console.log(`[JourneyOrchestrator] ${lastFramework} insight ID: ${frameworkInsightsResult[0].id}, sessionId: ${frameworkInsightsResult[0].sessionId}`);
          }
          let frameworkData = null;
          if (frameworkInsightsResult[0]?.insights) {
            const rawInsights = frameworkInsightsResult[0].insights;
            console.log(`[JourneyOrchestrator] ${lastFramework} insights raw type: ${typeof rawInsights}`);
            try {
              if (typeof rawInsights === "string") {
                frameworkData = await decryptJSONKMS(rawInsights);
                console.log(`[JourneyOrchestrator] Decrypted ${lastFramework} insights successfully`);
                if (frameworkData) {
                  console.log(`[JourneyOrchestrator] Decrypted data keys: ${Object.keys(frameworkData).join(", ")}`);
                }
              } else if (typeof rawInsights === "object") {
                frameworkData = rawInsights;
                console.log(`[JourneyOrchestrator] ${lastFramework} insights already an object with keys: ${Object.keys(frameworkData || {}).join(", ")}`);
              }
            } catch (decryptError) {
              console.warn(`[JourneyOrchestrator] Failed to decrypt ${lastFramework} insights:`, decryptError);
            }
          } else {
            console.log(`[JourneyOrchestrator] No insights field found in ${lastFramework} record`);
          }
          const frameworkOutput = frameworkData?.output || frameworkData;
          console.log(`[JourneyOrchestrator] ${lastFramework} output keys: ${Object.keys(frameworkOutput || {}).join(", ")}`);
          try {
            if (lastFramework === "swot" && frameworkOutput && Array.isArray(frameworkOutput.strengths)) {
              console.log("[JourneyOrchestrator] Generating AI decisions from SWOT analysis");
              console.log(`[JourneyOrchestrator] SWOT has ${frameworkOutput.strengths.length} strengths, ${frameworkOutput.weaknesses?.length || 0} weaknesses`);
              decisionsData = await generator.generateDecisionsFromSWOT(
                frameworkOutput,
                context.userInput || ""
              );
            } else if (lastFramework === "bmc" && frameworkOutput) {
              console.log("[JourneyOrchestrator] Generating AI decisions from BMC analysis");
              console.log(`[JourneyOrchestrator] BMC has ${frameworkOutput.blocks?.length || 0} blocks`);
              decisionsData = await generator.generateDecisionsFromBMC(
                frameworkOutput,
                context.userInput || ""
              );
            } else if (frameworkOutput) {
              console.log(`[JourneyOrchestrator] Generating decisions from ${lastFramework} using generic approach`);
              const genericSummary = this.extractGenericInsights(frameworkOutput, lastFramework);
              if (genericSummary) {
                decisionsData = await generator.generateDecisionsFromSWOT(
                  genericSummary,
                  context.userInput || ""
                );
              } else {
                decisionsData = this.generatePlaceholderDecisions(context);
              }
            } else {
              console.log(`[JourneyOrchestrator] No valid ${lastFramework} data available, using placeholder decisions`);
              decisionsData = this.generatePlaceholderDecisions(context);
            }
            console.log(`[JourneyOrchestrator] AI generated ${decisionsData?.decisions?.length || 0} decisions`);
          } catch (error) {
            console.warn("[JourneyOrchestrator] AI decision generation failed, using placeholders:", error);
            decisionsData = this.generatePlaceholderDecisions(context);
          }
          const [insertedVersion] = await db.insert(strategyVersions).values({
            sessionId: understandingId,
            versionNumber: 1,
            versionLabel: `Strategic Decisions v1`,
            decisionsData,
            createdBy: "system",
            userId: null
          }).returning({
            id: strategyVersions.id,
            sessionId: strategyVersions.sessionId,
            versionNumber: strategyVersions.versionNumber
          });
          if (!insertedVersion || insertedVersion.sessionId !== understandingId || insertedVersion.versionNumber !== 1) {
            console.error(`[JourneyOrchestrator] VALIDATION FAILED: Insert did not return expected row for session=${understandingId}, version=1`);
            throw new Error(`Failed to create strategy version 1 for session ${understandingId}`);
          }
          console.log(`[JourneyOrchestrator] \u2713 VALIDATION PASSED: strategy_versions row (id=${insertedVersion.id}, session=${understandingId}, version=1) atomically verified`);
          return `/strategic-consultant/decisions/${understandingId}/1`;
        } else {
          const latestVersion = existingVersions[existingVersions.length - 1];
          console.log(`[JourneyOrchestrator] Found existing decision version ${latestVersion.versionNumber}, reusing it`);
          return `/strategic-consultant/decisions/${understandingId}/${latestVersion.versionNumber}`;
        }
      }
      /**
       * Generate placeholder decisions structure when AI generation is not available
       */
      generatePlaceholderDecisions(context) {
        return {
          decisions: [
            {
              id: "decision-1",
              title: "Strategic Direction",
              description: "Define the primary strategic direction based on analysis",
              options: [
                { id: "opt-1", title: "Growth Focus", description: "Prioritize expansion and market growth" },
                { id: "opt-2", title: "Efficiency Focus", description: "Optimize operations and reduce costs" },
                { id: "opt-3", title: "Innovation Focus", description: "Invest in new products and capabilities" }
              ],
              selectedOptionId: null
            }
          ],
          priorities: []
        };
      }
      /**
       * Extract generic insights from any framework output and convert to SWOT-like structure
       * This allows decision generation from frameworks that don't have dedicated decision generators
       *
       * @param frameworkOutput - Raw output from the framework
       * @param frameworkName - Name of the framework (pestle, ansoff, porters, etc.)
       * @returns SWOT-like structure or null if unable to extract
       */
      extractGenericInsights(frameworkOutput, frameworkName) {
        if (!frameworkOutput) return null;
        console.log(`[JourneyOrchestrator] Extracting generic insights from ${frameworkName}`);
        switch (frameworkName.toLowerCase()) {
          case "pestle":
            return this.convertPESTLEToSWOT(frameworkOutput);
          case "ansoff":
            return this.convertAnsoffToSWOT(frameworkOutput);
          case "porters":
          case "porter":
            return this.convertPortersToSWOT(frameworkOutput);
          default:
            return this.convertGenericToSWOT(frameworkOutput, frameworkName);
        }
      }
      /**
       * Convert PESTLE output to SWOT-like structure
       */
      convertPESTLEToSWOT(pestle) {
        const strengths = [];
        const weaknesses = [];
        const opportunities = [];
        const threats = [];
        const categories = ["political", "economic", "social", "technological", "legal", "environmental"];
        for (const category of categories) {
          const factors = pestle[category] || pestle[category.charAt(0).toUpperCase() + category.slice(1)] || [];
          if (Array.isArray(factors)) {
            factors.forEach((factor) => {
              const text2 = typeof factor === "string" ? factor : factor?.factor || factor?.description || JSON.stringify(factor);
              const impact = factor?.impact || factor?.implication || "";
              const entry = `${text2}${impact ? ": " + impact : ""}`;
              if (this.isPositiveFactor(text2 + impact)) {
                opportunities.push(entry);
              } else {
                threats.push(entry);
              }
            });
          }
        }
        return { strengths, weaknesses, opportunities, threats };
      }
      /**
       * Convert Ansoff Matrix output to SWOT-like structure
       */
      convertAnsoffToSWOT(ansoff) {
        const strengths = [];
        const weaknesses = [];
        const opportunities = [];
        const threats = [];
        const strategies = ["market_penetration", "market_development", "product_development", "diversification"];
        for (const strategy of strategies) {
          const strategyData = ansoff[strategy] || ansoff[strategy.replace(/_/g, "")] || null;
          if (strategyData) {
            const description = typeof strategyData === "string" ? strategyData : strategyData?.description || strategyData?.recommendation || JSON.stringify(strategyData);
            opportunities.push(`${strategy.replace(/_/g, " ")}: ${description}`);
            if (strategyData?.risks && Array.isArray(strategyData.risks)) {
              threats.push(...strategyData.risks.map((r) => typeof r === "string" ? r : r?.description || JSON.stringify(r)));
            }
          }
        }
        if (ansoff.recommendation || ansoff.selectedStrategy) {
          const rec = ansoff.recommendation || ansoff.selectedStrategy;
          strengths.push(`Recommended strategy: ${typeof rec === "string" ? rec : JSON.stringify(rec)}`);
        }
        return { strengths, weaknesses, opportunities, threats };
      }
      /**
       * Convert Porter's Five Forces output to SWOT-like structure
       */
      convertPortersToSWOT(porters) {
        const strengths = [];
        const weaknesses = [];
        const opportunities = [];
        const threats = [];
        const forces = [
          "buyer_power",
          "supplier_power",
          "competitive_rivalry",
          "threat_of_substitutes",
          "threat_of_new_entrants"
        ];
        for (const force of forces) {
          const forceData = porters[force] || porters[force.replace(/_/g, "")] || null;
          if (forceData) {
            const intensity = forceData?.intensity || forceData?.level || "moderate";
            const description = forceData?.analysis || forceData?.description || "";
            const entry = `${force.replace(/_/g, " ")}: ${intensity}${description ? " - " + description : ""}`;
            if (intensity.toLowerCase().includes("high") || intensity.toLowerCase().includes("strong")) {
              threats.push(entry);
            } else if (intensity.toLowerCase().includes("low") || intensity.toLowerCase().includes("weak")) {
              opportunities.push(entry);
            } else {
              if (force.includes("buyer") || force.includes("supplier")) {
                weaknesses.push(entry);
              } else {
                threats.push(entry);
              }
            }
          }
        }
        return { strengths, weaknesses, opportunities, threats };
      }
      /**
       * Generic fallback conversion for unknown frameworks
       */
      convertGenericToSWOT(output, frameworkName) {
        const strengths = [];
        const weaknesses = [];
        const opportunities = [];
        const threats = [];
        const traverse = (obj, path3 = "") => {
          if (!obj || typeof obj !== "object") return;
          for (const key of Object.keys(obj)) {
            const value = obj[key];
            if (Array.isArray(value)) {
              value.forEach((item) => {
                const text2 = typeof item === "string" ? item : item?.text || item?.description || item?.insight || JSON.stringify(item);
                if (key.toLowerCase().includes("strength") || key.toLowerCase().includes("advantage")) {
                  strengths.push(text2);
                } else if (key.toLowerCase().includes("weakness") || key.toLowerCase().includes("challenge")) {
                  weaknesses.push(text2);
                } else if (key.toLowerCase().includes("opportunit")) {
                  opportunities.push(text2);
                } else if (key.toLowerCase().includes("threat") || key.toLowerCase().includes("risk")) {
                  threats.push(text2);
                } else {
                  if (this.isPositiveFactor(text2)) {
                    opportunities.push(`${key}: ${text2}`);
                  } else {
                    threats.push(`${key}: ${text2}`);
                  }
                }
              });
            } else if (typeof value === "object" && value !== null) {
              traverse(value, `${path3}.${key}`);
            }
          }
        };
        traverse(output);
        if (strengths.length === 0 && weaknesses.length === 0 && opportunities.length === 0 && threats.length === 0) {
          console.log(`[JourneyOrchestrator] Could not extract insights from ${frameworkName} output`);
          return null;
        }
        console.log(`[JourneyOrchestrator] Extracted ${strengths.length}S/${weaknesses.length}W/${opportunities.length}O/${threats.length}T from ${frameworkName}`);
        return { strengths, weaknesses, opportunities, threats };
      }
      /**
       * Simple heuristic to determine if a factor is positive or negative
       */
      isPositiveFactor(text2) {
        const positiveKeywords = ["growth", "opportunity", "advantage", "benefit", "improve", "increase", "expand", "gain", "positive", "favorable"];
        const negativeKeywords = ["risk", "threat", "decline", "decrease", "challenge", "obstacle", "barrier", "negative", "unfavorable", "loss"];
        const lowerText = text2.toLowerCase();
        const positiveScore = positiveKeywords.filter((k) => lowerText.includes(k)).length;
        const negativeScore = negativeKeywords.filter((k) => lowerText.includes(k)).length;
        return positiveScore >= negativeScore;
      }
      /**
       * Execute Five Whys framework
       */
      async executeFiveWhys(context) {
        console.log("[Journey] Executing Five Whys with AI...");
        const generator = new WhysTreeGenerator();
        const sessionId = context.sessionId;
        const userInput = context.userInput;
        const whysTree = await generator.generateTree(userInput, sessionId);
        console.log(`[Journey] Five Whys completed - generated tree with ${whysTree.branches.length} root branches`);
        const rootCauses = [];
        const whysPath = [];
        if (whysTree.branches && whysTree.branches.length > 0) {
          let currentLevel = whysTree.branches;
          let currentQuestion = whysTree.rootQuestion;
          while (currentLevel && currentLevel.length > 0) {
            const node = currentLevel[0];
            const answer = node.option || node.question || "";
            if (answer) {
              whysPath.push({ question: currentQuestion, answer });
            }
            if (!node.branches || node.branches.length === 0) {
              rootCauses.push(node.option || node.question);
            }
            currentQuestion = node.question || currentQuestion;
            currentLevel = node.branches || [];
          }
          for (const branch of whysTree.branches) {
            const deepestAnswer = this.findDeepestAnswer(branch);
            if (deepestAnswer && !rootCauses.includes(deepestAnswer)) {
              rootCauses.push(deepestAnswer);
            }
          }
        }
        const strategicImplications = rootCauses.map(
          (cause) => `Strategic implication: The business model must address ${cause}`
        );
        return {
          rootCauses: rootCauses.length > 0 ? rootCauses : ["No root causes identified"],
          whysPath,
          strategicImplications,
          tree: whysTree
          // Also include the full tree for reference
        };
      }
      /**
       * Helper to find the deepest answer in a branch
       */
      findDeepestAnswer(node) {
        if (!node.branches || node.branches.length === 0) {
          return node.option || node.question;
        }
        for (const branch of node.branches) {
          const deep = this.findDeepestAnswer(branch);
          if (deep) return deep;
        }
        return node.option || node.question;
      }
      /**
       * Execute Business Model Canvas framework
       */
      async executeBMC(context) {
        console.log("[Journey] Executing BMC with AI...");
        const constraints = context.insights.bmcDesignConstraints;
        if (constraints) {
          console.log("[Journey] BMC constraints from Five Whys:", {
            problems: constraints.problemsToSolve.length,
            capabilities: constraints.mustHaveCapabilities.length,
            principles: constraints.designPrinciples.length
          });
        }
        const researcher = new BMCResearcher();
        const sessionId = context.sessionId;
        const userInput = context.userInput;
        const bmcResults = await researcher.conductBMCResearch(userInput, sessionId);
        console.log(`[Journey] BMC analysis completed - generated ${Object.keys(bmcResults.blocks || {}).length} blocks`);
        return bmcResults;
      }
      /**
       * Update journey session status
       */
      async updateSessionStatus(journeySessionId, status) {
        await dbConnectionManager.retryWithBackoff(async (db2) => {
          await db2.update(journeySessions).set({
            status,
            updatedAt: /* @__PURE__ */ new Date(),
            ...status === "completed" ? { completedAt: /* @__PURE__ */ new Date() } : {}
          }).where(eq7(journeySessions.id, journeySessionId));
        });
      }
      /**
       * Auto-capture golden record if enabled
       * Called after journey completion (async, non-blocking)
       */
      async autoCaptureGoldenRecord(journeySessionId, journeyType) {
        const autoCaptureEnabled = process.env.AUTO_CAPTURE_GOLDEN === "true";
        if (!autoCaptureEnabled) {
          console.log("[Golden Records] Auto-capture disabled (AUTO_CAPTURE_GOLDEN=false)");
          return;
        }
        const allowedJourneys = [
          "market_entry",
          "business_model_innovation",
          "competitive_strategy",
          "digital_transformation",
          "crisis_recovery",
          "growth_strategy"
        ];
        if (!allowedJourneys.includes(journeyType)) {
          console.log(`[Golden Records] Journey type "${journeyType}" not in auto-capture allowlist`);
          return;
        }
        setImmediate(async () => {
          try {
            console.log(`[Golden Records] \u{1F504} Auto-capturing golden record for journey: ${journeyType}`);
            const timestamp2 = (/* @__PURE__ */ new Date()).toISOString();
            const {
              fetchJourneySessionData: fetchJourneySessionData2,
              sanitizeGoldenRecordData: sanitizeGoldenRecordData2,
              saveGoldenRecordToFile: saveGoldenRecordToFile2
            } = await Promise.resolve().then(() => (init_golden_records_service(), golden_records_service_exports));
            const { screenshotCaptureService: screenshotCaptureService2 } = await Promise.resolve().then(() => (init_screenshot_capture_service(), screenshot_capture_service_exports));
            const rawData = await fetchJourneySessionData2(journeySessionId);
            if (!rawData) {
              console.error("[Golden Records] Failed to fetch journey session data for auto-capture");
              return;
            }
            let sanitizedData = await sanitizeGoldenRecordData2(rawData);
            const existingRecords = await db.select().from(goldenRecords).where(eq7(goldenRecords.journeyType, journeyType)).orderBy(desc4(goldenRecords.version));
            const maxVersion = existingRecords.length > 0 ? existingRecords[0].version : 0;
            const nextVersion = maxVersion + 1;
            sanitizedData.versionNumber = nextVersion;
            try {
              const stepsWithScreenshots = await screenshotCaptureService2.captureStepScreenshots({
                journeyType,
                versionNumber: nextVersion,
                steps: sanitizedData.steps,
                adminSessionCookie: void 0
              });
              sanitizedData = {
                ...sanitizedData,
                steps: stepsWithScreenshots
              };
            } catch (screenshotError) {
              console.warn("[Golden Records] Screenshot capture failed during auto-capture, continuing without screenshots:", screenshotError);
            }
            await saveGoldenRecordToFile2(sanitizedData, `Auto-captured on ${timestamp2}`);
            const recordData = {
              journeyType,
              version: nextVersion,
              parentVersion: maxVersion > 0 ? maxVersion : null,
              isCurrent: false,
              // Don't auto-promote
              metadata: sanitizedData.metadata,
              notes: `Auto-captured on ${timestamp2}`,
              steps: sanitizedData.steps,
              createdBy: "system"
              // Auto-capture is system-initiated
            };
            const [newRecord] = await db.insert(goldenRecords).values(recordData).returning();
            console.log(`[Golden Records] \u2705 Auto-captured golden record v${nextVersion}: ${newRecord.id}`);
            console.log(`[Golden Records] Journey: ${journeyType}, Session: ${journeySessionId}`);
          } catch (error) {
            console.error("[Golden Records] Error during auto-capture:", error);
          }
        });
      }
      /**
       * Resume a paused journey
       */
      async resumeJourney(journeySessionId, progressCallback) {
        await this.updateSessionStatus(journeySessionId, "in_progress");
        return this.executeJourney(journeySessionId, progressCallback);
      }
      /**
       * Get journey progress
       */
      async getProgress(journeySessionId) {
        const session3 = await db.select().from(journeySessions).where(eq7(journeySessions.id, journeySessionId)).then((rows) => rows[0]);
        if (!session3) {
          return null;
        }
        const journey = getJourney(session3.journeyType);
        const currentIndex = session3.currentFrameworkIndex || 0;
        return {
          currentFramework: journey.frameworks[currentIndex] || journey.frameworks[0],
          frameworkIndex: currentIndex,
          totalFrameworks: journey.frameworks.length,
          percentComplete: Math.round(currentIndex / journey.frameworks.length * 100),
          status: session3.status || "initializing"
        };
      }
    };
    journeyOrchestrator = new JourneyOrchestrator();
  }
});

// server/services/strategic-understanding-worker.ts
var strategic_understanding_worker_exports = {};
__export(strategic_understanding_worker_exports, {
  processStrategicUnderstandingJob: () => processStrategicUnderstandingJob
});
async function processStrategicUnderstandingJob(job) {
  console.log("[StrategicUnderstanding Worker] Processing job:", job.id);
  try {
    const { sessionId, understandingId, journeyType, isFollowOn, baseUnderstandingId } = job.inputData;
    if (!sessionId || !journeyType) {
      throw new Error("Missing required input data: sessionId or journeyType");
    }
    console.log(`[StrategicUnderstanding Worker] Executing ${journeyType} journey for session ${sessionId}${isFollowOn ? " (follow-on)" : ""}`);
    await backgroundJobService.updateJob(job.id, {
      status: "running",
      progress: 5,
      progressMessage: `Starting ${journeyType} journey...`
    });
    await journeyOrchestrator2.executeJourney(
      sessionId,
      // Progress callback to update job status
      async (progress) => {
        const percentComplete = Math.min(95, 10 + Math.round(progress.percentComplete * 0.85));
        await backgroundJobService.updateJob(job.id, {
          progress: percentComplete,
          progressMessage: `${progress.status} (${progress.frameworkIndex + 1}/${progress.totalFrameworks})`
        });
      }
    );
    console.log(`[StrategicUnderstanding Worker] Journey ${journeyType} completed successfully`);
    await backgroundJobService.updateJob(job.id, {
      status: "completed",
      progress: 100,
      progressMessage: `${journeyType} journey completed successfully`,
      resultData: {
        understandingId,
        journeyType,
        isFollowOn,
        baseUnderstandingId,
        completedAt: (/* @__PURE__ */ new Date()).toISOString()
      }
    });
  } catch (error) {
    console.error("[StrategicUnderstanding Worker] Job failed:", error);
    await backgroundJobService.failJob(job.id, error);
    throw error;
  }
}
var journeyOrchestrator2;
var init_strategic_understanding_worker = __esm({
  "server/services/strategic-understanding-worker.ts"() {
    "use strict";
    init_journey_orchestrator();
    init_background_job_service();
    journeyOrchestrator2 = new JourneyOrchestrator();
  }
});

// server/services/background-job-service.ts
var background_job_service_exports = {};
__export(background_job_service_exports, {
  BackgroundJobService: () => BackgroundJobService,
  backgroundJobService: () => backgroundJobService
});
import { eq as eq8, and as and7, desc as desc5, inArray, sql as sql6 } from "drizzle-orm";
var BackgroundJobService, backgroundJobService;
var init_background_job_service = __esm({
  "server/services/background-job-service.ts"() {
    "use strict";
    init_schema();
    init_db_connection_manager();
    BackgroundJobService = class {
      /**
       * Create a new background job record
       * Called at the start of long-running operations
       */
      async createJob(params) {
        if (!params.userId) {
          console.log("[Background Job] Skipping job creation - no authenticated user");
          return null;
        }
        console.log("[Background Job] Creating job:", params.jobType, "for user:", params.userId);
        const jobData = {
          userId: params.userId,
          jobType: params.jobType,
          status: "pending",
          progress: 0,
          inputData: params.inputData,
          sessionId: params.sessionId,
          relatedEntityId: params.relatedEntityId,
          relatedEntityType: params.relatedEntityType
        };
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          const [job] = await db2.insert(backgroundJobs).values(jobData).returning();
          return job;
        });
        console.log("[Background Job] \u2713 Job created:", result.id);
        return result.id;
      }
      /**
       * Update job status and progress
       * Called during operation execution
       */
      async updateJob(jobId, updates) {
        const updateData = {
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (updates.status !== void 0) {
          updateData.status = updates.status;
          if (updates.status === "running") {
            updateData.startedAt = /* @__PURE__ */ new Date();
          } else if (updates.status === "completed") {
            updateData.completedAt = /* @__PURE__ */ new Date();
          } else if (updates.status === "failed") {
            updateData.failedAt = /* @__PURE__ */ new Date();
          }
        }
        if (updates.progress !== void 0) {
          updateData.progress = updates.progress;
        }
        if (updates.progressMessage !== void 0) {
          updateData.progressMessage = updates.progressMessage;
        }
        if (updates.resultData !== void 0) {
          updateData.resultData = updates.resultData;
        }
        await dbConnectionManager.retryWithBackoff(async (db2) => {
          await db2.update(backgroundJobs).set(updateData).where(eq8(backgroundJobs.id, jobId));
        });
      }
      /**
       * Mark job as failed with error details
       * Called when operation throws an error
       */
      async failJob(jobId, error) {
        console.error("[Background Job] Job failed:", jobId, error.message);
        await dbConnectionManager.retryWithBackoff(async (db2) => {
          await db2.update(backgroundJobs).set({
            status: "failed",
            errorMessage: error.message,
            errorStack: error.stack,
            failedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq8(backgroundJobs.id, jobId));
        });
      }
      /**
       * Get a specific job by ID
       */
      async getJobById(jobId) {
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          const [job] = await db2.select().from(backgroundJobs).where(eq8(backgroundJobs.id, jobId));
          return job || null;
        });
        return result;
      }
      /**
       * Get all jobs for a specific user
       * Optionally filter by status
       */
      async getJobsByUser(userId, options) {
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          let query = db2.select().from(backgroundJobs).where(eq8(backgroundJobs.userId, userId)).orderBy(desc5(backgroundJobs.createdAt));
          if (options?.limit) {
            query = query.limit(options.limit);
          }
          const jobs = await query;
          if (options?.status) {
            return jobs.filter((job) => job.status === options.status);
          }
          return jobs;
        });
        return result;
      }
      /**
       * Get all running jobs for a user
       * Used for reconnection logic
       */
      async getRunningJobs(userId) {
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          return await db2.select().from(backgroundJobs).where(
            and7(
              eq8(backgroundJobs.userId, userId),
              inArray(backgroundJobs.status, ["pending", "running"])
            )
          ).orderBy(desc5(backgroundJobs.createdAt));
        });
        return result;
      }
      /**
       * Get job by session ID
       * Used for reconnecting to jobs when user returns to a page
       */
      async getJobBySession(sessionId) {
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          const [job] = await db2.select().from(backgroundJobs).where(eq8(backgroundJobs.sessionId, sessionId)).orderBy(desc5(backgroundJobs.createdAt)).limit(1);
          return job || null;
        });
        return result;
      }
      /**
       * Get recent jobs (last 24 hours)
       * For showing in jobs dashboard
       */
      async getRecentJobs(userId, limit = 50) {
        const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1e3);
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          return await db2.select().from(backgroundJobs).where(eq8(backgroundJobs.userId, userId)).orderBy(desc5(backgroundJobs.createdAt)).limit(limit);
        });
        return result.filter((job) => new Date(job.createdAt) >= oneDayAgo);
      }
      /**
       * Get jobs by related entity
       * Useful for finding all jobs related to a specific program, analysis, etc.
       */
      async getJobsByRelatedEntity(relatedEntityId, relatedEntityType) {
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          return await db2.select().from(backgroundJobs).where(
            and7(
              eq8(backgroundJobs.relatedEntityId, relatedEntityId),
              eq8(backgroundJobs.relatedEntityType, relatedEntityType)
            )
          ).orderBy(desc5(backgroundJobs.createdAt));
        });
        return result;
      }
      /**
       * Cancel a running job
       * Marks job as failed with cancellation message
       */
      async cancelJob(jobId, userId) {
        console.log("[Background Job] Cancelling job:", jobId, "for user:", userId);
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          const [job] = await db2.select().from(backgroundJobs).where(eq8(backgroundJobs.id, jobId));
          if (!job) {
            console.error("[Background Job] Job not found:", jobId);
            return false;
          }
          if (job.userId !== userId) {
            console.error("[Background Job] User does not own job:", userId, "vs", job.userId);
            return false;
          }
          if (job.status !== "pending" && job.status !== "running") {
            console.error("[Background Job] Job is not cancellable (status:", job.status, ")");
            return false;
          }
          await db2.update(backgroundJobs).set({
            status: "failed",
            errorMessage: "Job cancelled by user",
            failedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq8(backgroundJobs.id, jobId));
          console.log("[Background Job] \u2713 Job cancelled:", jobId);
          return true;
        });
        return result;
      }
      /**
       * Delete old completed/failed jobs
       * Cleans up jobs older than specified days
       */
      async cleanupOldJobs(daysOld = 7) {
        console.log("[Background Job] Cleaning up jobs older than", daysOld, "days");
        const cutoffDate = new Date(Date.now() - daysOld * 24 * 60 * 60 * 1e3);
        const result = await dbConnectionManager.withFreshConnection(async (db2) => {
          const jobsToDelete = await db2.select({ id: backgroundJobs.id }).from(backgroundJobs).where(
            and7(
              inArray(backgroundJobs.status, ["completed", "failed"]),
              // Drizzle ORM date comparison using sql template tag from drizzle-orm
              sql6`${backgroundJobs.createdAt} < ${cutoffDate}`
            )
          );
          if (jobsToDelete.length === 0) {
            console.log("[Background Job] \u2713 No old jobs to delete");
            return 0;
          }
          const jobIds = jobsToDelete.map((job) => job.id);
          await db2.delete(backgroundJobs).where(inArray(backgroundJobs.id, jobIds));
          console.log("[Background Job] \u2713 Deleted", jobsToDelete.length, "old jobs");
          return jobsToDelete.length;
        });
        return result;
      }
      /**
       * Process pending jobs (dispatcher)
       * Polls for pending jobs and routes them to appropriate workers
       */
      async processPendingJobs() {
        try {
          const result = await dbConnectionManager.withFreshConnection(async (db2) => {
            return await db2.select().from(backgroundJobs).where(eq8(backgroundJobs.status, "pending")).orderBy(backgroundJobs.createdAt).limit(10);
          });
          if (result.length === 0) {
            if (Math.random() < 0.05) {
              console.log("[Background Job Dispatcher] No pending jobs");
            }
            return;
          }
          console.log(`[Background Job Dispatcher] Found ${result.length} pending job(s):`);
          result.forEach((job) => {
            console.log(`  - ${job.jobType} (ID: ${job.id.substring(0, 8)}..., created: ${job.createdAt})`);
          });
          for (const job of result) {
            this.processJob(job).catch((error) => {
              console.error("[Background Job Dispatcher] Error processing job:", job.id, error);
            });
          }
        } catch (error) {
          console.error("[Background Job Dispatcher] Error fetching pending jobs:", error);
        }
      }
      /**
       * Process a single job by routing to appropriate worker
       */
      async processJob(job) {
        console.log(`[Background Job Dispatcher] >>> Processing ${job.jobType} job: ${job.id}`);
        try {
          if (job.jobType === "document_enrichment") {
            console.log(`[Background Job Dispatcher] Importing document enrichment worker...`);
            const { processDocumentEnrichmentJob: processDocumentEnrichmentJob2 } = await Promise.resolve().then(() => (init_document_enrichment_worker(), document_enrichment_worker_exports));
            console.log(`[Background Job Dispatcher] Calling worker for job: ${job.id}`);
            await processDocumentEnrichmentJob2(job);
            console.log(`[Background Job Dispatcher] \u2713 Worker completed for job: ${job.id}`);
          } else if (job.jobType === "strategic_understanding") {
            console.log(`[Background Job Dispatcher] Importing strategic understanding worker...`);
            const { processStrategicUnderstandingJob: processStrategicUnderstandingJob2 } = await Promise.resolve().then(() => (init_strategic_understanding_worker(), strategic_understanding_worker_exports));
            console.log(`[Background Job Dispatcher] Calling worker for job: ${job.id}`);
            await processStrategicUnderstandingJob2(job);
            console.log(`[Background Job Dispatcher] \u2713 Worker completed for job: ${job.id}`);
          } else {
            console.log(`[Background Job Dispatcher] \u26A0 No worker for job type: ${job.jobType}`);
          }
        } catch (error) {
          console.error(`[Background Job Dispatcher] \u274C Job ${job.id} failed:`, error);
          await this.failJob(job.id, error);
        }
      }
    };
    backgroundJobService = new BackgroundJobService();
  }
});

// server/services/segment-discovery-engine.ts
var segment_discovery_engine_exports = {};
__export(segment_discovery_engine_exports, {
  SegmentDiscoveryEngine: () => SegmentDiscoveryEngine,
  detectSegmentationMode: () => detectSegmentationMode,
  extractContextKeywords: () => extractContextKeywords,
  segmentDiscoveryEngine: () => segmentDiscoveryEngine
});
import Anthropic3 from "@anthropic-ai/sdk";
function withTimeout(promise, timeoutMs, operation) {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error(`AI operation '${operation}' timed out after ${timeoutMs}ms`));
    }, timeoutMs);
    promise.then((result) => {
      clearTimeout(timeout);
      resolve(result);
    }).catch((error) => {
      clearTimeout(timeout);
      reject(error);
    });
  });
}
async function withRetry(fn, operation, maxRetries = MAX_RETRIES) {
  let lastError = null;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (attempt < maxRetries) {
        const backoff = INITIAL_BACKOFF_MS * Math.pow(2, attempt - 1);
        console.log(`[SegmentDiscoveryEngine] ${operation} attempt ${attempt} failed, retrying in ${backoff}ms...`);
        await new Promise((resolve) => setTimeout(resolve, backoff));
      }
    }
  }
  console.error(`[SegmentDiscoveryEngine] ${operation} failed after ${maxRetries} attempts`);
  throw lastError;
}
function detectSegmentationMode(offeringType) {
  const b2cTypes = ["b2c_software", "physical_product", "content_education"];
  return b2cTypes.includes(offeringType) ? "b2c" : "b2b";
}
function extractContextKeywords(description) {
  if (!description || description.trim().length < 10) return [];
  const text2 = description.toLowerCase();
  const nounPhrasePatterns = [
    /(?:premium|luxury|affordable|innovative|traditional|modern|artisan|gourmet|authentic|organic|sustainable|local|global|digital|mobile|online|physical)\s+[\w]+(?:\s+[\w]+)?/gi,
    /[\w]+(?:\s+[\w]+)?\s+(?:restaurant|cafe|shop|store|service|platform|app|software|product|solution|business|company|brand|agency)/gi,
    /(?:chinese|italian|mexican|indian|japanese|french|thai|mediterranean|american|asian|european|middle eastern|african|vietnamese|korean|greek|spanish|german|british|polish|russian|brazilian|peruvian|cuban|ethiopian|moroccan|lebanese|turkish|persian|pakistani|bengali|nepali|tibetan|burmese|malaysian|indonesian|filipino|hawaiian|caribbean|cajun|soul|southern|tex-mex|southwestern|new england|pacific)\s+(?:food|cuisine|restaurant|fusion|cooking|dishes|flavors?|recipes?|ingredients?|spices?|style)/gi,
    /[\w]+\s+[\w]+\s+[\w]+(?:\s+[\w]+)?/gi
  ];
  const extractedPhrases = [];
  for (const pattern of nounPhrasePatterns) {
    const matches = text2.match(pattern) || [];
    extractedPhrases.push(...matches.map((m) => m.trim()));
  }
  const words = text2.replace(/[^\w\s\u00C0-\u024F\u1E00-\u1EFF-]/g, " ").split(/\s+/).filter((word) => word.length >= 2 && !STOPWORDS.has(word));
  const wordFreq = /* @__PURE__ */ new Map();
  for (const word of words) {
    wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
  }
  const sortedWords = Array.from(wordFreq.entries()).sort((a, b) => b[1] - a[1]).map(([word]) => word).slice(0, 12);
  const allKeywords = Array.from(/* @__PURE__ */ new Set([...extractedPhrases, ...sortedWords]));
  return allKeywords.slice(0, 10);
}
var AI_TIMEOUT_MS, AI_TIMEOUT_LONG_MS, MAX_RETRIES, INITIAL_BACKOFF_MS, STOPWORDS, SegmentDiscoveryEngine, segmentDiscoveryEngine;
var init_segment_discovery_engine = __esm({
  "server/services/segment-discovery-engine.ts"() {
    "use strict";
    AI_TIMEOUT_MS = 9e4;
    AI_TIMEOUT_LONG_MS = 18e4;
    MAX_RETRIES = 3;
    INITIAL_BACKOFF_MS = 1e3;
    STOPWORDS = /* @__PURE__ */ new Set([
      "a",
      "an",
      "the",
      "and",
      "or",
      "but",
      "in",
      "on",
      "at",
      "to",
      "for",
      "of",
      "with",
      "by",
      "from",
      "as",
      "is",
      "was",
      "are",
      "were",
      "been",
      "be",
      "have",
      "has",
      "had",
      "do",
      "does",
      "did",
      "will",
      "would",
      "could",
      "should",
      "may",
      "might",
      "must",
      "shall",
      "can",
      "need",
      "dare",
      "ought",
      "used",
      "i",
      "we",
      "you",
      "he",
      "she",
      "it",
      "they",
      "what",
      "which",
      "who",
      "whom",
      "this",
      "that",
      "these",
      "those",
      "am",
      "my",
      "your",
      "our",
      "their",
      "its",
      "his",
      "her",
      "about",
      "into",
      "through",
      "during",
      "before",
      "after",
      "above",
      "below",
      "between",
      "under",
      "again",
      "further",
      "then",
      "once",
      "here",
      "there",
      "when",
      "where",
      "why",
      "how",
      "all",
      "each",
      "few",
      "more",
      "most",
      "other",
      "some",
      "such",
      "no",
      "nor",
      "not",
      "only",
      "own",
      "same",
      "so",
      "than",
      "too",
      "very",
      "just",
      "also",
      "now",
      "being",
      "over",
      "any",
      "both"
    ]);
    SegmentDiscoveryEngine = class {
      anthropic;
      constructor() {
        this.anthropic = new Anthropic3();
      }
      getB2BGeneLibraryPrompt(context) {
        return `You are a market segmentation expert specializing in discovering SURPRISING, NON-OBVIOUS B2B customer segments. Your job is to surface segments that founders would never think of on their own.

OFFERING CONTEXT:
- Description: ${context.offeringDescription}
- Type: ${context.offeringType}
- Stage: ${context.stage}
- GTM Constraint: ${context.gtmConstraint}
- Sales Motion: ${context.salesMotion}
${context.existingHypothesis ? `- Existing Hypothesis: ${context.existingHypothesis}` : ""}

Generate a COMPREHENSIVE gene library with 50+ options per dimension. The goal is DIVERSITY and DISCOVERY - push beyond the obvious.

KEY PRINCIPLE: "Who has this problem but nobody's building for them?"

DIMENSIONS TO POPULATE (50+ alleles each):

1. industry_vertical - FORCE DIVERSITY across:
   - Professional services (consulting, legal, accounting)
   - Creative industries (film, music, gaming, art)
   - Industrial/manufacturing (factories, logistics, construction)
   - Agriculture/farming (farms, ranches, agricultural suppliers)
   - Healthcare (hospitals, clinics, caregiving, wellness)
   - Education (schools, tutoring, training, e-learning)
   - Government/public sector (municipalities, agencies)
   - Non-profit/religious (churches, charities, foundations)
   - Consumer services (retail, hospitality, food service)
   - Sports/fitness (gyms, teams, coaches, athletes)
   - Trade/skilled labor (electricians, plumbers, mechanics)
   - Entertainment/media (streamers, podcasters, influencers)
   - Hobbyist communities (collectors, crafters, enthusiasts)
   Include UNUSUAL industries that might have the underlying need.

2. company_size - Full spectrum from individuals to enterprises:
   - Solo practitioners, freelancers, one-person businesses
   - Micro-businesses (2-5 people)
   - Small businesses (6-50)
   - Mid-market (51-500)
   - Enterprise (500+)
   - Also include: community groups, volunteer organizations, family businesses, creator collectives

3. decision_maker - INCLUDE NON-OBVIOUS ROLES:
   Obvious: CEO, CTO, VP Engineering, Head of Marketing, Product Manager
   NON-OBVIOUS (include these!): 
   - Farmers, ranchers, farm managers
   - Game masters, dungeon masters, community moderators
   - Pastors, clergy, religious leaders
   - Coaches (sports, life, business)
   - Tradespeople (electricians, plumbers, contractors)
   - Caregivers, home health aides
   - Teachers, tutors, trainers
   - Artists, musicians, performers
   - Hobbyist leaders, club organizers
   - Parents, family caregivers
   - Volunteers, community organizers
   - Retirees with side projects
   Be SPECIFIC with titles, not generic.

4. purchase_trigger - Events that create urgency:
   - Pain events (failure, loss, crisis)
   - Growth mandates (scaling, expanding)
   - Budget cycles (fiscal year, grants)
   - Life events (new job, new baby, retirement)
   - Seasonal needs (harvest, holidays, tax season)
   - Compliance requirements
   - Competitive pressure
   - Technology shifts

5. tech_adoption - Technology comfort levels:
   - Innovators (bleeding edge)
   - Early adopters (try new things)
   - Pragmatists (proven solutions)
   - Late majority (when others do)
   - Skeptics (only when forced)
   - Tech-resistant but high-need

6. buying_process - How decisions get made:
   - Impulse/immediate (personal card)
   - Self-serve research
   - Peer recommendation required
   - Family/partner approval
   - Team consensus
   - Committee/board approval
   - Procurement process
   - Grant-funded
   - Crowdfunded/community-funded

7. budget_authority - Who controls spending:
   - Personal funds/credit card
   - Household budget
   - Small discretionary budget
   - Department budget
   - C-suite approval
   - Board approval
   - External funding (grants, investors)
   - Community/membership dues

8. urgency_profile - Need intensity:
   - Burning platform (crisis mode)
   - Active search (shopping now)
   - Planning ahead (6-12 months)
   - Nice to have (if budget allows)
   - Exploring options (no timeline)
   - Recurring/seasonal need

MUTATION REQUIREMENT:
For each dimension, include 5-10 "MUTATION" options - roles, industries, or contexts that seem like UNLIKELY or COUNTERINTUITIVE fits at first glance but might have the underlying need. These are often where the best insights come from.

REQUIREMENTS:
- Generate 50+ alleles per dimension
- Include obvious segments but PRIORITIZE non-obvious ones
- Force diversity - no dimension should be dominated by one category
- Include the mutation options explicitly
- Think about underserved segments that are overlooked

Return ONLY valid JSON with this structure:
{
  "dimensions": {
    "industry_vertical": ["Industry 1", "Industry 2", ... 50+ options],
    "company_size": ["Size 1", "Size 2", ... 50+ options],
    "decision_maker": ["Role 1", "Role 2", ... 50+ options],
    "purchase_trigger": ["Trigger 1", "Trigger 2", ... 50+ options],
    "tech_adoption": ["Profile 1", "Profile 2", ... 50+ options],
    "buying_process": ["Process 1", "Process 2", ... 50+ options],
    "budget_authority": ["Authority 1", "Authority 2", ... 50+ options],
    "urgency_profile": ["Profile 1", "Profile 2", ... 50+ options]
  }
}`;
      }
      getB2CGeneLibraryPrompt(context) {
        const keywords = context.contextKeywords || [];
        const keywordsSection = keywords.length >= 3 ? `
CONTEXT GUIDANCE: Consider these context keywords when generating segments: ${keywords.slice(0, 6).join(", ")}. Prioritize segments that connect to this offering's specific domain while still exploring surprising adjacent opportunities.` : "";
        return `You are a consumer market segmentation expert specializing in discovering SURPRISING, NON-OBVIOUS B2C customer segments. Your job is to surface consumer segments that founders would never think of on their own.
${keywordsSection}

OFFERING CONTEXT:
- Description: ${context.offeringDescription}
- Type: ${context.offeringType}
- Stage: ${context.stage}
- GTM Constraint: ${context.gtmConstraint}
- Sales Motion: ${context.salesMotion}
${context.existingHypothesis ? `- Existing Hypothesis: ${context.existingHypothesis}` : ""}

Generate a COMPREHENSIVE gene library with 50+ options per dimension. The goal is DIVERSITY and DISCOVERY - push beyond the obvious, BUT all options must be relevant to this specific offering.

KEY PRINCIPLE: "Who has this need but nobody's serving them well?"

DIMENSIONS TO POPULATE (50+ alleles each):

1. demographic_segment - WHO they are:
   - Age groups (Gen Z, Millennials, Gen X, Boomers, Silent Gen)
   - Life stages (students, new grads, young professionals, new parents, empty nesters, retirees)
   - Family composition (singles, couples, young families, multi-generational households)
   - Income levels (budget-conscious, middle-income, affluent, ultra-high-net-worth)
   - Geographic (urban, suburban, rural, coastal, heartland)
   - Cultural backgrounds (immigrants, expats, multicultural families)
   - Education levels (high school, college, graduate, trade school)
   - Occupation types (blue collar, white collar, gig workers, stay-at-home parents)
   Include UNUSUAL demographics that might have the underlying need.

2. psychographic_profile - HOW they think:
   - Values-driven (eco-conscious, health-focused, family-first, career-driven)
   - Risk tolerance (adventurous, cautious, moderate)
   - Social orientation (introverts, extroverts, ambiverts)
   - Decision style (impulsive, analytical, emotional, social proof seekers)
   - Status orientation (aspirational, practical, luxury seekers, minimalists)
   - Tech relationship (digital natives, tech-curious, tech-resistant)
   - Health consciousness (wellness obsessed, health aware, health indifferent)
   - Environmental stance (activists, concerned, indifferent, skeptics)

3. lifestyle_context - HOW they live:
   - Living situations (renters, homeowners, apartment dwellers, mobile living)
   - Daily routines (9-5 workers, shift workers, remote workers, freelancers)
   - Hobbies and interests (sports, gaming, crafts, travel, cooking, fitness)
   - Social activities (social butterflies, homebodies, community volunteers)
   - Pet owners (dogs, cats, exotic pets, multiple pets)
   - Dietary preferences (vegan, keto, gluten-free, foodie, convenience eaters)
   - Fitness levels (athletes, gym-goers, casual exercisers, sedentary)
   - Entertainment preferences (streamers, readers, outdoor enthusiasts, gamers)

4. purchase_occasion - WHEN they buy:
   - Life events (weddings, babies, moving, graduation, retirement)
   - Seasonal triggers (holidays, back-to-school, summer, New Year's resolutions)
   - Emotional states (stress relief, celebration, self-care, boredom)
   - Problem triggers (something broke, ran out, discovered need)
   - Social triggers (gift giving, keeping up with friends, recommendations)
   - Habitual purchases (routine replenishment, subscriptions)
   - Impulse moments (browsing, waiting, commuting)
   - Discovery moments (saw on social media, heard from friend, saw in store)

5. channel_preference - WHERE they shop:
   - E-commerce (Amazon, DTC brands, marketplaces)
   - Social commerce (Instagram, TikTok Shop, Facebook Marketplace)
   - Physical retail (big box, boutique, convenience stores)
   - Subscription services (monthly boxes, auto-replenishment)
   - Local/artisan (farmers markets, craft fairs, local shops)
   - Discount/value (outlet stores, warehouse clubs, dollar stores)
   - Specialty channels (niche online communities, enthusiast sites)
   - Hybrid (BOPIS, curbside, showrooming)

6. price_sensitivity - HOW they value money:
   - Premium seekers (quality over price, status purchases)
   - Value optimizers (best bang for buck, comparison shoppers)
   - Deal hunters (coupon clippers, wait for sales, cashback obsessed)
   - Budget constrained (paycheck-to-paycheck, student budgets)
   - Situational spenders (splurge on passions, scrimp elsewhere)
   - Subscription tolerant (willing to pay recurring for convenience)
   - Free trial seekers (convert with experience, not price)
   - Investment mindset (pay more for durability/longevity)

7. brand_relationship - HOW they connect with brands:
   - Brand loyal (stick with what works, resistant to change)
   - Brand curious (open to trying new things, variety seekers)
   - Brand agnostic (commodity buyers, private label fans)
   - Brand advocates (influencers, reviewers, word-of-mouth drivers)
   - Brand skeptics (anti-corporate, prefer indie/local)
   - Community seekers (join brand communities, attend events)
   - Cause-aligned (support brands matching their values)
   - Convenience-driven (whatever is easiest, lowest friction)

8. usage_frequency - HOW often they engage:
   - Daily users (habitual, part of routine)
   - Weekly users (regular but not daily)
   - Occasional users (monthly, seasonal)
   - One-time/rare users (major purchases, special occasions)
   - Binge users (heavy use periods followed by breaks)
   - Trial users (trying before committing)
   - Power users (heavy usage, advanced features)
   - Light users (minimal engagement, basic features only)

MUTATION REQUIREMENT:
For each dimension, include 5-10 "MUTATION" options - consumer types that seem like UNLIKELY or COUNTERINTUITIVE fits at first glance but might have the underlying need. These are often where the best insights come from.

REQUIREMENTS:
- Generate 50+ alleles per dimension
- Include obvious consumer segments but PRIORITIZE non-obvious ones
- Force diversity - no dimension should be dominated by one category
- Include the mutation options explicitly
- Think about underserved consumer segments that are overlooked

Return ONLY valid JSON with this structure:
{
  "dimensions": {
    "demographic_segment": ["Segment 1", "Segment 2", ... 50+ options],
    "psychographic_profile": ["Profile 1", "Profile 2", ... 50+ options],
    "lifestyle_context": ["Context 1", "Context 2", ... 50+ options],
    "purchase_occasion": ["Occasion 1", "Occasion 2", ... 50+ options],
    "channel_preference": ["Channel 1", "Channel 2", ... 50+ options],
    "price_sensitivity": ["Sensitivity 1", "Sensitivity 2", ... 50+ options],
    "brand_relationship": ["Relationship 1", "Relationship 2", ... 50+ options],
    "usage_frequency": ["Frequency 1", "Frequency 2", ... 50+ options]
  }
}`;
      }
      async generateGeneLibrary(context) {
        const mode = context.segmentationMode || detectSegmentationMode(context.offeringType);
        const prompt = mode === "b2c" ? this.getB2CGeneLibraryPrompt(context) : this.getB2BGeneLibraryPrompt(context);
        console.log(`[SegmentDiscoveryEngine] Using ${mode.toUpperCase()} segmentation mode for: ${context.offeringType}`);
        console.log(`[SegmentDiscoveryEngine] Prompt type: ${mode === "b2c" ? "B2C Consumer Segments" : "B2B Business Segments"}`);
        if (context.contextKeywords?.length) {
          console.log(`[SegmentDiscoveryEngine] Context keywords: ${context.contextKeywords.join(", ")}`);
        }
        console.log(`[SegmentDiscoveryEngine] Prompt preview: ${prompt.substring(0, 150).replace(/\n/g, " ")}...`);
        return withRetry(async () => {
          const response = await withTimeout(
            this.anthropic.messages.create({
              model: "claude-sonnet-4-20250514",
              max_tokens: 16e3,
              messages: [{ role: "user", content: prompt }]
            }),
            AI_TIMEOUT_LONG_MS,
            // Longer timeout for large gene library generation
            "generateGeneLibrary"
          );
          const content = response.content[0];
          if (content.type !== "text") {
            throw new Error("Unexpected response type");
          }
          const jsonMatch = content.text.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            throw new Error("No JSON found in response");
          }
          const library = JSON.parse(jsonMatch[0]);
          const counts = Object.entries(library.dimensions).map(
            ([dim, alleles]) => `${dim}: ${alleles.length}`
          ).join(", ");
          console.log(`[SegmentDiscoveryEngine] Gene library dimensions: ${counts}`);
          return library;
        }, "generateGeneLibrary");
      }
      async generateGenomes(geneLibrary, context, count2 = 100) {
        const mode = context.segmentationMode || detectSegmentationMode(context.offeringType);
        const batchSize = Math.ceil(count2 / 4);
        const batchCount = 4;
        const batchPromises = Array.from(
          { length: batchCount },
          (_, batchIndex) => this.generateGenomeBatch(geneLibrary, context, batchSize, batchIndex)
        );
        console.log(`[SegmentDiscoveryEngine] Starting ${batchCount} parallel genome batches of ${batchSize} each`);
        const batchResults = await Promise.all(batchPromises);
        const allGenomes = batchResults.flat();
        const seen = /* @__PURE__ */ new Set();
        const diversityCounts = /* @__PURE__ */ new Map();
        const MAX_GENOMES_PER_KEY = 3;
        const uniqueGenomes = [];
        let duplicatesRemoved = 0;
        let diversityFiltered = 0;
        const diversityKey = mode === "b2c" ? "demographic_segment" : "decision_maker";
        for (const genome of allGenomes) {
          const hash = this.getCanonicalGenomeHash(genome.genes);
          if (seen.has(hash)) {
            duplicatesRemoved++;
            continue;
          }
          const keyValue = genome.genes[diversityKey];
          if (!keyValue) {
            console.warn(`[SegmentDiscoveryEngine] Skipping genome with missing ${diversityKey} key`);
            continue;
          }
          const currentCount = diversityCounts.get(keyValue) || 0;
          if (currentCount >= MAX_GENOMES_PER_KEY) {
            diversityFiltered++;
            continue;
          }
          seen.add(hash);
          diversityCounts.set(keyValue, currentCount + 1);
          uniqueGenomes.push({
            ...genome,
            id: `genome_${String(uniqueGenomes.length + 1).padStart(3, "0")}`
          });
        }
        console.log(`[SegmentDiscoveryEngine] Generated ${uniqueGenomes.length} unique genomes (${duplicatesRemoved} duplicates, ${diversityFiltered} filtered by diversity constraint)`);
        console.log(`[SegmentDiscoveryEngine] Diversity: ${diversityCounts.size} unique ${diversityKey} values`);
        if (uniqueGenomes.length < count2) {
          console.log(`[SegmentDiscoveryEngine] Warning: Only ${uniqueGenomes.length} unique genomes available (requested ${count2})`);
        }
        return uniqueGenomes.slice(0, count2);
      }
      getCanonicalGenomeHash(genes) {
        const isB2C = "demographic_segment" in genes;
        if (isB2C) {
          const b2cKeys = [
            "demographic_segment",
            "psychographic_profile",
            "lifestyle_context",
            "purchase_occasion",
            "channel_preference",
            "price_sensitivity",
            "brand_relationship",
            "usage_frequency"
          ];
          return b2cKeys.map((key) => genes[key]).join("|");
        }
        const b2bKeys = [
          "industry_vertical",
          "company_size",
          "decision_maker",
          "purchase_trigger",
          "tech_adoption",
          "buying_process",
          "budget_authority",
          "urgency_profile"
        ];
        return b2bKeys.map((key) => genes[key]).join("|");
      }
      getGenomeExampleForMode(mode, batchIndex, count2) {
        if (mode === "b2c") {
          return `[
  {
    "id": "genome_${String(batchIndex * count2 + 1).padStart(3, "0")}",
    "genes": {
      "demographic_segment": "one allele from the library",
      "psychographic_profile": "one allele from the library",
      "lifestyle_context": "one allele from the library",
      "purchase_occasion": "one allele from the library",
      "channel_preference": "one allele from the library",
      "price_sensitivity": "one allele from the library",
      "brand_relationship": "one allele from the library",
      "usage_frequency": "one allele from the library"
    }
  },
  ...
]`;
        }
        return `[
  {
    "id": "genome_${String(batchIndex * count2 + 1).padStart(3, "0")}",
    "genes": {
      "industry_vertical": "one allele from the library",
      "company_size": "one allele from the library",
      "decision_maker": "one allele from the library",
      "purchase_trigger": "one allele from the library",
      "tech_adoption": "one allele from the library",
      "buying_process": "one allele from the library",
      "budget_authority": "one allele from the library",
      "urgency_profile": "one allele from the library"
    }
  },
  ...
]`;
      }
      async generateGenomeBatch(geneLibrary, context, count2, batchIndex) {
        const mode = context.segmentationMode || detectSegmentationMode(context.offeringType);
        const segmentType = mode === "b2c" ? "consumer" : "business";
        const focusAreas = [
          "high-potential obvious segments that are most likely to succeed",
          "non-obvious but promising niche segments with unique opportunities",
          "edge cases and challenging segments to stress-test assumptions",
          "diverse combinations exploring the full gene space"
        ];
        const b2cGuidance = mode === "b2c" ? `
CRITICAL B2C RULES:
- These are INDIVIDUAL PEOPLE (consumers/end-users), NOT businesses or organizations
- For restaurants/cafes/local businesses: customers are DINERS/PATRONS who come to eat/drink, not other business owners
- Examples of CORRECT B2C segments: "Young professionals seeking date night spots", "Affluent couples celebrating anniversaries", "Food enthusiasts exploring new cuisines"
- Examples of WRONG B2B segments (never use these): "Shisha lounge owners", "Event planners", "Corporate catering managers", "Restaurant consultants"
- All segments must be people who would personally use/consume the offering
` : "";
        const prompt = `You are a ${segmentType} market strategist creating segment combinations for discovery.
${b2cGuidance}
OFFERING CONTEXT:
- Description: ${context.offeringDescription}
- Type: ${context.offeringType}
- Stage: ${context.stage}
- GTM Constraint: ${context.gtmConstraint}
- Sales Motion: ${context.salesMotion}

GENE LIBRARY (available alleles for each dimension):
${JSON.stringify(geneLibrary.dimensions, null, 2)}

YOUR FOCUS: Generate ${count2} unique ${segmentType} segment combinations focusing on ${focusAreas[batchIndex]}.

BATCH ID: ${batchIndex + 1} of 4 - Use IDs starting with genome_${String(batchIndex * count2 + 1).padStart(3, "0")}.

REQUIREMENTS:
- Create STRATEGICALLY interesting combinations for your focus area
- Each genome is a specific combination of one allele from each dimension
- Consider which combinations make logical sense together
- Ensure variety within your focus area
${mode === "b2c" ? "- REMEMBER: All segments must be individual people who personally consume the offering" : ""}

Return ONLY valid JSON array with exactly ${count2} genomes:
${this.getGenomeExampleForMode(mode, batchIndex, count2)}`;
        return withRetry(async () => {
          const response = await withTimeout(
            this.anthropic.messages.create({
              model: "claude-sonnet-4-20250514",
              max_tokens: 8e3,
              messages: [{ role: "user", content: prompt }]
            }),
            AI_TIMEOUT_MS,
            `generateGenomeBatch-${batchIndex}`
          );
          const content = response.content[0];
          if (content.type !== "text") {
            throw new Error("Unexpected response type");
          }
          const jsonMatch = content.text.match(/\[[\s\S]*\]/);
          if (!jsonMatch) {
            throw new Error("No JSON array found in response");
          }
          const genomes = JSON.parse(jsonMatch[0]);
          return genomes.map((g, idx) => ({
            id: g.id || `genome_${String(batchIndex * count2 + idx + 1).padStart(3, "0")}`,
            genes: g.genes,
            fitness: {
              painIntensity: 0,
              accessToDecisionMaker: 0,
              purchasePowerMatch: 0,
              competitionSaturation: 0,
              productFit: 0,
              urgencyAlignment: 0,
              scalePotential: 0,
              gtmEfficiency: 0,
              totalScore: 0
            },
            narrativeReason: ""
          }));
        }, `generateGenomeBatch-${batchIndex}`);
      }
      async scoreGenomes(genomes, context) {
        const batchSize = 25;
        const batches = [];
        for (let i = 0; i < genomes.length; i += batchSize) {
          batches.push(genomes.slice(i, i + batchSize));
        }
        const scoredBatches = await Promise.all(
          batches.map((batch) => this.scoreBatch(batch, context))
        );
        const scoredGenomes = scoredBatches.flat();
        return scoredGenomes.sort((a, b) => b.fitness.totalScore - a.fitness.totalScore);
      }
      filterByRelevance(genomes, context) {
        const mode = context.segmentationMode || detectSegmentationMode(context.offeringType);
        const keywords = context.contextKeywords || [];
        if (mode !== "b2c" || keywords.length < 3) {
          return genomes;
        }
        const originalCount = genomes.length;
        const keywordWords = /* @__PURE__ */ new Set();
        for (const kw of keywords) {
          const words = kw.toLowerCase().split(/\s+/);
          for (const w of words) {
            if (w.length >= 3) keywordWords.add(w);
          }
        }
        const keywordWordsArray = Array.from(keywordWords);
        const scoredByRelevance = genomes.map((genome) => {
          const geneText = Object.values(genome.genes).join(" ").toLowerCase();
          const narrativeText = (genome.narrativeReason || "").toLowerCase();
          const combinedText = `${geneText} ${narrativeText}`;
          let matchScore = 0;
          for (const word of keywordWordsArray) {
            if (combinedText.includes(word)) matchScore++;
            const words = combinedText.split(/\s+/);
            if (words.some((w) => w.startsWith(word.slice(0, Math.min(4, word.length))))) {
              matchScore += 0.5;
            }
          }
          return { genome, matchScore };
        });
        const filtered = scoredByRelevance.filter((g) => g.matchScore > 0).map((g) => g.genome);
        const prunedCount = originalCount - filtered.length;
        if (prunedCount > 0) {
          console.log(`[SegmentDiscoveryEngine] Soft-filtered ${prunedCount} genomes with low keyword relevance`);
        }
        if (filtered.length < 40 && genomes.length >= 40) {
          console.log(`[SegmentDiscoveryEngine] Adding top-scoring genomes to ensure diversity`);
          const needed = 40 - filtered.length;
          const additional = genomes.filter((g) => !filtered.includes(g)).slice(0, needed);
          return [...filtered, ...additional];
        }
        return filtered.length > 0 ? filtered : genomes;
      }
      getScoringCriteriaForMode(mode) {
        if (mode === "b2c") {
          return `Score each CONSUMER segment on these 8 criteria (1-5 scale each, 40 points max total):

CRITICAL: These are individual people/consumers who personally use the offering (e.g., diners at a restaurant), NOT businesses.

1. painIntensity (1-5): "Desire Strength" - How strong is this consumer's desire/craving for this type of offering?
2. accessToDecisionMaker (1-5): "Reachability" - How easy is it to reach and attract these individual consumers? (social media, local presence, word of mouth)
3. purchasePowerMatch (1-5): "Spending Match" - Does their disposable income match your pricing?
4. competitionSaturation (1-5): "Market Opportunity" - How underserved is this segment? (5 = many unmet needs)
5. productFit (1-5): "Lifestyle Fit" - How well does your offering match their lifestyle and preferences?
6. urgencyAlignment (1-5): "Purchase Readiness" - How motivated are they to buy/visit soon?
7. scalePotential (1-5): "Segment Size" - How many consumers like this exist in your market?
8. gtmEfficiency (1-5): "Marketing Efficiency" - Can you efficiently reach this consumer segment with your marketing resources?`;
        }
        return `Score each BUSINESS segment on these 8 criteria (1-5 scale each, 40 points max total):

1. painIntensity (1-5): How intense is the pain this segment experiences?
2. accessToDecisionMaker (1-5): How easy is it to reach the decision maker?
3. purchasePowerMatch (1-5): Does their budget match your pricing?
4. competitionSaturation (1-5): How uncrowded is this segment? (5 = very uncrowded/good)
5. productFit (1-5): How well does your offering fit their needs?
6. urgencyAlignment (1-5): How urgent is their need?
7. scalePotential (1-5): Can you scale in this segment?
8. gtmEfficiency (1-5): Can you efficiently reach this segment given your constraints?`;
      }
      async scoreBatch(genomes, context) {
        const mode = context.segmentationMode || detectSegmentationMode(context.offeringType);
        const segmentType = mode === "b2c" ? "consumer" : "business";
        const prompt = `You are a rigorous ${segmentType} market analyst scoring segment viability.

OFFERING CONTEXT:
- Description: ${context.offeringDescription}
- Type: ${context.offeringType}
- Stage: ${context.stage}
- GTM Constraint: ${context.gtmConstraint}
- Sales Motion: ${context.salesMotion}

GENOMES TO SCORE:
${JSON.stringify(genomes.map((g) => ({ id: g.id, genes: g.genes })), null, 2)}

${this.getScoringCriteriaForMode(mode)}

SCORING RULES:
- Be RIGOROUS and DIFFERENTIATED - don't give everything 3s and 4s
- Use the full 1-5 range
- Consider the stage and GTM constraints when scoring
- Provide a brief narrative reason explaining the score

Return ONLY valid JSON array:
[
  {
    "id": "genome_001",
    "fitness": {
      "painIntensity": 4,
      "accessToDecisionMaker": 3,
      "purchasePowerMatch": 5,
      "competitionSaturation": 2,
      "productFit": 4,
      "urgencyAlignment": 3,
      "scalePotential": 4,
      "gtmEfficiency": 3,
      "totalScore": 28
    },
    "narrativeReason": "Brief explanation of why this segment scores this way"
  },
  ...
]`;
        return withRetry(async () => {
          const response = await withTimeout(
            this.anthropic.messages.create({
              model: "claude-sonnet-4-20250514",
              max_tokens: 8e3,
              messages: [{ role: "user", content: prompt }]
            }),
            AI_TIMEOUT_MS,
            "scoreBatch"
          );
          const content = response.content[0];
          if (content.type !== "text") {
            throw new Error("Unexpected response type");
          }
          const jsonMatch = content.text.match(/\[[\s\S]*\]/);
          if (!jsonMatch) {
            throw new Error("No JSON array found in response");
          }
          const scores = JSON.parse(jsonMatch[0]);
          const scoreMap = new Map(scores.map((s) => [s.id, s]));
          return genomes.map((genome) => {
            const score = scoreMap.get(genome.id);
            if (score) {
              const fitness = score.fitness;
              fitness.totalScore = fitness.painIntensity + fitness.accessToDecisionMaker + fitness.purchasePowerMatch + fitness.competitionSaturation + fitness.productFit + fitness.urgencyAlignment + fitness.scalePotential + fitness.gtmEfficiency;
              return {
                ...genome,
                fitness,
                narrativeReason: score.narrativeReason
              };
            }
            return genome;
          });
        }, "scoreBatch");
      }
      async stressTest(topGenomes) {
        const batchSize = Math.ceil(topGenomes.length / 4);
        const batches = [];
        for (let i = 0; i < topGenomes.length; i += batchSize) {
          batches.push(topGenomes.slice(i, i + batchSize));
        }
        console.log(`[SegmentDiscoveryEngine] Starting ${batches.length} parallel stress test batches of ${batchSize} each`);
        const batchPromises = batches.map((batch) => this.stressTestBatch(batch));
        const batchResults = await Promise.all(batchPromises);
        const allTested = batchResults.flat();
        return allTested.sort((a, b) => b.fitness.totalScore - a.fitness.totalScore);
      }
      async stressTestBatch(genomes) {
        const prompt = `You are a critical market strategist stress-testing segment candidates.

TOP SEGMENT CANDIDATES:
${JSON.stringify(genomes.map((g) => ({
          id: g.id,
          genes: g.genes,
          totalScore: g.fitness.totalScore,
          narrativeReason: g.narrativeReason
        })), null, 2)}

For each segment, perform ADVERSARIAL TESTING:

1. Identify potential weaknesses or blind spots
2. Challenge the assumptions behind the scoring
3. Consider what could go wrong
4. Adjust scores if the stress test reveals issues
5. Add stress test findings to the narrative

Return ONLY valid JSON array with updated genomes:
[
  {
    "id": "genome_001",
    "fitness": {
      "painIntensity": 4,
      "accessToDecisionMaker": 3,
      "purchasePowerMatch": 5,
      "competitionSaturation": 2,
      "productFit": 4,
      "urgencyAlignment": 3,
      "scalePotential": 3,
      "gtmEfficiency": 3,
      "totalScore": 27
    },
    "narrativeReason": "Original narrative + STRESS TEST: Key risks identified...",
    "stressTestFindings": ["Finding 1", "Finding 2"]
  },
  ...
]`;
        try {
          return await withRetry(async () => {
            const response = await withTimeout(
              this.anthropic.messages.create({
                model: "claude-sonnet-4-20250514",
                max_tokens: 4e3,
                messages: [{ role: "user", content: prompt }]
              }),
              AI_TIMEOUT_MS,
              "stressTestBatch"
            );
            const content = response.content[0];
            if (content.type !== "text") {
              throw new Error("Unexpected response type");
            }
            const jsonMatch = content.text.match(/\[[\s\S]*\]/);
            if (!jsonMatch) {
              throw new Error("No JSON array found in response");
            }
            const testedGenomes = JSON.parse(jsonMatch[0]);
            const testedMap = new Map(testedGenomes.map((g) => [g.id, g]));
            return genomes.map((genome) => {
              const tested = testedMap.get(genome.id);
              if (tested) {
                const fitness = tested.fitness;
                fitness.totalScore = fitness.painIntensity + fitness.accessToDecisionMaker + fitness.purchasePowerMatch + fitness.competitionSaturation + fitness.productFit + fitness.urgencyAlignment + fitness.scalePotential + fitness.gtmEfficiency;
                return {
                  ...genome,
                  genes: genome.genes,
                  fitness,
                  narrativeReason: tested.narrativeReason
                };
              }
              return genome;
            });
          }, "stressTestBatch");
        } catch (error) {
          console.error("[SegmentDiscoveryEngine] Error in stress test batch (after retries):", error);
          return genomes;
        }
      }
      async synthesize(genomes, context) {
        const top10 = genomes.slice(0, 10);
        const bottom5 = genomes.slice(-5);
        const mode = context.segmentationMode || detectSegmentationMode(context.offeringType);
        const b2cSynthesisGuidance = mode === "b2c" ? `
CRITICAL B2C CONTEXT:
- These segments are INDIVIDUAL CONSUMERS (people), not businesses
- For restaurants/cafes: these are DINERS who come to eat, not other business owners
- Validation plans should focus on reaching individual consumers (social media, local events, dining apps)
- NOT business networking, B2B partnerships, or industry conferences
` : "";
        const prompt = `You are a strategic advisor synthesizing ${mode === "b2c" ? "consumer" : "business"} segment discovery findings.
${b2cSynthesisGuidance}
OFFERING CONTEXT:
- Description: ${context.offeringDescription}
- Type: ${context.offeringType}
- Stage: ${context.stage}
- GTM Constraint: ${context.gtmConstraint}
- Sales Motion: ${context.salesMotion}

TOP 10 SEGMENTS (sorted by score):
${JSON.stringify(top10.map((g) => ({
          id: g.id,
          genes: g.genes,
          totalScore: g.fitness.totalScore,
          fitness: g.fitness,
          narrativeReason: g.narrativeReason
        })), null, 2)}

BOTTOM 5 SEGMENTS (for never list consideration):
${JSON.stringify(bottom5.map((g) => ({
          id: g.id,
          genes: g.genes,
          totalScore: g.fitness.totalScore,
          narrativeReason: g.narrativeReason
        })), null, 2)}

SYNTHESIS TASK:
1. Select the BEACHHEAD segment - your #1 recommendation with clear rationale
2. Provide a concrete validation plan (3-5 specific actions)
3. Select 2-3 BACKUP segments
4. Identify 2-3 segments for the NEVER LIST with reasons
5. Generate 3-5 strategic insights from this analysis

Return ONLY valid JSON:
{
  "beachhead": {
    "genomeId": "genome_xxx",
    "rationale": "Why this is the best beachhead segment...",
    "validationPlan": [
      "Specific action 1",
      "Specific action 2",
      "Specific action 3"
    ]
  },
  "backupSegmentIds": ["genome_xxx", "genome_yyy"],
  "neverList": [
    {
      "genomeId": "genome_zzz",
      "reason": "Why to avoid this segment..."
    }
  ],
  "strategicInsights": [
    "Insight 1 about the overall segment landscape",
    "Insight 2 about patterns observed",
    "Insight 3 about go-to-market implications"
  ]
}`;
        return withRetry(async () => {
          const response = await withTimeout(
            this.anthropic.messages.create({
              model: "claude-sonnet-4-20250514",
              max_tokens: 4e3,
              messages: [{ role: "user", content: prompt }]
            }),
            AI_TIMEOUT_MS,
            "synthesize"
          );
          const content = response.content[0];
          if (content.type !== "text") {
            throw new Error("Unexpected response type");
          }
          const jsonMatch = content.text.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            throw new Error("No JSON found in response");
          }
          const result = JSON.parse(jsonMatch[0]);
          const genomeMap = new Map(genomes.map((g) => [g.id, g]));
          const beachheadGenome = genomeMap.get(result.beachhead.genomeId) || top10[0];
          const backupGenomes = result.backupSegmentIds.map((id) => genomeMap.get(id)).filter((g) => g !== void 0);
          const neverListItems = result.neverList.map((item) => ({
            genome: genomeMap.get(item.genomeId) || bottom5[0],
            reason: item.reason
          }));
          return {
            beachhead: {
              genome: beachheadGenome,
              rationale: result.beachhead.rationale,
              validationPlan: result.beachhead.validationPlan
            },
            backupSegments: backupGenomes.length > 0 ? backupGenomes : top10.slice(1, 4),
            neverList: neverListItems,
            strategicInsights: result.strategicInsights
          };
        }, "synthesize");
      }
      async runDiscovery(context, onProgress) {
        console.log("[SegmentDiscoveryEngine] Starting discovery for:", context.offeringType);
        onProgress("Generating gene library", 10);
        const geneLibrary = await this.generateGeneLibrary(context);
        console.log("[SegmentDiscoveryEngine] Gene library generated:", Object.keys(geneLibrary.dimensions).length, "dimensions");
        onProgress("Creating segment combinations", 30);
        const genomes = await this.generateGenomes(geneLibrary, context, 100);
        console.log("[SegmentDiscoveryEngine] Generated", genomes.length, "genomes");
        onProgress("Scoring segments", 50);
        const scoredGenomes = await this.scoreGenomes(genomes, context);
        console.log("[SegmentDiscoveryEngine] Scored genomes, top score:", scoredGenomes[0]?.fitness.totalScore);
        const filteredGenomes = this.filterByRelevance(scoredGenomes, context);
        onProgress("Stress testing top candidates", 70);
        const top20 = filteredGenomes.slice(0, 20);
        const testedGenomes = await this.stressTest(top20);
        console.log("[SegmentDiscoveryEngine] Stress tested top 20");
        const finalGenomes = [
          ...testedGenomes,
          ...filteredGenomes.slice(20)
        ];
        onProgress("Synthesizing recommendations", 90);
        const synthesis = await this.synthesize(finalGenomes, context);
        console.log("[SegmentDiscoveryEngine] Synthesis complete, beachhead:", synthesis.beachhead.genome.id);
        onProgress("Complete", 100);
        return {
          geneLibrary,
          genomes: finalGenomes,
          synthesis
        };
      }
    };
    segmentDiscoveryEngine = new SegmentDiscoveryEngine();
  }
});

// server/intelligence/porters-analyzer.ts
var PortersAnalyzer;
var init_porters_analyzer = __esm({
  "server/intelligence/porters-analyzer.ts"() {
    "use strict";
    PortersAnalyzer = class {
      /**
       * Generate references from Porter's Five Forces analysis
       */
      generateReferences(frameworkResults) {
        const references3 = [];
        const forces = [
          { name: "Threat of New Entrants", force: frameworkResults.threatOfNewEntrants },
          { name: "Bargaining Power of Suppliers", force: frameworkResults.bargainingPowerOfSuppliers },
          { name: "Bargaining Power of Buyers", force: frameworkResults.bargainingPowerOfBuyers },
          { name: "Threat of Substitutes", force: frameworkResults.threatOfSubstitutes },
          { name: "Competitive Rivalry", force: frameworkResults.competitiveRivalry }
        ];
        forces.forEach(({ name, force }) => {
          references3.push({
            title: `Porter's Five Forces: ${name}`,
            sourceType: "internal_doc",
            description: force.analysis.substring(0, 200),
            topics: ["porter's five forces", name.toLowerCase(), "competitive analysis"],
            confidence: force.score / 10,
            // Normalize 0-10 to 0-1
            snippet: force.analysis,
            origin: "llm_generation"
          });
        });
        if (frameworkResults.overallAttractiveness?.summary) {
          references3.push({
            title: "Porter's Five Forces: Market Attractiveness Summary",
            sourceType: "internal_doc",
            description: frameworkResults.overallAttractiveness.summary.substring(0, 200),
            topics: ["porter's five forces", "market attractiveness", "strategic recommendations"],
            confidence: frameworkResults.overallAttractiveness.score / 10,
            snippet: frameworkResults.overallAttractiveness.summary,
            origin: "llm_generation"
          });
        }
        return references3;
      }
      async analyze(frameworkResults) {
        const insights = [];
        insights.push(...await this.extractWorkstreams(frameworkResults));
        insights.push(...await this.extractResources(frameworkResults));
        insights.push(...await this.extractRisks(frameworkResults));
        insights.push(...await this.extractStakeholders(frameworkResults));
        insights.push(...await this.extractBenefits(frameworkResults));
        insights.push(...await this.extractCosts(frameworkResults));
        const timelineInsight = await this.inferTimeline(frameworkResults);
        insights.push(timelineInsight);
        if (frameworkResults.strategicImplications) {
          frameworkResults.strategicImplications.forEach((implication, idx) => {
            insights.push({
              type: "other",
              source: `Porters.strategicImplications[${idx}]`,
              content: implication,
              confidence: 0.85,
              reasoning: "Strategic implication from Five Forces analysis"
            });
          });
        }
        if (frameworkResults.overallAttractiveness) {
          insights.push({
            type: "other",
            source: "Porters.overallAttractiveness",
            content: frameworkResults.overallAttractiveness.summary,
            confidence: 0.9,
            reasoning: "Overall market attractiveness assessment"
          });
        }
        const overallConfidence = this.calculateConfidence(insights);
        const references3 = this.generateReferences(frameworkResults);
        return {
          frameworkType: "porters",
          frameworkRunId: "porters-run-id",
          // Will be set by caller
          insights,
          references: references3,
          marketContext: {
            urgency: this.inferUrgency(frameworkResults),
            riskTolerance: this.inferRiskTolerance(frameworkResults)
          },
          overallConfidence
        };
      }
      async extractWorkstreams(frameworkResults) {
        const insights = [];
        if (frameworkResults.threatOfNewEntrants.barriers && frameworkResults.threatOfNewEntrants.barriers.length > 0) {
          frameworkResults.threatOfNewEntrants.barriers.forEach((barrier, idx) => {
            insights.push({
              type: "workstream",
              source: `Porters.threatOfNewEntrants.barriers[${idx}]`,
              content: `Barrier Reinforcement: ${barrier}`,
              confidence: 0.8,
              reasoning: "Strengthen existing barrier to entry",
              metadata: { category: "Defensive", force: "New Entrants" }
            });
          });
        }
        if (frameworkResults.competitiveRivalry.strategies && frameworkResults.competitiveRivalry.strategies.length > 0) {
          frameworkResults.competitiveRivalry.strategies.forEach((strategy, idx) => {
            insights.push({
              type: "workstream",
              source: `Porters.competitiveRivalry.strategies[${idx}]`,
              content: `Competitive Strategy: ${strategy}`,
              confidence: 0.85,
              reasoning: "Offensive strategy to gain competitive advantage",
              metadata: { category: "Offensive", force: "Competitive Rivalry" }
            });
          });
        }
        if (frameworkResults.bargainingPowerOfSuppliers.score > 5) {
          insights.push({
            type: "workstream",
            source: "Porters.bargainingPowerOfSuppliers",
            content: `Supplier Diversification & Relationship Management
Reduce supplier power through multi-sourcing and strategic partnerships`,
            confidence: 0.75,
            reasoning: `High supplier power (score: ${frameworkResults.bargainingPowerOfSuppliers.score}/10) requires mitigation`,
            metadata: { category: "Risk Mitigation", force: "Supplier Power" }
          });
          if (frameworkResults.bargainingPowerOfSuppliers.mitigations) {
            frameworkResults.bargainingPowerOfSuppliers.mitigations.forEach((mitigation, idx) => {
              insights.push({
                type: "workstream",
                source: `Porters.bargainingPowerOfSuppliers.mitigations[${idx}]`,
                content: `Supplier Mitigation: ${mitigation}`,
                confidence: 0.7,
                reasoning: "Mitigation strategy for supplier power",
                metadata: { category: "Risk Mitigation", force: "Supplier Power" }
              });
            });
          }
        }
        if (frameworkResults.bargainingPowerOfBuyers.score > 5) {
          insights.push({
            type: "workstream",
            source: "Porters.bargainingPowerOfBuyers",
            content: `Customer Retention & Value Enhancement
Increase switching costs and strengthen buyer relationships`,
            confidence: 0.75,
            reasoning: `High buyer power (score: ${frameworkResults.bargainingPowerOfBuyers.score}/10) requires customer loyalty focus`,
            metadata: { category: "Customer Management", force: "Buyer Power" }
          });
        }
        if (frameworkResults.threatOfSubstitutes.score > 5 || frameworkResults.threatOfSubstitutes.substitutes) {
          insights.push({
            type: "workstream",
            source: "Porters.threatOfSubstitutes",
            content: `Product Differentiation & Innovation
Develop unique value propositions to combat substitute threats`,
            confidence: 0.8,
            reasoning: `Substitutes threat (score: ${frameworkResults.threatOfSubstitutes.score}/10) requires differentiation`,
            metadata: { category: "Innovation", force: "Substitutes" }
          });
          if (frameworkResults.threatOfSubstitutes.substitutes && frameworkResults.threatOfSubstitutes.substitutes.length > 0) {
            frameworkResults.threatOfSubstitutes.substitutes.forEach((substitute, idx) => {
              insights.push({
                type: "workstream",
                source: `Porters.threatOfSubstitutes.substitutes[${idx}]`,
                content: `Substitute Defense: Counter ${substitute}`,
                confidence: 0.7,
                reasoning: "Specific workstream to address substitute threat",
                metadata: { category: "Defensive", force: "Substitutes" }
              });
            });
          }
        }
        if (frameworkResults.overallAttractiveness?.recommendations) {
          frameworkResults.overallAttractiveness.recommendations.slice(0, 3).forEach((rec, idx) => {
            insights.push({
              type: "workstream",
              source: `Porters.recommendations[${idx}]`,
              content: rec,
              confidence: 0.75,
              reasoning: "Strategic recommendation from Five Forces analysis",
              metadata: { category: "Strategic" }
            });
          });
        }
        return insights;
      }
      async extractResources(frameworkResults) {
        const insights = [];
        const avgForceScore = this.calculateAverageForceScore(frameworkResults);
        if (avgForceScore > 6) {
          insights.push({
            type: "resource",
            source: "Porters.inference",
            content: "Competitive Intelligence Team: Market analysts, competitive researchers",
            confidence: 0.75,
            reasoning: "High competitive intensity requires dedicated market intelligence",
            metadata: { category: "Competitive" }
          });
        }
        if (frameworkResults.bargainingPowerOfSuppliers.score > 6) {
          insights.push({
            type: "resource",
            source: "Porters.bargainingPowerOfSuppliers",
            content: "Procurement & Supplier Relations: Sourcing specialists, vendor managers",
            confidence: 0.7,
            reasoning: "High supplier power requires strong procurement capabilities",
            metadata: { category: "Procurement" }
          });
        }
        if (frameworkResults.threatOfSubstitutes.score > 5 || frameworkResults.competitiveRivalry.score > 7) {
          insights.push({
            type: "resource",
            source: "Porters.inference",
            content: "Innovation Team: Product developers, R&D, design thinking experts",
            confidence: 0.7,
            reasoning: "Differentiation requirements need innovation capabilities",
            metadata: { category: "Innovation" }
          });
        }
        if (frameworkResults.competitiveRivalry.score > 5) {
          insights.push({
            type: "resource",
            source: "Porters.competitiveRivalry",
            content: "Marketing & Brand: Brand strategists, marketing analysts, content creators",
            confidence: 0.7,
            reasoning: "Competitive rivalry requires strong market positioning",
            metadata: { category: "Marketing" }
          });
        }
        return insights;
      }
      async extractRisks(frameworkResults) {
        const insights = [];
        const forces = [
          { name: "New Entrants", force: frameworkResults.threatOfNewEntrants, type: "Market Entry" },
          { name: "Supplier Power", force: frameworkResults.bargainingPowerOfSuppliers, type: "Supply Chain" },
          { name: "Buyer Power", force: frameworkResults.bargainingPowerOfBuyers, type: "Customer" },
          { name: "Substitutes", force: frameworkResults.threatOfSubstitutes, type: "Product" },
          { name: "Competitive Rivalry", force: frameworkResults.competitiveRivalry, type: "Competitive" }
        ];
        forces.forEach(({ name, force, type }) => {
          if (force.risks && force.risks.length > 0) {
            force.risks.forEach((risk, idx) => {
              insights.push({
                type: "risk",
                source: `Porters.${name.replace(" ", "")}.risks[${idx}]`,
                content: risk,
                confidence: 0.85,
                reasoning: `Identified risk from ${name} force analysis`,
                metadata: {
                  severity: this.scoreToSeverity(force.score),
                  category: type,
                  forceScore: force.score
                }
              });
            });
          }
          if (force.score > 6 && (!force.risks || force.risks.length === 0)) {
            insights.push({
              type: "risk",
              source: `Porters.${name.replace(" ", "")}`,
              content: `${name} Risk: High competitive pressure from ${name.toLowerCase()} (score: ${force.score}/10)`,
              confidence: 0.8,
              reasoning: "High force score indicates significant competitive risk",
              metadata: {
                severity: this.scoreToSeverity(force.score),
                category: type,
                forceScore: force.score
              }
            });
          }
        });
        const highForceCount = forces.filter((f) => f.force.score > 6).length;
        if (highForceCount >= 3) {
          insights.push({
            type: "risk",
            source: "Porters.inference",
            content: `Hostile Competitive Environment: ${highForceCount} of 5 forces scoring high creates challenging market conditions`,
            confidence: 0.85,
            reasoning: "Multiple high forces indicate difficult competitive landscape",
            metadata: {
              severity: "High",
              category: "Strategic",
              highForceCount
            }
          });
        }
        if (frameworkResults.overallAttractiveness.score < 5) {
          insights.push({
            type: "risk",
            source: "Porters.overallAttractiveness",
            content: `Market Attractiveness Risk: Overall industry attractiveness score of ${frameworkResults.overallAttractiveness.score}/10 suggests challenging market conditions`,
            confidence: 0.9,
            reasoning: "Low overall attractiveness indicates strategic market risk",
            metadata: {
              severity: "High",
              category: "Strategic",
              attractivenessScore: frameworkResults.overallAttractiveness.score
            }
          });
        }
        return insights;
      }
      async extractStakeholders(frameworkResults) {
        const insights = [];
        if (frameworkResults.competitiveRivalry.competitors && frameworkResults.competitiveRivalry.competitors.length > 0) {
          frameworkResults.competitiveRivalry.competitors.forEach((competitor, idx) => {
            insights.push({
              type: "stakeholder",
              source: `Porters.competitiveRivalry.competitors[${idx}]`,
              content: `Competitor: ${competitor}`,
              confidence: 0.85,
              reasoning: "Key competitor requiring monitoring and response",
              metadata: {
                power: "High",
                interest: "High",
                group: "Competitors"
              }
            });
          });
        } else if (frameworkResults.competitiveRivalry.score > 5) {
          insights.push({
            type: "stakeholder",
            source: "Porters.competitiveRivalry",
            content: "Competitive Landscape: Direct competitors requiring continuous monitoring",
            confidence: 0.75,
            reasoning: "High competitive rivalry indicates significant competitor presence",
            metadata: {
              power: "High",
              interest: "High",
              group: "Competitors"
            }
          });
        }
        if (frameworkResults.bargainingPowerOfSuppliers.score > 4) {
          insights.push({
            type: "stakeholder",
            source: "Porters.bargainingPowerOfSuppliers",
            content: `Key Suppliers: Critical supply chain partners with ${frameworkResults.bargainingPowerOfSuppliers.score > 6 ? "high" : "moderate"} bargaining power`,
            confidence: 0.8,
            reasoning: "Suppliers are key stakeholders based on their power",
            metadata: {
              power: frameworkResults.bargainingPowerOfSuppliers.score > 6 ? "High" : "Medium",
              interest: "Medium",
              group: "Suppliers"
            }
          });
        }
        if (frameworkResults.bargainingPowerOfBuyers.score > 4) {
          insights.push({
            type: "stakeholder",
            source: "Porters.bargainingPowerOfBuyers",
            content: `Customer Base: ${frameworkResults.bargainingPowerOfBuyers.score > 6 ? "Powerful" : "Influential"} buyers requiring value delivery`,
            confidence: 0.85,
            reasoning: "Buyer power indicates customer stakeholder importance",
            metadata: {
              power: frameworkResults.bargainingPowerOfBuyers.score > 6 ? "High" : "Medium",
              interest: "High",
              group: "Customers"
            }
          });
        }
        if (frameworkResults.threatOfNewEntrants.barriers) {
          const hasRegulatoryBarrier = frameworkResults.threatOfNewEntrants.barriers.some(
            (b) => b.toLowerCase().includes("regulat") || b.toLowerCase().includes("compliance") || b.toLowerCase().includes("license")
          );
          if (hasRegulatoryBarrier) {
            insights.push({
              type: "stakeholder",
              source: "Porters.threatOfNewEntrants.barriers",
              content: "Regulatory Bodies: Industry regulators and compliance authorities",
              confidence: 0.75,
              reasoning: "Regulatory barriers indicate regulatory stakeholder importance",
              metadata: {
                power: "High",
                interest: "Medium",
                group: "Regulatory"
              }
            });
          }
        }
        return insights;
      }
      async extractBenefits(frameworkResults) {
        const insights = [];
        if (frameworkResults.threatOfNewEntrants.score < 5) {
          insights.push({
            type: "benefit",
            source: "Porters.threatOfNewEntrants",
            content: `Barrier Protection: Low new entrant threat (${frameworkResults.threatOfNewEntrants.score}/10) provides sustainable competitive advantage`,
            confidence: 0.8,
            reasoning: "Low entry threat is a strategic benefit",
            metadata: { category: "Strategic", defensibility: true }
          });
        }
        if (frameworkResults.overallAttractiveness.score > 6) {
          insights.push({
            type: "benefit",
            source: "Porters.overallAttractiveness",
            content: `Attractive Market: Industry attractiveness score of ${frameworkResults.overallAttractiveness.score}/10 indicates favorable market conditions`,
            confidence: 0.85,
            reasoning: "High market attractiveness represents strategic benefit",
            metadata: { category: "Strategic" }
          });
        }
        const forces = [
          { name: "New Entrants", force: frameworkResults.threatOfNewEntrants },
          { name: "Supplier Power", force: frameworkResults.bargainingPowerOfSuppliers },
          { name: "Buyer Power", force: frameworkResults.bargainingPowerOfBuyers },
          { name: "Substitutes", force: frameworkResults.threatOfSubstitutes },
          { name: "Competitive Rivalry", force: frameworkResults.competitiveRivalry }
        ];
        forces.forEach(({ name, force }) => {
          if (force.opportunities && force.opportunities.length > 0) {
            force.opportunities.forEach((opportunity, idx) => {
              insights.push({
                type: "benefit",
                source: `Porters.${name.replace(" ", "")}.opportunities[${idx}]`,
                content: opportunity,
                confidence: 0.75,
                reasoning: `Opportunity identified from ${name} analysis`,
                metadata: { category: "Strategic" }
              });
            });
          }
        });
        if (frameworkResults.competitiveRivalry.score < 6) {
          insights.push({
            type: "benefit",
            source: "Porters.competitiveRivalry",
            content: "Competitive Breathing Room: Moderate competitive rivalry allows for strategic positioning and differentiation",
            confidence: 0.7,
            reasoning: "Lower competitive intensity provides strategic flexibility",
            metadata: { category: "Strategic" }
          });
        }
        return insights;
      }
      async extractCosts(frameworkResults) {
        const insights = [];
        const avgForceScore = this.calculateAverageForceScore(frameworkResults);
        if (avgForceScore > 6) {
          insights.push({
            type: "cost",
            source: "Porters.inference",
            content: "Competitive Defense Budget: Marketing, sales, and product development to maintain position",
            confidence: 0.7,
            reasoning: "High competitive pressure requires investment in market defense",
            metadata: { estimatedAmount: 3e5 }
          });
        }
        if (frameworkResults.bargainingPowerOfSuppliers.score > 6) {
          insights.push({
            type: "cost",
            source: "Porters.bargainingPowerOfSuppliers",
            content: "Supplier Premium Costs: Higher input costs due to supplier bargaining power",
            confidence: 0.75,
            reasoning: "High supplier power typically increases procurement costs",
            metadata: { estimatedAmount: 2e5 }
          });
        }
        if (frameworkResults.threatOfSubstitutes.score > 6) {
          insights.push({
            type: "cost",
            source: "Porters.threatOfSubstitutes",
            content: "Innovation & Differentiation Investment: R&D and product development to counter substitutes",
            confidence: 0.7,
            reasoning: "Substitute threats require investment in differentiation",
            metadata: { estimatedAmount: 25e4 }
          });
        }
        return insights;
      }
      async inferTimeline(frameworkResults) {
        let urgency = "Strategic";
        let confidence = 0.7;
        let reasoning = "Default strategic timeline based on competitive analysis";
        const avgForceScore = this.calculateAverageForceScore(frameworkResults);
        if (avgForceScore > 7 || frameworkResults.competitiveRivalry.score > 8) {
          urgency = "ASAP";
          confidence = 0.8;
          reasoning = "High competitive intensity requires urgent strategic response";
        } else if (avgForceScore < 4 && frameworkResults.overallAttractiveness.score > 6) {
          urgency = "Exploratory";
          confidence = 0.75;
          reasoning = "Favorable conditions allow for deliberate strategic development";
        }
        return {
          type: "timeline",
          source: "Porters.inference",
          content: `Recommended timeline: ${urgency === "ASAP" ? "6" : urgency === "Exploratory" ? "18" : "12"} months based on competitive urgency`,
          confidence,
          reasoning,
          metadata: {
            urgency,
            avgForceScore,
            competitiveIntensity: avgForceScore > 6 ? "High" : avgForceScore > 4 ? "Medium" : "Low",
            estimatedMonths: urgency === "ASAP" ? 6 : urgency === "Exploratory" ? 18 : 12
          }
        };
      }
      calculateConfidence(insights) {
        if (insights.length === 0) return 0.5;
        const avgConfidence = insights.reduce((sum, i) => sum + i.confidence, 0) / insights.length;
        const insightPenalty = insights.length < 10 ? 0.05 : 0;
        const types = new Set(insights.map((i) => i.type));
        const requiredTypes = ["workstream", "risk", "stakeholder", "benefit"];
        const missingTypes = requiredTypes.filter((t) => !types.has(t));
        const typePenalty = missingTypes.length * 0.03;
        return Math.max(0.5, Math.min(0.95, avgConfidence - insightPenalty - typePenalty));
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      calculateAverageForceScore(frameworkResults) {
        return (frameworkResults.threatOfNewEntrants.score + frameworkResults.bargainingPowerOfSuppliers.score + frameworkResults.bargainingPowerOfBuyers.score + frameworkResults.threatOfSubstitutes.score + frameworkResults.competitiveRivalry.score) / 5;
      }
      scoreToSeverity(score) {
        if (score >= 8) return "Critical";
        if (score >= 6) return "High";
        if (score >= 4) return "Medium";
        return "Low";
      }
      inferUrgency(frameworkResults) {
        const avgForceScore = this.calculateAverageForceScore(frameworkResults);
        if (avgForceScore > 7 || frameworkResults.competitiveRivalry.score > 8) {
          return "ASAP";
        }
        if (avgForceScore < 4 && frameworkResults.overallAttractiveness.score > 6) {
          return "Exploratory";
        }
        return "Strategic";
      }
      inferRiskTolerance(frameworkResults) {
        const avgForceScore = this.calculateAverageForceScore(frameworkResults);
        if (avgForceScore > 7) {
          return "Conservative";
        }
        if (frameworkResults.overallAttractiveness.score > 7 && avgForceScore < 5) {
          return "Aggressive";
        }
        return "Moderate";
      }
    };
  }
});

// server/utils/json-parser.ts
function extractJsonFromMarkdown(input) {
  const rawOutput = input;
  if (!input || typeof input !== "string") {
    console.error("[JSON Parser] Invalid input:", typeof input, input?.slice?.(0, 100));
    return {
      success: false,
      error: "Invalid input: expected string",
      rawOutput: String(input || "")
    };
  }
  let cleaned = input.trim();
  const jsonCodeBlockRegex = /^```(?:json)?\s*\n?([\s\S]*?)\n?```$/;
  const match = cleaned.match(jsonCodeBlockRegex);
  if (match) {
    cleaned = match[1].trim();
    console.log("[JSON Parser] Stripped markdown fences, content length:", cleaned.length);
  }
  if (cleaned.startsWith("```")) {
    cleaned = cleaned.replace(/^```(?:json)?\s*\n?/, "");
  }
  if (cleaned.endsWith("```")) {
    cleaned = cleaned.replace(/\n?```$/, "");
  }
  cleaned = cleaned.trim();
  try {
    const data = JSON.parse(cleaned);
    return {
      success: true,
      data,
      rawOutput
    };
  } catch (parseError) {
    console.error("[JSON Parser] Parse failed:", parseError.message);
    console.error("[JSON Parser] Raw output (first 500 chars):", rawOutput.slice(0, 500));
    console.error("[JSON Parser] Cleaned output (first 500 chars):", cleaned.slice(0, 500));
    return {
      success: false,
      error: `JSON parse error: ${parseError.message}`,
      rawOutput
    };
  }
}
function createAnalysisErrorResult(frameworkName, errorMessage, rawOutput, parseError) {
  return {
    error: true,
    framework: frameworkName,
    message: errorMessage,
    rawOutput: rawOutput.slice(0, 5e3),
    // Limit size for DB storage
    parseError: parseError || null,
    failedAt: (/* @__PURE__ */ new Date()).toISOString()
  };
}
var init_json_parser = __esm({
  "server/utils/json-parser.ts"() {
    "use strict";
  }
});

// server/intelligence/pestle-analyzer.ts
var PESTLEAnalyzer;
var init_pestle_analyzer = __esm({
  "server/intelligence/pestle-analyzer.ts"() {
    "use strict";
    PESTLEAnalyzer = class {
      /**
       * Generate references from PESTLE analysis
       */
      generateReferences(frameworkResults) {
        const references3 = [];
        const factors = [
          { name: "Political", factor: frameworkResults.political },
          { name: "Economic", factor: frameworkResults.economic },
          { name: "Social", factor: frameworkResults.social },
          { name: "Technological", factor: frameworkResults.technological },
          { name: "Legal", factor: frameworkResults.legal },
          { name: "Environmental", factor: frameworkResults.environmental }
        ];
        factors.forEach(({ name, factor }) => {
          factor.trends.forEach((trend, idx) => {
            references3.push({
              title: `PESTLE ${name}: ${trend.description.substring(0, 50)}...`,
              sourceType: trend.source ? "article" : "internal_doc",
              description: trend.description,
              topics: ["pestle analysis", name.toLowerCase(), "macro trends"],
              confidence: trend.strength / 10,
              // Normalize 0-10 to 0-1
              snippet: `${trend.description} (${trend.timeframe})`,
              origin: trend.source ? "web_search" : "llm_generation"
            });
          });
          factor.opportunities.forEach((opp, idx) => {
            references3.push({
              title: `PESTLE ${name} Opportunity: ${opp.description.substring(0, 50)}...`,
              sourceType: "internal_doc",
              description: opp.description,
              topics: ["pestle analysis", name.toLowerCase(), "opportunities"],
              confidence: 0.7,
              snippet: `${opp.description} - Requirements: ${opp.requirements.join(", ")}`,
              origin: "llm_generation"
            });
          });
        });
        return references3;
      }
      async analyze(frameworkResults) {
        const insights = [];
        insights.push(...await this.extractWorkstreams(frameworkResults));
        insights.push(...await this.extractResources(frameworkResults));
        insights.push(...await this.extractRisks(frameworkResults));
        insights.push(...await this.extractStakeholders(frameworkResults));
        insights.push(...await this.extractBenefits(frameworkResults));
        insights.push(...await this.extractCosts(frameworkResults));
        const timelineInsight = await this.inferTimeline(frameworkResults);
        insights.push(timelineInsight);
        if (frameworkResults.strategicRecommendations) {
          frameworkResults.strategicRecommendations.forEach((rec, idx) => {
            insights.push({
              type: "other",
              source: `PESTLE.strategicRecommendations[${idx}]`,
              content: rec,
              confidence: 0.85,
              reasoning: "Strategic recommendation from PESTLE analysis"
            });
          });
        }
        if (frameworkResults.crossFactorInsights) {
          frameworkResults.crossFactorInsights.synergies?.forEach((synergy, idx) => {
            insights.push({
              type: "other",
              source: `PESTLE.synergies[${idx}]`,
              content: `Synergy: ${synergy}`,
              confidence: 0.8,
              reasoning: "Cross-factor synergy identified"
            });
          });
          frameworkResults.crossFactorInsights.conflicts?.forEach((conflict, idx) => {
            insights.push({
              type: "risk",
              source: `PESTLE.conflicts[${idx}]`,
              content: `Factor Conflict: ${conflict}`,
              confidence: 0.75,
              reasoning: "Cross-factor conflict creates strategic tension",
              metadata: { severity: "Medium", category: "Strategic" }
            });
          });
        }
        const overallConfidence = this.calculateConfidence(insights);
        const references3 = this.generateReferences(frameworkResults);
        return {
          frameworkType: "pestle",
          frameworkRunId: "pestle-run-id",
          // Will be set by caller
          insights,
          references: references3,
          marketContext: {
            urgency: this.inferUrgency(frameworkResults),
            riskTolerance: this.inferRiskTolerance(frameworkResults)
          },
          overallConfidence
        };
      }
      async extractWorkstreams(frameworkResults) {
        const insights = [];
        if (frameworkResults.political.opportunities.length > 0) {
          frameworkResults.political.opportunities.forEach((opp, idx) => {
            insights.push({
              type: "workstream",
              source: `PESTLE.political.opportunities[${idx}]`,
              content: `Policy Opportunity: ${opp.description}
Requirements: ${opp.requirements.join(", ")}`,
              confidence: 0.75,
              reasoning: "Political opportunity requires strategic workstream",
              metadata: { category: "Political", factor: "Political" }
            });
          });
        }
        if (frameworkResults.political.trends.some((t) => t.strength > 6)) {
          insights.push({
            type: "workstream",
            source: "PESTLE.political",
            content: "Regulatory Compliance & Government Affairs\nMonitor policy changes and ensure regulatory compliance",
            confidence: 0.8,
            reasoning: "Strong political trends require proactive government relations",
            metadata: { category: "Compliance", factor: "Political" }
          });
        }
        if (frameworkResults.economic.trends.some((t) => t.strength > 6)) {
          insights.push({
            type: "workstream",
            source: "PESTLE.economic",
            content: "Economic Adaptation & Financial Resilience\nAdapt pricing, costs, and investments to economic conditions",
            confidence: 0.75,
            reasoning: "Strong economic trends require strategic financial adaptation",
            metadata: { category: "Financial", factor: "Economic" }
          });
        }
        frameworkResults.economic.opportunities.forEach((opp, idx) => {
          insights.push({
            type: "workstream",
            source: `PESTLE.economic.opportunities[${idx}]`,
            content: `Economic Opportunity: ${opp.description}
Requirements: ${opp.requirements.join(", ")}`,
            confidence: 0.7,
            reasoning: "Economic opportunity workstream",
            metadata: { category: "Market Expansion", factor: "Economic" }
          });
        });
        if (frameworkResults.social.trends.length > 0) {
          const strongSocialTrends = frameworkResults.social.trends.filter((t) => t.strength > 6);
          if (strongSocialTrends.length > 0) {
            insights.push({
              type: "workstream",
              source: "PESTLE.social",
              content: `Social Trend Adaptation
Respond to: ${strongSocialTrends.map((t) => t.description).join("; ")}`,
              confidence: 0.75,
              reasoning: "Strong social trends require market adaptation",
              metadata: { category: "Customer Engagement", factor: "Social" }
            });
          }
        }
        frameworkResults.social.opportunities.forEach((opp, idx) => {
          insights.push({
            type: "workstream",
            source: `PESTLE.social.opportunities[${idx}]`,
            content: `Social Opportunity: ${opp.description}
Requirements: ${opp.requirements.join(", ")}`,
            confidence: 0.7,
            reasoning: "Social opportunity workstream",
            metadata: { category: "Market Positioning", factor: "Social" }
          });
        });
        if (frameworkResults.technological.trends.some((t) => t.strength > 6)) {
          insights.push({
            type: "workstream",
            source: "PESTLE.technological",
            content: "Digital Transformation & Technology Adoption\nLeverage emerging technologies for competitive advantage",
            confidence: 0.8,
            reasoning: "Strong technology trends require innovation response",
            metadata: { category: "Innovation", factor: "Technological" }
          });
        }
        frameworkResults.technological.opportunities.forEach((opp, idx) => {
          insights.push({
            type: "workstream",
            source: `PESTLE.technological.opportunities[${idx}]`,
            content: `Technology Opportunity: ${opp.description}
Requirements: ${opp.requirements.join(", ")}`,
            confidence: 0.75,
            reasoning: "Technology opportunity workstream",
            metadata: { category: "Innovation", factor: "Technological" }
          });
        });
        if (frameworkResults.legal.trends.some((t) => t.strength > 5) || frameworkResults.legal.risks.length > 0) {
          insights.push({
            type: "workstream",
            source: "PESTLE.legal",
            content: "Legal Compliance & Risk Management\nEnsure adherence to legal requirements and manage legal exposure",
            confidence: 0.85,
            reasoning: "Legal trends/risks require dedicated compliance workstream",
            metadata: { category: "Compliance", factor: "Legal" }
          });
        }
        if (frameworkResults.environmental.trends.some((t) => t.strength > 5) || frameworkResults.environmental.opportunities.length > 0) {
          insights.push({
            type: "workstream",
            source: "PESTLE.environmental",
            content: "Sustainability & ESG Initiative\nImplement environmental best practices and reduce carbon footprint",
            confidence: 0.75,
            reasoning: "Environmental trends require sustainability focus",
            metadata: { category: "Sustainability", factor: "Environmental" }
          });
        }
        frameworkResults.environmental.opportunities.forEach((opp, idx) => {
          insights.push({
            type: "workstream",
            source: `PESTLE.environmental.opportunities[${idx}]`,
            content: `Environmental Opportunity: ${opp.description}
Requirements: ${opp.requirements.join(", ")}`,
            confidence: 0.7,
            reasoning: "Environmental opportunity workstream",
            metadata: { category: "Sustainability", factor: "Environmental" }
          });
        });
        return insights;
      }
      async extractResources(frameworkResults) {
        const insights = [];
        if (frameworkResults.political.trends.some((t) => t.strength > 5) || frameworkResults.legal.trends.some((t) => t.strength > 5)) {
          insights.push({
            type: "resource",
            source: "PESTLE.political+legal",
            content: "Regulatory Affairs: Compliance officers, legal counsel, government relations",
            confidence: 0.75,
            reasoning: "Political and legal trends require regulatory expertise",
            metadata: { category: "Compliance" }
          });
        }
        if (frameworkResults.technological.trends.some((t) => t.strength > 6)) {
          insights.push({
            type: "resource",
            source: "PESTLE.technological",
            content: "Technology Team: Software engineers, data scientists, digital strategists",
            confidence: 0.8,
            reasoning: "Strong technology trends require technical capabilities",
            metadata: { category: "Technology" }
          });
        }
        if (frameworkResults.social.trends.some((t) => t.strength > 5)) {
          insights.push({
            type: "resource",
            source: "PESTLE.social",
            content: "Customer Insights: Market researchers, customer experience, cultural advisors",
            confidence: 0.7,
            reasoning: "Social trends require deep customer understanding",
            metadata: { category: "Customer" }
          });
        }
        if (frameworkResults.environmental.trends.some((t) => t.strength > 5)) {
          insights.push({
            type: "resource",
            source: "PESTLE.environmental",
            content: "Sustainability Team: ESG specialists, environmental consultants, carbon auditors",
            confidence: 0.7,
            reasoning: "Environmental trends require sustainability expertise",
            metadata: { category: "Sustainability" }
          });
        }
        if (frameworkResults.economic.risks.some((r) => r.probability > 0.5)) {
          insights.push({
            type: "resource",
            source: "PESTLE.economic",
            content: "Financial Planning: Economists, financial analysts, risk managers",
            confidence: 0.75,
            reasoning: "Economic risks require financial planning capabilities",
            metadata: { category: "Financial" }
          });
        }
        return insights;
      }
      async extractRisks(frameworkResults) {
        const insights = [];
        const factors = [
          { name: "Political", factor: frameworkResults.political, category: "Political" },
          { name: "Economic", factor: frameworkResults.economic, category: "Economic" },
          { name: "Social", factor: frameworkResults.social, category: "Social" },
          { name: "Technological", factor: frameworkResults.technological, category: "Technological" },
          { name: "Legal", factor: frameworkResults.legal, category: "Legal" },
          { name: "Environmental", factor: frameworkResults.environmental, category: "Environmental" }
        ];
        factors.forEach(({ name, factor, category }) => {
          factor.risks.forEach((risk, idx) => {
            insights.push({
              type: "risk",
              source: `PESTLE.${name.toLowerCase()}.risks[${idx}]`,
              content: risk.description,
              confidence: 0.85,
              reasoning: `${name} risk from PESTLE analysis`,
              metadata: {
                severity: risk.impact,
                category,
                probability: Math.round(risk.probability * 100)
              }
            });
          });
        });
        const negativeFactors = factors.filter(
          (f) => f.factor.risks.length > 2 || f.factor.trends.some((t) => t.strength > 7)
        );
        if (negativeFactors.length >= 3) {
          insights.push({
            type: "risk",
            source: "PESTLE.inference",
            content: `Macro-Environmental Headwinds: ${negativeFactors.length} of 6 PESTLE factors showing significant challenges`,
            confidence: 0.8,
            reasoning: "Multiple environmental factors create systemic risk",
            metadata: {
              severity: "High",
              category: "Strategic",
              affectedFactors: negativeFactors.map((f) => f.name)
            }
          });
        }
        return insights;
      }
      async extractStakeholders(frameworkResults) {
        const insights = [];
        if (frameworkResults.political.trends.length > 0 || frameworkResults.political.risks.length > 0) {
          insights.push({
            type: "stakeholder",
            source: "PESTLE.political",
            content: "Government & Regulatory Bodies: Policy makers, regulatory agencies",
            confidence: 0.8,
            reasoning: "Political factor indicates government stakeholder importance",
            metadata: {
              power: "High",
              interest: "Medium",
              group: "Regulatory"
            }
          });
        }
        if (frameworkResults.social.trends.some((t) => t.strength > 5)) {
          insights.push({
            type: "stakeholder",
            source: "PESTLE.social",
            content: "Community & Social Groups: Customer segments, cultural communities, advocacy groups",
            confidence: 0.75,
            reasoning: "Strong social trends indicate community stakeholder importance",
            metadata: {
              power: "Medium",
              interest: "High",
              group: "Community"
            }
          });
        }
        if (frameworkResults.environmental.trends.some((t) => t.strength > 5)) {
          insights.push({
            type: "stakeholder",
            source: "PESTLE.environmental",
            content: "Environmental Stakeholders: NGOs, sustainability advocates, climate activists",
            confidence: 0.7,
            reasoning: "Environmental trends indicate ESG stakeholder importance",
            metadata: {
              power: "Medium",
              interest: "High",
              group: "Environmental"
            }
          });
        }
        if (frameworkResults.technological.opportunities.length > 0) {
          insights.push({
            type: "stakeholder",
            source: "PESTLE.technological",
            content: "Technology Partners: Software vendors, tech consultants, innovation labs",
            confidence: 0.7,
            reasoning: "Technology opportunities require tech partnership stakeholders",
            metadata: {
              power: "Medium",
              interest: "High",
              group: "Technology"
            }
          });
        }
        if (frameworkResults.legal.risks.length > 0) {
          insights.push({
            type: "stakeholder",
            source: "PESTLE.legal",
            content: "Legal Authorities: Courts, legal regulators, compliance auditors",
            confidence: 0.75,
            reasoning: "Legal risks indicate regulatory stakeholder importance",
            metadata: {
              power: "High",
              interest: "Medium",
              group: "Legal"
            }
          });
        }
        if (frameworkResults.economic.risks.length > 0 || frameworkResults.economic.opportunities.length > 0) {
          insights.push({
            type: "stakeholder",
            source: "PESTLE.economic",
            content: "Financial Stakeholders: Investors, lenders, financial partners",
            confidence: 0.75,
            reasoning: "Economic factors indicate financial stakeholder importance",
            metadata: {
              power: "High",
              interest: "High",
              group: "Financial"
            }
          });
        }
        return insights;
      }
      async extractBenefits(frameworkResults) {
        const insights = [];
        const factors = [
          { name: "Political", factor: frameworkResults.political, category: "Strategic" },
          { name: "Economic", factor: frameworkResults.economic, category: "Financial" },
          { name: "Social", factor: frameworkResults.social, category: "Strategic" },
          { name: "Technological", factor: frameworkResults.technological, category: "Strategic" },
          { name: "Legal", factor: frameworkResults.legal, category: "Strategic" },
          { name: "Environmental", factor: frameworkResults.environmental, category: "Strategic" }
        ];
        factors.forEach(({ name, factor, category }) => {
          factor.opportunities.forEach((opp, idx) => {
            insights.push({
              type: "benefit",
              source: `PESTLE.${name.toLowerCase()}.opportunities[${idx}]`,
              content: `${name} Benefit: ${opp.description} (Potential: ${opp.potential})`,
              confidence: 0.75,
              reasoning: `Opportunity from ${name} factor analysis`,
              metadata: { category }
            });
          });
        });
        factors.forEach(({ name, factor, category }) => {
          const strongPositiveTrends = factor.trends.filter(
            (t) => t.strength > 6 && !t.description.toLowerCase().includes("threat")
          );
          if (strongPositiveTrends.length > 0) {
            insights.push({
              type: "benefit",
              source: `PESTLE.${name.toLowerCase()}`,
              content: `${name} Advantage: Favorable trends in ${name.toLowerCase()} environment`,
              confidence: 0.7,
              reasoning: "Strong positive trends create strategic advantage",
              metadata: { category }
            });
          }
        });
        return insights;
      }
      async extractCosts(frameworkResults) {
        const insights = [];
        if (frameworkResults.legal.trends.some((t) => t.strength > 5) || frameworkResults.political.trends.some((t) => t.strength > 5)) {
          insights.push({
            type: "cost",
            source: "PESTLE.legal+political",
            content: "Regulatory Compliance Costs: Legal fees, compliance systems, audits",
            confidence: 0.75,
            reasoning: "Legal and political requirements generate compliance costs",
            metadata: { estimatedAmount: 2e5 }
          });
        }
        if (frameworkResults.technological.opportunities.length > 0 || frameworkResults.technological.trends.some((t) => t.strength > 6)) {
          insights.push({
            type: "cost",
            source: "PESTLE.technological",
            content: "Technology Investment: Software, infrastructure, digital transformation",
            confidence: 0.7,
            reasoning: "Technology trends require investment in digital capabilities",
            metadata: { estimatedAmount: 3e5 }
          });
        }
        if (frameworkResults.environmental.trends.some((t) => t.strength > 5)) {
          insights.push({
            type: "cost",
            source: "PESTLE.environmental",
            content: "Sustainability Investment: ESG programs, carbon reduction, environmental compliance",
            confidence: 0.7,
            reasoning: "Environmental trends require sustainability investments",
            metadata: { estimatedAmount: 15e4 }
          });
        }
        if (frameworkResults.social.trends.some((t) => t.strength > 6)) {
          insights.push({
            type: "cost",
            source: "PESTLE.social",
            content: "Market Adaptation: Customer research, product adjustments, cultural training",
            confidence: 0.65,
            reasoning: "Social trends require market adaptation investments",
            metadata: { estimatedAmount: 1e5 }
          });
        }
        return insights;
      }
      async inferTimeline(frameworkResults) {
        let urgency = "Strategic";
        let confidence = 0.7;
        let reasoning = "Default strategic timeline based on macro-environmental analysis";
        const urgentFactors = [
          frameworkResults.political,
          frameworkResults.economic,
          frameworkResults.social,
          frameworkResults.technological,
          frameworkResults.legal,
          frameworkResults.environmental
        ].filter((factor) => {
          return factor.risks.length > 3 || factor.trends.some((t) => t.strength > 8);
        });
        if (urgentFactors.length >= 3) {
          urgency = "ASAP";
          confidence = 0.8;
          reasoning = `${urgentFactors.length} PESTLE factors showing urgent trends/risks requiring rapid response`;
        } else if (urgentFactors.length === 0) {
          urgency = "Exploratory";
          confidence = 0.75;
          reasoning = "Stable macro-environment allows for deliberate strategic planning";
        }
        return {
          type: "timeline",
          source: "PESTLE.inference",
          content: `Recommended timeline: ${urgency === "ASAP" ? "6" : urgency === "Exploratory" ? "18" : "12"} months based on environmental urgency`,
          confidence,
          reasoning,
          metadata: {
            urgency,
            urgentFactors: urgentFactors.length,
            estimatedMonths: urgency === "ASAP" ? 6 : urgency === "Exploratory" ? 18 : 12
          }
        };
      }
      calculateConfidence(insights) {
        if (insights.length === 0) return 0.5;
        const avgConfidence = insights.reduce((sum, i) => sum + i.confidence, 0) / insights.length;
        const insightPenalty = insights.length < 10 ? 0.05 : 0;
        const types = new Set(insights.map((i) => i.type));
        const requiredTypes = ["workstream", "risk", "stakeholder", "benefit"];
        const missingTypes = requiredTypes.filter((t) => !types.has(t));
        const typePenalty = missingTypes.length * 0.03;
        return Math.max(0.5, Math.min(0.95, avgConfidence - insightPenalty - typePenalty));
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      inferUrgency(frameworkResults) {
        const urgentFactors = [
          frameworkResults.political,
          frameworkResults.economic,
          frameworkResults.social,
          frameworkResults.technological,
          frameworkResults.legal,
          frameworkResults.environmental
        ].filter((factor) => factor.risks.length > 3 || factor.trends.some((t) => t.strength > 8));
        if (urgentFactors.length >= 3) return "ASAP";
        if (urgentFactors.length === 0) return "Exploratory";
        return "Strategic";
      }
      inferRiskTolerance(frameworkResults) {
        const totalRisks = [
          frameworkResults.political,
          frameworkResults.economic,
          frameworkResults.social,
          frameworkResults.technological,
          frameworkResults.legal,
          frameworkResults.environmental
        ].reduce((sum, factor) => sum + factor.risks.length, 0);
        const totalOpportunities = [
          frameworkResults.political,
          frameworkResults.economic,
          frameworkResults.social,
          frameworkResults.technological,
          frameworkResults.legal,
          frameworkResults.environmental
        ].reduce((sum, factor) => sum + factor.opportunities.length, 0);
        if (totalRisks > 10) return "Conservative";
        if (totalOpportunities > 5 && totalRisks < 5) return "Aggressive";
        return "Moderate";
      }
    };
  }
});

// server/intelligence/swot-analyzer.ts
var SWOTAnalyzer, swotAnalyzer;
var init_swot_analyzer = __esm({
  "server/intelligence/swot-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    init_json_parser();
    SWOTAnalyzer = class {
      async analyze(input) {
        console.log("[SWOT Analyzer] Starting analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        if (input.bmcOutput) {
          contextParts.push(`Business Model Canvas: ${JSON.stringify(input.bmcOutput)}`);
          inputSources.push("bmc");
        }
        if (input.portersOutput) {
          contextParts.push(`Porter's Five Forces: ${JSON.stringify(input.portersOutput)}`);
          inputSources.push("porters");
        }
        if (input.pestleOutput) {
          contextParts.push(`PESTLE Analysis: ${JSON.stringify(input.pestleOutput)}`);
          inputSources.push("pestle");
        }
        const analysisDepth = inputSources.length > 1 ? "enhanced" : "basic";
        const prompt = `
Perform a comprehensive SWOT analysis for this business:

${contextParts.join("\n\n")}

Analyze and provide:

1. STRENGTHS (internal positive factors)
   - What does this business do well?
   - What unique resources does it have?
   - What advantages does it have over competitors?

2. WEAKNESSES (internal negative factors)
   - What could be improved?
   - What resources are lacking?
   - What are competitors doing better?

3. OPPORTUNITIES (external positive factors)
   - What market trends could benefit the business?
   - What gaps exist in the market?
   - What external changes could be leveraged?

4. THREATS (external negative factors)
   - What obstacles does the business face?
   - What are competitors doing?
   - What external changes could hurt the business?

5. STRATEGIC OPTIONS (TOWS Matrix)
   - SO Strategies: Use strengths to capture opportunities
   - WO Strategies: Overcome weaknesses by exploiting opportunities
   - ST Strategies: Use strengths to avoid threats
   - WT Strategies: Minimize weaknesses and avoid threats

6. PRIORITY ACTIONS: Top 3-5 immediate actions based on the analysis

For each factor, provide:
- A clear, specific factor name
- A detailed description
- Importance rating (high/medium/low)
- Supporting evidence if available

Return as JSON matching this structure:
{
  "strengths": [{"factor": "", "description": "", "importance": "high|medium|low", "evidence": ""}],
  "weaknesses": [{"factor": "", "description": "", "importance": "high|medium|low", "evidence": ""}],
  "opportunities": [{"factor": "", "description": "", "importance": "high|medium|low", "evidence": ""}],
  "threats": [{"factor": "", "description": "", "importance": "high|medium|low", "evidence": ""}],
  "strategicOptions": {
    "soStrategies": [""],
    "woStrategies": [""],
    "stStrategies": [""],
    "wtStrategies": [""]
  },
  "priorityActions": [""]
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a strategic analysis expert specializing in SWOT analysis. Return only valid JSON without markdown code blocks.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const parseResult = extractJsonFromMarkdown(response.content);
          if (!parseResult.success) {
            console.error("[SWOT Analyzer] Failed to parse AI response");
            return createAnalysisErrorResult(
              "swot",
              "Failed to parse SWOT analysis response",
              parseResult.rawOutput,
              parseResult.error
            );
          }
          const result = parseResult.data;
          console.log("[SWOT Analyzer] Analysis complete");
          console.log(`  Strengths: ${result.strengths?.length || 0}`);
          console.log(`  Weaknesses: ${result.weaknesses?.length || 0}`);
          console.log(`  Opportunities: ${result.opportunities?.length || 0}`);
          console.log(`  Threats: ${result.threats?.length || 0}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources),
            metadata: {
              inputSources,
              analysisDepth,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[SWOT Analyzer] Analysis failed:", error);
          return createAnalysisErrorResult(
            "swot",
            `SWOT analysis failed: ${error.message}`,
            "",
            error.message
          );
        }
      }
      calculateConfidence(result, inputSources) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.05;
        const totalFactors = (result.strengths?.length || 0) + (result.weaknesses?.length || 0) + (result.opportunities?.length || 0) + (result.threats?.length || 0);
        if (totalFactors >= 12) confidence += 0.1;
        else if (totalFactors >= 8) confidence += 0.05;
        if (result.strategicOptions?.soStrategies?.length > 0) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    swotAnalyzer = new SWOTAnalyzer();
  }
});

// server/intelligence/competitive-positioning-analyzer.ts
var CompetitivePositioningAnalyzer, competitivePositioningAnalyzer;
var init_competitive_positioning_analyzer = __esm({
  "server/intelligence/competitive-positioning-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    CompetitivePositioningAnalyzer = class {
      async analyze(input) {
        console.log("[CompetitivePositioning Analyzer] Starting analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        contextParts.push(`Target Market: ${input.targetMarket}`);
        contextParts.push(`Competitors Analyzed: ${input.competitors.map((c) => c.name).join(", ")}`);
        contextParts.push(`Competitor Details: ${JSON.stringify(input.competitors)}`);
        if (input.bmcOutput) {
          contextParts.push(`Business Model Canvas: ${JSON.stringify(input.bmcOutput)}`);
          inputSources.push("bmc");
        }
        if (input.portersOutput) {
          contextParts.push(`Porter's Five Forces: ${JSON.stringify(input.portersOutput)}`);
          inputSources.push("porters");
        }
        const prompt = `
Analyze the competitive positioning for this business in the target market:

${contextParts.join("\n\n")}

Provide a comprehensive competitive positioning analysis:

1. POSITIONING MAP (Select 2-3 most relevant axes for the market)
   For each axis, provide:
   - Axis name and what it measures
   - Low end descriptor and high end descriptor
   - Business position (1-10 scale)
   - Competitor positions on the same scale
   - Rationale for positioning

   Suggested axes (choose the most relevant):
   - Price vs Quality
   - Innovation vs Stability
   - Breadth vs Depth
   - Convenience vs Experience
   - Mass Market vs Premium

2. DIFFERENTIATION FACTORS (3-5 key ways to differentiate)
   For each factor:
   - Clear factor name
   - Detailed description
   - Strength level: unique/strong/moderate/weak
   - Is it defensible? (true/false)
   - Supporting evidence

3. COMPETITIVE ADVANTAGES (2-4 core advantages)
   For each advantage:
   - Advantage description
   - Type: cost/differentiation/focus
   - Duration: sustainable/temporary
   - How it's achieved

4. POSITIONING RECOMMENDATION
   - Recommended market position
   - Key brand/positioning message
   - Target segment focus
   - Top 3-5 action priorities to achieve positioning
   - Risk factors to monitor

5. COMPETITIVE THREATS (2-3 major threats)
   For each threat:
   - Threat description
   - Severity: high/medium/low
   - Why this is a threat
   - Countermeasures to implement

6. PRIORITY ACTIONS: Top 3-5 immediate actions to strengthen positioning

Return as JSON:
{
  "positioningMap": [
    {
      "name": "",
      "lowEnd": "",
      "highEnd": "",
      "businessPosition": 7,
      "competitorPositions": {"Competitor A": 5, "Competitor B": 8},
      "rationale": ""
    }
  ],
  "differentationFactors": [
    {"factor": "", "description": "", "strength": "unique|strong|moderate|weak", "defensible": true, "evidence": ""}
  ],
  "competitiveAdvantages": [
    {"advantage": "", "type": "cost|differentiation|focus", "duration": "sustainable|temporary", "description": ""}
  ],
  "positioningRecommendation": {
    "recommendedPosition": "",
    "keyMessage": "",
    "targetSegment": "",
    "actionPriorities": [],
    "riskFactors": []
  },
  "competitiveThreats": [
    {"threat": "", "severity": "high|medium|low", "description": "", "countermeasures": []}
  ],
  "priorityActions": []
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a competitive strategy expert specializing in positioning analysis. Return only valid JSON.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const result = JSON.parse(response.content);
          console.log("[CompetitivePositioning Analyzer] Analysis complete");
          console.log(`  Positioning Axes: ${result.positioningMap?.length || 0}`);
          console.log(`  Differentiation Factors: ${result.differentationFactors?.length || 0}`);
          console.log(`  Competitive Advantages: ${result.competitiveAdvantages?.length || 0}`);
          console.log(`  Competitive Threats: ${result.competitiveThreats?.length || 0}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources, input.competitors.length),
            metadata: {
              competitorsAnalyzed: input.competitors.length,
              inputSources,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[CompetitivePositioning Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, inputSources, competitorCount) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.05;
        confidence += Math.min(0.1, competitorCount * 0.025);
        if (result.positioningMap?.length >= 2) confidence += 0.1;
        if (result.differentationFactors?.length >= 3) confidence += 0.05;
        if (result.competitiveAdvantages?.length >= 2) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    competitivePositioningAnalyzer = new CompetitivePositioningAnalyzer();
  }
});

// server/intelligence/ansoff-analyzer.ts
var AnsoffAnalyzer, ansoffAnalyzer;
var init_ansoff_analyzer = __esm({
  "server/intelligence/ansoff-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    AnsoffAnalyzer = class {
      async analyze(input) {
        console.log("[Ansoff Analyzer] Starting growth strategy analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        if (input.currentProducts?.length) {
          contextParts.push(`Current Products/Services: ${input.currentProducts.join(", ")}`);
        }
        if (input.currentMarkets?.length) {
          contextParts.push(`Current Markets: ${input.currentMarkets.join(", ")}`);
        }
        if (input.swotOutput) {
          contextParts.push(`SWOT Analysis: ${JSON.stringify(input.swotOutput)}`);
          inputSources.push("swot");
        }
        if (input.bmcOutput) {
          contextParts.push(`Business Model Canvas: ${JSON.stringify(input.bmcOutput)}`);
          inputSources.push("bmc");
        }
        const prompt = `
Analyze growth strategy options using the Ansoff Matrix for this business:

${contextParts.join("\n\n")}

Evaluate each of the four growth strategies:

1. MARKET PENETRATION (Existing Products, Existing Markets)
   - How can the business grow by selling more to current customers?
   - What market share can be captured?
   - What pricing or promotion strategies would work?

2. MARKET DEVELOPMENT (Existing Products, New Markets)
   - What new geographic markets could be entered?
   - What new customer segments could be targeted?
   - What channels could reach new markets?

3. PRODUCT DEVELOPMENT (New Products, Existing Markets)
   - What new products/services could be offered to current customers?
   - What product improvements or extensions are possible?
   - What unmet needs can be addressed?

4. DIVERSIFICATION (New Products, New Markets)
   - What related diversification opportunities exist?
   - What unrelated diversification makes sense?
   - What synergies could be leveraged?

For each quadrant, provide:
- Score (1-10 for attractiveness)
- Specific strategies
- Key risks
- Main opportunities
- Implementation notes
- Timeframe (short/medium/long-term)

Then recommend the PRIMARY growth strategy with rationale.

Return as JSON:
{
  "marketPenetration": {"score": 8, "strategies": [], "risks": [], "opportunities": [], "implementationNotes": "", "timeframe": "short-term"},
  "marketDevelopment": {"score": 6, "strategies": [], "risks": [], "opportunities": [], "implementationNotes": "", "timeframe": "medium-term"},
  "productDevelopment": {"score": 7, "strategies": [], "risks": [], "opportunities": [], "implementationNotes": "", "timeframe": "medium-term"},
  "diversification": {"score": 4, "strategies": [], "risks": [], "opportunities": [], "implementationNotes": "", "timeframe": "long-term"},
  "recommendation": {"primaryStrategy": "", "secondaryStrategy": "", "rationale": "", "riskLevel": "medium"},
  "priorityActions": []
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a strategic growth expert specializing in Ansoff Matrix analysis. Return only valid JSON.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const result = JSON.parse(response.content);
          console.log("[Ansoff Analyzer] Analysis complete");
          console.log(`  Recommended: ${result.recommendation?.primaryStrategy}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources),
            metadata: {
              inputSources,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[Ansoff Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, inputSources) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.05;
        if (result.recommendation?.primaryStrategy) confidence += 0.1;
        if (result.priorityActions?.length >= 3) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    ansoffAnalyzer = new AnsoffAnalyzer();
  }
});

// server/intelligence/blue-ocean-analyzer.ts
var BlueOceanAnalyzer, blueOceanAnalyzer;
var init_blue_ocean_analyzer = __esm({
  "server/intelligence/blue-ocean-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    BlueOceanAnalyzer = class {
      async analyze(input) {
        console.log("[BlueOcean Analyzer] Starting Blue Ocean analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        contextParts.push(`Industry: ${input.industry}`);
        contextParts.push(`Current Offering: ${input.currentOffering.join(", ")}`);
        if (input.swotOutput) {
          contextParts.push(`SWOT Analysis: ${JSON.stringify(input.swotOutput)}`);
          inputSources.push("swot");
        }
        if (input.portersOutput) {
          contextParts.push(`Porter's Five Forces: ${JSON.stringify(input.portersOutput)}`);
          inputSources.push("porters");
        }
        if (input.competitorsData) {
          contextParts.push(`Competitors Data: ${JSON.stringify(input.competitorsData)}`);
          inputSources.push("competitors");
        }
        const prompt = `
Perform a Blue Ocean Strategy analysis for this business:

${contextParts.join("\n\n")}

Apply the Blue Ocean framework to identify uncontested market space:

1. ELIMINATE-REDUCE-RAISE-CREATE GRID
   Identify factors/attributes in the industry (5-8 key factors):
   
   For each factor:
   - ELIMINATE: Factors the industry takes for granted that should be removed
   - REDUCE: Factors that should be below industry standards
   - RAISE: Factors that should be increased above industry standards
   - CREATE: Factors the industry has never offered that should be created

   For each item, provide:
   - Factor name
   - Current approach in the industry
   - Red Ocean level (1-10 where industry currently competes)
   - Blue Ocean level (1-10 target for differentiation)
   - Rationale for the shift

2. VALUE CURVE ANALYSIS
   - Current value curve: Your business's profile across key factors
   - Competitor curves: 2-3 major competitors' profiles
   - Blue Ocean curve: The proposed new value curve
   - Comparison: How the Blue Ocean curve breaks from the red ocean

3. BLUE OCEAN OPPORTUNITIES (3-5 specific opportunities)
   For each opportunity:
   - Clear opportunity description
   - What this creates/enables
   - Market size estimate: large/medium/small
   - Implementation complexity: high/medium/low
   - Time to market estimate
   - Potential ROI estimate

4. NEW MARKET SPACE RECOMMENDATIONS
   - Overall Blue Ocean strategy description
   - Target customers for this new market space
   - Key offering/value proposition
   - Value proposition statement
   - Cost structure adjustments needed
   - Profit model in the new market space
   - Risk factors in pursuing this strategy

5. INNOVATION STRATEGY
   - Focus areas for innovation
   - Discontinuities being driven (what changes fundamentally)
   - Description of the new value curve

6. PRIORITY ACTIONS: Top 3-5 actions to create blue ocean space

Return as JSON:
{
  "ercGrid": {
    "eliminate": [{"name": "", "currentApproach": "", "redOceanLevel": 7, "blueOceanLevel": 2, "rationale": ""}],
    "reduce": [{"name": "", "currentApproach": "", "redOceanLevel": 8, "blueOceanLevel": 4, "rationale": ""}],
    "raise": [{"name": "", "currentApproach": "", "redOceanLevel": 4, "blueOceanLevel": 8, "rationale": ""}],
    "create": [{"name": "", "currentApproach": "", "redOceanLevel": 0, "blueOceanLevel": 7, "rationale": ""}]
  },
  "valueCurve": {
    "currentCurve": {"factor1": 7, "factor2": 5},
    "competitorCurves": {"Competitor A": {"factor1": 8, "factor2": 6}},
    "bluOceanCurve": {"factor1": 4, "factor2": 9},
    "comparison": ""
  },
  "blueOceanOpportunities": [{"opportunity": "", "description": "", "marketSize": "large", "implementationComplexity": "medium", "timeToMarket": "", "potentialROI": ""}],
  "newMarketSpaceRecommendations": {"strategy": "", "targetCustomers": "", "keyOffering": "", "valueProposition": "", "costStructure": "", "profitModel": "", "riskFactors": []},
  "innovationStrategy": {"focusAreas": [], "discontinuitiesDriven": [], "newValueCurve": ""},
  "priorityActions": []
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a Blue Ocean Strategy expert. Identify uncontested market spaces and return valid JSON.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const result = JSON.parse(response.content);
          console.log("[BlueOcean Analyzer] Analysis complete");
          console.log(`  Eliminate factors: ${result.ercGrid?.eliminate?.length || 0}`);
          console.log(`  Reduce factors: ${result.ercGrid?.reduce?.length || 0}`);
          console.log(`  Raise factors: ${result.ercGrid?.raise?.length || 0}`);
          console.log(`  Create factors: ${result.ercGrid?.create?.length || 0}`);
          console.log(`  Blue Ocean opportunities: ${result.blueOceanOpportunities?.length || 0}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources),
            metadata: {
              industryAnalyzed: input.industry,
              inputSources,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[BlueOcean Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, inputSources) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.05;
        const ercFactors = (result.ercGrid?.eliminate?.length || 0) + (result.ercGrid?.reduce?.length || 0) + (result.ercGrid?.raise?.length || 0) + (result.ercGrid?.create?.length || 0);
        if (ercFactors >= 8) confidence += 0.1;
        else if (ercFactors >= 4) confidence += 0.05;
        if (result.blueOceanOpportunities?.length >= 2) confidence += 0.1;
        if (result.valueCurve?.bluOceanCurve) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    blueOceanAnalyzer = new BlueOceanAnalyzer();
  }
});

// server/intelligence/bcg-matrix-analyzer.ts
var BCGMatrixAnalyzer, bcgMatrixAnalyzer;
var init_bcg_matrix_analyzer = __esm({
  "server/intelligence/bcg-matrix-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    BCGMatrixAnalyzer = class {
      async analyze(input) {
        console.log("[BCG Matrix Analyzer] Starting analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        contextParts.push(`Business Units: ${JSON.stringify(input.products)}`);
        if (input.industryData) {
          contextParts.push(`Industry Data: ${JSON.stringify(input.industryData)}`);
          inputSources.push("industry");
        }
        if (input.portersOutput) {
          contextParts.push(`Porter's Five Forces: ${JSON.stringify(input.portersOutput)}`);
          inputSources.push("porters");
        }
        if (input.ansoffOutput) {
          contextParts.push(`Ansoff Analysis: ${JSON.stringify(input.ansoffOutput)}`);
          inputSources.push("ansoff");
        }
        const prompt = `
Perform a BCG Matrix analysis for this business's products/units:

${contextParts.join("\n\n")}

Classify each product/business unit using the BCG Matrix framework:

1. UNIT CLASSIFICATIONS
   For each unit, determine:
   - Classification: Star (high growth, high share) / Cash Cow (low growth, high share) / Question Mark (high growth, low share) / Dog (low growth, low share)
   - Market share percentage (1-100)
   - Market growth rate (% annually)
   - Detailed description of the unit's position
   - Financial characteristics: cash generation, investment needs, profitability (high/medium/low)
   - 3-4 strategic recommendations specific to this classification
   - Key risks for this unit
   - Key opportunities

   Classification guidelines:
   - STARS: High growth rate (>10%), high market share (>50%). Require investment to maintain position.
   - CASH COWS: Low growth rate (<5%), high market share (>50%). Generate steady cash flow.
   - QUESTION MARKS: High growth rate (>10%), low market share (<50%). Need decisions about investment.
   - DOGS: Low growth rate (<5%), low market share (<50%). May need restructuring or exit.

2. PORTFOLIO BALANCE ASSESSMENT
   - Overall portfolio health: healthy/at-risk/imbalanced
   - Key concerns about current portfolio mix
   - Recommendations for balance

3. PORTFOLIO SUMMARY BY CATEGORY
   For Stars, Cash Cows, Question Marks, and Dogs:
   - Count and estimated total revenue
   - Strategic importance to the business
   - Overall strategy (invest/harvest/divest/decide)

4. OVERALL PORTFOLIO STRATEGY
   - Short-term actions (0-6 months)
   - Medium-term actions (6-18 months)
   - Long-term vision (2+ years)

5. PRIORITY ACTIONS: Top 3-5 portfolio management actions

Return as JSON:
{
  "classifications": [
    {
      "unit": "",
      "classification": "star|cash-cow|question-mark|dog",
      "marketShare": 75,
      "marketGrowth": 15,
      "description": "",
      "financialCharacteristics": {"cashGeneration": "high", "investmentNeeds": "high", "profitability": "high"},
      "strategicRecommendations": [],
      "risks": [],
      "opportunities": []
    }
  ],
  "portfolioBalance": {
    "description": "",
    "healthAssessment": "healthy|at-risk|imbalanced",
    "concerns": [],
    "recommendations": []
  },
  "stars": {"count": 0, "totalRevenue": 0, "strategicImportance": "", "investmentStrategy": ""},
  "cashCows": {"count": 0, "totalRevenue": 0, "strategicImportance": "", "utilizationStrategy": ""},
  "questionMarks": {"count": 0, "totalRevenue": 0, "strategicImportance": "", "decisionStrategy": ""},
  "dogs": {"count": 0, "totalRevenue": 0, "strategicImportance": "", "exitStrategy": ""},
  "portfolioStrategy": {
    "shortTermActions": [],
    "mediumTermActions": [],
    "longTermVision": ""
  },
  "priorityActions": []
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a portfolio strategy expert specializing in BCG Matrix analysis. Return only valid JSON.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const result = JSON.parse(response.content);
          console.log("[BCG Matrix Analyzer] Analysis complete");
          console.log(`  Total units classified: ${result.classifications?.length || 0}`);
          console.log(`  Stars: ${result.stars?.count || 0}`);
          console.log(`  Cash Cows: ${result.cashCows?.count || 0}`);
          console.log(`  Question Marks: ${result.questionMarks?.count || 0}`);
          console.log(`  Dogs: ${result.dogs?.count || 0}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources, input.products.length),
            metadata: {
              unitsAnalyzed: input.products.length,
              inputSources,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[BCG Matrix Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, inputSources, unitCount) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.05;
        confidence += Math.min(0.1, unitCount * 0.02);
        if (result.classifications?.length === unitCount) confidence += 0.1;
        if (result.portfolioStrategy?.shortTermActions?.length >= 2) confidence += 0.05;
        if (result.portfolioBalance?.healthAssessment) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    bcgMatrixAnalyzer = new BCGMatrixAnalyzer();
  }
});

// server/intelligence/value-chain-analyzer.ts
var ValueChainAnalyzer, valueChainAnalyzer;
var init_value_chain_analyzer = __esm({
  "server/intelligence/value-chain-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    ValueChainAnalyzer = class {
      async analyze(input) {
        console.log("[ValueChain Analyzer] Starting analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        contextParts.push(`Industry: ${input.industry}`);
        if (input.portersOutput) {
          contextParts.push(`Porter's Five Forces: ${JSON.stringify(input.portersOutput)}`);
          inputSources.push("porters");
        }
        if (input.competitivePositionData) {
          contextParts.push(`Competitive Position Data: ${JSON.stringify(input.competitivePositionData)}`);
          inputSources.push("competitive");
        }
        if (input.operationsData) {
          contextParts.push(`Operations Data: ${JSON.stringify(input.operationsData)}`);
          inputSources.push("operations");
        }
        const prompt = `
Perform a comprehensive Value Chain analysis for this business:

${contextParts.join("\n\n")}

Analyze the business's value chain across all activities:

1. PRIMARY ACTIVITIES (directly involved in creating and delivering value)

   A. INBOUND LOGISTICS
      - How are raw materials/inputs sourced?
      - Quality and reliability of supply
      - Cost efficiency
      - Competitive position vs industry

   B. OPERATIONS
      - Manufacturing/service delivery processes
      - Efficiency and quality metrics
      - Technology utilization
      - Competitive advantages/disadvantages

   C. OUTBOUND LOGISTICS
      - Distribution and delivery methods
      - Speed and reliability
      - Customer experience
      - Cost effectiveness

   D. MARKETING & SALES
      - Brand positioning and messaging
      - Sales channels and effectiveness
      - Customer acquisition costs
      - Market reach and penetration

   E. SERVICE
      - Post-purchase support quality
      - Warranty and returns handling
      - Customer satisfaction
      - Differentiation through service

   For each activity, provide: description, cost %, value creation (high/medium/low), competitive position (advantage/neutral/disadvantage), key drivers, improvement opportunities, and industry benchmark comparison.

2. SUPPORT ACTIVITIES (enable primary activities to function)

   A. FIRM INFRASTRUCTURE
      - Management and governance
      - Financial systems
      - Quality control
      - Organizational structure

   B. HUMAN RESOURCES
      - Recruitment and training
      - Employee motivation
      - Compensation strategy
      - Skill development

   C. TECHNOLOGY DEVELOPMENT
      - R&D investment
      - Process improvements
      - Digital capabilities
      - Innovation focus

   D. PROCUREMENT
      - Supplier relationships
      - Purchasing efficiency
      - Strategic sourcing
      - Supplier quality

   For each activity, provide same details as primary activities.

3. VALUE DRIVERS (what creates value in the business)
   - Driver name
   - Impact level: high/medium/low
   - Current performance description
   - Improvement potential

4. COST DRIVERS (what creates costs in the business)
   - Cost driver name
   - Current cost impact: high/medium/low
   - Optimization opportunity description
   - Estimated savings potential

5. COMPETITIVE ADVANTAGES
   For each advantage (2-4):
   - Source/description
   - Which value chain location(s)
   - Type: cost/differentiation/both
   - Sustainability: sustainable/temporary
   - Defensibility: high/medium/low

6. LINKAGES (connections between activities that create value)
   - 2-3 important linkages
   - Example of the linkage
   - Value creation from this linkage

7. STRATEGIC OPPORTUNITIES (ways to improve the value chain)
   For each opportunity:
   - Clear opportunity description
   - Which activities are involved
   - Potential impact
   - Implementation complexity

8. PRIORITY ACTIONS: Top 3-5 value chain improvement actions

Return as JSON:
{
  "primaryActivities": {
    "inboundLogistics": {"name": "", "description": "", "costPercentage": 10, "valueCreation": "high", "competitivePosition": "advantage", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "operations": {"name": "", "description": "", "costPercentage": 30, "valueCreation": "high", "competitivePosition": "advantage", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "outboundLogistics": {"name": "", "description": "", "costPercentage": 8, "valueCreation": "medium", "competitivePosition": "neutral", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "marketing": {"name": "", "description": "", "costPercentage": 15, "valueCreation": "high", "competitivePosition": "advantage", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "service": {"name": "", "description": "", "costPercentage": 5, "valueCreation": "medium", "competitivePosition": "neutral", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "summary": {"totalCostPercentage": 68, "valueCreationScore": 8, "description": ""}
  },
  "supportActivities": {
    "firmInfrastructure": {"name": "", "description": "", "costPercentage": 5, "valueCreation": "medium", "competitivePosition": "neutral", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "humanResources": {"name": "", "description": "", "costPercentage": 10, "valueCreation": "high", "competitivePosition": "advantage", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "technologyDevelopment": {"name": "", "description": "", "costPercentage": 8, "valueCreation": "high", "competitivePosition": "advantage", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "procurement": {"name": "", "description": "", "costPercentage": 9, "valueCreation": "medium", "competitivePosition": "neutral", "keyDrivers": [], "improvementOpportunities": [], "benchmarkVsIndustry": ""},
    "summary": {"totalCostPercentage": 32, "valueCreationScore": 7, "description": ""}
  },
  "valueDrivers": [{"driver": "", "impact": "high", "currentPerformance": "", "improvementPotential": ""}],
  "costDrivers": [{"driver": "", "currentCostImpact": "high", "optimizationOpportunity": "", "estimatedSavings": ""}],
  "competitiveAdvantages": [{"source": "", "location": "", "type": "cost", "sustainability": "sustainable", "defensibility": "high", "description": ""}],
  "linkages": [{"description": "", "example": "", "valueCreation": ""}],
  "strategicOpportunities": [{"opportunity": "", "activities": [], "potentialImpact": "", "implementationComplexity": "medium"}],
  "priorityActions": []
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a value chain analyst specializing in Porter's Value Chain framework. Return only valid JSON.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const result = JSON.parse(response.content);
          console.log("[ValueChain Analyzer] Analysis complete");
          console.log(`  Value Drivers: ${result.valueDrivers?.length || 0}`);
          console.log(`  Cost Drivers: ${result.costDrivers?.length || 0}`);
          console.log(`  Competitive Advantages: ${result.competitiveAdvantages?.length || 0}`);
          console.log(`  Linkages: ${result.linkages?.length || 0}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources),
            metadata: {
              industryAnalyzed: input.industry,
              inputSources,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[ValueChain Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, inputSources) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.05;
        if (result.primaryActivities && Object.keys(result.primaryActivities).length >= 5) confidence += 0.1;
        if (result.supportActivities && Object.keys(result.supportActivities).length >= 4) confidence += 0.05;
        if (result.competitiveAdvantages?.length >= 2) confidence += 0.1;
        if (result.strategicOpportunities?.length >= 2) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    valueChainAnalyzer = new ValueChainAnalyzer();
  }
});

// server/intelligence/vrio-analyzer.ts
var VRIOAnalyzer, vrioAnalyzer;
var init_vrio_analyzer = __esm({
  "server/intelligence/vrio-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    VRIOAnalyzer = class {
      async analyze(input) {
        console.log("[VRIO Analyzer] Starting resource evaluation...");
        const prompt = `
Perform a comprehensive VRIO analysis for this business and its resources/capabilities:

Business Context:
${input.businessContext}

Resources/Capabilities to Evaluate:
${input.resources.map((r, i) => `${i + 1}. ${r}`).join("\n")}

For each resource, evaluate it against the VRIO criteria:

1. VALUABLE - Does the resource help the company exploit opportunities or neutralize threats?
2. RARE - Is the resource uncommon among current and potential competitors?
3. COSTLY TO IMITATE - Would it be difficult and expensive for competitors to develop or acquire this resource?
4. ORGANIZED TO CAPTURE VALUE - Does the company have the organizational systems and processes to fully utilize this resource?

Based on the VRIO evaluation, each resource will have a competitive implication:
- If all 4 criteria are YES \u2192 Sustained Competitive Advantage
- If first 3 criteria are YES but not organized \u2192 Temporary Competitive Advantage
- If only some criteria are YES \u2192 Competitive Parity
- If most criteria are NO \u2192 Competitive Disadvantage

Provide detailed reasoning for each evaluation. Consider the business context when assessing each resource.

Return as JSON:
{
  "evaluations": [
    {
      "resource": "",
      "description": "",
      "valuable": true/false,
      "rare": true/false,
      "costlyToImitate": true/false,
      "organizedToCapture": true/false,
      "competitiveImplication": "sustained-advantage|temporary-advantage|parity|disadvantage",
      "reasoning": ""
    }
  ],
  "strategicRecommendations": [""]
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a strategic resource analyst specializing in VRIO analysis. Evaluate resources comprehensively and return only valid JSON.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const result = JSON.parse(response.content);
          console.log("[VRIO Analyzer] Analysis complete");
          console.log(`  Resources evaluated: ${result.evaluations?.length || 0}`);
          const summary = {
            sustainedAdvantageResources: result.evaluations.filter((e) => e.competitiveImplication === "sustained-advantage").map((e) => e.resource),
            temporaryAdvantageResources: result.evaluations.filter((e) => e.competitiveImplication === "temporary-advantage").map((e) => e.resource),
            parityResources: result.evaluations.filter((e) => e.competitiveImplication === "parity").map((e) => e.resource),
            disadvantageResources: result.evaluations.filter((e) => e.competitiveImplication === "disadvantage").map((e) => e.resource)
          };
          return {
            evaluations: result.evaluations,
            summary,
            strategicRecommendations: result.strategicRecommendations || [],
            confidence: this.calculateConfidence(result),
            metadata: {
              resourcesEvaluated: result.evaluations?.length || 0,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[VRIO Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result) {
        let confidence = 0.6;
        const evaluationCount = result.evaluations?.length || 0;
        if (evaluationCount >= 5) confidence += 0.15;
        else if (evaluationCount >= 3) confidence += 0.1;
        const allHaveReasoning = result.evaluations?.every((e) => e.reasoning) ?? false;
        if (allHaveReasoning) confidence += 0.1;
        if (result.strategicRecommendations?.length > 0) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    vrioAnalyzer = new VRIOAnalyzer();
  }
});

// server/intelligence/scenario-planning-analyzer.ts
var ScenarioPlanningAnalyzer, scenarioPlanningAnalyzer;
var init_scenario_planning_analyzer = __esm({
  "server/intelligence/scenario-planning-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    ScenarioPlanningAnalyzer = class {
      async analyze(input) {
        console.log("[Scenario Planning Analyzer] Starting scenario generation...");
        const prompt = `
Generate plausible business scenarios for the following context:

Business Context:
${input.businessContext}

Time Horizon: ${input.timeHorizon}

Key Uncertainties to Consider:
${input.uncertainties.map((u, i) => `${i + 1}. ${u}`).join("\n")}

Create 3-4 distinct, plausible future scenarios that represent different outcomes based on how the key uncertainties might resolve. Each scenario should be internally consistent and represent a coherent future state.

For each scenario, provide:

1. SCENARIO NAME - A memorable, descriptive name for this future state

2. DESCRIPTION - A detailed narrative description of the business environment, market conditions, and company position in this scenario

3. PROBABILITY - Your estimate of the likelihood of this scenario (0-1 scale, where 1 = certain)

4. KEY DRIVERS - The 3-5 most important factors that would drive this scenario to occur

5. STRATEGIC IMPLICATIONS:
   - Opportunities: What advantages would exist in this scenario?
   - Threats: What challenges would the business face?

6. EARLY WARNING SIGNALS - What indicators or events would signal that this scenario is becoming more likely?

7. RECOMMENDED STRATEGIES - How should the business adapt its strategy in this scenario?

Also identify:
- The 2-3 CRITICAL UNCERTAINTIES that have the most impact on scenario outcomes
- ROBUST STRATEGIES that would work across multiple scenarios
- STRATEGIC OPTIONS to prepare for different scenarios

Return as JSON:
{
  "scenarios": [
    {
      "name": "",
      "description": "",
      "probability": 0.3,
      "keyDrivers": [""],
      "strategicImplications": {
        "opportunities": [""],
        "threats": [""]
      },
      "earlyWarningSignals": [""],
      "recommendedStrategies": [""]
    }
  ],
  "criticalUncertainties": [
    {
      "uncertainty": "",
      "impact": "high|medium|low",
      "monitoringStrategy": ""
    }
  ],
  "robustStrategies": [""],
  "strategicOptions": [""]
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a strategic foresight expert specializing in scenario planning. Generate coherent, plausible scenarios and return only valid JSON.",
            userMessage: prompt,
            maxTokens: 4500
          });
          const result = JSON.parse(response.content);
          console.log("[Scenario Planning Analyzer] Scenario generation complete");
          console.log(`  Scenarios created: ${result.scenarios?.length || 0}`);
          console.log(`  Critical uncertainties identified: ${result.criticalUncertainties?.length || 0}`);
          return {
            scenarios: result.scenarios || [],
            criticalUncertainties: result.criticalUncertainties || [],
            robustStrategies: result.robustStrategies || [],
            strategicOptions: result.strategicOptions || [],
            confidence: this.calculateConfidence(result),
            metadata: {
              timeHorizon: input.timeHorizon,
              scenariosGenerated: result.scenarios?.length || 0,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[Scenario Planning Analyzer] Scenario generation failed:", error);
          throw error;
        }
      }
      calculateConfidence(result) {
        let confidence = 0.6;
        const scenarioCount = result.scenarios?.length || 0;
        if (scenarioCount >= 4) confidence += 0.15;
        else if (scenarioCount >= 3) confidence += 0.1;
        const allScenariosComplete = result.scenarios?.every(
          (s) => s.name && s.description && s.keyDrivers?.length > 0 && s.earlyWarningSignals?.length > 0
        ) ?? false;
        if (allScenariosComplete) confidence += 0.1;
        if (result.criticalUncertainties?.length > 0) confidence += 0.05;
        if (result.robustStrategies?.length > 0) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    scenarioPlanningAnalyzer = new ScenarioPlanningAnalyzer();
  }
});

// server/intelligence/jtbd-analyzer.ts
var JTBDAnalyzer, jtbdAnalyzer;
var init_jtbd_analyzer = __esm({
  "server/intelligence/jtbd-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    JTBDAnalyzer = class {
      async analyze(input) {
        console.log("[JTBD Analyzer] Starting jobs-to-be-done analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        let segmentsAnalyzed = 0;
        if (input.targetSegments?.length) {
          contextParts.push(`Target Segments: ${JSON.stringify(input.targetSegments)}`);
          inputSources.push("segments");
          segmentsAnalyzed = input.targetSegments.length;
        }
        if (input.bmcOutput) {
          contextParts.push(`Business Model Canvas: ${JSON.stringify(input.bmcOutput)}`);
          inputSources.push("bmc");
        }
        const prompt = `
Perform a Jobs-To-Be-Done analysis for this business:

${contextParts.join("\n\n")}

Identify and analyze the "jobs" customers are trying to accomplish:

1. CORE JOBS (3-5 primary jobs)
   For each job, provide:
   - The job statement: "When [situation], I want to [motivation], so I can [outcome]"
   - Type: functional (practical task), emotional (feeling), or social (perception by others)
   - Context: When/where does this job arise?
   - Desired outcome: What does success look like?
   - Current solution: How do customers currently solve this?
   - Pain points: What frustrations exist with current solutions?
   - Importance: high/medium/low
   - Frequency: daily/weekly/monthly/occasionally

2. RELATED JOBS (2-3 adjacent jobs)
   Jobs that often occur before, during, or after the core jobs

3. OPPORTUNITIES
   - Underserved jobs: Jobs not well addressed by current solutions
   - Overserved jobs: Jobs where solutions exceed needs (cost-cutting opportunity)
   - Top opportunities: Highest-value improvement areas
   - Innovation directions: New product/service possibilities

4. VALUE PROPOSITION ALIGNMENT
   - Well-aligned: Where the business already addresses jobs well
   - Gaps: Where the business doesn't address important jobs
   - Recommendations: How to better align with customer jobs

5. PRIORITY ACTIONS: Top 3-5 actions to better serve customer jobs

Return as JSON:
{
  "coreJobs": [{"job": "", "type": "functional|emotional|social", "context": "", "desiredOutcome": "", "currentSolution": "", "painPoints": [], "importance": "high", "frequency": "weekly"}],
  "relatedJobs": [],
  "opportunities": {"underservedJobs": [], "overservedJobs": [], "topOpportunities": [], "innovationDirections": []},
  "valuePropositionAlignment": {"wellAligned": [], "gaps": [], "recommendations": []},
  "priorityActions": []
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a Jobs-To-Be-Done expert. Analyze customer motivations and return valid JSON.",
            userMessage: prompt,
            maxTokens: 4e3
          });
          const result = JSON.parse(response.content);
          console.log("[JTBD Analyzer] Analysis complete");
          console.log(`  Core Jobs: ${result.coreJobs?.length || 0}`);
          console.log(`  Related Jobs: ${result.relatedJobs?.length || 0}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources),
            metadata: {
              segmentsAnalyzed,
              inputSources,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[JTBD Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, inputSources) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.05;
        if (result.coreJobs?.length >= 3) confidence += 0.1;
        if (result.opportunities?.topOpportunities?.length >= 2) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    jtbdAnalyzer = new JTBDAnalyzer();
  }
});

// server/intelligence/okr-generator.ts
var OKRGenerator, okrGenerator;
var init_okr_generator = __esm({
  "server/intelligence/okr-generator.ts"() {
    "use strict";
    init_ai_clients();
    OKRGenerator = class {
      async generate(input) {
        console.log("[OKR Generator] Starting OKR generation...");
        const prompt = `
Generate a comprehensive OKR (Objectives and Key Results) framework for this organization:

Business Context:
${input.businessContext}

Strategic Goals:
${input.strategicGoals.map((g, i) => `${i + 1}. ${g}`).join("\n")}

Timeframe: ${input.timeframe}

Create a complete OKR framework with the following characteristics:

1. OBJECTIVES - Clear, inspirational statements of what to achieve
   - Should be qualitative and motivating
   - Aligned with the strategic goals

2. KEY RESULTS - Measurable outcomes that define success
   - Should be 3-5 per objective
   - Must be specific, measurable, and ambitious yet achievable
   - Should include: the metric, target value, and any supporting initiatives

3. OWNERSHIP - Suggest an owner or role for each OKR

4. TIMELINE - Specify the realistic timeline for achieving each OKR within the given timeframe

5. PRIORITY - Classify each OKR as critical, high, or medium priority

6. ALIGNMENT - Show how each OKR maps back to a strategic goal

7. SUCCESS CRITERIA - Define what complete success looks like for each OKR

Also provide:
- An executive summary of the OKR strategy
- An alignment map showing which OKRs support each strategic goal
- Key success metrics for measuring overall performance
- Implementation phases/waves for rolling out the OKRs

Return as JSON:
{
  "okrs": [
    {
      "objective": "",
      "objectiveDescription": "",
      "keyResults": [
        {
          "text": "",
          "metric": "",
          "target": "",
          "initiative": ""
        }
      ],
      "owner": "",
      "timeline": "",
      "priority": "critical|high|medium",
      "alignedWithGoal": "",
      "successCriteria": ""
    }
  ],
  "executiveSummary": "",
  "alignmentMap": [
    {
      "strategicGoal": "",
      "alignedOKRs": [""]
    }
  ],
  "successMetrics": [
    {
      "metric": "",
      "target": "",
      "measurement": ""
    }
  ],
  "implementation": [
    {
      "phase": "",
      "focus": "",
      "duration": ""
    }
  ]
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are an expert in OKR methodology and strategic goal-setting. Generate comprehensive, measurable OKRs that are ambitious yet achievable. Return only valid JSON.",
            userMessage: prompt,
            maxTokens: 5e3
          });
          const result = JSON.parse(response.content);
          console.log("[OKR Generator] OKR generation complete");
          console.log(`  OKRs generated: ${result.okrs?.length || 0}`);
          console.log(`  Implementation phases: ${result.implementation?.length || 0}`);
          return {
            okrs: result.okrs || [],
            executiveSummary: result.executiveSummary || "",
            alignmentMap: result.alignmentMap || [],
            successMetrics: result.successMetrics || [],
            implementation: result.implementation || [],
            confidence: this.calculateConfidence(result, input.strategicGoals.length),
            metadata: {
              okrsGenerated: result.okrs?.length || 0,
              timeframe: input.timeframe,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[OKR Generator] OKR generation failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, goalCount) {
        let confidence = 0.65;
        const okrCount = result.okrs?.length || 0;
        if (okrCount >= goalCount * 1.5) confidence += 0.15;
        else if (okrCount >= goalCount) confidence += 0.1;
        const allOKRsComplete = result.okrs?.every(
          (o) => o.objective && o.keyResults?.length >= 3 && o.owner && o.priority
        ) ?? false;
        if (allOKRsComplete) confidence += 0.1;
        const avgKeyResultsPerOKR = okrCount > 0 ? result.okrs.reduce((sum, o) => sum + (o.keyResults?.length || 0), 0) / okrCount : 0;
        if (avgKeyResultsPerOKR >= 3) confidence += 0.05;
        if (result.executiveSummary && result.alignmentMap?.length > 0) confidence += 0.05;
        return Math.min(0.95, confidence);
      }
    };
    okrGenerator = new OKRGenerator();
  }
});

// server/intelligence/ocean-strategy-analyzer.ts
var OceanStrategyAnalyzer, oceanStrategyAnalyzer;
var init_ocean_strategy_analyzer = __esm({
  "server/intelligence/ocean-strategy-analyzer.ts"() {
    "use strict";
    init_ai_clients();
    OceanStrategyAnalyzer = class {
      async analyze(input) {
        console.log("[OceanStrategy Analyzer] Starting Ocean Strategy analysis...");
        const contextParts = [input.businessContext];
        const inputSources = ["business_context"];
        contextParts.push(`Industry: ${input.industry}`);
        if (input.currentMarketPosition) {
          contextParts.push(`Current Market Position: ${input.currentMarketPosition}`);
          inputSources.push("market_position");
        }
        if (input.competitiveLandscape) {
          contextParts.push(`Competitive Landscape: ${input.competitiveLandscape}`);
          inputSources.push("competitive_landscape");
        }
        if (input.sustainabilityGoals) {
          contextParts.push(`Sustainability Goals: ${input.sustainabilityGoals}`);
          inputSources.push("sustainability");
        }
        if (input.blueOceanOutput) {
          contextParts.push(`Blue Ocean Analysis: ${JSON.stringify(input.blueOceanOutput)}`);
          inputSources.push("blue_ocean");
        }
        if (input.swotOutput) {
          contextParts.push(`SWOT Analysis: ${JSON.stringify(input.swotOutput)}`);
          inputSources.push("swot");
        }
        if (input.portersOutput) {
          contextParts.push(`Porter's Five Forces: ${JSON.stringify(input.portersOutput)}`);
          inputSources.push("porters");
        }
        const prompt = `
Perform a comprehensive Ocean Strategy analysis for this business:

${contextParts.join("\n\n")}

Analyze the business against ALL FOUR OCEAN STRATEGIES:

**RED OCEAN** - Compete in existing market space
- Beat the competition in existing markets
- Exploit existing demand
- Make value-cost trade-off
- Align activities with strategic choice of differentiation OR low cost

**BLUE OCEAN** - Create uncontested market space
- Create and capture new demand
- Break the value-cost trade-off
- Align activities in pursuit of differentiation AND low cost
- Make competition irrelevant

**GREEN OCEAN** - Sustainable and purpose-driven strategy
- Balance profit with environmental/social responsibility
- Build sustainability into the core business model
- Create shared value for all stakeholders
- Long-term resilience through ESG integration

**WHITE OCEAN** - Social enterprise and impact-first strategy
- Primary focus on social/community impact
- Business model serves social mission
- Profit enables mission, not the reverse
- Collaborative, ecosystem-building approach

Provide analysis in this structure:

1. CURRENT OCEAN ASSESSMENT
   - Which ocean does this business currently operate in?
   - What are the market characteristics that indicate this?
   - Reasoning for this assessment

2. ASSESSMENT OF EACH OCEAN (for all 4 oceans)
   For each ocean provide:
   - Fit score (1-10 how well this strategy fits the business)
   - Strengths of this approach for this business
   - Challenges/obstacles to this approach
   - Required capabilities to pursue this ocean
   - Time to implement this strategy
   - Risk level (high/medium/low)
   - Potential rewards

3. RECOMMENDED OCEAN
   - Which ocean strategy is best for this business?
   - Detailed reasoning for this recommendation
   - Transition path from current state (step by step)
   - Quick wins in the first 90 days
   - Long-term goals (1-3 years)

4. OCEAN COMPARISON
   For each ocean (red, blue, green, white) provide:
   - Core approach
   - Primary focus
   - How competition is handled
   - How value is created
   - Whether it's suitable for this business
   - Why/why not suitable

5. HYBRID STRATEGY (if applicable)
   - Can this business combine ocean strategies?
   - Primary and secondary ocean
   - How to integrate them
   - Benefits and risks of hybrid approach

6. IMPLEMENTATION ROADMAP
   3-4 phases with:
   - Phase name/description
   - Specific actions
   - Timeline
   - Key milestones

7. PRIORITY ACTIONS: Top 5 immediate actions

Return as JSON:
{
  "currentOcean": {
    "ocean": "red|blue|green|white",
    "reasoning": "",
    "marketCharacteristics": []
  },
  "oceanAssessments": [
    {
      "ocean": "red",
      "displayName": "Red Ocean Strategy",
      "description": "",
      "fitScore": 7,
      "strengths": [],
      "challenges": [],
      "requiredCapabilities": [],
      "timeToImplement": "",
      "riskLevel": "medium",
      "potentialRewards": ""
    }
  ],
  "recommendedOcean": {
    "ocean": "blue",
    "reasoning": "",
    "transitionPath": [],
    "quickWins": [],
    "longTermGoals": []
  },
  "oceanComparison": {
    "redOcean": {"approach": "", "focus": "", "competitionMode": "", "valueCreation": "", "suitable": true, "suitabilityReason": ""},
    "blueOcean": {"approach": "", "focus": "", "competitionMode": "", "valueCreation": "", "suitable": true, "suitabilityReason": ""},
    "greenOcean": {"approach": "", "focus": "", "competitionMode": "", "valueCreation": "", "suitable": false, "suitabilityReason": ""},
    "whiteOcean": {"approach": "", "focus": "", "competitionMode": "", "valueCreation": "", "suitable": false, "suitabilityReason": ""}
  },
  "hybridStrategy": {
    "primaryOcean": "blue",
    "secondaryOcean": "green",
    "integration": "",
    "benefits": [],
    "risks": []
  },
  "implementationRoadmap": [
    {"phase": "", "actions": [], "timeline": "", "milestones": []}
  ],
  "priorityActions": []
}
    `.trim();
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are an Ocean Strategy expert specializing in Red, Blue, Green, and White ocean strategies. Analyze businesses and recommend the optimal ocean strategy. Return valid JSON only.",
            userMessage: prompt,
            maxTokens: 4500
          });
          const result = JSON.parse(response.content);
          console.log("[OceanStrategy Analyzer] Analysis complete");
          console.log(`  Current ocean: ${result.currentOcean?.ocean || "unknown"}`);
          console.log(`  Recommended ocean: ${result.recommendedOcean?.ocean || "unknown"}`);
          console.log(`  Assessments: ${result.oceanAssessments?.length || 0} oceans analyzed`);
          console.log(`  Roadmap phases: ${result.implementationRoadmap?.length || 0}`);
          return {
            ...result,
            confidence: this.calculateConfidence(result, inputSources),
            metadata: {
              industryAnalyzed: input.industry,
              inputSources,
              generatedAt: (/* @__PURE__ */ new Date()).toISOString()
            }
          };
        } catch (error) {
          console.error("[OceanStrategy Analyzer] Analysis failed:", error);
          throw error;
        }
      }
      calculateConfidence(result, inputSources) {
        let confidence = 0.6;
        confidence += inputSources.length * 0.04;
        if (result.oceanAssessments?.length >= 4) confidence += 0.1;
        else if (result.oceanAssessments?.length >= 2) confidence += 0.05;
        if (result.recommendedOcean?.reasoning?.length > 100) confidence += 0.05;
        if (result.recommendedOcean?.transitionPath?.length >= 3) confidence += 0.05;
        if (result.implementationRoadmap?.length >= 3) confidence += 0.05;
        if (result.hybridStrategy) confidence += 0.03;
        return Math.min(0.95, confidence);
      }
    };
    oceanStrategyAnalyzer = new OceanStrategyAnalyzer();
  }
});

// server/auth-readiness.ts
var AuthReadiness, authReadiness;
var init_auth_readiness = __esm({
  "server/auth-readiness.ts"() {
    "use strict";
    AuthReadiness = class {
      ready = false;
      resolvers = [];
      setReady() {
        this.ready = true;
        this.resolvers.forEach((resolve) => resolve());
        this.resolvers = [];
      }
      isReady() {
        return this.ready;
      }
      waitForReady() {
        if (this.ready) {
          return Promise.resolve();
        }
        return new Promise((resolve) => {
          this.resolvers.push(resolve);
        });
      }
    };
    authReadiness = new AuthReadiness();
  }
});

// server/types/interfaces.ts
var ServiceKeys;
var init_interfaces = __esm({
  "server/types/interfaces.ts"() {
    "use strict";
    ServiceKeys = {
      // Exporters
      MARKDOWN_EXPORTER: "exporter:markdown",
      HTML_EXPORTER: "exporter:html",
      PDF_EXPORTER: "exporter:pdf",
      DOCX_EXPORTER: "exporter:docx",
      CSV_EXPORTER: "exporter:csv",
      EXPORT_ORCHESTRATOR: "exporter:orchestrator",
      // EPM Components
      EPM_SYNTHESIZER: "epm:synthesizer",
      CONTEXT_BUILDER: "epm:context-builder",
      WORKSTREAM_GENERATOR: "epm:workstream-generator",
      TIMELINE_CALCULATOR: "epm:timeline-calculator",
      RESOURCE_ALLOCATOR: "epm:resource-allocator",
      EPM_VALIDATOR: "epm:validator",
      // Other services
      SSE_PROGRESS_MANAGER: "service:sse-progress",
      // Repositories
      EPM_REPOSITORY: "repository:epm",
      JOURNEY_REPOSITORY: "repository:journey",
      STRATEGY_REPOSITORY: "repository:strategy"
    };
  }
});

// src/lib/intelligent-planning/llm-provider.ts
var llm_provider_exports = {};
__export(llm_provider_exports, {
  DEFAULT_LLM_TIMEOUT_MS: () => DEFAULT_LLM_TIMEOUT_MS,
  MAX_TOTAL_RETRY_MS: () => MAX_TOTAL_RETRY_MS,
  MODEL_CONFIG: () => MODEL_CONFIG,
  OpenAIProvider: () => OpenAIProvider,
  createOpenAIProvider: () => createOpenAIProvider
});
import OpenAI3 from "openai";
function createOpenAIProvider(config) {
  return new OpenAIProvider(config);
}
var MODEL_CONFIG, DEFAULT_LLM_TIMEOUT_MS, MAX_TOTAL_RETRY_MS, OpenAIProvider;
var init_llm_provider = __esm({
  "src/lib/intelligent-planning/llm-provider.ts"() {
    "use strict";
    MODEL_CONFIG = {
      workstreamGeneration: "gpt-5",
      // Heavy reasoning - keep expensive model
      dependencyLinkage: "gpt-4o-mini",
      // Deterministic - use fast/cheap model
      riskAssessment: "gpt-4-turbo",
      // Medium complexity
      fallback: "gpt-4-turbo-preview",
      // Last resort
      default: "gpt-4-turbo-preview"
      // Standard operations
    };
    DEFAULT_LLM_TIMEOUT_MS = 3e4;
    MAX_TOTAL_RETRY_MS = 45e3;
    OpenAIProvider = class _OpenAIProvider {
      client;
      model;
      maxRetries;
      timeoutMs;
      constructor(config) {
        this.client = new OpenAI3({ apiKey: config.apiKey });
        this.model = config.model || "gpt-4-turbo-preview";
        this.maxRetries = config.maxRetries ?? 3;
        this.timeoutMs = config.timeoutMs ?? DEFAULT_LLM_TIMEOUT_MS;
      }
      delay(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
      /**
       * Create a provider with a specific model for targeted tasks
       */
      withModel(model) {
        return new _OpenAIProvider({
          apiKey: process.env.OPENAI_API_KEY || "",
          model,
          maxRetries: this.maxRetries,
          timeoutMs: this.timeoutMs
        });
      }
      /**
       * Create a provider with a specific timeout
       */
      withTimeout(timeoutMs) {
        return new _OpenAIProvider({
          apiKey: process.env.OPENAI_API_KEY || "",
          model: this.model,
          maxRetries: this.maxRetries,
          timeoutMs
        });
      }
      async generate(prompt) {
        console.log("[LLM Provider] Starting OpenAI call...");
        console.log("[LLM Provider] Using API key:", process.env.OPENAI_API_KEY ? "Found \u2713" : "MISSING! \u2717");
        console.log("[LLM Provider] Model:", this.model);
        console.log("[LLM Provider] Timeout:", `${this.timeoutMs}ms`);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => {
          console.warn(`[LLM Provider] Aborting call after ${this.timeoutMs}ms timeout`);
          controller.abort();
        }, this.timeoutMs);
        const startTime = Date.now();
        try {
          const response = await this.client.chat.completions.create({
            model: this.model,
            messages: [{ role: "user", content: prompt }],
            max_completion_tokens: 4e3
          }, { signal: controller.signal });
          const elapsed = ((Date.now() - startTime) / 1e3).toFixed(2);
          console.log(`[LLM Provider] Success - response received in ${elapsed}s`);
          return response.choices[0].message.content || "";
        } catch (error) {
          const elapsed = ((Date.now() - startTime) / 1e3).toFixed(2);
          if (error.name === "AbortError" || error.message?.includes("aborted")) {
            console.error(`[LLM Provider] Request timed out after ${elapsed}s`);
            throw new Error(`LLM request timed out after ${this.timeoutMs}ms`);
          }
          console.error(`[LLM Provider] OpenAI API error after ${elapsed}s:`, error.message);
          throw new Error(`LLM generation failed: ${error.message}`);
        } finally {
          clearTimeout(timeoutId);
        }
      }
      async generateStructured(config) {
        let lastError = null;
        const totalStartTime = Date.now();
        for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
          const totalElapsed = Date.now() - totalStartTime;
          if (totalElapsed > MAX_TOTAL_RETRY_MS) {
            console.warn(`[LLM Provider] Total retry time exceeded ${MAX_TOTAL_RETRY_MS}ms, giving up`);
            throw new Error(`Structured generation failed: total time budget exceeded (${(totalElapsed / 1e3).toFixed(1)}s)`);
          }
          console.log(`[LLM Provider] Starting STRUCTURED OpenAI call (attempt ${attempt}/${this.maxRetries})...`);
          console.log("[LLM Provider] Using API key:", process.env.OPENAI_API_KEY ? "Found \u2713" : "MISSING! \u2717");
          console.log("[LLM Provider] Model:", this.model);
          console.log("[LLM Provider] Timeout:", `${this.timeoutMs}ms`);
          const startTime = Date.now();
          let content = null;
          let shouldRetry = false;
          const controller = new AbortController();
          const timeoutId = setTimeout(() => {
            console.warn(`[LLM Provider] Aborting structured call after ${this.timeoutMs}ms timeout`);
            controller.abort();
          }, this.timeoutMs);
          try {
            const response = await this.client.chat.completions.create({
              model: this.model,
              messages: [
                {
                  role: "system",
                  content: "You are a project planning expert. Always return valid JSON matching the provided schema."
                },
                {
                  role: "user",
                  content: `${config.prompt}

Return as JSON matching this schema:
${JSON.stringify(config.schema, null, 2)}`
                }
              ],
              response_format: { type: "json_object" },
              max_completion_tokens: 4e3
            }, { signal: controller.signal });
            content = response.choices[0].message.content;
          } catch (apiError) {
            clearTimeout(timeoutId);
            const elapsed = ((Date.now() - startTime) / 1e3).toFixed(2);
            if (apiError.name === "AbortError" || apiError.message?.includes("aborted")) {
              lastError = new Error(`Request timed out after ${this.timeoutMs}ms`);
              shouldRetry = true;
              console.warn(`[LLM Provider] Timeout on attempt ${attempt}/${this.maxRetries} after ${elapsed}s`);
            } else {
              lastError = new Error(`API error: ${apiError.message}`);
              shouldRetry = true;
              console.warn(`[LLM Provider] API error on attempt ${attempt}/${this.maxRetries}: ${apiError.message}`);
            }
          } finally {
            clearTimeout(timeoutId);
          }
          if (!shouldRetry) {
            const elapsed = ((Date.now() - startTime) / 1e3).toFixed(2);
            console.log(`[LLM Provider] API call completed in ${elapsed}s`);
            if (!content || content.trim().length === 0) {
              lastError = new Error("Empty response from LLM");
              shouldRetry = true;
              console.warn(`[LLM Provider] Empty response on attempt ${attempt}/${this.maxRetries}`);
            } else {
              try {
                const parsed = JSON.parse(content);
                console.log("[LLM Provider] Success - structured response received");
                return parsed;
              } catch (parseError) {
                lastError = new Error(`Invalid JSON response: ${parseError.message}`);
                shouldRetry = true;
                console.warn(`[LLM Provider] JSON parse failed on attempt ${attempt}/${this.maxRetries}: ${parseError.message}`);
              }
            }
          }
          if (shouldRetry && attempt < this.maxRetries) {
            const backoffMs = Math.min(2e3 * Math.pow(2, attempt - 1), 8e3);
            console.log(`[LLM Provider] Retrying in ${backoffMs}ms...`);
            await this.delay(backoffMs);
            continue;
          }
          if (shouldRetry) {
            const totalTime2 = ((Date.now() - totalStartTime) / 1e3).toFixed(1);
            throw new Error(`Structured generation failed after ${attempt} attempts (${totalTime2}s total): ${lastError?.message}`);
          }
        }
        const totalTime = ((Date.now() - totalStartTime) / 1e3).toFixed(1);
        throw new Error(`Structured generation failed after ${this.maxRetries} retries (${totalTime}s total): ${lastError?.message || "Unknown error"}`);
      }
    };
  }
});

// server/ontology-service.ts
import { eq as eq10, and as and8, or } from "drizzle-orm";
var OntologyService, ontologyService;
var init_ontology_service = __esm({
  "server/ontology-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    OntologyService = class {
      async getEntityDefinition(entityName) {
        const [entity] = await db.select().from(ontologyEntities).where(eq10(ontologyEntities.entityName, entityName));
        return entity;
      }
      async getAllEntities() {
        return await db.select().from(ontologyEntities);
      }
      async getEntityRelationships(entityName, direction = "both") {
        if (direction === "from") {
          return await db.select().from(ontologyRelationships).where(eq10(ontologyRelationships.fromEntity, entityName));
        } else if (direction === "to") {
          return await db.select().from(ontologyRelationships).where(eq10(ontologyRelationships.toEntity, entityName));
        } else {
          return await db.select().from(ontologyRelationships).where(
            or(
              eq10(ontologyRelationships.fromEntity, entityName),
              eq10(ontologyRelationships.toEntity, entityName)
            )
          );
        }
      }
      async getValidationRules(params) {
        let query = db.select().from(ontologyValidationRules);
        const conditions = [];
        if (params?.entity) {
          conditions.push(eq10(ontologyValidationRules.entity, params.entity));
        }
        if (params?.category) {
          conditions.push(eq10(ontologyValidationRules.category, params.category));
        }
        if (params?.severity) {
          conditions.push(eq10(ontologyValidationRules.severity, params.severity));
        }
        if (params?.enabled !== void 0) {
          conditions.push(eq10(ontologyValidationRules.enabled, params.enabled));
        }
        if (conditions.length > 0) {
          return await query.where(and8(...conditions));
        }
        return await query;
      }
      async getCompletenessChecks(params) {
        let query = db.select().from(ontologyCompletenessChecks);
        const conditions = [];
        if (params?.entity) {
          conditions.push(eq10(ontologyCompletenessChecks.entity, params.entity));
        }
        if (params?.checkType) {
          conditions.push(eq10(ontologyCompletenessChecks.checkType, params.checkType));
        }
        if (params?.importance) {
          conditions.push(eq10(ontologyCompletenessChecks.importance, params.importance));
        }
        if (params?.enabled !== void 0) {
          conditions.push(eq10(ontologyCompletenessChecks.enabled, params.enabled));
        }
        if (conditions.length > 0) {
          return await query.where(and8(...conditions));
        }
        return await query;
      }
      async getCascadeImpacts(trigger) {
        if (trigger) {
          return await db.select().from(ontologyCascadeImpacts).where(eq10(ontologyCascadeImpacts.trigger, trigger));
        }
        return await db.select().from(ontologyCascadeImpacts);
      }
      async getDomainTerm(term) {
        const [domainTerm] = await db.select().from(ontologyDomainTerms).where(eq10(ontologyDomainTerms.term, term));
        return domainTerm;
      }
      async getAllDomainTerms() {
        return await db.select().from(ontologyDomainTerms);
      }
      async getFrameworkMappings(params) {
        let query = db.select().from(ontologyFrameworkMappings);
        const conditions = [];
        if (params?.framework) {
          conditions.push(eq10(ontologyFrameworkMappings.framework, params.framework));
        }
        if (params?.epmEntity) {
          conditions.push(eq10(ontologyFrameworkMappings.epmEntity, params.epmEntity));
        }
        if (conditions.length > 0) {
          return await query.where(and8(...conditions));
        }
        return await query;
      }
      async validateEntityData(entityName, data) {
        const rules = await this.getValidationRules({
          entity: entityName,
          enabled: true
        });
        const results = {
          isValid: true,
          errors: [],
          warnings: []
        };
        for (const rule of rules) {
          const ruleData = rule.data;
          const isViolated = this.evaluateValidationRule(rule.ruleId, ruleData, data);
          if (isViolated) {
            const issue = {
              rule: rule.ruleId,
              message: this.interpolateMessage(ruleData.errorMessage, data),
              autoFix: ruleData.autoFix
            };
            if (rule.severity === "error") {
              results.errors.push(issue);
              results.isValid = false;
            } else {
              results.warnings.push(issue);
            }
          }
        }
        return results;
      }
      evaluateValidationRule(ruleId, ruleData, data) {
        if (ruleId === "program-date-consistency" || ruleId === "task-date-consistency") {
          return data.startDate && data.endDate && new Date(data.startDate) >= new Date(data.endDate);
        }
        if (ruleId === "workstream-within-program-timeline") {
          return false;
        }
        if (ruleId === "task-within-program-timeline") {
          return false;
        }
        if (ruleData.category === "relationship") {
          return false;
        }
        if (ruleData.category === "budget") {
          return false;
        }
        if (ruleData.category === "state") {
          return false;
        }
        return false;
      }
      interpolateMessage(template, data) {
        return template.replace(/\{(\w+)\}/g, (match, key) => {
          return data[key] !== void 0 ? String(data[key]) : match;
        });
      }
      async checkCompleteness(entityName, data) {
        const checks = await this.getCompletenessChecks({
          entity: entityName,
          enabled: true
        });
        const results = {
          score: 0,
          maxScore: 0,
          critical: { passed: 0, total: 0 },
          important: { passed: 0, total: 0 },
          niceToHave: { passed: 0, total: 0 },
          missingFields: []
        };
        for (const check of checks) {
          const checkData = check.data;
          const fieldValue = data[checkData.field];
          const isPassed = fieldValue !== void 0 && fieldValue !== null && fieldValue !== "";
          const scoreValue = check.importance === "critical" ? 3 : check.importance === "important" ? 2 : 1;
          results.maxScore += scoreValue;
          if (isPassed) {
            results.score += scoreValue;
            if (check.importance === "critical") results.critical.passed++;
            else if (check.importance === "important") results.important.passed++;
            else results.niceToHave.passed++;
          } else {
            results.missingFields.push({
              field: checkData.field,
              importance: check.importance,
              description: checkData.description
            });
          }
          if (check.importance === "critical") results.critical.total++;
          else if (check.importance === "important") results.important.total++;
          else results.niceToHave.total++;
        }
        return results;
      }
      async getFullEntityContext(entityName) {
        const [definition, relationships, validationRules, completenessChecks, frameworkMappings] = await Promise.all([
          this.getEntityDefinition(entityName),
          this.getEntityRelationships(entityName),
          this.getValidationRules({ entity: entityName }),
          this.getCompletenessChecks({ entity: entityName }),
          this.getFrameworkMappings({ epmEntity: entityName })
        ]);
        return {
          definition,
          relationships,
          validationRules,
          completenessChecks,
          frameworkMappings
        };
      }
    };
    ontologyService = new OntologyService();
  }
});

// server/storage.ts
import { eq as eq11, desc as desc6, and as and9, isNull, not, count, sql as sql8 } from "drizzle-orm";
import session from "express-session";
import connectPg from "connect-pg-simple";
var PostgresSessionStore, DatabaseStorage, storage;
var init_storage = __esm({
  "server/storage.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_db();
    init_ontology_service();
    init_secure_data_service();
    init_kms_encryption();
    PostgresSessionStore = connectPg(session);
    DatabaseStorage = class {
      sessionStore;
      constructor() {
        this.sessionStore = new PostgresSessionStore({
          pool,
          createTableIfMissing: true
        });
      }
      async validateEntity(entityName, data) {
        const [validation, completeness] = await Promise.all([
          ontologyService.validateEntityData(entityName, data),
          ontologyService.checkCompleteness(entityName, data)
        ]);
        return {
          isValid: validation.isValid,
          errors: validation.errors,
          warnings: validation.warnings,
          completeness: {
            ...completeness,
            percentage: completeness.maxScore > 0 ? Math.round(completeness.score / completeness.maxScore * 100) : 0
          }
        };
      }
      logValidationResults(entityName, entityId, results) {
        if (results.errors.length > 0) {
          console.warn(`[Validation] ${entityName} ${entityId} has ${results.errors.length} error(s):`, results.errors);
        }
        if (results.warnings.length > 0) {
          console.info(`[Validation] ${entityName} ${entityId} has ${results.warnings.length} warning(s):`, results.warnings);
        }
        console.info(`[Completeness] ${entityName} ${entityId} is ${results.completeness.percentage}% complete (${results.completeness.score}/${results.completeness.maxScore})`);
        if (results.completeness.missingFields.length > 0) {
          console.info(`[Completeness] Missing fields for ${entityName} ${entityId}:`, results.completeness.missingFields.map((f) => `${f.field} (${f.importance})`).join(", "));
        }
      }
      // Helper to decrypt strategy version fields
      async decryptStrategyVersion(version) {
        const isEncrypted2 = (data) => {
          if (!data || typeof data !== "object") return false;
          return "dataKeyCiphertext" in data && "iv" in data && "authTag" in data && "ciphertext" in data;
        };
        let decryptedAnalysis = version.analysisData;
        if (version.analysisData && isEncrypted2(version.analysisData)) {
          const analysisDataStr = JSON.stringify(version.analysisData);
          decryptedAnalysis = await decryptJSONKMS(analysisDataStr);
        }
        let decryptedDecisions = version.decisionsData;
        if (version.decisionsData && isEncrypted2(version.decisionsData)) {
          const decisionsDataStr = JSON.stringify(version.decisionsData);
          decryptedDecisions = await decryptJSONKMS(decisionsDataStr);
        }
        return {
          ...version,
          inputSummary: version.inputSummary ? await decryptKMS(version.inputSummary) : null,
          analysisData: decryptedAnalysis,
          decisionsData: decryptedDecisions
        };
      }
      // User management
      async getUser(id) {
        const [user] = await db.select().from(users).where(eq11(users.id, id));
        return user || void 0;
      }
      async getUserByUsername(username) {
        return void 0;
      }
      async createUser(insertUser) {
        const [user] = await db.insert(users).values(insertUser).returning();
        return user;
      }
      // Replit Auth user upsert
      async upsertUser(userData) {
        if (userData.email) {
          const existing = await db.select().from(users).where(eq11(users.email, userData.email)).limit(1);
          if (existing.length > 0) {
            const { id, ...updateData2 } = userData;
            const [user2] = await db.update(users).set({
              ...updateData2,
              updatedAt: /* @__PURE__ */ new Date()
            }).where(eq11(users.id, existing[0].id)).returning();
            return user2;
          }
        }
        const { id: _, ...updateData } = userData;
        const [user] = await db.insert(users).values(userData).onConflictDoUpdate({
          target: users.id,
          set: {
            ...updateData,
            updatedAt: /* @__PURE__ */ new Date()
          }
        }).returning();
        return user;
      }
      // Location management
      async createLocation(location) {
        const [newLocation] = await db.insert(locations).values(location).returning();
        return newLocation;
      }
      async getLocationsByQuery(rawQuery) {
        return await db.select().from(locations).where(eq11(locations.rawQuery, rawQuery));
      }
      async getLocation(id) {
        const [location] = await db.select().from(locations).where(eq11(locations.id, id));
        return location || void 0;
      }
      // Program management
      async getPrograms() {
        return await db.select().from(programs).orderBy(desc6(programs.createdAt));
      }
      async getProgram(id) {
        const [program] = await db.select().from(programs).where(eq11(programs.id, id));
        return program || void 0;
      }
      async createProgram(program) {
        const validationResults = await this.validateEntity("Program", program);
        this.logValidationResults("Program", program.name || "new", validationResults);
        const [newProgram] = await db.insert(programs).values(program).returning();
        const defaultStageGates = [
          {
            code: "G0",
            name: "Ideation",
            description: "Initial concept development and feasibility assessment",
            successCriteria: "Business case approved, feasibility confirmed, initial scope defined",
            programId: newProgram.id
          },
          {
            code: "G1",
            name: "Planning",
            description: "Detailed planning and requirements definition",
            successCriteria: "Requirements documented, project plan approved, resources allocated",
            programId: newProgram.id
          },
          {
            code: "G2",
            name: "Execution",
            description: "Development and implementation phase",
            successCriteria: "Development complete, quality standards met, documentation updated",
            programId: newProgram.id
          },
          {
            code: "G3",
            name: "Validation",
            description: "Testing and quality assurance",
            successCriteria: "Testing complete, acceptance criteria met, stakeholder approval received",
            programId: newProgram.id
          },
          {
            code: "G4",
            name: "Closure",
            description: "Deployment and project closeout",
            successCriteria: "Deployment successful, handover complete, lessons learned documented",
            programId: newProgram.id
          }
        ];
        await db.insert(stageGates).values(defaultStageGates);
        return newProgram;
      }
      // Workstream management
      async getWorkstreams(programId) {
        const query = programId ? db.select().from(workstreams).where(eq11(workstreams.programId, programId)) : db.select().from(workstreams);
        return await query.orderBy(desc6(workstreams.createdAt));
      }
      async createWorkstream(workstream) {
        const [newWorkstream] = await db.insert(workstreams).values(workstream).returning();
        return newWorkstream;
      }
      // Resource management
      async getResources(programId) {
        const query = programId ? db.select().from(resources).where(eq11(resources.programId, programId)) : db.select().from(resources);
        return await query.orderBy(desc6(resources.createdAt));
      }
      async createResource(resource) {
        const [newResource] = await db.insert(resources).values(resource).returning();
        return newResource;
      }
      async updateResource(id, resource) {
        const [updatedResource] = await db.update(resources).set(resource).where(eq11(resources.id, id)).returning();
        return updatedResource;
      }
      // Stage Gates
      async getStageGates(programId) {
        const query = programId ? db.select().from(stageGates).where(eq11(stageGates.programId, programId)) : db.select().from(stageGates);
        return await query.orderBy(stageGates.code);
      }
      async createStageGate(gate) {
        const validationResults = await this.validateEntity("StageGate", gate);
        this.logValidationResults("StageGate", gate.name || gate.code || "new", validationResults);
        const [newGate] = await db.insert(stageGates).values(gate).returning();
        return newGate;
      }
      async getStageGateReviews(programId) {
        const query = programId ? db.select().from(stageGateReviews).where(eq11(stageGateReviews.programId, programId)) : db.select().from(stageGateReviews);
        return await query.orderBy(desc6(stageGateReviews.reviewDate));
      }
      async createStageGateReview(review) {
        const [newReview] = await db.insert(stageGateReviews).values(review).returning();
        return newReview;
      }
      // Tasks
      async getTasks(programId, workstreamId) {
        if (workstreamId) {
          return await db.select().from(tasks).where(eq11(tasks.workstreamId, workstreamId)).orderBy(desc6(tasks.createdAt));
        } else if (programId) {
          const result = await db.select({
            id: tasks.id,
            name: tasks.name,
            description: tasks.description,
            workstreamId: tasks.workstreamId,
            ownerId: tasks.ownerId,
            stageGateId: tasks.stageGateId,
            startDate: tasks.startDate,
            endDate: tasks.endDate,
            status: tasks.status,
            progress: tasks.progress,
            priority: tasks.priority,
            createdAt: tasks.createdAt
          }).from(tasks).leftJoin(workstreams, eq11(tasks.workstreamId, workstreams.id)).where(eq11(workstreams.programId, programId)).orderBy(desc6(tasks.createdAt));
          return result;
        }
        return await db.select().from(tasks).orderBy(desc6(tasks.createdAt));
      }
      async getTask(id) {
        const [task] = await db.select().from(tasks).where(eq11(tasks.id, id));
        return task || void 0;
      }
      async createTask(task) {
        const validationResults = await this.validateEntity("Task", task);
        this.logValidationResults("Task", task.name || "new", validationResults);
        const [newTask] = await db.insert(tasks).values(task).returning();
        return newTask;
      }
      async updateTask(id, task) {
        const [updatedTask] = await db.update(tasks).set(task).where(eq11(tasks.id, id)).returning();
        return updatedTask;
      }
      async deleteTask(id) {
        await db.delete(tasks).where(eq11(tasks.id, id));
      }
      // KPIs
      async getKpis(programId) {
        const query = programId ? db.select().from(kpis).where(eq11(kpis.programId, programId)) : db.select().from(kpis);
        return await query.orderBy(desc6(kpis.createdAt));
      }
      async getKpiMeasurements(kpiId) {
        return await db.select().from(kpiMeasurements).where(eq11(kpiMeasurements.kpiId, kpiId)).orderBy(desc6(kpiMeasurements.measurementDate));
      }
      async createKpi(kpi) {
        const [newKpi] = await db.insert(kpis).values(kpi).returning();
        return newKpi;
      }
      async updateKpi(id, kpi) {
        const [updatedKpi] = await db.update(kpis).set(kpi).where(eq11(kpis.id, id)).returning();
        return updatedKpi;
      }
      async createKpiMeasurement(measurement) {
        const [newMeasurement] = await db.insert(kpiMeasurements).values(measurement).returning();
        return newMeasurement;
      }
      // Risks
      async getRisks(programId) {
        const query = programId ? db.select().from(risks).where(eq11(risks.programId, programId)) : db.select().from(risks);
        return await query.orderBy(desc6(risks.createdAt));
      }
      async getRisk(id) {
        const [risk] = await db.select().from(risks).where(eq11(risks.id, id));
        return risk || void 0;
      }
      async createRisk(risk) {
        const [newRisk] = await db.insert(risks).values(risk).returning();
        return newRisk;
      }
      async updateRisk(id, risk) {
        const [updatedRisk] = await db.update(risks).set(risk).where(eq11(risks.id, id)).returning();
        return updatedRisk;
      }
      async getRiskMitigations(riskId) {
        return await db.select().from(riskMitigations).where(eq11(riskMitigations.riskId, riskId)).orderBy(desc6(riskMitigations.actionDate));
      }
      async createRiskMitigation(mitigation) {
        const [newMitigation] = await db.insert(riskMitigations).values(mitigation).returning();
        return newMitigation;
      }
      // Benefits
      async getBenefits(programId) {
        const query = programId ? db.select().from(benefits).where(eq11(benefits.programId, programId)) : db.select().from(benefits);
        return await query.orderBy(desc6(benefits.createdAt));
      }
      async createBenefit(benefit) {
        const [newBenefit] = await db.insert(benefits).values(benefit).returning();
        return newBenefit;
      }
      async updateBenefit(id, benefit) {
        const [updatedBenefit] = await db.update(benefits).set(benefit).where(eq11(benefits.id, id)).returning();
        return updatedBenefit;
      }
      // Funding
      async getFundingSources(programId) {
        const query = programId ? db.select().from(fundingSources).where(eq11(fundingSources.programId, programId)) : db.select().from(fundingSources);
        return await query.orderBy(desc6(fundingSources.createdAt));
      }
      async getExpenses(programId) {
        const query = programId ? db.select().from(expenses).where(eq11(expenses.programId, programId)) : db.select().from(expenses);
        return await query.orderBy(desc6(expenses.expenseDate));
      }
      async createFundingSource(source) {
        const [newSource] = await db.insert(fundingSources).values(source).returning();
        return newSource;
      }
      async createExpense(expense) {
        const [newExpense] = await db.insert(expenses).values(expense).returning();
        return newExpense;
      }
      // Session Context
      async getActiveSessionContext() {
        const [activeContext] = await db.select().from(sessionContext).where(eq11(sessionContext.isActive, true)).orderBy(desc6(sessionContext.createdAt)).limit(1);
        return activeContext || void 0;
      }
      async getSessionContextById(id) {
        const [context] = await db.select().from(sessionContext).where(eq11(sessionContext.id, id));
        return context || void 0;
      }
      async createSessionContext(context) {
        await db.update(sessionContext).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq11(sessionContext.isActive, true));
        const [newContext] = await db.insert(sessionContext).values(context).returning();
        return newContext;
      }
      async updateSessionContext(id, data) {
        const [updatedContext] = await db.update(sessionContext).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq11(sessionContext.id, id)).returning();
        return updatedContext;
      }
      async deactivateSessionContext(id) {
        await db.update(sessionContext).set({ isActive: false, updatedAt: /* @__PURE__ */ new Date() }).where(eq11(sessionContext.id, id));
      }
      async addDecisionToContext(id, decision) {
        const [existing] = await db.select().from(sessionContext).where(eq11(sessionContext.id, id));
        if (!existing) {
          throw new Error(`SessionContext with id ${id} not found`);
        }
        const currentLog = existing.decisionsLog || [];
        const updatedLog = [...currentLog, { ...decision, timestamp: (/* @__PURE__ */ new Date()).toISOString() }];
        const [updated] = await db.update(sessionContext).set({ decisionsLog: updatedLog, updatedAt: /* @__PURE__ */ new Date() }).where(eq11(sessionContext.id, id)).returning();
        return updated;
      }
      // Strategy Versions
      async getStrategyVersionsBySession(sessionId) {
        const versions = await db.select().from(strategyVersions).where(eq11(strategyVersions.sessionId, sessionId)).orderBy(desc6(strategyVersions.versionNumber));
        return await Promise.all(versions.map((v) => this.decryptStrategyVersion(v)));
      }
      async getAllStrategyVersionsByUser(userId) {
        const versions = await db.select().from(strategyVersions).where(eq11(strategyVersions.userId, userId)).orderBy(desc6(strategyVersions.createdAt));
        return await Promise.all(versions.map((v) => this.decryptStrategyVersion(v)));
      }
      async getStrategyVersion(sessionId, versionNumber) {
        const [version] = await db.select().from(strategyVersions).where(and9(
          eq11(strategyVersions.sessionId, sessionId),
          eq11(strategyVersions.versionNumber, versionNumber)
        ));
        if (!version) return void 0;
        return await this.decryptStrategyVersion(version);
      }
      async getStrategyVersionById(id) {
        const [version] = await db.select().from(strategyVersions).where(eq11(strategyVersions.id, id)).limit(1);
        if (!version) return void 0;
        return await this.decryptStrategyVersion(version);
      }
      async createStrategyVersion(version) {
        const dataToInsert = { ...version };
        if (version.inputSummary) {
          dataToInsert.inputSummary = await encryptKMS(version.inputSummary);
        }
        if (version.analysisData) {
          dataToInsert.analysisData = await encryptJSONKMS(version.analysisData);
        }
        if (version.decisionsData) {
          dataToInsert.decisionsData = await encryptJSONKMS(version.decisionsData);
        }
        const result = await db.insert(strategyVersions).values(dataToInsert).returning();
        return result[0];
      }
      async getInitiativeDescriptionForSession(sessionId) {
        const understanding = await getStrategicUnderstandingBySession(sessionId);
        return understanding?.initiativeDescription || null;
      }
      async updateStrategyVersion(id, data) {
        const dataToUpdate = { ...data };
        if (data.inputSummary !== void 0) {
          dataToUpdate.inputSummary = data.inputSummary ? await encryptKMS(data.inputSummary) : null;
        }
        if (data.analysisData !== void 0) {
          dataToUpdate.analysisData = data.analysisData ? await encryptJSONKMS(data.analysisData) : null;
        }
        if (data.decisionsData !== void 0) {
          dataToUpdate.decisionsData = data.decisionsData ? await encryptJSONKMS(data.decisionsData) : null;
        }
        const [updated] = await db.update(strategyVersions).set({ ...dataToUpdate, updatedAt: /* @__PURE__ */ new Date() }).where(eq11(strategyVersions.id, id)).returning();
        return updated;
      }
      async getDashboardSummary(userId) {
        try {
          const counts = await Promise.all([
            // Count analyses (DISTINCT strategic_understanding records) via journey sessions - matches repository logic
            db.select({ count: sql8`COUNT(DISTINCT ${strategicUnderstanding.id})` }).from(strategicUnderstanding).innerJoin(
              journeySessions,
              and9(
                eq11(strategicUnderstanding.id, journeySessions.understandingId),
                eq11(journeySessions.userId, userId)
              )
            ).where(eq11(strategicUnderstanding.archived, false)),
            // Count strategic_understanding records (strategies) via journey sessions for ownership
            db.select({ count: sql8`COUNT(DISTINCT ${strategicUnderstanding.id})` }).from(strategicUnderstanding).innerJoin(
              journeySessions,
              and9(
                eq11(strategicUnderstanding.id, journeySessions.understandingId),
                eq11(journeySessions.userId, userId)
              )
            ).where(eq11(strategicUnderstanding.archived, false)),
            db.select({ count: count() }).from(epmPrograms).where(and9(
              eq11(epmPrograms.userId, userId),
              eq11(epmPrograms.archived, false)
            )),
            // Count completed segment discoveries
            db.select({ count: count() }).from(segmentDiscoveryResults).where(and9(
              eq11(segmentDiscoveryResults.userId, userId),
              eq11(segmentDiscoveryResults.status, "completed")
            ))
          ]);
          const [analysesCount] = counts[0];
          const [strategiesCount] = counts[1];
          const [programsCount] = counts[2];
          const [segmentsCount] = counts[3];
          const [recentAnalyses, recentPrograms] = await Promise.all([
            // Recent strategy versions (analyses)
            db.select({
              id: strategyVersions.id,
              inputSummary: strategyVersions.inputSummary,
              createdAt: strategyVersions.createdAt
            }).from(strategyVersions).where(and9(
              eq11(strategyVersions.userId, userId),
              eq11(strategyVersions.archived, false)
            )).orderBy(desc6(strategyVersions.createdAt)).limit(5),
            // Recent EPM programs
            db.select({
              id: epmPrograms.id,
              executiveSummary: epmPrograms.executiveSummary,
              createdAt: epmPrograms.createdAt
            }).from(epmPrograms).where(and9(
              eq11(epmPrograms.userId, userId),
              eq11(epmPrograms.archived, false)
            )).orderBy(desc6(epmPrograms.createdAt)).limit(5)
          ]);
          const { decryptKMS: decryptKMS2 } = await Promise.resolve().then(() => (init_kms_encryption(), kms_encryption_exports));
          const formattedAnalyses = await Promise.all(
            recentAnalyses.map(async (analysis) => {
              const decryptedSummary = analysis.inputSummary ? await decryptKMS2(analysis.inputSummary) : "Strategic Analysis";
              return {
                id: analysis.id,
                type: "analysis",
                title: decryptedSummary || "Strategic Analysis",
                createdAt: analysis.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
                link: `/repository?highlight=${analysis.id}`
              };
            })
          );
          const formattedPrograms = recentPrograms.map((program) => {
            const executiveSummary = program.executiveSummary;
            const title = executiveSummary?.title || "EPM Program";
            return {
              id: program.id,
              type: "program",
              title,
              createdAt: program.createdAt?.toISOString() || (/* @__PURE__ */ new Date()).toISOString(),
              link: `/strategy-workspace/epm/${program.id}`
            };
          });
          const allArtifacts = [...formattedAnalyses, ...formattedPrograms].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()).slice(0, 5);
          return {
            counts: {
              analyses: analysesCount?.count || 0,
              strategies: strategiesCount?.count || 0,
              programs: programsCount?.count || 0,
              segments: segmentsCount?.count || 0
            },
            recentArtifacts: allArtifacts
          };
        } catch (error) {
          console.error("Error fetching dashboard summary:", error);
          throw new Error("Failed to fetch dashboard summary");
        }
      }
      /**
       * Atomically start integration - prevents concurrent integrations
       * Returns the version if successful, null if already integrating/integrated
       */
      async tryStartIntegration(versionId) {
        const [updated] = await db.update(strategyVersions).set({ status: "converting", updatedAt: /* @__PURE__ */ new Date() }).where(
          and9(
            eq11(strategyVersions.id, versionId),
            isNull(strategyVersions.convertedProgramId),
            not(eq11(strategyVersions.status, "converting"))
          )
        ).returning();
        return updated || null;
      }
      // Golden Records
      async createGoldenRecord(record) {
        const existing = await db.select().from(goldenRecords).where(eq11(goldenRecords.journeyType, record.journeyType)).orderBy(desc6(goldenRecords.version));
        const nextVersion = existing.length > 0 ? existing[0].version + 1 : 1;
        const newRecord = {
          ...record,
          version: nextVersion
        };
        if (record.promoteAsCurrent) {
          await db.update(goldenRecords).set({ isCurrent: false }).where(
            and9(
              eq11(goldenRecords.journeyType, record.journeyType),
              eq11(goldenRecords.isCurrent, true)
            )
          );
          newRecord.isCurrent = true;
          delete newRecord.promoteAsCurrent;
        }
        const [created] = await db.insert(goldenRecords).values(newRecord).returning();
        return created;
      }
      async listGoldenRecords(journeyType, includeHistory) {
        let query = db.select().from(goldenRecords);
        if (journeyType) {
          query = query.where(eq11(goldenRecords.journeyType, journeyType));
        }
        if (!includeHistory) {
          query = query.where(eq11(goldenRecords.isCurrent, true));
        }
        const records = await query.orderBy(desc6(goldenRecords.createdAt));
        return records;
      }
      async getGoldenRecord(journeyType, version) {
        const [record] = await db.select().from(goldenRecords).where(
          and9(
            eq11(goldenRecords.journeyType, journeyType),
            eq11(goldenRecords.version, version)
          )
        );
        return record || void 0;
      }
      async getCurrentGoldenRecord(journeyType) {
        const [record] = await db.select().from(goldenRecords).where(
          and9(
            eq11(goldenRecords.journeyType, journeyType),
            eq11(goldenRecords.isCurrent, true)
          )
        );
        return record || void 0;
      }
      async promoteGoldenRecord(journeyType, version) {
        await db.update(goldenRecords).set({ isCurrent: false }).where(eq11(goldenRecords.journeyType, journeyType));
        const [promoted] = await db.update(goldenRecords).set({ isCurrent: true }).where(
          and9(
            eq11(goldenRecords.journeyType, journeyType),
            eq11(goldenRecords.version, version)
          )
        ).returning();
        return promoted;
      }
      async compareGoldenRecords(journeyType, version1, version2) {
        const [record1, record2] = await Promise.all([
          this.getGoldenRecord(journeyType, version1),
          this.getGoldenRecord(journeyType, version2)
        ]);
        if (!record1 || !record2) {
          throw new Error("One or both golden records not found");
        }
        const stepDiffs = [];
        const steps1 = record1.steps || [];
        const steps2 = record2.steps || [];
        const maxSteps = Math.max(steps1.length, steps2.length);
        for (let i = 0; i < maxSteps; i++) {
          const step1 = steps1[i];
          const step2 = steps2[i];
          if (!step1) {
            stepDiffs.push({
              stepNumber: i + 1,
              changeType: "added",
              v1Step: null,
              v2Step: step2
            });
          } else if (!step2) {
            stepDiffs.push({
              stepNumber: i + 1,
              changeType: "removed",
              v1Step: step1,
              v2Step: null
            });
          } else if (JSON.stringify(step1) !== JSON.stringify(step2)) {
            const differences = [];
            if (step1.stepName !== step2.stepName) {
              differences.push({
                field: "stepName",
                v1Value: step1.stepName,
                v2Value: step2.stepName
              });
            }
            if (step1.expectedUrl !== step2.expectedUrl) {
              differences.push({
                field: "expectedUrl",
                v1Value: step1.expectedUrl,
                v2Value: step2.expectedUrl
              });
            }
            if (JSON.stringify(step1.requestPayload) !== JSON.stringify(step2.requestPayload)) {
              differences.push({
                field: "requestPayload",
                v1Value: step1.requestPayload,
                v2Value: step2.requestPayload
              });
            }
            if (JSON.stringify(step1.responsePayload) !== JSON.stringify(step2.responsePayload)) {
              differences.push({
                field: "responsePayload",
                v1Value: step1.responsePayload,
                v2Value: step2.responsePayload
              });
            }
            if (JSON.stringify(step1.dbSnapshot) !== JSON.stringify(step2.dbSnapshot)) {
              differences.push({
                field: "dbSnapshot",
                v1Value: step1.dbSnapshot,
                v2Value: step2.dbSnapshot
              });
            }
            if (step1.observations !== step2.observations) {
              differences.push({
                field: "observations",
                v1Value: step1.observations,
                v2Value: step2.observations
              });
            }
            stepDiffs.push({
              stepNumber: i + 1,
              changeType: "modified",
              v1Step: step1,
              v2Step: step2,
              differences
            });
          } else {
            stepDiffs.push({
              stepNumber: i + 1,
              changeType: "unchanged",
              v1Step: step1,
              v2Step: step2
            });
          }
        }
        return {
          journeyType,
          version1,
          version2,
          totalSteps1: steps1.length,
          totalSteps2: steps2.length,
          stepDiffs,
          summary: {
            totalSteps: maxSteps,
            added: stepDiffs.filter((d) => d.changeType === "added").length,
            removed: stepDiffs.filter((d) => d.changeType === "removed").length,
            modified: stepDiffs.filter((d) => d.changeType === "modified").length,
            unchanged: stepDiffs.filter((d) => d.changeType === "unchanged").length
          }
        };
      }
      async createGoldenRecordCheck(check) {
        const [created] = await db.insert(goldenRecordChecks).values(check).returning();
        return created;
      }
    };
    storage = new DatabaseStorage();
  }
});

// server/services/export/base-exporter.ts
import { eq as eq12, desc as desc7 } from "drizzle-orm";
function escapeCsvField(field) {
  if (field === null || field === void 0) {
    return "";
  }
  const str = field.toString();
  if (str.includes(",") || str.includes('"') || str.includes("\n")) {
    return `"${str.replace(/"/g, '""')}"`;
  }
  return str;
}
async function loadExportData(sessionId, versionNumber, programId, userId) {
  console.log("[Export Service] loadExportData - Loading strategic understanding for sessionId:", sessionId);
  const understanding = await getStrategicUnderstandingBySession(sessionId);
  console.log("[Export Service] loadExportData - Understanding loaded:", understanding ? "Yes" : "No");
  if (understanding?.userInput) {
    const isEncrypted2 = understanding.userInput.includes(":") && understanding.userInput.split(":").length === 3;
    console.log("[Export Service] userInput encryption status:", {
      isEncrypted: isEncrypted2,
      firstChars: understanding.userInput.substring(0, 50),
      length: understanding.userInput.length
    });
  }
  console.log("[Export Service] loadExportData - Loading journey session...");
  const [journeySession] = await db.select().from(journeySessions).where(eq12(journeySessions.understandingId, understanding?.id || sessionId)).limit(1);
  console.log("[Export Service] loadExportData - Journey session loaded:", journeySession ? "Yes" : "No");
  console.log("[Export Service] loadExportData - Loading strategy version. Requested version:", versionNumber);
  let strategyVersion;
  if (versionNumber !== void 0) {
    strategyVersion = await storage.getStrategyVersion(sessionId, versionNumber);
    console.log("[Export Service] loadExportData - Loaded specific version:", versionNumber);
  } else {
    const versions = await storage.getStrategyVersionsBySession(sessionId);
    strategyVersion = versions[0];
    console.log("[Export Service] loadExportData - Loaded latest version:", strategyVersion?.versionNumber);
  }
  let epmProgram;
  let assignments = [];
  if (programId) {
    [epmProgram] = await db.select().from(epmPrograms).where(eq12(epmPrograms.id, programId)).limit(1);
    if (epmProgram) {
      assignments = await db.select().from(taskAssignments).where(eq12(taskAssignments.epmProgramId, programId));
    }
  }
  if (assignments.length > 0) {
    assignments = assignments.map((a) => ({
      ...a,
      owner: a.owner || a.resourceName || a.resourceRole || null
    }));
  }
  console.log("[Export Service] loadExportData - Using canonical Five Whys from analysisData...");
  let fiveWhysTree;
  let whysPath = [];
  if (strategyVersion?.analysisData) {
    const analysisData = typeof strategyVersion.analysisData === "string" ? JSON.parse(strategyVersion.analysisData) : strategyVersion.analysisData;
    const fiveWhys = analysisData?.five_whys || analysisData?.fiveWhys;
    if (fiveWhys?.whysPath && Array.isArray(fiveWhys.whysPath)) {
      whysPath = normalizeWhysPathSteps(fiveWhys.whysPath);
      console.log("[Export Service] Five Whys path loaded from analysisData:", whysPath.length);
    } else {
      whysPath = [];
    }
    if (fiveWhys?.tree) {
      fiveWhysTree = fiveWhys.tree;
    } else if (whysPath.length > 0) {
      fiveWhysTree = buildLinearWhysTree(whysPath);
    }
  }
  console.log("[Export Service] loadExportData - Fetching clarifications from strategic understanding...");
  let clarifications;
  if (understanding) {
    const metadata = typeof understanding.strategyMetadata === "string" ? JSON.parse(understanding.strategyMetadata) : understanding.strategyMetadata;
    console.log("[Export Service] strategyMetadata keys:", metadata ? Object.keys(metadata) : "null");
    let questions = null;
    let answers = null;
    if (metadata?.clarificationQuestions) {
      questions = metadata.clarificationQuestions;
      console.log("[Export Service] Found clarificationQuestions in metadata");
    }
    if (!questions && metadata?.clarificationContext?.questions) {
      questions = metadata.clarificationContext.questions;
      console.log("[Export Service] Found clarificationContext.questions in metadata");
    }
    if (!questions && metadata?.questions) {
      questions = metadata.questions;
      console.log("[Export Service] Found questions in metadata");
    }
    if (metadata?.clarificationsProvided) {
      answers = metadata.clarificationsProvided;
      console.log("[Export Service] Found clarificationsProvided");
    } else if (metadata?.clarificationContext?.answers) {
      answers = metadata.clarificationContext.answers;
      console.log("[Export Service] Found clarificationContext.answers");
    } else if (metadata?.answers) {
      answers = metadata.answers;
      console.log("[Export Service] Found answers");
    }
    if (questions && answers) {
      clarifications = {
        questions: Array.isArray(questions) ? questions : [],
        answers: typeof answers === "object" ? answers : {}
      };
      console.log("[Export Service] Clarifications loaded:", clarifications.questions?.length || 0, "questions");
    } else {
      console.log("[Export Service] No clarifications found. Questions:", !!questions, "Answers:", !!answers);
    }
  }
  console.log("[Export Service] loadExportData - Fetching strategic decisions...");
  let decisions = [];
  if (strategyVersion?.id) {
    const decisionRows = await db.select().from(strategyDecisions).where(eq12(strategyDecisions.strategyVersionId, strategyVersion.id)).orderBy(desc7(strategyDecisions.createdAt));
    decisions = decisionRows.map((d) => ({
      id: d.id,
      primaryCustomerSegment: d.primaryCustomerSegment,
      revenueModel: d.revenueModel,
      channelPriorities: d.channelPriorities,
      partnershipStrategy: d.partnershipStrategy,
      riskTolerance: d.riskTolerance,
      investmentCapacityMin: d.investmentCapacityMin,
      investmentCapacityMax: d.investmentCapacityMax,
      timelinePreference: d.timelinePreference,
      successMetricsPriority: d.successMetricsPriority,
      validatedAssumptions: d.validatedAssumptions,
      concerns: d.concerns,
      topPriorities: d.topPriorities,
      goDecision: d.goDecision,
      decisionRationale: d.decisionRationale,
      createdAt: d.createdAt
    }));
    console.log("[Export Service] Strategic decisions loaded:", decisions.length);
  }
  if (decisions.length === 0 && strategyVersion?.decisionsData) {
    const decisionsData = typeof strategyVersion.decisionsData === "string" ? JSON.parse(strategyVersion.decisionsData) : strategyVersion.decisionsData;
    const rawDecisions = Array.isArray(decisionsData?.decisions) ? decisionsData.decisions : [];
    if (rawDecisions.length > 0) {
      decisions = rawDecisions.map((d, idx) => {
        const recommended = Array.isArray(d.options) ? d.options.find((o) => o.recommended) : null;
        return {
          id: d.id || `decision_${idx + 1}`,
          type: d.title || d.question || "Decision",
          value: recommended?.label || d.options && d.options[0]?.label || d.title || "Not specified",
          rationale: recommended?.reasoning || d.context || "",
          options: d.options || [],
          question: d.question || ""
        };
      });
      console.log("[Export Service] Strategic decisions loaded from decisionsData:", decisions.length);
    }
  }
  return {
    metadata: {
      exportedAt: (/* @__PURE__ */ new Date()).toISOString(),
      sessionId,
      versionNumber: versionNumber ?? strategyVersion?.versionNumber,
      programId,
      exportedBy: userId
    },
    strategy: {
      understanding,
      journeySession,
      strategyVersion,
      decisions,
      fiveWhysTree,
      whysPath,
      clarifications
    },
    epm: epmProgram ? {
      program: epmProgram,
      assignments
    } : void 0
  };
}
var BaseExporter;
var init_base_exporter = __esm({
  "server/services/export/base-exporter.ts"() {
    "use strict";
    init_secure_data_service();
    init_db();
    init_storage();
    init_schema();
    init_whys_path();
    BaseExporter = class {
      isAvailable() {
        return true;
      }
      parseField(field) {
        if (!field) return null;
        if (typeof field === "object") return field;
        try {
          return JSON.parse(field);
        } catch (err) {
          console.warn("[Export] Failed to parse JSONB field:", err);
          return null;
        }
      }
    };
  }
});

// server/services/export/insights.ts
var BLOCK_TYPE_MAP, normalizeKey, buildBmcBlocksFromList, deriveInsights;
var init_insights = __esm({
  "server/services/export/insights.ts"() {
    "use strict";
    init_whys_path();
    BLOCK_TYPE_MAP = {
      customer_segments: "customerSegments",
      value_propositions: "valuePropositions",
      channels: "channels",
      customer_relationships: "customerRelationships",
      revenue_streams: "revenueStreams",
      key_resources: "keyResources",
      key_activities: "keyActivities",
      key_partners: "keyPartnerships",
      key_partnerships: "keyPartnerships",
      cost_structure: "costStructure"
    };
    normalizeKey = (value) => (value || "").toLowerCase().replace(/\s+/g, "_").replace(/[^a-z0-9_]/g, "");
    buildBmcBlocksFromList = (blocks) => {
      const output = {};
      blocks.forEach((block) => {
        const typeKey = BLOCK_TYPE_MAP[normalizeKey(block.blockType)] || BLOCK_TYPE_MAP[normalizeKey(block.blockName)];
        if (!typeKey) return;
        const items = [];
        if (block.description) items.push(block.description);
        if (Array.isArray(block.findings)) {
          block.findings.slice(0, 4).forEach((f) => {
            if (typeof f === "string") items.push(f);
            else if (f.fact) items.push(f.fact);
          });
        }
        if (block.strategicImplications) items.push(block.strategicImplications);
        if (items.length > 0) {
          output[typeKey] = items;
        }
      });
      return output;
    };
    deriveInsights = (pkg, parseField2) => {
      const insights = {};
      const j = pkg.strategy.journeySession;
      if (j?.accumulatedContext) {
        const context = parseField2(j.accumulatedContext);
        if (context?.insights && typeof context.insights === "object") {
          Object.assign(insights, context.insights);
        }
      }
      const sv = pkg.strategy.strategyVersion;
      const analysisData = sv ? parseField2(sv.analysisData) : null;
      const five = analysisData?.five_whys || analysisData?.fiveWhys;
      if (five) {
        if (!insights.whysPath && Array.isArray(five.whysPath)) {
          insights.whysPath = normalizeWhysPathSteps(five.whysPath);
        }
        if (!insights.rootCauses) {
          const root = five.root_cause || five.rootCause || "";
          if (root) insights.rootCauses = [root];
        }
        if (!insights.strategicImplications && Array.isArray(five.strategic_implications)) {
          insights.strategicImplications = five.strategic_implications;
        }
      }
      const bmc = analysisData?.bmc;
      if (!insights.bmcBlocks && bmc) {
        if (Array.isArray(bmc.blocks)) {
          const blocks = buildBmcBlocksFromList(bmc.blocks);
          if (Object.keys(blocks).length > 0) insights.bmcBlocks = blocks;
        } else if (bmc.blocks && typeof bmc.blocks === "object") {
          insights.bmcBlocks = bmc.blocks;
        } else if (bmc.customerSegments || bmc.valuePropositions) {
          insights.bmcBlocks = bmc;
        }
        if (!insights.bmcContradictions && Array.isArray(bmc.contradictions)) {
          insights.bmcContradictions = bmc.contradictions;
        }
        if (!insights.businessModelGaps && Array.isArray(bmc.criticalGaps)) {
          insights.businessModelGaps = bmc.criticalGaps;
        }
      }
      return insights;
    };
  }
});

// server/services/export/markdown-exporter.ts
import { format } from "date-fns";
function generateFiveWhysTreeMarkdown(tree, whysPath) {
  if (!tree) return "";
  const lines = [];
  lines.push("## Five Whys - Complete Analysis Tree\n");
  lines.push(`**Root Question:** ${tree.rootQuestion}
`);
  lines.push(`**Maximum Depth:** ${tree.maxDepth} levels
`);
  const isNodeInPath = (nodeOption, nodeQuestion) => {
    if (!whysPath || whysPath.length === 0) return false;
    return whysPath.some((pathStep) => {
      if (typeof pathStep === "string") {
        return pathStep === nodeOption || pathStep === nodeQuestion;
      } else if (pathStep && typeof pathStep === "object") {
        const stepText = pathStep.option || pathStep.question || pathStep.why || pathStep.answer || "";
        return stepText === nodeOption || stepText === nodeQuestion;
      }
      return false;
    });
  };
  const renderNode = (node, level) => {
    const indent = "  ".repeat(level);
    const isChosen = isNodeInPath(node.option, node.question);
    const chosenMarker = isChosen ? " \u2713 (Chosen path)" : "";
    lines.push(`${indent}${level + 1}. **${node.option}**${chosenMarker}`);
    if (node.supporting_evidence && node.supporting_evidence.length > 0) {
      lines.push(`${indent}   - **Supporting Evidence:**`);
      node.supporting_evidence.forEach((evidence) => {
        lines.push(`${indent}     - ${evidence}`);
      });
    }
    if (node.counter_arguments && node.counter_arguments.length > 0) {
      lines.push(`${indent}   - **Counter Arguments:**`);
      node.counter_arguments.forEach((counter) => {
        lines.push(`${indent}     - ${counter}`);
      });
    }
    if (node.consideration) {
      lines.push(`${indent}   - **Consideration:** ${node.consideration}`);
    }
    if (node.question && node.branches && node.branches.length > 0) {
      lines.push(`${indent}   - **Next Question:** ${node.question}
`);
    }
    lines.push("");
  };
  if (tree.branches && tree.branches.length > 0) {
    lines.push("### Level 1 Options:\n");
    tree.branches.forEach((branch) => {
      renderNode(branch, 0);
      if (branch.branches && branch.branches.length > 0) {
        lines.push(`### Level 2 Options (from "${branch.option}"):
`);
        branch.branches.forEach((subBranch) => {
          renderNode(subBranch, 1);
          if (subBranch.branches && subBranch.branches.length > 0) {
            lines.push(`### Level 3 Options (from "${subBranch.option}"):
`);
            subBranch.branches.forEach((subSubBranch) => {
              renderNode(subSubBranch, 2);
              if (subSubBranch.branches && subSubBranch.branches.length > 0) {
                lines.push(`### Level 4 Options (from "${subSubBranch.option}"):
`);
                subSubBranch.branches.forEach((level4) => {
                  renderNode(level4, 3);
                  if (level4.branches && level4.branches.length > 0) {
                    lines.push(`### Level 5 Options (from "${level4.option}"):
`);
                    level4.branches.forEach((level5) => {
                      renderNode(level5, 4);
                    });
                  }
                });
              }
            });
          }
        });
      }
    });
  }
  lines.push("\n---\n");
  return lines.join("\n");
}
function generateClarificationsMarkdown(clarifications) {
  if (!clarifications || !clarifications.questions || clarifications.questions.length === 0) {
    return "";
  }
  const lines = [];
  lines.push("## Strategic Input Clarifications\n");
  lines.push("During initial analysis, you provided the following clarifications:\n");
  clarifications.questions.forEach((q) => {
    lines.push(`**${q.question}**
`);
    if (q.options && Array.isArray(q.options)) {
      q.options.forEach((option) => {
        const isChosen = clarifications.answers && clarifications.answers[q.id] === option.value;
        const chosenMarker = isChosen ? " \u2713 (You chose this)" : "";
        lines.push(`- **${option.label}**${chosenMarker}`);
        if (option.description) {
          lines.push(`  - ${option.description}`);
        }
      });
    }
    lines.push("");
  });
  lines.push("\n---\n");
  return lines.join("\n");
}
function generateMarkdownReport(pkg) {
  const lines = [];
  const parseField2 = (field) => {
    if (!field) return null;
    if (typeof field === "object") return field;
    try {
      return JSON.parse(field);
    } catch (err) {
      console.warn("[Export] Failed to parse JSONB field:", err);
      return null;
    }
  };
  lines.push("# Premisia Strategic Analysis & EPM Program Report\n");
  lines.push(`**Generated:** ${format(new Date(pkg.metadata.exportedAt), "PPpp")}
`);
  lines.push(`**Session ID:** ${pkg.metadata.sessionId}`);
  if (pkg.metadata.versionNumber) {
    lines.push(`**Version:** ${pkg.metadata.versionNumber}`);
  }
  lines.push("\n---\n");
  if (pkg.strategy.understanding) {
    const u = pkg.strategy.understanding;
    lines.push("## Strategic Understanding\n");
    lines.push(`**Title:** ${u.title || "Untitled Initiative"}
`);
    lines.push(`**Initiative Type:** ${u.initiativeType || "Not classified"}
`);
    if (u.classificationConfidence) {
      lines.push(`**Classification Confidence:** ${(parseFloat(u.classificationConfidence) * 100).toFixed(0)}%
`);
    }
    if (u.initiativeDescription) {
      lines.push(`
**Description:**
${u.initiativeDescription}
`);
    }
    if (u.userInput) {
      lines.push(`
**Original User Input:**
${u.userInput}
`);
    }
    lines.push("\n---\n");
  }
  if (pkg.strategy.clarifications) {
    const clarificationsMarkdown = generateClarificationsMarkdown(pkg.strategy.clarifications);
    if (clarificationsMarkdown) {
      lines.push(clarificationsMarkdown);
    }
  }
  if (pkg.strategy.journeySession) {
    const j = pkg.strategy.journeySession;
    lines.push("## Strategic Journey\n");
    lines.push(`**Journey Type:** ${j.journeyType || "Custom"}
`);
    lines.push(`**Status:** ${j.status}
`);
    if (j.completedFrameworks && j.completedFrameworks.length > 0) {
      lines.push(`
**Completed Frameworks:**
`);
      j.completedFrameworks.forEach((fw) => lines.push(`- ${fw}`));
      lines.push("");
    }
    lines.push("\n---\n");
    const insights = deriveInsights(pkg, parseField2);
    if (pkg.strategy.fiveWhysTree) {
      const treeMarkdown = generateFiveWhysTreeMarkdown(pkg.strategy.fiveWhysTree, pkg.strategy.whysPath);
      if (treeMarkdown) {
        lines.push(treeMarkdown);
      }
    }
    if (insights.rootCauses || insights.whysPath || insights.strategicImplications) {
      lines.push("## Five Whys - Chosen Path Summary\n");
      if (insights.whysPath && insights.whysPath.length > 0) {
        lines.push("\n**Analysis Path (Chosen):**\n");
        insights.whysPath.forEach((step, idx) => {
          if (typeof step === "string") {
            lines.push(`${idx + 1}. ${step}`);
          } else {
            lines.push(`${idx + 1}. **Why?** ${step.question || step.why || step}`);
            if (step.answer) {
              lines.push(`   **Answer:** ${step.answer}
`);
            }
          }
        });
        lines.push("");
      }
      if (insights.rootCauses && insights.rootCauses.length > 0) {
        lines.push("\n**Identified Root Causes:**\n");
        insights.rootCauses.forEach((cause) => {
          lines.push(`- ${cause}`);
        });
        lines.push("");
      }
      if (insights.strategicImplications && insights.strategicImplications.length > 0) {
        lines.push("\n**Strategic Implications:**\n");
        insights.strategicImplications.forEach((imp) => {
          lines.push(`- ${imp}`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (insights.bmcBlocks) {
      const bmc = insights.bmcBlocks;
      lines.push("## Business Model Canvas Analysis\n");
      if (bmc.customerSegments) {
        lines.push("\n### Customer Segments\n");
        if (typeof bmc.customerSegments === "string") {
          lines.push(`${bmc.customerSegments}
`);
        } else if (Array.isArray(bmc.customerSegments)) {
          bmc.customerSegments.forEach((seg) => lines.push(`- ${seg}`));
          lines.push("");
        } else if (bmc.customerSegments.segments) {
          bmc.customerSegments.segments.forEach((seg) => {
            lines.push(`- **${seg.name || "Segment"}:** ${seg.description || ""}`);
          });
          lines.push("");
        }
      }
      if (bmc.valuePropositions) {
        lines.push("\n### Value Propositions\n");
        if (typeof bmc.valuePropositions === "string") {
          lines.push(`${bmc.valuePropositions}
`);
        } else if (Array.isArray(bmc.valuePropositions)) {
          bmc.valuePropositions.forEach((vp) => lines.push(`- ${vp}`));
          lines.push("");
        } else if (bmc.valuePropositions.propositions) {
          bmc.valuePropositions.propositions.forEach((vp) => {
            lines.push(`- **${vp.title || "Value Proposition"}:** ${vp.description || ""}`);
          });
          lines.push("");
        }
      }
      if (bmc.channels) {
        lines.push("\n### Channels\n");
        if (typeof bmc.channels === "string") {
          lines.push(`${bmc.channels}
`);
        } else if (Array.isArray(bmc.channels)) {
          bmc.channels.forEach((ch) => lines.push(`- ${ch}`));
          lines.push("");
        } else if (bmc.channels.channels) {
          bmc.channels.channels.forEach((ch) => {
            lines.push(`- **${ch.name || "Channel"}:** ${ch.description || ""}`);
          });
          lines.push("");
        }
      }
      if (bmc.customerRelationships) {
        lines.push("\n### Customer Relationships\n");
        if (typeof bmc.customerRelationships === "string") {
          lines.push(`${bmc.customerRelationships}
`);
        } else if (Array.isArray(bmc.customerRelationships)) {
          bmc.customerRelationships.forEach((rel) => lines.push(`- ${rel}`));
          lines.push("");
        } else if (bmc.customerRelationships.relationships) {
          bmc.customerRelationships.relationships.forEach((rel) => {
            lines.push(`- **${rel.type || "Relationship"}:** ${rel.description || ""}`);
          });
          lines.push("");
        }
      }
      if (bmc.revenueStreams) {
        lines.push("\n### Revenue Streams\n");
        if (typeof bmc.revenueStreams === "string") {
          lines.push(`${bmc.revenueStreams}
`);
        } else if (Array.isArray(bmc.revenueStreams)) {
          bmc.revenueStreams.forEach((rev) => lines.push(`- ${rev}`));
          lines.push("");
        } else if (bmc.revenueStreams.streams) {
          bmc.revenueStreams.streams.forEach((rev) => {
            lines.push(`- **${rev.name || "Revenue Stream"}:** ${rev.description || ""}`);
            if (rev.pricingModel) {
              lines.push(`  - *Pricing Model:* ${rev.pricingModel}`);
            }
          });
          lines.push("");
        }
      }
      if (bmc.keyResources) {
        lines.push("\n### Key Resources\n");
        if (typeof bmc.keyResources === "string") {
          lines.push(`${bmc.keyResources}
`);
        } else if (Array.isArray(bmc.keyResources)) {
          bmc.keyResources.forEach((res) => lines.push(`- ${res}`));
          lines.push("");
        } else if (bmc.keyResources.resources) {
          bmc.keyResources.resources.forEach((res) => {
            lines.push(`- **${res.name || "Resource"}:** ${res.description || ""}`);
          });
          lines.push("");
        }
      }
      if (bmc.keyActivities) {
        lines.push("\n### Key Activities\n");
        if (typeof bmc.keyActivities === "string") {
          lines.push(`${bmc.keyActivities}
`);
        } else if (Array.isArray(bmc.keyActivities)) {
          bmc.keyActivities.forEach((act) => lines.push(`- ${act}`));
          lines.push("");
        } else if (bmc.keyActivities.activities) {
          bmc.keyActivities.activities.forEach((act) => {
            lines.push(`- **${act.name || "Activity"}:** ${act.description || ""}`);
          });
          lines.push("");
        }
      }
      if (bmc.keyPartnerships) {
        lines.push("\n### Key Partnerships\n");
        if (typeof bmc.keyPartnerships === "string") {
          lines.push(`${bmc.keyPartnerships}
`);
        } else if (Array.isArray(bmc.keyPartnerships)) {
          bmc.keyPartnerships.forEach((part) => lines.push(`- ${part}`));
          lines.push("");
        } else if (bmc.keyPartnerships.partnerships) {
          bmc.keyPartnerships.partnerships.forEach((part) => {
            lines.push(`- **${part.partner || "Partner"}:** ${part.description || ""}`);
          });
          lines.push("");
        }
      }
      if (bmc.costStructure) {
        lines.push("\n### Cost Structure\n");
        if (typeof bmc.costStructure === "string") {
          lines.push(`${bmc.costStructure}
`);
        } else if (Array.isArray(bmc.costStructure)) {
          bmc.costStructure.forEach((cost) => lines.push(`- ${cost}`));
          lines.push("");
        } else if (bmc.costStructure.costs) {
          bmc.costStructure.costs.forEach((cost) => {
            lines.push(`- **${cost.category || "Cost"}:** ${cost.description || ""}`);
          });
          lines.push("");
        }
      }
      if (insights.bmcContradictions && insights.bmcContradictions.length > 0) {
        lines.push("\n### Identified Contradictions\n");
        insights.bmcContradictions.forEach((cont) => {
          if (typeof cont === "string") {
            lines.push(`- ${cont}`);
          } else {
            lines.push(`- **${cont.title || "Contradiction"}:** ${cont.description || cont.issue || ""}`);
            if (cont.recommendation) {
              lines.push(`  - *Recommendation:* ${cont.recommendation}`);
            }
          }
        });
        lines.push("");
      }
      if (insights.businessModelGaps && insights.businessModelGaps.length > 0) {
        lines.push("\n### Critical Gaps\n");
        insights.businessModelGaps.forEach((gap) => {
          if (typeof gap === "string") {
            lines.push(`- ${gap}`);
          } else {
            lines.push(`- **${gap.area || "Gap"}:** ${gap.description || ""}`);
            if (gap.impact) {
              lines.push(`  - *Impact:* ${gap.impact}`);
            }
          }
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (insights.portersForces) {
      const forces = insights.portersForces;
      lines.push("## Porter's Five Forces Analysis\n");
      const renderForce = (title, force) => {
        if (!force) return;
        lines.push(`
### ${title}
`);
        if (typeof force === "string") {
          lines.push(`${force}
`);
        } else {
          if (force.intensity) lines.push(`**Intensity:** ${force.intensity}
`);
          if (force.level) lines.push(`**Level:** ${force.level}
`);
          if (force.power) lines.push(`**Power:** ${force.power}
`);
          if (force.factors && Array.isArray(force.factors)) {
            lines.push("\n**Key Factors:**");
            force.factors.forEach((f) => lines.push(`- ${f}`));
            lines.push("");
          }
          if (force.barriers && Array.isArray(force.barriers)) {
            lines.push("\n**Entry Barriers:**");
            force.barriers.forEach((b) => lines.push(`- ${b}`));
            lines.push("");
          }
          if (force.substitutes && Array.isArray(force.substitutes)) {
            lines.push("\n**Substitutes:**");
            force.substitutes.forEach((s) => lines.push(`- ${s}`));
            lines.push("");
          }
        }
      };
      renderForce("Competitive Rivalry", forces.competitiveRivalry || forces.competitive_rivalry);
      renderForce("Threat of New Entrants", forces.threatOfNewEntrants || forces.threat_of_new_entrants);
      renderForce("Bargaining Power of Suppliers", forces.bargainingPowerOfSuppliers || forces.supplier_power);
      renderForce("Bargaining Power of Buyers", forces.bargainingPowerOfBuyers || forces.buyer_power);
      renderForce("Threat of Substitutes", forces.threatOfSubstitutes || forces.threat_of_substitutes);
      lines.push("---\n");
    }
    if (insights.trendFactors || insights.externalForces) {
      lines.push("## PESTLE Analysis\n");
      const factors = insights.trendFactors ?? insights.externalForces ?? {};
      ["political", "economic", "social", "technological", "legal", "environmental"].forEach((category) => {
        if (factors[category]) {
          lines.push(`
### ${category.charAt(0).toUpperCase() + category.slice(1)} Factors
`);
          const catData = factors[category];
          if (typeof catData === "string") {
            lines.push(`${catData}
`);
          } else if (Array.isArray(catData)) {
            catData.forEach((item) => lines.push(`- ${item}`));
            lines.push("");
          } else {
            if (catData.trends && Array.isArray(catData.trends)) {
              lines.push("**Trends:**\n");
              catData.trends.forEach((t) => lines.push(`- ${t}`));
              lines.push("");
            }
            if (catData.opportunities && Array.isArray(catData.opportunities)) {
              lines.push("**Opportunities:**\n");
              catData.opportunities.forEach((o) => lines.push(`- ${o}`));
              lines.push("");
            }
            if (catData.risks && Array.isArray(catData.risks)) {
              lines.push("**Risks:**\n");
              catData.risks.forEach((r) => lines.push(`- ${r}`));
              lines.push("");
            }
          }
        }
      });
      lines.push("---\n");
    }
  }
  if (pkg.strategy.strategyVersion) {
    const sv = pkg.strategy.strategyVersion;
    lines.push("## Strategic Decisions\n");
    if (sv.versionLabel) {
      lines.push(`**Version:** ${sv.versionLabel}
`);
    }
    if (sv.inputSummary) {
      lines.push(`
**Summary:**
${sv.inputSummary}
`);
    }
    if (pkg.strategy.decisions && pkg.strategy.decisions.length > 0) {
      lines.push("\n### Selected Decisions\n");
      pkg.strategy.decisions.forEach((decision, idx) => {
        const decType = decision.type || decision.category || "Decision";
        const decValue = decision.value || decision.description || decision.choice || "Not specified";
        lines.push(`${idx + 1}. **${decType}:** ${decValue}`);
        if (decision.rationale) {
          lines.push(`   - *Rationale:* ${decision.rationale}`);
        }
      });
      lines.push("");
    }
    lines.push("\n---\n");
  }
  if (pkg.epm?.program) {
    const program = pkg.epm.program;
    const execSummary = parseField2(program.executiveSummary);
    const workstreams2 = parseField2(program.workstreams);
    const timeline = parseField2(program.timeline);
    const resourcePlan = parseField2(program.resourcePlan);
    const financialPlan = parseField2(program.financialPlan);
    const benefits2 = parseField2(program.benefitsRealization);
    const risks2 = parseField2(program.riskRegister);
    const stageGates2 = parseField2(program.stageGates);
    const kpis2 = parseField2(program.kpis);
    const stakeholders = parseField2(program.stakeholderMap);
    const governance = parseField2(program.governance);
    const qaPlan = parseField2(program.qaPlan);
    const procurement = parseField2(program.procurement);
    const exitStrategy = parseField2(program.exitStrategy);
    lines.push("# Enterprise Program Management (EPM) Program\n");
    lines.push(`**Framework:** ${program.frameworkType || "Not specified"}
`);
    lines.push(`**Status:** ${program.status}
`);
    const confidenceValue = program.overallConfidence ? parseFloat(program.overallConfidence) : null;
    const confidenceText = confidenceValue !== null && !isNaN(confidenceValue) ? `${(confidenceValue * 100).toFixed(1)}%` : "Not calculated";
    lines.push(`**Overall Confidence:** ${confidenceText}
`);
    lines.push("\n---\n");
    if (execSummary) {
      lines.push("## 1. Executive Summary\n");
      if (execSummary.title) {
        lines.push(`**Program Title:** ${execSummary.title}
`);
      }
      if (execSummary.overview || execSummary.summary) {
        lines.push(`
${execSummary.overview || execSummary.summary}
`);
      }
      if (execSummary.objectives && execSummary.objectives.length > 0) {
        lines.push("\n**Strategic Objectives:**\n");
        execSummary.objectives.forEach((obj, idx) => {
          lines.push(`${idx + 1}. ${obj}`);
        });
        lines.push("");
      }
      if (execSummary.scope) {
        lines.push(`
**Scope:** ${execSummary.scope}
`);
      }
      if (execSummary.successCriteria && execSummary.successCriteria.length > 0) {
        lines.push("\n**Success Criteria:**\n");
        execSummary.successCriteria.forEach((criteria) => {
          lines.push(`- ${criteria}`);
        });
        lines.push("");
      }
      lines.push("\n---\n");
    }
    if (workstreams2 && workstreams2.length > 0) {
      lines.push("## 2. Workstreams\n");
      workstreams2.forEach((ws2, idx) => {
        lines.push(`### ${idx + 1}. ${ws2.name || `Workstream ${idx + 1}`}
`);
        if (ws2.description) {
          lines.push(`${ws2.description}
`);
        }
        if (ws2.owner) {
          lines.push(`**Owner:** ${ws2.owner}`);
        }
        if (ws2.startMonth !== void 0 && ws2.endMonth !== void 0) {
          lines.push(`**Duration:** Month ${ws2.startMonth} to Month ${ws2.endMonth}`);
        }
        if (ws2.dependencies && ws2.dependencies.length > 0) {
          lines.push(`**Dependencies:** ${ws2.dependencies.join(", ")}`);
        }
        if (ws2.deliverables && ws2.deliverables.length > 0) {
          lines.push("\n**Key Deliverables:**");
          ws2.deliverables.forEach((d) => {
            const delName = typeof d === "string" ? d : d.name || d.title || "Deliverable";
            lines.push(`- ${delName}`);
          });
        }
        if (ws2.tasks && ws2.tasks.length > 0) {
          lines.push(`
**Tasks:** ${ws2.tasks.length} tasks defined`);
        }
        lines.push("");
      });
      lines.push("---\n");
    }
    if (timeline) {
      lines.push("## 3. Timeline & Critical Path\n");
      if (timeline.totalDuration) {
        lines.push(`**Total Program Duration:** ${timeline.totalDuration} months
`);
      }
      if (timeline.phases && timeline.phases.length > 0) {
        lines.push("\n**Program Phases:**\n");
        timeline.phases.forEach((phase) => {
          lines.push(`- **${phase.name}:** Month ${phase.startMonth} to Month ${phase.endMonth}`);
          if (phase.milestones && phase.milestones.length > 0) {
            lines.push(`  - Milestones: ${phase.milestones.join(", ")}`);
          }
        });
        lines.push("");
      }
      if (timeline.criticalPath && timeline.criticalPath.length > 0) {
        lines.push("\n**Critical Path:**\n");
        timeline.criticalPath.forEach((item) => {
          lines.push(`- ${item}`);
        });
        lines.push("");
      }
      if (timeline.milestones && timeline.milestones.length > 0) {
        lines.push("\n**Key Milestones:**\n");
        timeline.milestones.forEach((m) => {
          const mName = typeof m === "string" ? m : m.name || m.title;
          const mDate = m.date || m.month ? ` (${m.date || `Month ${m.month}`})` : "";
          lines.push(`- ${mName}${mDate}`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (resourcePlan) {
      lines.push("## 4. Resource Plan\n");
      if (resourcePlan.internalTeam && resourcePlan.internalTeam.length > 0) {
        lines.push("\n### Internal Team\n");
        lines.push("| Role | FTE | Responsibilities |");
        lines.push("|------|-----|------------------|");
        resourcePlan.internalTeam.forEach((r) => {
          const role = r.role || r.title || "Not specified";
          const fte = r.fte || r.allocation || "TBD";
          const resp = r.responsibilities || r.description || "-";
          lines.push(`| ${role} | ${fte} | ${resp} |`);
        });
        lines.push("");
      }
      if (resourcePlan.externalResources && resourcePlan.externalResources.length > 0) {
        lines.push("\n### External Resources\n");
        lines.push("| Type | Quantity | Skills Required |");
        lines.push("|------|----------|-----------------|");
        resourcePlan.externalResources.forEach((r) => {
          const type = r.type || r.role || "Contractor";
          const qty = r.quantity || r.count || "1";
          const skills = r.skills || r.requirements || "-";
          lines.push(`| ${type} | ${qty} | ${skills} |`);
        });
        lines.push("");
      }
      if (resourcePlan.totalFTE) {
        lines.push(`
**Total FTE Required:** ${resourcePlan.totalFTE}
`);
      }
      lines.push("---\n");
    }
    if (financialPlan) {
      lines.push("## 5. Financial Plan\n");
      if (financialPlan.totalBudget) {
        const budget = typeof financialPlan.totalBudget === "number" ? `$${financialPlan.totalBudget.toLocaleString()}` : financialPlan.totalBudget;
        lines.push(`**Total Program Budget:** ${budget}
`);
      }
      if (financialPlan.costBreakdown && financialPlan.costBreakdown.length > 0) {
        lines.push("\n### Cost Breakdown\n");
        lines.push("| Category | Amount | Percentage |");
        lines.push("|----------|--------|------------|");
        financialPlan.costBreakdown.forEach((item) => {
          const category = item.category || item.name || "Other";
          const amount = typeof item.amount === "number" ? `$${item.amount.toLocaleString()}` : item.amount;
          const pct = item.percentage || "-";
          lines.push(`| ${category} | ${amount} | ${pct} |`);
        });
        lines.push("");
      }
      if (financialPlan.cashFlow && financialPlan.cashFlow.length > 0) {
        lines.push("\n### Cash Flow Projection\n");
        financialPlan.cashFlow.forEach((cf) => {
          lines.push(`- **${cf.period || `Period ${cf.month || cf.quarter}`}:** $${cf.amount?.toLocaleString() || "0"}`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (benefits2) {
      lines.push("## 6. Benefits Realization\n");
      if (benefits2.benefits && benefits2.benefits.length > 0) {
        lines.push("\n### Expected Benefits\n");
        benefits2.benefits.forEach((b, idx) => {
          const benefitName = b.name || b.benefit || b.description || b.category || "Benefit";
          lines.push(`${idx + 1}. **${benefitName}**`);
          if (b.description && b.description !== benefitName) lines.push(`   - ${b.description}`);
          if (b.metric) lines.push(`   - **Metric:** ${b.metric}`);
          if (b.target) lines.push(`   - **Target:** ${b.target}`);
          if (b.timeframe) lines.push(`   - **Timeframe:** ${b.timeframe}`);
        });
        lines.push("");
      }
      if (benefits2.realizationPlan) {
        lines.push(`
**Realization Plan:** ${benefits2.realizationPlan}
`);
      }
      lines.push("---\n");
    }
    if (risks2) {
      lines.push("## 7. Risk Register\n");
      const riskArray = risks2.risks || risks2;
      if (Array.isArray(riskArray) && riskArray.length > 0) {
        lines.push("| Risk | Probability | Impact | Mitigation |");
        lines.push("|------|-------------|--------|------------|");
        riskArray.forEach((r) => {
          const name = r.risk || r.name || r.description || "Unnamed risk";
          const prob = r.probability || r.likelihood || "-";
          const impact = r.impact || r.severity || "-";
          const mit = r.mitigation || r.response || "-";
          lines.push(`| ${name} | ${prob} | ${impact} | ${mit} |`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (stageGates2) {
      lines.push("## 8. Stage Gates & Milestones\n");
      const gates = stageGates2.gates || stageGates2;
      if (Array.isArray(gates) && gates.length > 0) {
        gates.forEach((gate, idx) => {
          lines.push(`### Gate ${idx + 1}: ${gate.name || gate.title}
`);
          if (gate.timing) lines.push(`**Timing:** ${gate.timing}`);
          if (gate.criteria && gate.criteria.length > 0) {
            lines.push("\n**Approval Criteria:**");
            gate.criteria.forEach((c) => lines.push(`- ${c}`));
          }
          if (gate.deliverables && gate.deliverables.length > 0) {
            lines.push("\n**Required Deliverables:**");
            gate.deliverables.forEach((d) => lines.push(`- ${d}`));
          }
          lines.push("");
        });
      }
      lines.push("---\n");
    }
    if (kpis2) {
      lines.push("## 9. Key Performance Indicators (KPIs)\n");
      const kpiArray = kpis2.kpis || kpis2.metrics || kpis2;
      if (Array.isArray(kpiArray) && kpiArray.length > 0) {
        lines.push("| KPI | Target | Measurement Frequency |");
        lines.push("|-----|--------|----------------------|");
        kpiArray.forEach((kpi) => {
          const name = kpi.name || kpi.metric || kpi.kpi || "KPI";
          const target = kpi.target || kpi.goal || "-";
          const freq = kpi.frequency || kpi.measurementFrequency || "Monthly";
          lines.push(`| ${name} | ${target} | ${freq} |`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (stakeholders) {
      lines.push("## 10. Stakeholder Map\n");
      const stakeholderArray = stakeholders.stakeholders || stakeholders;
      if (Array.isArray(stakeholderArray) && stakeholderArray.length > 0) {
        lines.push("| Stakeholder | Role | Interest Level | Engagement Strategy |");
        lines.push("|-------------|------|----------------|---------------------|");
        stakeholderArray.forEach((s) => {
          const name = s.name || s.stakeholder || "Stakeholder";
          const role = s.role || s.position || "-";
          const interest = s.interest || s.interestLevel || "-";
          const strategy = s.engagement || s.strategy || "-";
          lines.push(`| ${name} | ${role} | ${interest} | ${strategy} |`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (governance) {
      lines.push("## 11. Governance Structure\n");
      if (governance.structure) lines.push(`**Governance Model:** ${governance.structure}
`);
      if (governance.decisionMaking) lines.push(`
**Decision-Making Framework:** ${governance.decisionMaking}
`);
      if (governance.roles && governance.roles.length > 0) {
        lines.push("\n**Key Governance Roles:**\n");
        governance.roles.forEach((r) => {
          const role = typeof r === "string" ? r : r.role || r.name;
          const resp = r.responsibilities || "";
          lines.push(`- **${role}**${resp ? `: ${resp}` : ""}`);
        });
        lines.push("");
      }
      if (governance.meetings) lines.push(`
**Meeting Cadence:** ${governance.meetings}
`);
      lines.push("---\n");
    }
    if (qaPlan) {
      lines.push("## 12. Quality Assurance Plan\n");
      if (qaPlan.approach) lines.push(`**QA Approach:** ${qaPlan.approach}
`);
      if (qaPlan.standards && qaPlan.standards.length > 0) {
        lines.push("\n**Quality Standards:**\n");
        qaPlan.standards.forEach((std) => {
          if (typeof std === "string") {
            lines.push(`- ${std}`);
          } else if (std && typeof std === "object") {
            const area = std.area || "General";
            const standard = std.standard || std.name || std.description || "Quality standard";
            lines.push(`- **${area}:** ${standard}`);
            if (std.acceptanceCriteria && Array.isArray(std.acceptanceCriteria)) {
              std.acceptanceCriteria.forEach((criteria) => {
                lines.push(`  - ${criteria}`);
              });
            }
          }
        });
        lines.push("");
      }
      if (qaPlan.reviews && qaPlan.reviews.length > 0) {
        lines.push("\n**Review Gates:**\n");
        qaPlan.reviews.forEach((rev) => {
          const name = typeof rev === "string" ? rev : rev.name || rev.type;
          lines.push(`- ${name}`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (procurement) {
      lines.push("## 13. Procurement Plan\n");
      if (procurement.strategy) lines.push(`**Procurement Strategy:** ${procurement.strategy}
`);
      const vendors = procurement.vendors || procurement.suppliers || [];
      if (vendors.length > 0) {
        lines.push("\n**Vendor Requirements:**\n");
        vendors.forEach((v) => {
          const name = typeof v === "string" ? v : v.name || v.vendor || v.type;
          const req = v.requirements || v.details || "";
          lines.push(`- **${name}**${req ? `: ${req}` : ""}`);
        });
        lines.push("");
      }
      lines.push("---\n");
    }
    if (exitStrategy) {
      lines.push("## 14. Exit Strategy\n");
      if (exitStrategy.approach) lines.push(`**Exit Approach:** ${exitStrategy.approach}
`);
      if (exitStrategy.criteria && exitStrategy.criteria.length > 0) {
        lines.push("\n**Exit Criteria:**\n");
        exitStrategy.criteria.forEach((c) => lines.push(`- ${c}`));
        lines.push("");
      }
      if (exitStrategy.transitionPlan) lines.push(`
**Transition Plan:** ${exitStrategy.transitionPlan}
`);
      lines.push("---\n");
    }
  }
  if (pkg.epm?.assignments && pkg.epm.assignments.length > 0) {
    lines.push("## Task Assignments Overview\n");
    lines.push(`**Total Assignments:** ${pkg.epm.assignments.length}
`);
    const resourceCounts = pkg.epm.assignments.reduce((acc, a) => {
      acc[a.resourceName] = (acc[a.resourceName] || 0) + 1;
      return acc;
    }, {});
    lines.push("\n**Assignments by Resource:**\n");
    Object.entries(resourceCounts).forEach(([name, count2]) => {
      lines.push(`- **${name}:** ${count2} task(s)`);
    });
    lines.push("\n");
    lines.push("*Detailed assignment data available in assignments.csv*\n");
    lines.push("\n---\n");
  }
  lines.push("\n*Report generated by Premisia Intelligent Strategic EPM*\n");
  lines.push(`*Export Date: ${format(new Date(pkg.metadata.exportedAt), "PPPPpp")}*`);
  return lines.join("\n");
}
var MarkdownExporter;
var init_markdown_exporter = __esm({
  "server/services/export/markdown-exporter.ts"() {
    "use strict";
    init_base_exporter();
    init_insights();
    MarkdownExporter = class extends BaseExporter {
      name = "Markdown Exporter";
      format = "md";
      mimeType = "text/markdown";
      async export(pkg) {
        try {
          const markdown = generateMarkdownReport(pkg);
          return {
            filename: "report.md",
            content: Buffer.from(markdown, "utf-8"),
            mimeType: this.mimeType,
            success: true
          };
        } catch (error) {
          return {
            filename: "report.md",
            content: Buffer.from(""),
            mimeType: this.mimeType,
            success: false,
            error: error instanceof Error ? error.message : "Markdown generation failed"
          };
        }
      }
    };
  }
});

// server/services/export/html-exporter.ts
import { marked } from "marked";
import { format as format2 } from "date-fns";
import { readFileSync } from "fs";
import { join as join4 } from "path";
async function generateHtmlFromMarkdown(markdown) {
  const content = await marked.parse(markdown);
  return `
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Premisia Strategic Analysis Report</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 40px 20px;
      color: #333;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 24px;
      margin-bottom: 16px;
      font-weight: 600;
      line-height: 1.25;
    }
    h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
    h3 { font-size: 1.25em; }
    p { margin-bottom: 16px; }
    code { 
      background: #f6f8fa; 
      padding: 2px 6px; 
      border-radius: 3px; 
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
      font-size: 85%;
    }
    pre {
      background: #f6f8fa;
      padding: 16px;
      border-radius: 6px;
      overflow-x: auto;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 16px 0;
    }
    th, td {
      border: 1px solid #dfe2e5;
      padding: 6px 13px;
    }
    th {
      background: #f6f8fa;
      font-weight: 600;
    }
    hr {
      height: 0.25em;
      padding: 0;
      margin: 24px 0;
      background-color: #e1e4e8;
      border: 0;
    }
    ul, ol {
      padding-left: 2em;
      margin-bottom: 16px;
    }
    li + li {
      margin-top: 0.25em;
    }
    strong {
      font-weight: 600;
    }
  </style>
</head>
<body>
  ${content}
</body>
</html>
  `.trim();
}
function generateUiStyledHtml(pkg) {
  const parseField2 = (field) => {
    if (!field) return null;
    if (typeof field === "object") return field;
    try {
      return JSON.parse(field);
    } catch (err) {
      console.warn("[Export] Failed to parse JSONB field:", err);
      return null;
    }
  };
  const getConfidenceBadge = (confidence) => {
    const conf = typeof confidence === "number" ? confidence : parseFloat(confidence);
    if (isNaN(conf)) return '<span class="badge badge-secondary">N/A</span>';
    const percentage = conf * 100;
    let badgeClass = "badge-warning";
    if (percentage >= 75) badgeClass = "badge-success";
    else if (percentage < 50) badgeClass = "badge-destructive";
    return `<span class="badge ${badgeClass}">${percentage.toFixed(0)}%</span>`;
  };
  const escapeHtml = (str) => {
    if (str === null || str === void 0) return "";
    let stringValue;
    if (typeof str === "object") {
      stringValue = JSON.stringify(str);
    } else {
      stringValue = String(str);
    }
    return stringValue.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  };
  const contentParts = [];
  const title = pkg.strategy.understanding?.title || "Strategic Analysis Report";
  contentParts.push(`
    <div class="header">
      <h1>${escapeHtml(title)}</h1>
      <p class="subtitle">Generated: ${format2(new Date(pkg.metadata.exportedAt), "PPpp")}</p>
      <p class="subtitle">Session ID: ${pkg.metadata.sessionId}</p>
      ${pkg.metadata.versionNumber ? `<p class="subtitle">Version: ${pkg.metadata.versionNumber}</p>` : ""}
    </div>
  `);
  if (pkg.strategy.understanding) {
    const u = pkg.strategy.understanding;
    contentParts.push(`
      <div class="card">
        <div class="card-header">
          <h2 class="card-title">Strategic Understanding</h2>
        </div>
        <div class="card-content">
          <div class="key-value">
            <div class="key-value-label">Title:</div>
            <div class="key-value-value">${escapeHtml(u.title || "Untitled Initiative")}</div>
          </div>
          <div class="key-value">
            <div class="key-value-label">Initiative Type:</div>
            <div class="key-value-value">${escapeHtml(u.initiativeType || "Not classified")}</div>
          </div>
          ${u.classificationConfidence ? `
          <div class="key-value">
            <div class="key-value-label">Classification Confidence:</div>
            <div class="key-value-value">${getConfidenceBadge(u.classificationConfidence)}</div>
          </div>
          ` : ""}
          ${u.initiativeDescription ? `
          <div class="mt-4">
            <h3>Description</h3>
            <p>${escapeHtml(u.initiativeDescription)}</p>
          </div>
          ` : ""}
          ${u.userInput ? `
          <div class="mt-4">
            <h3>Original User Input</h3>
            <p>${escapeHtml(u.userInput)}</p>
          </div>
          ` : ""}
        </div>
      </div>
    `);
  }
  if (pkg.strategy.journeySession) {
    const j = pkg.strategy.journeySession;
    contentParts.push(`
      <div class="card">
        <div class="card-header">
          <h2 class="card-title">Strategic Journey</h2>
        </div>
        <div class="card-content">
          <div class="key-value">
            <div class="key-value-label">Journey Type:</div>
            <div class="key-value-value">${escapeHtml(j.journeyType || "Custom")}</div>
          </div>
          <div class="key-value">
            <div class="key-value-label">Status:</div>
            <div class="key-value-value"><span class="badge badge-default">${escapeHtml(j.status)}</span></div>
          </div>
          ${j.completedFrameworks && j.completedFrameworks.length > 0 ? `
          <div class="mt-4">
            <h3>Completed Frameworks</h3>
            <ul>
              ${j.completedFrameworks.map((fw) => `<li>${escapeHtml(fw)}</li>`).join("")}
            </ul>
          </div>
          ` : ""}
        </div>
      </div>
    `);
    const insights = deriveInsights(pkg, parseField2);
    if (insights.rootCauses || insights.whysPath || insights.strategicImplications) {
      contentParts.push(`
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">Five Whys Analysis</h2>
          </div>
          <div class="card-content">
            ${insights.whysPath && insights.whysPath.length > 0 ? `
            <div class="mb-4">
              <h3>Analysis Path</h3>
              <ol>
                ${insights.whysPath.map((step, idx) => `
                  <li class="mb-2">
                    <strong>Why?</strong> ${escapeHtml(step.question || step.why || "Not specified")}
                    <br><strong>Answer:</strong> ${escapeHtml(step.answer || "Not specified")}
                  </li>
                `).join("")}
              </ol>
            </div>
            ` : ""}
            ${insights.rootCauses && insights.rootCauses.length > 0 ? `
            <div class="mb-4">
              <h3>Identified Root Causes</h3>
              <ul>
                ${insights.rootCauses.map((cause) => `<li>${escapeHtml(cause)}</li>`).join("")}
              </ul>
            </div>
            ` : ""}
            ${insights.strategicImplications && insights.strategicImplications.length > 0 ? `
            <div>
              <h3>Strategic Implications</h3>
              <ul>
                ${insights.strategicImplications.map((imp) => `<li>${escapeHtml(imp)}</li>`).join("")}
              </ul>
            </div>
            ` : ""}
          </div>
        </div>
      `);
    }
    if (insights.bmcBlocks) {
      const bmc = insights.bmcBlocks;
      const renderBmcBlock = (title2, data) => {
        if (!data) return "";
        if (typeof data === "string") {
          return `<div class="mb-3"><h4>${title2}</h4><p>${escapeHtml(data)}</p></div>`;
        } else if (Array.isArray(data)) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.map((item) => `<li>${escapeHtml(item)}</li>`).join("")}</ul></div>`;
        } else if (data.segments) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.segments.map((seg) => `<li><strong>${escapeHtml(seg.name || "Segment")}:</strong> ${escapeHtml(seg.description || "")}</li>`).join("")}</ul></div>`;
        } else if (data.propositions) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.propositions.map((vp) => `<li><strong>${escapeHtml(vp.title || "Value Proposition")}:</strong> ${escapeHtml(vp.description || "")}</li>`).join("")}</ul></div>`;
        } else if (data.channels) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.channels.map((ch) => `<li><strong>${escapeHtml(ch.name || "Channel")}:</strong> ${escapeHtml(ch.description || "")}</li>`).join("")}</ul></div>`;
        } else if (data.relationships) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.relationships.map((rel) => `<li><strong>${escapeHtml(rel.type || "Relationship")}:</strong> ${escapeHtml(rel.description || "")}</li>`).join("")}</ul></div>`;
        } else if (data.streams) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.streams.map((rev) => `<li><strong>${escapeHtml(rev.name || "Revenue Stream")}:</strong> ${escapeHtml(rev.description || "")}${rev.pricingModel ? `<br><em>Pricing: ${escapeHtml(rev.pricingModel)}</em>` : ""}</li>`).join("")}</ul></div>`;
        } else if (data.resources) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.resources.map((res) => `<li><strong>${escapeHtml(res.name || "Resource")}:</strong> ${escapeHtml(res.description || "")}</li>`).join("")}</ul></div>`;
        } else if (data.activities) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.activities.map((act) => `<li><strong>${escapeHtml(act.name || "Activity")}:</strong> ${escapeHtml(act.description || "")}</li>`).join("")}</ul></div>`;
        } else if (data.partnerships) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.partnerships.map((part) => `<li><strong>${escapeHtml(part.partner || "Partner")}:</strong> ${escapeHtml(part.description || "")}</li>`).join("")}</ul></div>`;
        } else if (data.costs) {
          return `<div class="mb-3"><h4>${title2}</h4><ul>${data.costs.map((cost) => `<li><strong>${escapeHtml(cost.category || "Cost")}:</strong> ${escapeHtml(cost.description || "")}</li>`).join("")}</ul></div>`;
        }
        return "";
      };
      contentParts.push(`
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">Business Model Canvas Analysis</h2>
          </div>
          <div class="card-content">
            ${renderBmcBlock("Customer Segments", bmc.customerSegments)}
            ${renderBmcBlock("Value Propositions", bmc.valuePropositions)}
            ${renderBmcBlock("Channels", bmc.channels)}
            ${renderBmcBlock("Customer Relationships", bmc.customerRelationships)}
            ${renderBmcBlock("Revenue Streams", bmc.revenueStreams)}
            ${renderBmcBlock("Key Resources", bmc.keyResources)}
            ${renderBmcBlock("Key Activities", bmc.keyActivities)}
            ${renderBmcBlock("Key Partnerships", bmc.keyPartnerships)}
            ${renderBmcBlock("Cost Structure", bmc.costStructure)}
          </div>
        </div>
      `);
    }
  }
  if (pkg.strategy.strategyVersion) {
    const sv = pkg.strategy.strategyVersion;
    contentParts.push(`
      <div class="card">
        <div class="card-header">
          <h2 class="card-title">Strategic Decisions</h2>
          ${sv.versionLabel ? `<p class="card-description">Version: ${escapeHtml(sv.versionLabel)}</p>` : ""}
        </div>
        <div class="card-content">
          ${sv.inputSummary ? `
          <div class="mb-4">
            <h3>Summary</h3>
            <p>${escapeHtml(sv.inputSummary)}</p>
          </div>
          ` : ""}
          ${pkg.strategy.decisions && pkg.strategy.decisions.length > 0 ? `
          <div>
            <h3>Selected Decisions</h3>
            <ol>
              ${pkg.strategy.decisions.map((decision) => {
      const decType = decision.type || decision.category || "Decision";
      const decValue = decision.value || decision.description || decision.choice || "Not specified";
      return `
                  <li>
                    <strong>${escapeHtml(decType)}:</strong> ${escapeHtml(decValue)}
                    ${decision.rationale ? `<br><em class="text-muted">Rationale: ${escapeHtml(decision.rationale)}</em>` : ""}
                  </li>
                `;
    }).join("")}
            </ol>
          </div>
          ` : ""}
        </div>
      </div>
    `);
  }
  if (pkg.epm?.program) {
    const program = pkg.epm.program;
    const execSummary = parseField2(program.executiveSummary);
    const workstreams2 = parseField2(program.workstreams);
    const timeline = parseField2(program.timeline);
    const resourcePlan = parseField2(program.resourcePlan);
    const risks2 = parseField2(program.riskRegister);
    const stageGates2 = parseField2(program.stageGates);
    const kpis2 = parseField2(program.kpis);
    const confidenceValue = program.overallConfidence ? parseFloat(program.overallConfidence) : null;
    contentParts.push(`
      <div class="card">
        <div class="card-header">
          <h2 class="card-title">Enterprise Program Management (EPM) Program</h2>
        </div>
        <div class="card-content">
          <div class="key-value">
            <div class="key-value-label">Framework:</div>
            <div class="key-value-value">${escapeHtml(program.frameworkType || "Not specified")}</div>
          </div>
          <div class="key-value">
            <div class="key-value-label">Status:</div>
            <div class="key-value-value"><span class="badge badge-default">${escapeHtml(program.status)}</span></div>
          </div>
          ${confidenceValue !== null && !isNaN(confidenceValue) ? `
          <div class="key-value">
            <div class="key-value-label">Overall Confidence:</div>
            <div class="key-value-value">${getConfidenceBadge(confidenceValue)}</div>
          </div>
          ` : ""}
        </div>
      </div>
    `);
    if (execSummary) {
      contentParts.push(`
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">1. Executive Summary</h2>
          </div>
          <div class="card-content">
            ${execSummary.title ? `<h3 class="mb-2">${escapeHtml(execSummary.title)}</h3>` : ""}
            ${execSummary.overview || execSummary.summary ? `<p class="mb-4">${escapeHtml(execSummary.overview || execSummary.summary)}</p>` : ""}
            ${execSummary.objectives && execSummary.objectives.length > 0 ? `
            <div class="mb-4">
              <strong>Strategic Objectives:</strong>
              <ol>
                ${execSummary.objectives.map((obj) => `<li>${escapeHtml(obj)}</li>`).join("")}
              </ol>
            </div>
            ` : ""}
          </div>
        </div>
      `);
    }
    if (workstreams2 && workstreams2.length > 0) {
      contentParts.push(`
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">2. Workstreams</h2>
          </div>
          <div class="card-content">
            ${workstreams2.map((ws2, idx) => `
              <div class="mb-4">
                <h3>${idx + 1}. ${escapeHtml(ws2.name || `Workstream ${idx + 1}`)}</h3>
                ${ws2.description ? `<p>${escapeHtml(ws2.description)}</p>` : ""}
                ${ws2.owner ? `<p><strong>Owner:</strong> ${escapeHtml(ws2.owner)}</p>` : ""}
                ${ws2.startMonth !== void 0 && ws2.endMonth !== void 0 ? `<p><strong>Duration:</strong> Month ${ws2.startMonth} to Month ${ws2.endMonth}</p>` : ""}
              </div>
            `).join("")}
          </div>
        </div>
      `);
    }
    if (timeline) {
      const totalMonths = timeline.totalDuration || 12;
      const criticalPathSet = new Set((timeline.criticalPath || []).map((item) => item.toLowerCase()));
      const renderGanttChart = () => {
        if (!workstreams2 || workstreams2.length === 0) return "";
        const ganttRows = workstreams2.map((ws2) => {
          const startMonth = ws2.startMonth ?? 0;
          const endMonth = ws2.endMonth ?? totalMonths;
          const leftPercent = startMonth / totalMonths * 100;
          const widthPercent = (endMonth - startMonth) / totalMonths * 100;
          const wsNameLower = (ws2.name || "").toLowerCase();
          const isCritical = ws2.isCritical || criticalPathSet.has(wsNameLower);
          return `
            <div class="gantt-row">
              <div class="gantt-label" title="${escapeHtml(ws2.name || "Workstream")}">${escapeHtml(ws2.name || "Workstream")}</div>
              <div class="gantt-bar-track">
                <div class="gantt-bar${isCritical ? " critical" : ""}" style="left: ${leftPercent}%; width: ${widthPercent}%;">
                  <span class="gantt-bar-label">M${startMonth}-M${endMonth}</span>
                </div>
              </div>
            </div>
          `;
        }).join("");
        const axisTicks = [];
        const tickCount = Math.min(totalMonths + 1, 13);
        const tickInterval = Math.ceil(totalMonths / (tickCount - 1));
        for (let i = 0; i <= totalMonths; i += tickInterval) {
          axisTicks.push(`<div class="gantt-axis-tick">M${i}</div>`);
        }
        return `
          <div class="gantt-chart">
            ${ganttRows}
            <div class="gantt-axis">
              ${axisTicks.join("")}
            </div>
          </div>
        `;
      };
      contentParts.push(`
        <div class="card">
          <div class="card-header">
            <h2 class="card-title">3. Timeline & Critical Path</h2>
          </div>
          <div class="card-content">
            ${timeline.totalDuration ? `<p><strong>Total Duration:</strong> ${timeline.totalDuration} months</p>` : ""}
            ${timeline.phases && timeline.phases.length > 0 ? `
            <div class="mb-4">
              <strong>Program Phases:</strong>
              <ul>
                ${timeline.phases.map((phase) => `<li><strong>${escapeHtml(phase.name)}:</strong> Month ${phase.startMonth} to Month ${phase.endMonth}</li>`).join("")}
              </ul>
            </div>
            ` : ""}
            ${timeline.criticalPath && timeline.criticalPath.length > 0 ? `
            <div class="mb-4">
              <strong>Critical Path:</strong>
              <ul>
                ${timeline.criticalPath.map((item) => `<li>${escapeHtml(item)}</li>`).join("")}
              </ul>
            </div>
            ` : ""}
            ${renderGanttChart()}
          </div>
        </div>
      `);
    }
    if (risks2) {
      const riskArray = risks2.risks || risks2;
      if (Array.isArray(riskArray) && riskArray.length > 0) {
        contentParts.push(`
          <div class="card">
            <div class="card-header">
              <h2 class="card-title">7. Risk Register</h2>
            </div>
            <div class="card-content">
              <table class="table">
                <thead>
                  <tr>
                    <th>Risk</th>
                    <th>Probability</th>
                    <th>Impact</th>
                    <th>Mitigation</th>
                  </tr>
                </thead>
                <tbody>
                  ${riskArray.map((r) => `
                    <tr>
                      <td>${escapeHtml(r.risk || r.name || r.description || "Unnamed risk")}</td>
                      <td>${escapeHtml(r.probability || r.likelihood || "-")}</td>
                      <td>${escapeHtml(r.impact || r.severity || "-")}</td>
                      <td>${escapeHtml(r.mitigation || r.response || "-")}</td>
                    </tr>
                  `).join("")}
                </tbody>
              </table>
            </div>
          </div>
        `);
      }
    }
  }
  if (pkg.epm?.assignments && pkg.epm.assignments.length > 0) {
    const resourceCounts = pkg.epm.assignments.reduce((acc, a) => {
      acc[a.resourceName] = (acc[a.resourceName] || 0) + 1;
      return acc;
    }, {});
    contentParts.push(`
      <div class="card">
        <div class="card-header">
          <h2 class="card-title">Task Assignments Overview</h2>
        </div>
        <div class="card-content">
          <p class="mb-4"><strong>Total Assignments:</strong> ${pkg.epm.assignments.length}</p>
          <h3>Assignments by Resource</h3>
          <ul>
            ${Object.entries(resourceCounts).map(([name, count2]) => `
              <li><strong>${escapeHtml(name)}:</strong> ${count2} task(s)</li>
            `).join("")}
          </ul>
          <p class="mt-4 text-muted"><em>Detailed assignment data available in assignments.csv</em></p>
        </div>
      </div>
    `);
  }
  contentParts.push(`
    <div class="card" style="background: hsl(var(--muted)); border: none;">
      <div class="card-content" style="text-align: center;">
        <p class="text-muted"><em>Report generated by Premisia Intelligent Strategic EPM</em></p>
        <p class="text-muted"><em>Export Date: ${format2(new Date(pkg.metadata.exportedAt), "PPPPpp")}</em></p>
      </div>
    </div>
  `);
  const templatePath = join4(process.cwd(), "server/export/templates/report-ui.html");
  try {
    const template = readFileSync(templatePath, "utf-8");
    console.log("[Export] Successfully loaded HTML template from:", templatePath);
    return template.replace("{{TITLE}}", escapeHtml(title)).replace("{{CONTENT}}", contentParts.join("\n"));
  } catch (error) {
    console.error("[Export] Failed to read HTML template");
    console.error("[Export] Template path:", templatePath);
    console.error("[Export] process.cwd():", process.cwd());
    console.error("[Export] Error:", error);
    throw new Error(`Failed to load HTML template: ${error instanceof Error ? error.message : "Unknown error"}`);
  }
}
var HtmlExporter;
var init_html_exporter = __esm({
  "server/services/export/html-exporter.ts"() {
    "use strict";
    init_base_exporter();
    init_insights();
    HtmlExporter = class extends BaseExporter {
      name = "HTML Exporter";
      format = "html";
      mimeType = "text/html";
      async export(pkg) {
        try {
          const html = generateUiStyledHtml(pkg);
          return {
            filename: "report.html",
            content: Buffer.from(html, "utf-8"),
            mimeType: this.mimeType,
            success: true
          };
        } catch (error) {
          return {
            filename: "report.html",
            content: Buffer.from(""),
            mimeType: this.mimeType,
            success: false,
            error: error instanceof Error ? error.message : "HTML generation failed"
          };
        }
      }
      generateHtmlFromMarkdown(markdown) {
        return generateHtmlFromMarkdown(markdown);
      }
      generateUiStyledHtml(pkg) {
        return generateUiStyledHtml(pkg);
      }
    };
  }
});

// server/services/export/pdf-exporter.ts
import puppeteer from "puppeteer";
import { execSync } from "child_process";
function findChromiumExecutable() {
  if (cachedChromiumPath !== null) {
    return cachedChromiumPath || void 0;
  }
  try {
    const path3 = execSync("command -v chromium-browser || command -v chromium || command -v google-chrome", {
      encoding: "utf8",
      stdio: ["pipe", "pipe", "ignore"]
    }).trim();
    cachedChromiumPath = path3 || void 0;
    if (cachedChromiumPath) {
      console.log("[Export Service] Chromium executable found:", cachedChromiumPath);
    } else {
      console.warn("[Export Service] Chromium executable not found - PDF generation will be skipped");
    }
    return cachedChromiumPath;
  } catch (error) {
    console.warn("[Export Service] Failed to locate Chromium executable:", error instanceof Error ? error.message : String(error));
    cachedChromiumPath = void 0;
    return void 0;
  }
}
async function generatePdfFromHtml(html) {
  const chromiumPath = findChromiumExecutable();
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
    executablePath: chromiumPath
  });
  try {
    const page = await browser.newPage();
    await page.setContent(html, { waitUntil: "networkidle0" });
    const pdf2 = await page.pdf({
      format: "A4",
      margin: {
        top: "20mm",
        right: "15mm",
        bottom: "20mm",
        left: "15mm"
      },
      printBackground: true
    });
    return Buffer.from(pdf2);
  } finally {
    await browser.close();
  }
}
async function generatePdfFromUiHtml(html) {
  const chromiumPath = findChromiumExecutable();
  const browser = await puppeteer.launch({
    headless: true,
    args: ["--no-sandbox", "--disable-setuid-sandbox"],
    executablePath: chromiumPath
  });
  try {
    const page = await browser.newPage();
    await page.setContent(html, { waitUntil: "networkidle0" });
    const pdf2 = await page.pdf({
      format: "A4",
      margin: {
        top: "20mm",
        right: "15mm",
        bottom: "20mm",
        left: "15mm"
      },
      printBackground: true
    });
    return Buffer.from(pdf2);
  } finally {
    await browser.close();
  }
}
var cachedChromiumPath, PdfExporter;
var init_pdf_exporter = __esm({
  "server/services/export/pdf-exporter.ts"() {
    "use strict";
    init_base_exporter();
    cachedChromiumPath = null;
    PdfExporter = class extends BaseExporter {
      name = "PDF Exporter";
      format = "pdf";
      mimeType = "application/pdf";
      isAvailable() {
        return findChromiumExecutable() !== void 0;
      }
      async export(pkg) {
        if (!this.isAvailable()) {
          return {
            filename: "report.pdf",
            content: Buffer.from(""),
            mimeType: this.mimeType,
            success: false,
            error: "Chromium not available for PDF generation"
          };
        }
        return {
          filename: "report.pdf",
          content: Buffer.from(""),
          mimeType: this.mimeType,
          success: false,
          error: "Use generatePdfFromHtml or generatePdfFromUiHtml directly"
        };
      }
    };
  }
});

// server/services/export/docx-exporter.ts
import { Document, Packer, Paragraph, TextRun, HeadingLevel, Table, TableRow, TableCell, WidthType } from "docx";
import { format as format3 } from "date-fns";
import HTMLtoDOCX from "html-docx-js";
async function generateDocxFromHtml(html) {
  const docxBlob = HTMLtoDOCX.asBlob(html, {
    orientation: "portrait",
    margins: {
      top: 720,
      right: 720,
      bottom: 720,
      left: 720
    }
  });
  const arrayBuffer = await docxBlob.arrayBuffer();
  return Buffer.from(arrayBuffer);
}
async function generateDocxReport(pkg) {
  const sections = [];
  const parseField2 = (field) => {
    if (!field) return null;
    if (typeof field === "object") return field;
    try {
      return JSON.parse(field);
    } catch (err) {
      console.warn("[DOCX Export] Failed to parse JSONB field:", err);
      return null;
    }
  };
  sections.push(
    new Paragraph({
      text: "Premisia Strategic Analysis & EPM Program Report",
      heading: HeadingLevel.HEADING_1
    }),
    new Paragraph({
      children: [
        new TextRun({ text: "Generated: ", bold: true }),
        new TextRun(format3(new Date(pkg.metadata.exportedAt), "PPpp"))
      ]
    }),
    new Paragraph({
      children: [
        new TextRun({ text: "Session ID: ", bold: true }),
        new TextRun(pkg.metadata.sessionId)
      ]
    })
  );
  if (pkg.metadata.versionNumber) {
    sections.push(
      new Paragraph({
        children: [
          new TextRun({ text: "Version: ", bold: true }),
          new TextRun(pkg.metadata.versionNumber.toString())
        ]
      })
    );
  }
  sections.push(new Paragraph({ text: "" }));
  if (pkg.strategy.understanding) {
    const u = pkg.strategy.understanding;
    sections.push(
      new Paragraph({
        text: "Strategic Understanding",
        heading: HeadingLevel.HEADING_2
      }),
      new Paragraph({
        children: [
          new TextRun({ text: "Title: ", bold: true }),
          new TextRun(u.title || "Untitled Initiative")
        ]
      }),
      new Paragraph({
        children: [
          new TextRun({ text: "Initiative Type: ", bold: true }),
          new TextRun(u.initiativeType || "Not classified")
        ]
      })
    );
    if (u.classificationConfidence) {
      const conf = parseFloat(u.classificationConfidence);
      if (!isNaN(conf)) {
        sections.push(
          new Paragraph({
            children: [
              new TextRun({ text: "Classification Confidence: ", bold: true }),
              new TextRun(`${(conf * 100).toFixed(0)}%`)
            ]
          })
        );
      }
    }
    if (u.initiativeDescription) {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: "Description", bold: true })]
        }),
        new Paragraph({ text: u.initiativeDescription })
      );
    }
    if (u.userInput) {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: "Original User Input", bold: true })]
        }),
        new Paragraph({ text: u.userInput })
      );
    }
    sections.push(new Paragraph({ text: "" }));
  }
  if (pkg.strategy.journeySession) {
    const j = pkg.strategy.journeySession;
    sections.push(
      new Paragraph({
        text: "Strategic Journey",
        heading: HeadingLevel.HEADING_2
      }),
      new Paragraph({
        children: [
          new TextRun({ text: "Journey Type: ", bold: true }),
          new TextRun(j.journeyType || "Custom")
        ]
      }),
      new Paragraph({
        children: [
          new TextRun({ text: "Status: ", bold: true }),
          new TextRun(j.status)
        ]
      })
    );
    if (j.completedFrameworks && j.completedFrameworks.length > 0) {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: "Completed Frameworks", bold: true })]
        })
      );
      j.completedFrameworks.forEach((fw) => {
        sections.push(
          new Paragraph({
            text: `\u2022 ${fw}`,
            bullet: { level: 0 }
          })
        );
      });
    }
    sections.push(new Paragraph({ text: "" }));
  }
  if (pkg.strategy.strategyVersion) {
    const sv = pkg.strategy.strategyVersion;
    sections.push(
      new Paragraph({
        text: "Strategic Decisions",
        heading: HeadingLevel.HEADING_2
      })
    );
    if (sv.versionLabel) {
      sections.push(
        new Paragraph({
          children: [
            new TextRun({ text: "Version: ", bold: true }),
            new TextRun(sv.versionLabel)
          ]
        })
      );
    }
    if (sv.inputSummary) {
      sections.push(
        new Paragraph({
          children: [new TextRun({ text: "Summary", bold: true })]
        }),
        new Paragraph({ text: sv.inputSummary })
      );
    }
    if (pkg.strategy.decisions && pkg.strategy.decisions.length > 0) {
      sections.push(
        new Paragraph({
          text: "Selected Decisions",
          heading: HeadingLevel.HEADING_3
        })
      );
      pkg.strategy.decisions.forEach((decision, idx) => {
        const decType = decision.type || decision.category || "Decision";
        const decValue = decision.value || decision.description || decision.choice || "Not specified";
        sections.push(
          new Paragraph({
            children: [
              new TextRun({ text: `${idx + 1}. ${decType}: `, bold: true }),
              new TextRun(decValue)
            ]
          })
        );
        if (decision.rationale) {
          sections.push(
            new Paragraph({
              children: [
                new TextRun({ text: `   Rationale: ${decision.rationale}`, italics: true })
              ]
            })
          );
        }
      });
    }
    sections.push(new Paragraph({ text: "" }));
  }
  if (pkg.epm?.program) {
    const program = pkg.epm.program;
    const execSummary = parseField2(program.executiveSummary);
    const workstreams2 = parseField2(program.workstreams);
    const timeline = parseField2(program.timeline);
    const resourcePlan = parseField2(program.resourcePlan);
    const financialPlan = parseField2(program.financialPlan);
    const benefits2 = parseField2(program.benefitsRealization);
    const risks2 = parseField2(program.riskRegister);
    const stageGates2 = parseField2(program.stageGates);
    const kpis2 = parseField2(program.kpis);
    const stakeholders = parseField2(program.stakeholderMap);
    const governance = parseField2(program.governance);
    const qaPlan = parseField2(program.qaPlan);
    const procurement = parseField2(program.procurement);
    const exitStrategy = parseField2(program.exitStrategy);
    sections.push(
      new Paragraph({
        text: "Enterprise Program Management (EPM) Program",
        heading: HeadingLevel.HEADING_1
      }),
      new Paragraph({
        children: [
          new TextRun({ text: "Framework: ", bold: true }),
          new TextRun(program.frameworkType || "Not specified")
        ]
      }),
      new Paragraph({
        children: [
          new TextRun({ text: "Status: ", bold: true }),
          new TextRun(program.status)
        ]
      })
    );
    const confidenceValue = program.overallConfidence ? parseFloat(program.overallConfidence) : null;
    const confidenceText = confidenceValue !== null && !isNaN(confidenceValue) ? `${(confidenceValue * 100).toFixed(1)}%` : "Not calculated";
    sections.push(
      new Paragraph({
        children: [
          new TextRun({ text: "Overall Confidence: ", bold: true }),
          new TextRun(confidenceText)
        ]
      }),
      new Paragraph({ text: "" })
    );
    if (execSummary) {
      sections.push(
        new Paragraph({
          text: "1. Executive Summary",
          heading: HeadingLevel.HEADING_2
        })
      );
      if (execSummary.title) {
        sections.push(
          new Paragraph({
            children: [
              new TextRun({ text: "Program Title: ", bold: true }),
              new TextRun(execSummary.title)
            ]
          })
        );
      }
      if (execSummary.overview || execSummary.summary) {
        sections.push(
          new Paragraph({ text: execSummary.overview || execSummary.summary })
        );
      }
      if (execSummary.objectives && execSummary.objectives.length > 0) {
        sections.push(
          new Paragraph({
            children: [new TextRun({ text: "Strategic Objectives", bold: true })]
          })
        );
        execSummary.objectives.forEach((obj, idx) => {
          sections.push(
            new Paragraph({
              text: `${idx + 1}. ${obj}`
            })
          );
        });
      }
      sections.push(new Paragraph({ text: "" }));
    }
    if (workstreams2 && workstreams2.length > 0) {
      sections.push(
        new Paragraph({
          text: "2. Workstreams",
          heading: HeadingLevel.HEADING_2
        })
      );
      workstreams2.forEach((ws2, idx) => {
        sections.push(
          new Paragraph({
            text: `${idx + 1}. ${ws2.name || `Workstream ${idx + 1}`}`,
            heading: HeadingLevel.HEADING_3
          })
        );
        if (ws2.description) {
          sections.push(new Paragraph({ text: ws2.description }));
        }
        if (ws2.owner) {
          sections.push(
            new Paragraph({
              children: [
                new TextRun({ text: "Owner: ", bold: true }),
                new TextRun(ws2.owner)
              ]
            })
          );
        }
        if (ws2.startMonth !== void 0 && ws2.endMonth !== void 0) {
          sections.push(
            new Paragraph({
              children: [
                new TextRun({ text: "Duration: ", bold: true }),
                new TextRun(`Month ${ws2.startMonth} to Month ${ws2.endMonth}`)
              ]
            })
          );
        }
        sections.push(new Paragraph({ text: "" }));
      });
    }
    if (timeline) {
      sections.push(
        new Paragraph({
          text: "3. Timeline & Critical Path",
          heading: HeadingLevel.HEADING_2
        })
      );
      if (timeline.totalDuration) {
        sections.push(
          new Paragraph({
            children: [
              new TextRun({ text: "Total Program Duration: ", bold: true }),
              new TextRun(`${timeline.totalDuration} months`)
            ]
          })
        );
      }
      if (timeline.phases && timeline.phases.length > 0) {
        sections.push(
          new Paragraph({
            children: [new TextRun({ text: "Program Phases", bold: true })]
          })
        );
        timeline.phases.forEach((phase) => {
          sections.push(
            new Paragraph({
              text: `\u2022 ${phase.name}: Month ${phase.startMonth} to Month ${phase.endMonth}`,
              bullet: { level: 0 }
            })
          );
        });
      }
      sections.push(new Paragraph({ text: "" }));
    }
    if (resourcePlan) {
      sections.push(
        new Paragraph({
          text: "4. Resource Plan",
          heading: HeadingLevel.HEADING_2
        })
      );
      if (resourcePlan.internalTeam && resourcePlan.internalTeam.length > 0) {
        sections.push(
          new Paragraph({
            text: "Internal Team",
            heading: HeadingLevel.HEADING_3
          })
        );
        const internalTeamRows = [
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Role", bold: true })] })] }),
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "FTE", bold: true })] })] }),
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Responsibilities", bold: true })] })] })
            ]
          })
        ];
        resourcePlan.internalTeam.forEach((r) => {
          internalTeamRows.push(
            new TableRow({
              children: [
                new TableCell({ children: [new Paragraph(r.role || r.title || "Not specified")] }),
                new TableCell({ children: [new Paragraph(String(r.fte || r.allocation || "TBD"))] }),
                new TableCell({ children: [new Paragraph(r.responsibilities || r.description || "-")] })
              ]
            })
          );
        });
        sections.push(
          new Table({
            rows: internalTeamRows,
            width: { size: 100, type: WidthType.PERCENTAGE }
          })
        );
      }
      sections.push(new Paragraph({ text: "" }));
    }
    if (risks2) {
      sections.push(
        new Paragraph({
          text: "7. Risk Register",
          heading: HeadingLevel.HEADING_2
        })
      );
      const riskArray = risks2.risks || risks2;
      if (Array.isArray(riskArray) && riskArray.length > 0) {
        const riskRows = [
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Risk", bold: true })] })] }),
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Probability", bold: true })] })] }),
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Impact", bold: true })] })] }),
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Mitigation", bold: true })] })] })
            ]
          })
        ];
        riskArray.forEach((r) => {
          const name = r.risk || r.name || r.description || "Unnamed risk";
          const prob = r.probability || r.likelihood || "-";
          const impact = r.impact || r.severity || "-";
          const mit = r.mitigation || r.response || "-";
          riskRows.push(
            new TableRow({
              children: [
                new TableCell({ children: [new Paragraph({ text: name })] }),
                new TableCell({ children: [new Paragraph({ text: prob })] }),
                new TableCell({ children: [new Paragraph({ text: impact })] }),
                new TableCell({ children: [new Paragraph({ text: mit })] })
              ]
            })
          );
        });
        sections.push(
          new Table({
            rows: riskRows,
            width: { size: 100, type: WidthType.PERCENTAGE }
          })
        );
      }
      sections.push(new Paragraph({ text: "" }));
    }
    if (kpis2) {
      sections.push(
        new Paragraph({
          text: "9. Key Performance Indicators (KPIs)",
          heading: HeadingLevel.HEADING_2
        })
      );
      const kpiArray = kpis2.kpis || kpis2.metrics || kpis2;
      if (Array.isArray(kpiArray) && kpiArray.length > 0) {
        const kpiRows = [
          new TableRow({
            children: [
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "KPI", bold: true })] })] }),
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Target", bold: true })] })] }),
              new TableCell({ children: [new Paragraph({ children: [new TextRun({ text: "Measurement Frequency", bold: true })] })] })
            ]
          })
        ];
        kpiArray.forEach((kpi) => {
          const name = kpi.name || kpi.metric || kpi.kpi || "KPI";
          const target = kpi.target || kpi.goal || "-";
          const freq = kpi.frequency || kpi.measurementFrequency || "Monthly";
          kpiRows.push(
            new TableRow({
              children: [
                new TableCell({ children: [new Paragraph({ text: name })] }),
                new TableCell({ children: [new Paragraph({ text: target })] }),
                new TableCell({ children: [new Paragraph({ text: freq })] })
              ]
            })
          );
        });
        sections.push(
          new Table({
            rows: kpiRows,
            width: { size: 100, type: WidthType.PERCENTAGE }
          })
        );
      }
      sections.push(new Paragraph({ text: "" }));
    }
  }
  if (pkg.epm?.assignments && pkg.epm.assignments.length > 0) {
    sections.push(
      new Paragraph({
        text: "Task Assignments Overview",
        heading: HeadingLevel.HEADING_2
      })
    );
    sections.push(
      new Paragraph({
        children: [
          new TextRun({ text: "Total Assignments: ", bold: true }),
          new TextRun(pkg.epm.assignments.length.toString())
        ]
      })
    );
    const resourceCounts = pkg.epm.assignments.reduce((acc, a) => {
      acc[a.resourceName] = (acc[a.resourceName] || 0) + 1;
      return acc;
    }, {});
    sections.push(
      new Paragraph({
        children: [new TextRun({ text: "Assignments by Resource", bold: true })]
      })
    );
    Object.entries(resourceCounts).forEach(([name, count2]) => {
      sections.push(
        new Paragraph({
          text: `\u2022 ${name}: ${count2} task(s)`,
          bullet: { level: 0 }
        })
      );
    });
    sections.push(new Paragraph({ text: "" }));
  }
  sections.push(
    new Paragraph({ text: "" }),
    new Paragraph({
      children: [
        new TextRun({
          text: "Report generated by Premisia Intelligent Strategic EPM",
          italics: true
        })
      ]
    }),
    new Paragraph({
      children: [
        new TextRun({
          text: `Export Date: ${format3(new Date(pkg.metadata.exportedAt), "PPPPpp")}`,
          italics: true
        })
      ]
    })
  );
  const doc = new Document({
    sections: [{
      properties: {},
      children: sections
    }]
  });
  return await Packer.toBuffer(doc);
}
var DocxExporter;
var init_docx_exporter = __esm({
  "server/services/export/docx-exporter.ts"() {
    "use strict";
    init_base_exporter();
    DocxExporter = class extends BaseExporter {
      name = "DOCX Exporter";
      format = "docx";
      mimeType = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
      async export(pkg) {
        try {
          const docx = await generateDocxReport(pkg);
          return {
            filename: "report.docx",
            content: docx,
            mimeType: this.mimeType,
            success: true
          };
        } catch (error) {
          return {
            filename: "report.docx",
            content: Buffer.from(""),
            mimeType: this.mimeType,
            success: false,
            error: error instanceof Error ? error.message : "DOCX generation failed"
          };
        }
      }
    };
  }
});

// server/services/export/csv-exporter.ts
import { format as format4 } from "date-fns";
function generateAssignmentsCsv(assignments, workstreams2) {
  const headers = ["Task ID", "Task Name", "Workstream ID", "Owner", "Resource ID", "Resource Name", "Resource Role", "Resource Type", "Status", "Allocation %", "Assigned From", "Assigned To", "Start Month", "End Month"];
  const rows = [headers.join(",")];
  const deliverableLookup = {};
  if (Array.isArray(workstreams2)) {
    workstreams2.forEach((ws2) => {
      const wsId = ws2.id;
      const wsStart = ws2.startMonth;
      const wsEnd = ws2.endMonth;
      (ws2.deliverables || []).forEach((d) => {
        const taskId = d.id || d.taskId || d.name;
        if (!taskId) return;
        const dueMonth = d.dueMonth ?? d.due_month;
        deliverableLookup[taskId] = {
          workstreamId: wsId,
          startMonth: wsStart,
          endMonth: dueMonth ?? wsEnd ?? wsStart
        };
      });
    });
  }
  const parseTaskIdWorkstream = (taskId) => {
    if (!taskId) return "";
    const match = taskId.match(/^(WS\\d+)/i);
    return match ? match[1] : "";
  };
  const minAssignedFrom = assignments.map((a) => a.assignedFrom).filter(Boolean).map((d) => new Date(d)).sort((a, b) => a.getTime() - b.getTime())[0];
  assignments.forEach((assignment) => {
    const lookup = deliverableLookup[assignment.taskId] || {};
    const workstreamId = lookup.workstreamId || assignment.workstreamId || parseTaskIdWorkstream(assignment.taskId);
    let startMonth = lookup.startMonth;
    let endMonth = lookup.endMonth;
    if ((startMonth === void 0 || endMonth === void 0) && assignment.assignedFrom && assignment.assignedTo && minAssignedFrom) {
      const start = new Date(assignment.assignedFrom);
      const end = new Date(assignment.assignedTo);
      const monthsFromStart = (d) => Math.max(0, Math.round((d.getTime() - minAssignedFrom.getTime()) / (1e3 * 60 * 60 * 24 * 30)));
      startMonth = startMonth ?? monthsFromStart(start);
      endMonth = endMonth ?? monthsFromStart(end);
    }
    const row = [
      escapeCsvField(assignment.taskId),
      escapeCsvField(assignment.taskName),
      escapeCsvField(workstreamId || ""),
      escapeCsvField(assignment.owner || assignment.resourceName || assignment.resourceRole || ""),
      escapeCsvField(assignment.resourceId),
      escapeCsvField(assignment.resourceName),
      escapeCsvField(assignment.resourceRole || ""),
      escapeCsvField(assignment.resourceType),
      escapeCsvField(assignment.status),
      assignment.allocationPercent?.toString() || "100",
      assignment.assignedFrom ? format4(new Date(assignment.assignedFrom), "yyyy-MM-dd") : "",
      assignment.assignedTo ? format4(new Date(assignment.assignedTo), "yyyy-MM-dd") : "",
      startMonth !== void 0 ? `Month ${startMonth}` : "",
      endMonth !== void 0 ? `Month ${endMonth}` : ""
    ];
    rows.push(row.join(","));
  });
  return rows.join("\n");
}
function generateWorkstreamsCsv(workstreams2) {
  const headers = ["Workstream ID", "Name", "Description", "Owner", "Start Date", "End Date", "Status", "Deliverables Count", "Deliverables"];
  const rows = [headers.join(",")];
  workstreams2.forEach((ws2, idx) => {
    const deliverables = ws2.deliverables || [];
    const deliverableNames = deliverables.map(
      (d) => typeof d === "string" ? d : d.name || d.title || d.description || "Deliverable"
    );
    const row = [
      ws2.id || `WS-${idx + 1}`,
      escapeCsvField(ws2.name || `Workstream ${idx + 1}`),
      escapeCsvField(ws2.description || "-"),
      escapeCsvField(ws2.owner || "-"),
      ws2.startMonth !== void 0 ? `Month ${ws2.startMonth}` : "-",
      ws2.endMonth !== void 0 ? `Month ${ws2.endMonth}` : "-",
      escapeCsvField(ws2.status || "Pending"),
      deliverables.length.toString(),
      escapeCsvField(deliverableNames.join("; ") || "-")
    ];
    rows.push(row.join(","));
  });
  return rows.join("\n");
}
function generateResourcesCsv(resourcePlan, assignments = []) {
  const headers = ["Resource Type", "Role/Title", "FTE/Quantity", "Total Allocation %", "Estimated FTE", "Overallocated", "Skills/Responsibilities", "Source"];
  const rows = [headers.join(",")];
  const plan = typeof resourcePlan === "string" ? JSON.parse(resourcePlan) : resourcePlan;
  if (!plan) return rows.join("\n");
  const allocationByRole = {};
  assignments.forEach((a) => {
    const key = a.resourceRole || a.resourceName || a.owner;
    if (!key) return;
    const alloc = typeof a.allocationPercent === "number" ? a.allocationPercent : parseFloat(a.allocationPercent || "0");
    if (!Number.isNaN(alloc)) {
      allocationByRole[key] = (allocationByRole[key] || 0) + alloc;
    }
  });
  const allocationInfo = (role) => {
    const total = allocationByRole[role] ?? 0;
    const estimatedFte = total ? (total / 100).toFixed(2) : "";
    const over = total > 100 ? "Yes" : "No";
    return { total: total ? total.toFixed(0) + "%" : "", estimatedFte, over };
  };
  if (plan.internalTeam && plan.internalTeam.length > 0) {
    plan.internalTeam.forEach((r) => {
      let skillsText = "-";
      if (Array.isArray(r.skills) && r.skills.length > 0) {
        skillsText = r.skills.join(", ");
      } else if (r.skills && typeof r.skills === "string") {
        skillsText = r.skills;
      } else if (r.responsibilities) {
        skillsText = r.responsibilities;
      } else if (r.justification) {
        skillsText = r.justification;
      }
      const role = r.role || r.title || "Not specified";
      const alloc = allocationInfo(role);
      const row = [
        "Internal",
        escapeCsvField(role),
        r.allocation || r.fte || "TBD",
        alloc.total,
        alloc.estimatedFte,
        alloc.over,
        escapeCsvField(skillsText),
        "Internal Team"
      ];
      rows.push(row.join(","));
    });
  }
  if (plan.externalResources && plan.externalResources.length > 0) {
    plan.externalResources.forEach((r) => {
      let skillsText = "-";
      if (Array.isArray(r.skills) && r.skills.length > 0) {
        skillsText = r.skills.join(", ");
      } else if (r.skills && typeof r.skills === "string") {
        skillsText = r.skills;
      } else if (r.requirements) {
        skillsText = r.requirements;
      } else if (r.description) {
        skillsText = r.description;
      }
      const role = r.type || r.role || "Contractor";
      const alloc = allocationInfo(role);
      const row = [
        "External",
        escapeCsvField(role),
        r.quantity || r.count || "1",
        alloc.total,
        alloc.estimatedFte,
        alloc.over,
        escapeCsvField(skillsText),
        "External/Vendor"
      ];
      rows.push(row.join(","));
    });
  }
  return rows.join("\n");
}
function generateRisksCsv(riskRegister) {
  const headers = ["Risk ID", "Risk Description", "Probability", "Impact", "Severity", "Severity Score", "Severity Level", "Mitigation Strategy", "Owner"];
  const rows = [headers.join(",")];
  const risks2 = typeof riskRegister === "string" ? JSON.parse(riskRegister) : riskRegister;
  if (!risks2) return rows.join("\n");
  const riskArray = risks2.risks || risks2;
  if (Array.isArray(riskArray)) {
    riskArray.forEach((r, idx) => {
      const impactMultiplier = r.impact === "Critical" ? 4 : r.impact === "High" ? 3 : r.impact === "Medium" ? 2 : 1;
      let probabilityValue = null;
      if (typeof r.probability === "number") probabilityValue = r.probability;
      if (typeof r.probability === "string") {
        const p = parseFloat(r.probability.replace("%", "").trim());
        if (!Number.isNaN(p)) probabilityValue = p;
      }
      const calculatedSeverity = r.severity ?? (probabilityValue !== null ? Math.round(probabilityValue * impactMultiplier / 10) : "-");
      const severityScore = typeof calculatedSeverity === "number" ? calculatedSeverity : "-";
      const severityLabel = typeof calculatedSeverity === "number" ? calculatedSeverity >= 30 ? "Critical" : calculatedSeverity >= 20 ? "High" : calculatedSeverity >= 10 ? "Medium" : calculatedSeverity > 0 ? "Low" : "-" : "-";
      const row = [
        r.id || `RISK-${idx + 1}`,
        escapeCsvField(r.risk || r.name || r.description || "Unnamed risk"),
        typeof r.probability === "number" ? `${r.probability}%` : r.probability || r.likelihood || "-",
        r.impact || "-",
        typeof calculatedSeverity === "number" ? `${calculatedSeverity} (${severityLabel})` : calculatedSeverity,
        severityScore,
        severityLabel,
        escapeCsvField(r.mitigation || r.response || r.strategy || "-"),
        escapeCsvField(r.owner || "-")
      ];
      rows.push(row.join(","));
    });
  }
  return rows.join("\n");
}
function generateBenefitsCsv(benefitsRealization) {
  const headers = ["Benefit ID", "Benefit Name", "Description", "Category", "Metric", "Target", "Timeframe", "Responsible Party"];
  const rows = [headers.join(",")];
  const benefits2 = typeof benefitsRealization === "string" ? JSON.parse(benefitsRealization) : benefitsRealization;
  if (!benefits2) return rows.join("\n");
  const benefitArray = benefits2.benefits || [];
  if (Array.isArray(benefitArray)) {
    benefitArray.forEach((b, idx) => {
      const benefitName = b.name || b.benefit || (b.description ? b.description.split(".")[0].substring(0, 80) : "Benefit " + (idx + 1));
      const target = b.target || b.goal || b.measurable_target || (b.estimatedValue ? `$${b.estimatedValue.toLocaleString()}` : b.measurement || "-");
      const timeframe = b.timeframe || b.timeline || b.realization_timeline || (b.realizationMonth ? `Month ${b.realizationMonth}` : "-");
      const row = [
        `BEN-${idx + 1}`,
        escapeCsvField(benefitName),
        escapeCsvField(b.description || "-"),
        escapeCsvField(b.category || b.type || "-"),
        escapeCsvField(b.metric || b.quantified_value || b.measurement || "-"),
        escapeCsvField(target),
        escapeCsvField(timeframe),
        escapeCsvField(b.responsibleParty || b.owner || b.responsible || "-")
      ];
      rows.push(row.join(","));
    });
  }
  return rows.join("\n");
}
var CsvExporter;
var init_csv_exporter = __esm({
  "server/services/export/csv-exporter.ts"() {
    "use strict";
    init_base_exporter();
    CsvExporter = class extends BaseExporter {
      name = "CSV Exporter";
      format = "csv";
      mimeType = "text/csv";
      async export(pkg) {
        try {
          const csvFiles = [];
          if (pkg.epm?.assignments && pkg.epm.assignments.length > 0) {
            csvFiles.push({
              name: "assignments.csv",
              content: generateAssignmentsCsv(pkg.epm.assignments)
            });
          }
          if (pkg.epm?.program?.workstreams) {
            const workstreams2 = this.parseField(pkg.epm.program.workstreams);
            if (workstreams2 && workstreams2.length > 0) {
              csvFiles.push({
                name: "workstreams.csv",
                content: generateWorkstreamsCsv(workstreams2)
              });
            }
          }
          if (pkg.epm?.program?.resourcePlan) {
            const resourcePlan = this.parseField(pkg.epm.program.resourcePlan);
            if (resourcePlan) {
              csvFiles.push({
                name: "resources.csv",
                content: generateResourcesCsv(resourcePlan)
              });
            }
          }
          if (pkg.epm?.program?.riskRegister) {
            const riskRegister = this.parseField(pkg.epm.program.riskRegister);
            if (riskRegister) {
              csvFiles.push({
                name: "risks.csv",
                content: generateRisksCsv(riskRegister)
              });
            }
          }
          if (pkg.epm?.program?.benefitsRealization) {
            const benefitsRealization = this.parseField(pkg.epm.program.benefitsRealization);
            if (benefitsRealization) {
              csvFiles.push({
                name: "benefits.csv",
                content: generateBenefitsCsv(benefitsRealization)
              });
            }
          }
          const combinedContent = csvFiles.map((f) => `=== ${f.name} ===
${f.content}`).join("\n\n");
          return {
            filename: "data.csv",
            content: Buffer.from(combinedContent, "utf-8"),
            mimeType: this.mimeType,
            success: true
          };
        } catch (error) {
          return {
            filename: "data.csv",
            content: Buffer.from(""),
            mimeType: this.mimeType,
            success: false,
            error: error instanceof Error ? error.message : "CSV generation failed"
          };
        }
      }
      generateAssignmentsCsv(assignments, workstreams2) {
        return generateAssignmentsCsv(assignments, workstreams2);
      }
      generateWorkstreamsCsv(workstreams2) {
        return generateWorkstreamsCsv(workstreams2);
      }
      generateResourcesCsv(resourcePlan, assignments = []) {
        return generateResourcesCsv(resourcePlan, assignments);
      }
      generateRisksCsv(riskRegister) {
        return generateRisksCsv(riskRegister);
      }
      generateBenefitsCsv(benefitsRealization) {
        return generateBenefitsCsv(benefitsRealization);
      }
    };
  }
});

// server/services/export/excel-exporter.ts
import * as XLSX from "xlsx";
async function generateExcelWorkbook(pkg) {
  const workbook = XLSX.utils.book_new();
  const program = pkg.epm?.program;
  addSummarySheet(workbook, pkg);
  addWBSSheet(workbook, program);
  addScheduleSheet(workbook, program);
  addResourcesSheet(workbook, program);
  addBudgetSheet(workbook, program);
  addRACISheet(workbook, program, pkg.epm?.assignments);
  addRisksSheet(workbook, program);
  addAssumptionsSheet(workbook, pkg);
  const buffer = XLSX.write(workbook, { type: "buffer", bookType: "xlsx" });
  console.log("[ExcelExporter] Generated workbook with", workbook.SheetNames.length, "sheets");
  return buffer;
}
function addSummarySheet(workbook, pkg) {
  const program = pkg.epm?.program;
  const understanding = pkg.strategy?.understanding;
  const data = [
    ["EPM PROGRAM SUMMARY"],
    [""],
    ["Program Name", program?.name || understanding?.title || "Strategic Program"],
    ["Description", program?.description || understanding?.userInput || ""],
    [""],
    ["KEY METRICS"],
    ["Total Duration", program?.timeline ? `${parseField(program.timeline)?.totalMonths || 0} months` : "N/A"],
    ["Total Workstreams", parseField(program?.workstreams)?.length || 0],
    ["Total Budget", formatCurrency(calculateTotalBudget(program))],
    ["Total FTE", calculateTotalFTE(program)],
    ["Risk Count", parseField(program?.riskRegister)?.risks?.length || 0],
    [""],
    ["EXPORT METADATA"],
    ["Exported At", pkg.metadata.exportedAt],
    ["Session ID", pkg.metadata.sessionId],
    ["Version", pkg.metadata.versionNumber || "Latest"]
  ];
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [30, 60]);
  XLSX.utils.book_append_sheet(workbook, ws2, "Summary");
}
function addWBSSheet(workbook, program) {
  const workstreams2 = parseField(program?.workstreams) || [];
  const headers = ["ID", "Workstream", "Deliverable", "Due Month", "Acceptance Criteria"];
  const data = [headers];
  let rowNum = 1;
  for (const ws3 of workstreams2) {
    const deliverables = ws3.deliverables || [];
    if (deliverables.length === 0) {
      data.push([ws3.id, ws3.name, "No deliverables", "", ""]);
      rowNum++;
    } else {
      for (const del of deliverables) {
        data.push([
          ws3.id,
          ws3.name,
          del.name,
          `M${del.dueMonth}`,
          Array.isArray(del.acceptanceCriteria) ? del.acceptanceCriteria.join("; ") : del.acceptanceCriteria || ""
        ]);
        rowNum++;
      }
    }
  }
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [10, 30, 40, 12, 50]);
  XLSX.utils.book_append_sheet(workbook, ws2, "WBS");
}
function addScheduleSheet(workbook, program) {
  const workstreams2 = parseField(program?.workstreams) || [];
  const timeline = parseField(program?.timeline);
  const phases = timeline?.phases || [];
  const headers = ["Phase", "Item", "Start Month", "End Month", "Duration", "Dependencies"];
  const data = [headers];
  for (const phase of phases) {
    data.push([
      phase.name || phase.phase,
      "Phase",
      `M${phase.startMonth}`,
      `M${phase.endMonth}`,
      `${phase.endMonth - phase.startMonth + 1} months`,
      ""
    ]);
    const phaseWs = workstreams2.filter((ws3) => ws3.phase === phase.name || ws3.startMonth >= phase.startMonth && ws3.startMonth <= phase.endMonth);
    for (const ws3 of phaseWs) {
      data.push([
        "",
        ws3.name,
        `M${ws3.startMonth}`,
        `M${ws3.endMonth}`,
        `${ws3.endMonth - ws3.startMonth + 1} months`,
        (ws3.dependencies || []).join(", ")
      ]);
    }
  }
  if (phases.length === 0) {
    for (const ws3 of workstreams2) {
      data.push([
        ws3.phase || "",
        ws3.name,
        `M${ws3.startMonth}`,
        `M${ws3.endMonth}`,
        `${ws3.endMonth - ws3.startMonth + 1} months`,
        (ws3.dependencies || []).join(", ")
      ]);
    }
  }
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [20, 40, 12, 12, 12, 30]);
  XLSX.utils.book_append_sheet(workbook, ws2, "Schedule");
}
function addResourcesSheet(workbook, program) {
  const resourcePlan = parseField(program?.resourcePlan);
  const allocations = resourcePlan?.allocations || [];
  const headers = ["Role", "Workstream", "FTE", "Start Month", "End Month", "Skill Requirements"];
  const data = [headers];
  for (const alloc of allocations) {
    data.push([
      alloc.role || alloc.resourceType,
      alloc.workstreamId || alloc.workstream || "Program-wide",
      alloc.fte?.toFixed(2) || alloc.percentage?.toString() || "0",
      alloc.startMonth ? `M${alloc.startMonth}` : "",
      alloc.endMonth ? `M${alloc.endMonth}` : "",
      Array.isArray(alloc.skills) ? alloc.skills.join(", ") : alloc.skillRequirements || ""
    ]);
  }
  if (resourcePlan?.summary) {
    data.push([""]);
    data.push(["RESOURCE SUMMARY"]);
    data.push(["Total FTE", "", resourcePlan.summary.totalFte?.toFixed(2) || ""]);
    data.push(["Peak FTE", "", resourcePlan.summary.peakFte?.toFixed(2) || ""]);
    data.push(["Key Roles", "", (resourcePlan.summary.keyRoles || []).join(", ")]);
  }
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [25, 30, 10, 12, 12, 40]);
  XLSX.utils.book_append_sheet(workbook, ws2, "Resources");
}
function addBudgetSheet(workbook, program) {
  const budget = parseField(program?.budget);
  const workstreams2 = parseField(program?.workstreams) || [];
  const headers = ["Category", "Item", "Amount", "Notes"];
  const data = [headers];
  if (budget?.breakdown) {
    for (const item of budget.breakdown) {
      data.push([
        item.category || "General",
        item.name || item.description,
        formatCurrency(item.amount),
        item.notes || ""
      ]);
    }
  }
  for (const ws3 of workstreams2) {
    if (ws3.estimatedCost) {
      data.push([
        "Workstream",
        ws3.name,
        formatCurrency(ws3.estimatedCost),
        ""
      ]);
    }
  }
  data.push([""]);
  data.push(["BUDGET SUMMARY"]);
  data.push(["Total Program Budget", "", formatCurrency(budget?.totalBudget || calculateTotalBudget(program))]);
  data.push(["Contingency", "", formatCurrency(budget?.contingency || 0)]);
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [20, 40, 15, 40]);
  XLSX.utils.book_append_sheet(workbook, ws2, "Budget");
}
function addRACISheet(workbook, program, assignments = []) {
  const workstreams2 = parseField(program?.workstreams) || [];
  const roles = extractRoles(program);
  const headers = ["Deliverable", ...roles];
  const data = [headers];
  for (const ws3 of workstreams2) {
    for (const del of ws3.deliverables || []) {
      const row = [del.name];
      for (const role of roles) {
        const assignment = findAssignment(assignments, ws3.id, del.id, role);
        row.push(assignment?.responsibility || "");
      }
      data.push(row);
    }
  }
  data.push([""]);
  data.push(["LEGEND"]);
  data.push(["R = Responsible", "A = Accountable", "C = Consulted", "I = Informed"]);
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [40, ...roles.map(() => 15)]);
  XLSX.utils.book_append_sheet(workbook, ws2, "RACI");
}
function addRisksSheet(workbook, program) {
  const riskRegister = parseField(program?.riskRegister);
  const risks2 = riskRegister?.risks || [];
  const headers = ["ID", "Risk", "Category", "Probability", "Impact", "Score", "Mitigation", "Owner", "Status"];
  const data = [headers];
  for (const risk of risks2) {
    const score = (risk.probability || 0) * (risk.impact || 0);
    data.push([
      risk.id || "",
      risk.description || risk.name,
      risk.category || "",
      risk.probability || "",
      risk.impact || "",
      score.toFixed(1),
      risk.mitigation || risk.mitigationStrategy || "",
      risk.owner || "",
      risk.status || "Open"
    ]);
  }
  data.push([""]);
  data.push(["RISK SUMMARY"]);
  data.push(["Total Risks", risks2.length]);
  data.push(["High Risks (Score > 6)", risks2.filter((r) => (r.probability || 0) * (r.impact || 0) > 6).length]);
  data.push(["Medium Risks (Score 3-6)", risks2.filter((r) => {
    const s = (r.probability || 0) * (r.impact || 0);
    return s >= 3 && s <= 6;
  }).length]);
  data.push(["Low Risks (Score < 3)", risks2.filter((r) => (r.probability || 0) * (r.impact || 0) < 3).length]);
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [10, 40, 15, 12, 10, 10, 40, 15, 12]);
  XLSX.utils.book_append_sheet(workbook, ws2, "Risks");
}
function addAssumptionsSheet(workbook, pkg) {
  const program = pkg.epm?.program;
  const assumptions = parseField(program?.assumptions) || [];
  const constraints = parseField(program?.constraints) || [];
  const understanding = pkg.strategy?.understanding;
  const data = [
    ["STRATEGIC ASSUMPTIONS & CONSTRAINTS"],
    [""],
    ["ASSUMPTIONS"],
    ["ID", "Assumption", "Category", "Validated"]
  ];
  if (Array.isArray(assumptions)) {
    for (let i = 0; i < assumptions.length; i++) {
      const a = assumptions[i];
      if (typeof a === "string") {
        data.push([`A${i + 1}`, a, "", ""]);
      } else {
        data.push([a.id || `A${i + 1}`, a.description || a.assumption, a.category || "", a.validated ? "Yes" : "No"]);
      }
    }
  }
  data.push([""]);
  data.push(["CONSTRAINTS"]);
  data.push(["ID", "Constraint", "Type", "Impact"]);
  if (Array.isArray(constraints)) {
    for (let i = 0; i < constraints.length; i++) {
      const c = constraints[i];
      if (typeof c === "string") {
        data.push([`C${i + 1}`, c, "", ""]);
      } else {
        data.push([c.id || `C${i + 1}`, c.description || c.constraint, c.type || "", c.impact || ""]);
      }
    }
  }
  if (understanding) {
    data.push([""]);
    data.push(["STRATEGIC CONTEXT"]);
    data.push(["Business Context", understanding.userInput || ""]);
    data.push(["Title", understanding.title || ""]);
  }
  const ws2 = XLSX.utils.aoa_to_sheet(data);
  setColumnWidths(ws2, [10, 50, 20, 15]);
  XLSX.utils.book_append_sheet(workbook, ws2, "Assumptions");
}
function parseField(field) {
  if (!field) return null;
  if (typeof field === "object") return field;
  try {
    return JSON.parse(field);
  } catch {
    return null;
  }
}
function setColumnWidths(ws2, widths) {
  ws2["!cols"] = widths.map((w) => ({ wch: w }));
}
function formatCurrency(amount) {
  if (amount === null || amount === void 0) return "$0";
  return new Intl.NumberFormat("en-US", { style: "currency", currency: "USD", maximumFractionDigits: 0 }).format(amount);
}
function calculateTotalBudget(program) {
  const budget = parseField(program?.budget);
  if (budget?.totalBudget) return budget.totalBudget;
  const workstreams2 = parseField(program?.workstreams) || [];
  return workstreams2.reduce((sum, ws2) => sum + (ws2.estimatedCost || 0), 0);
}
function calculateTotalFTE(program) {
  const resourcePlan = parseField(program?.resourcePlan);
  if (resourcePlan?.summary?.totalFte) return resourcePlan.summary.totalFte.toFixed(2);
  const allocations = resourcePlan?.allocations || [];
  const total = allocations.reduce((sum, a) => sum + (a.fte || 0), 0);
  return total.toFixed(2);
}
function extractRoles(program) {
  const resourcePlan = parseField(program?.resourcePlan);
  const allocations = resourcePlan?.allocations || [];
  const roles = /* @__PURE__ */ new Set();
  for (const alloc of allocations) {
    if (alloc.role) roles.add(alloc.role);
    if (alloc.resourceType) roles.add(alloc.resourceType);
  }
  if (roles.size === 0) {
    return ["Project Manager", "Lead", "Developer", "Analyst"];
  }
  return Array.from(roles);
}
function findAssignment(assignments, wsId, delId, role) {
  return assignments.find(
    (a) => a.workstreamId === wsId && a.deliverableId === delId && (a.role === role || a.assignee === role)
  );
}
var init_excel_exporter = __esm({
  "server/services/export/excel-exporter.ts"() {
    "use strict";
    init_base_exporter();
  }
});

// server/services/export/json-payloads.ts
function parseMaybeJson(value) {
  if (value === null || value === void 0) return null;
  if (typeof value === "object") return value;
  if (typeof value !== "string") return null;
  try {
    return JSON.parse(value);
  } catch {
    return null;
  }
}
function normalizeFrameworkName(value) {
  const key = value.toLowerCase().replace(/[\s-]+/g, "_");
  return FRAMEWORK_ALIASES[key] || null;
}
function uniqueNonEmpty(values) {
  const seen = /* @__PURE__ */ new Set();
  const out = [];
  for (const value of values) {
    if (!value) continue;
    if (seen.has(value)) continue;
    seen.add(value);
    out.push(value);
  }
  return out;
}
function normalizeFrameworkList(values) {
  return uniqueNonEmpty(
    values.map((value) => typeof value === "string" ? normalizeFrameworkName(value) : null)
  );
}
function deriveAuthoritativeFrameworks(strategy) {
  const journeySession = strategy.journeySession || {};
  const journeyType = typeof journeySession.journeyType === "string" ? journeySession.journeyType : null;
  if (journeyType) {
    try {
      const journey = getJourney(journeyType);
      if (journey && Array.isArray(journey.frameworks)) {
        const fromJourney = normalizeFrameworkList(journey.frameworks);
        if (fromJourney.length > 0) return fromJourney;
      }
    } catch {
    }
  }
  const metadata = parseMaybeJson(journeySession.metadata) || {};
  const fromMetadata = Array.isArray(metadata.frameworks) ? normalizeFrameworkList(metadata.frameworks) : [];
  if (fromMetadata.length > 0) return fromMetadata;
  return [];
}
function deriveFrameworks(strategy, analysisData) {
  const authoritative = deriveAuthoritativeFrameworks(strategy);
  if (authoritative.length > 0) {
    return authoritative;
  }
  const fromAnalysisArray = Array.isArray(analysisData.frameworks) ? normalizeFrameworkList(analysisData.frameworks) : [];
  const fromJourneySession = Array.isArray(strategy.journeySession?.completedFrameworks) ? normalizeFrameworkList(strategy.journeySession?.completedFrameworks) : [];
  if (fromJourneySession.length > 0) return fromJourneySession;
  if (fromAnalysisArray.length > 0) return fromAnalysisArray;
  return [];
}
function getFiveWhys(analysisData) {
  const fromSnake = parseMaybeJson(analysisData.five_whys);
  if (fromSnake) return fromSnake;
  const fromCamel = parseMaybeJson(analysisData.fiveWhys);
  if (fromCamel) return fromCamel;
  return {};
}
function deriveWhysPath(strategy, fiveWhys) {
  const nestedParsed = parseMaybeJson(fiveWhys.whysPath);
  const nestedNormalized = normalizeWhysPathSteps(Array.isArray(nestedParsed) ? nestedParsed : []);
  if (nestedNormalized.length > 0) return nestedNormalized;
  const topLevel = Array.isArray(strategy.whysPath) ? normalizeWhysPathSteps(strategy.whysPath) : [];
  return topLevel;
}
function deriveRootCause(fiveWhys, analysisData) {
  const candidates = [
    analysisData.root_cause,
    analysisData.rootCause,
    fiveWhys.root_cause,
    fiveWhys.rootCause,
    fiveWhys.primaryRootCause
  ];
  for (const candidate of candidates) {
    if (typeof candidate === "string" && candidate.trim().length > 0) {
      return candidate;
    }
  }
  return null;
}
function deriveStrategicImplications(fiveWhys, analysisData) {
  const candidates = [
    analysisData.strategic_implications,
    analysisData.strategicImplications,
    fiveWhys.strategic_implications,
    fiveWhys.strategicImplications
  ];
  for (const candidate of candidates) {
    if (Array.isArray(candidate)) {
      return candidate.filter((v) => typeof v === "string" && v.trim().length > 0);
    }
  }
  return [];
}
function deriveResources(resourcePlan) {
  if (!resourcePlan || typeof resourcePlan !== "object") return [];
  const internal = Array.isArray(resourcePlan.internalTeam) ? resourcePlan.internalTeam.map((resource) => ({
    ...resource,
    resourceType: "internal"
  })) : [];
  const external = Array.isArray(resourcePlan.externalResources) ? resourcePlan.externalResources.map((resource) => ({
    ...resource,
    resourceType: "external"
  })) : [];
  return [...internal, ...external];
}
function deriveRiskList(riskRegister) {
  if (!riskRegister) return [];
  if (Array.isArray(riskRegister)) return riskRegister;
  if (Array.isArray(riskRegister.risks)) return riskRegister.risks;
  return [];
}
function deriveBenefitList(benefitsRealization) {
  if (!benefitsRealization) return [];
  if (Array.isArray(benefitsRealization)) return benefitsRealization;
  if (Array.isArray(benefitsRealization.benefits)) return benefitsRealization.benefits;
  return [];
}
function computeLongestDependencyChain(workstreams2) {
  if (!Array.isArray(workstreams2) || workstreams2.length === 0) return [];
  const byId = /* @__PURE__ */ new Map();
  const inDegree = /* @__PURE__ */ new Map();
  const dependents = /* @__PURE__ */ new Map();
  for (const ws2 of workstreams2) {
    if (typeof ws2?.id !== "string") continue;
    byId.set(ws2.id, ws2);
    inDegree.set(ws2.id, 0);
    dependents.set(ws2.id, []);
  }
  for (const ws2 of workstreams2) {
    if (typeof ws2?.id !== "string") continue;
    for (const depId of ws2.dependencies || []) {
      if (!byId.has(depId)) continue;
      inDegree.set(ws2.id, (inDegree.get(ws2.id) || 0) + 1);
      dependents.get(depId)?.push(ws2.id);
    }
  }
  const queue = [];
  inDegree.forEach((degree, id) => {
    if (degree === 0) queue.push(id);
  });
  const topo = [];
  while (queue.length > 0) {
    const id = queue.shift();
    topo.push(id);
    for (const dependentId of dependents.get(id) || []) {
      const next = (inDegree.get(dependentId) || 0) - 1;
      inDegree.set(dependentId, next);
      if (next === 0) queue.push(dependentId);
    }
  }
  if (topo.length !== byId.size) return [];
  const scoreById = /* @__PURE__ */ new Map();
  const predecessorById = /* @__PURE__ */ new Map();
  for (const id of topo) {
    const ws2 = byId.get(id);
    const startMonth = Number(ws2?.startMonth ?? 0);
    const endMonth = Number(ws2?.endMonth ?? startMonth);
    const duration = Math.max(1, endMonth - startMonth + 1);
    let bestPred = null;
    let bestScore = 0;
    for (const depId of ws2.dependencies || []) {
      const depScore = scoreById.get(depId);
      if (depScore === void 0) continue;
      if (depScore > bestScore) {
        bestScore = depScore;
        bestPred = depId;
      }
    }
    scoreById.set(id, duration + bestScore);
    predecessorById.set(id, bestPred);
  }
  let bestId = null;
  let best = -1;
  scoreById.forEach((score, id) => {
    if (score > best) {
      best = score;
      bestId = id;
    }
  });
  if (!bestId) return [];
  const path3 = [];
  let cursor = bestId;
  while (cursor) {
    path3.push(cursor);
    cursor = predecessorById.get(cursor) || null;
  }
  return path3.reverse();
}
function normalizeTimeline(program, workstreams2) {
  const timeline = parseMaybeJson(program.timeline) || {};
  const maxWorkstreamEnd = workstreams2.reduce(
    (max3, ws2) => Math.max(max3, Number(ws2?.endMonth) || 0),
    0
  );
  const totalMonths = Math.max(Number(timeline.totalMonths) || 0, maxWorkstreamEnd);
  const phases = Array.isArray(timeline.phases) ? [...timeline.phases] : [];
  const phaseMaxEnd = phases.reduce((max3, phase) => {
    return Math.max(max3, Number(phase?.endMonth) || 0);
  }, 0);
  if (maxWorkstreamEnd > 0 && phases.length > 0 && phaseMaxEnd < maxWorkstreamEnd) {
    const last = phases[phases.length - 1];
    phases[phases.length - 1] = {
      ...last,
      endMonth: maxWorkstreamEnd
    };
  } else if (maxWorkstreamEnd > 0 && phases.length === 0) {
    phases.push({
      phase: 1,
      name: "Execution",
      startMonth: 0,
      endMonth: maxWorkstreamEnd,
      description: "Program execution",
      keyMilestones: [],
      workstreamIds: workstreams2.map((ws2) => ws2?.id).filter((id) => typeof id === "string")
    });
  }
  const longestChain = computeLongestDependencyChain(workstreams2);
  const criticalPath = longestChain.length > 0 ? longestChain : Array.isArray(timeline.criticalPath) ? timeline.criticalPath : [];
  return {
    ...timeline,
    totalMonths,
    phases,
    criticalPath
  };
}
function buildStrategyJsonPayload(strategy) {
  const parsedAnalysisData = parseMaybeJson(strategy.strategyVersion?.analysisData) || {};
  const fiveWhys = getFiveWhys(parsedAnalysisData);
  const frameworks = deriveFrameworks(strategy, parsedAnalysisData);
  const whysPath = deriveWhysPath(strategy, fiveWhys);
  const rootCause = deriveRootCause(fiveWhys, parsedAnalysisData);
  const strategicImplications = deriveStrategicImplications(fiveWhys, parsedAnalysisData);
  return {
    ...strategy,
    strategyVersion: strategy.strategyVersion ? {
      ...strategy.strategyVersion,
      analysisData: parsedAnalysisData
    } : strategy.strategyVersion,
    frameworks,
    whysPath,
    rootCause,
    strategicImplications
  };
}
function buildEpmJsonPayload(epm) {
  const program = epm.program || {};
  const workstreams2 = parseMaybeJson(program.workstreams) || [];
  const timeline = normalizeTimeline(program, workstreams2);
  const resourcePlan = parseMaybeJson(program.resourcePlan);
  const riskRegister = parseMaybeJson(program.riskRegister);
  const benefitsRealization = parseMaybeJson(program.benefitsRealization);
  const stageGates2 = parseMaybeJson(program.stageGates);
  const normalizedProgram = {
    ...program,
    workstreams: workstreams2,
    timeline,
    resourcePlan,
    riskRegister,
    benefitsRealization,
    stageGates: stageGates2 || program.stageGates
  };
  return {
    ...epm,
    program: normalizedProgram,
    workstreams: workstreams2,
    resourcePlan,
    resources: deriveResources(resourcePlan),
    riskRegister,
    risks: deriveRiskList(riskRegister),
    benefitsRealization,
    benefits: deriveBenefitList(benefitsRealization)
  };
}
var FRAMEWORK_ALIASES;
var init_json_payloads = __esm({
  "server/services/export/json-payloads.ts"() {
    "use strict";
    init_journey_registry();
    init_whys_path();
    FRAMEWORK_ALIASES = {
      five_whys: "five_whys",
      fivewhys: "five_whys",
      bmc: "bmc",
      bmc_research: "bmc",
      porters: "porters",
      porters_analysis: "porters",
      pestle: "pestle",
      swot: "swot",
      ansoff: "ansoff",
      blue_ocean: "blue_ocean",
      blueocean: "blue_ocean",
      segment_discovery: "segment_discovery",
      competitive_positioning: "competitive_positioning",
      ocean_strategy: "ocean_strategy",
      bcg_matrix: "bcg_matrix",
      value_chain: "value_chain",
      vrio: "vrio",
      scenario_planning: "scenario_planning",
      jobs_to_be_done: "jobs_to_be_done",
      okr_generator: "okr_generator"
    };
  }
});

// server/intelligence/epm/validators/validator-registry.ts
var ValidatorRegistry, validatorRegistry;
var init_validator_registry = __esm({
  "server/intelligence/epm/validators/validator-registry.ts"() {
    "use strict";
    ValidatorRegistry = class {
      validators = /* @__PURE__ */ new Map();
      register(validator) {
        if (this.validators.has(validator.name)) {
          console.warn(`[ValidatorRegistry] Validator "${validator.name}" already registered, overwriting`);
        }
        this.validators.set(validator.name, validator);
        console.log(`[ValidatorRegistry] Registered validator: ${validator.name}`);
      }
      unregister(name) {
        return this.validators.delete(name);
      }
      get(name) {
        return this.validators.get(name);
      }
      list() {
        return Array.from(this.validators.keys());
      }
      runAll(context) {
        const startTime = Date.now();
        const validatorResults = [];
        const allCorrections = [];
        let errorCount = 0;
        let warningCount = 0;
        let infoCount = 0;
        for (const [name, validator] of Array.from(this.validators.entries())) {
          try {
            const result = validator.validate(context);
            validatorResults.push(result);
            allCorrections.push(...result.corrections);
            for (const issue of result.issues) {
              switch (issue.severity) {
                case "error":
                  errorCount++;
                  break;
                case "warning":
                  warningCount++;
                  break;
                case "info":
                  infoCount++;
                  break;
              }
            }
          } catch (err) {
            console.error(`[ValidatorRegistry] Validator "${name}" threw error:`, err);
            validatorResults.push({
              validatorName: name,
              passed: false,
              issues: [{
                severity: "error",
                code: "VALIDATOR_ERROR",
                message: `Validator threw exception: ${err instanceof Error ? err.message : String(err)}`
              }],
              corrections: []
            });
            errorCount++;
          }
        }
        return {
          overallPassed: errorCount === 0,
          totalIssues: errorCount + warningCount + infoCount,
          errorCount,
          warningCount,
          infoCount,
          validatorResults,
          corrections: allCorrections,
          timestamp: /* @__PURE__ */ new Date(),
          durationMs: Date.now() - startTime
        };
      }
      runSelected(context, validatorNames) {
        const startTime = Date.now();
        const validatorResults = [];
        const allCorrections = [];
        let errorCount = 0;
        let warningCount = 0;
        let infoCount = 0;
        for (const name of validatorNames) {
          const validator = this.validators.get(name);
          if (!validator) {
            validatorResults.push({
              validatorName: name,
              passed: false,
              issues: [{
                severity: "error",
                code: "VALIDATOR_NOT_FOUND",
                message: `Validator "${name}" not registered`
              }],
              corrections: []
            });
            errorCount++;
            continue;
          }
          try {
            const result = validator.validate(context);
            validatorResults.push(result);
            allCorrections.push(...result.corrections);
            for (const issue of result.issues) {
              switch (issue.severity) {
                case "error":
                  errorCount++;
                  break;
                case "warning":
                  warningCount++;
                  break;
                case "info":
                  infoCount++;
                  break;
              }
            }
          } catch (err) {
            console.error(`[ValidatorRegistry] Validator "${name}" threw error:`, err);
            validatorResults.push({
              validatorName: name,
              passed: false,
              issues: [{
                severity: "error",
                code: "VALIDATOR_ERROR",
                message: `Validator threw exception: ${err instanceof Error ? err.message : String(err)}`
              }],
              corrections: []
            });
            errorCount++;
          }
        }
        return {
          overallPassed: errorCount === 0,
          totalIssues: errorCount + warningCount + infoCount,
          errorCount,
          warningCount,
          infoCount,
          validatorResults,
          corrections: allCorrections,
          timestamp: /* @__PURE__ */ new Date(),
          durationMs: Date.now() - startTime
        };
      }
    };
    validatorRegistry = new ValidatorRegistry();
  }
});

// server/intelligence/epm/validators/base-validator.ts
var BaseValidator;
var init_base_validator = __esm({
  "server/intelligence/epm/validators/base-validator.ts"() {
    "use strict";
    BaseValidator = class {
      createIssue(severity, code, message, options) {
        return {
          severity,
          code,
          message,
          ...options
        };
      }
      createResult(passed, issues, corrections = [], metadata) {
        return {
          validatorName: this.name,
          passed,
          issues,
          corrections,
          metadata
        };
      }
    };
  }
});

// server/intelligence/epm/validators/dependency-validator.ts
var DependencyValidator;
var init_dependency_validator = __esm({
  "server/intelligence/epm/validators/dependency-validator.ts"() {
    "use strict";
    init_base_validator();
    DependencyValidator = class extends BaseValidator {
      name = "DependencyValidator";
      description = "Validates workstream dependency timing and logical consistency";
      validate(context) {
        const issues = [];
        const corrections = [];
        const { workstreams: workstreams2 } = context;
        for (const workstream of workstreams2) {
          this.validateDependencyExists(workstream, workstreams2, issues);
          this.validateDependencyTiming(workstream, workstreams2, issues, corrections);
          this.validateCircularDependencies(workstream, workstreams2, issues);
        }
        return this.createResult(
          issues.filter((i) => i.severity === "error").length === 0,
          issues,
          corrections
        );
      }
      validateDependencyExists(workstream, allWorkstreams, issues) {
        for (const depId of workstream.dependencies) {
          const dependency = allWorkstreams.find((w) => w.id === depId);
          if (!dependency) {
            issues.push(this.createIssue(
              "error",
              "DEP_NOT_FOUND",
              `Workstream "${workstream.name}" depends on non-existent workstream "${depId}"`,
              {
                workstreamId: workstream.id,
                field: "dependencies",
                suggestion: `Remove invalid dependency "${depId}" or add the missing workstream`
              }
            ));
          }
        }
      }
      validateDependencyTiming(workstream, allWorkstreams, issues, corrections) {
        for (const depId of workstream.dependencies) {
          const dependency = allWorkstreams.find((w) => w.id === depId);
          if (!dependency) continue;
          if (dependency.endMonth >= workstream.startMonth) {
            issues.push(this.createIssue(
              "warning",
              "DEP_TIMING_INVALID",
              `"${workstream.name}" (M${workstream.startMonth}) starts before/during "${dependency.name}" (ends M${dependency.endMonth})`,
              {
                workstreamId: workstream.id,
                field: "startMonth",
                suggestion: `Shift "${workstream.name}" to start after M${dependency.endMonth}`
              }
            ));
            const oldStart = workstream.startMonth;
            const duration = workstream.endMonth - oldStart;
            workstream.startMonth = dependency.endMonth + 1;
            workstream.endMonth = workstream.startMonth + duration;
            corrections.push(
              `Adjusted "${workstream.name}" from M${oldStart} to M${workstream.startMonth} to respect dependency`
            );
            this.adjustDeliverables(workstream, oldStart, corrections);
          }
        }
      }
      adjustDeliverables(workstream, oldStart, corrections) {
        for (const deliverable of workstream.deliverables) {
          if (deliverable.dueMonth < workstream.startMonth || deliverable.dueMonth > workstream.endMonth) {
            const originalDue = deliverable.dueMonth;
            deliverable.dueMonth = Math.max(
              workstream.startMonth,
              Math.min(deliverable.dueMonth, workstream.endMonth)
            );
            corrections.push(
              `Re-clamped deliverable "${deliverable.name}" from M${originalDue} to M${deliverable.dueMonth}`
            );
          }
        }
      }
      validateCircularDependencies(workstream, allWorkstreams, issues) {
        const visited = /* @__PURE__ */ new Set();
        const path3 = [];
        const hasCycle = (wsId) => {
          if (path3.includes(wsId)) {
            return true;
          }
          if (visited.has(wsId)) {
            return false;
          }
          visited.add(wsId);
          path3.push(wsId);
          const ws2 = allWorkstreams.find((w) => w.id === wsId);
          if (ws2) {
            for (const depId of ws2.dependencies) {
              if (hasCycle(depId)) {
                return true;
              }
            }
          }
          path3.pop();
          return false;
        };
        if (hasCycle(workstream.id)) {
          issues.push(this.createIssue(
            "error",
            "CIRCULAR_DEPENDENCY",
            `Circular dependency detected involving workstream "${workstream.name}"`,
            {
              workstreamId: workstream.id,
              field: "dependencies",
              suggestion: "Review and break the circular dependency chain"
            }
          ));
        }
      }
    };
  }
});

// server/intelligence/epm/validators/industry-validator.ts
var IndustryValidator;
var init_industry_validator = __esm({
  "server/intelligence/epm/validators/industry-validator.ts"() {
    "use strict";
    init_base_validator();
    IndustryValidator = class extends BaseValidator {
      name = "IndustryValidator";
      description = "Detects cross-industry template contamination in workstreams";
      industryKeywords = {
        food_service: ["food safety", "kitchen", "restaurant", "menu", "chef", "dining", "catering", "culinary", "food handling", "haccp"],
        healthcare: ["hipaa", "patient", "clinical", "medical", "healthcare", "pharmacy", "hospital", "diagnosis", "treatment"],
        finance: ["banking", "trading", "securities", "investment", "loan", "credit", "forex", "asset management"],
        manufacturing: ["assembly line", "production floor", "quality control", "lean manufacturing", "six sigma", "warehouse"],
        retail: ["inventory", "point of sale", "merchandising", "storefront", "e-commerce", "fulfillment"],
        technology: ["software development", "devops", "api", "database", "cloud", "agile", "sprint"],
        education: ["curriculum", "enrollment", "student", "faculty", "academic", "campus"],
        construction: ["site safety", "building permit", "contractor", "blueprints", "construction site"],
        hospitality: ["hotel", "guest services", "booking", "concierge", "housekeeping"],
        transportation: ["logistics", "fleet management", "route optimization", "cargo", "freight"]
      };
      validate(context) {
        const issues = [];
        const { workstreams: workstreams2, businessContext } = context;
        if (!businessContext) {
          return this.createResult(true, [], [], { skipped: true, reason: "No business context provided" });
        }
        const contextLower = businessContext.toLowerCase();
        const detectedIndustries = [];
        for (const [industry, keywords] of Object.entries(this.industryKeywords)) {
          if (keywords.some((kw) => contextLower.includes(kw))) {
            detectedIndustries.push(industry);
          }
        }
        for (const workstream of workstreams2) {
          const wsContent = `${workstream.name} ${workstream.description || ""}`.toLowerCase();
          for (const [industry, keywords] of Object.entries(this.industryKeywords)) {
            if (detectedIndustries.includes(industry)) continue;
            const matchedKeyword = keywords.find((kw) => wsContent.includes(kw));
            if (matchedKeyword) {
              issues.push(this.createIssue(
                "warning",
                "INDUSTRY_MISMATCH",
                `Workstream "${workstream.name}" contains "${matchedKeyword}" (${industry} industry term)`,
                {
                  workstreamId: workstream.id,
                  suggestion: `Review if this workstream is appropriate for your business context: ${businessContext}`
                }
              ));
            }
          }
        }
        return this.createResult(
          true,
          issues,
          [],
          {
            detectedIndustries,
            workstreamsChecked: workstreams2.length,
            mismatches: issues.length
          }
        );
      }
    };
  }
});

// server/intelligence/epm/validators/completeness-validator.ts
var CompletenessValidator;
var init_completeness_validator = __esm({
  "server/intelligence/epm/validators/completeness-validator.ts"() {
    "use strict";
    init_base_validator();
    CompletenessValidator = class extends BaseValidator {
      name = "CompletenessValidator";
      description = "Ensures all required EPM fields are populated with meaningful values";
      validate(context) {
        const issues = [];
        const { workstreams: workstreams2, timeline, stageGates: stageGates2 } = context;
        this.validateWorkstreams(workstreams2, issues);
        this.validateTimeline(timeline, issues);
        this.validateStageGates(stageGates2, issues);
        return this.createResult(
          issues.filter((i) => i.severity === "error").length === 0,
          issues,
          []
        );
      }
      validateWorkstreams(workstreams2, issues) {
        if (workstreams2.length === 0) {
          issues.push(this.createIssue(
            "error",
            "NO_WORKSTREAMS",
            "No workstreams defined in the EPM program",
            { suggestion: "Add at least one workstream to the program" }
          ));
          return;
        }
        for (const ws2 of workstreams2) {
          if (!ws2.name || ws2.name.trim().length === 0) {
            issues.push(this.createIssue(
              "error",
              "MISSING_WS_NAME",
              `Workstream ${ws2.id} has no name`,
              { workstreamId: ws2.id, field: "name" }
            ));
          }
          if (!ws2.description || ws2.description.trim().length === 0) {
            issues.push(this.createIssue(
              "warning",
              "MISSING_WS_DESCRIPTION",
              `Workstream "${ws2.name}" has no description`,
              { workstreamId: ws2.id, field: "description" }
            ));
          }
          if (ws2.deliverables.length === 0) {
            issues.push(this.createIssue(
              "warning",
              "NO_DELIVERABLES",
              `Workstream "${ws2.name}" has no deliverables`,
              { workstreamId: ws2.id, field: "deliverables", suggestion: "Add at least one deliverable" }
            ));
          }
          if (ws2.startMonth < 0) {
            issues.push(this.createIssue(
              "error",
              "INVALID_START_MONTH",
              `Workstream "${ws2.name}" has invalid start month: ${ws2.startMonth}`,
              { workstreamId: ws2.id, field: "startMonth" }
            ));
          }
          if (ws2.endMonth < ws2.startMonth) {
            issues.push(this.createIssue(
              "error",
              "INVALID_DURATION",
              `Workstream "${ws2.name}" ends (M${ws2.endMonth}) before it starts (M${ws2.startMonth})`,
              { workstreamId: ws2.id, field: "endMonth" }
            ));
          }
          for (const del of ws2.deliverables) {
            if (!del.name || del.name.trim().length === 0) {
              issues.push(this.createIssue(
                "error",
                "MISSING_DELIVERABLE_NAME",
                `Deliverable ${del.id} in "${ws2.name}" has no name`,
                { workstreamId: ws2.id, field: `deliverables.${del.id}.name` }
              ));
            }
          }
        }
      }
      validateTimeline(timeline, issues) {
        if (!timeline) {
          issues.push(this.createIssue(
            "error",
            "NO_TIMELINE",
            "No timeline defined for the EPM program",
            { suggestion: "Generate a timeline with phases and milestones" }
          ));
          return;
        }
        if (!timeline.phases || timeline.phases.length === 0) {
          issues.push(this.createIssue(
            "warning",
            "NO_PHASES",
            "Timeline has no phases defined",
            { suggestion: "Add at least one phase to the timeline" }
          ));
        }
        if (timeline.totalMonths <= 0) {
          issues.push(this.createIssue(
            "error",
            "INVALID_DURATION",
            `Invalid total program duration: ${timeline.totalMonths} months`,
            { field: "timeline.totalMonths" }
          ));
        }
      }
      validateStageGates(stageGates2, issues) {
        if (!stageGates2) {
          issues.push(this.createIssue(
            "warning",
            "NO_STAGE_GATES",
            "No stage gates defined for the EPM program",
            { suggestion: "Add stage gates for phase completion reviews" }
          ));
          return;
        }
        if (!stageGates2.gates || stageGates2.gates.length === 0) {
          issues.push(this.createIssue(
            "warning",
            "EMPTY_STAGE_GATES",
            "Stage gates array is empty",
            { suggestion: "Add at least one stage gate" }
          ));
        }
        for (const gate of stageGates2.gates || []) {
          if (!gate.goCriteria || gate.goCriteria.length === 0) {
            issues.push(this.createIssue(
              "warning",
              "NO_GO_CRITERIA",
              `Stage gate ${gate.gate} has no go/no-go criteria`,
              { field: `stageGates.gates[${gate.gate}].goCriteria` }
            ));
          }
        }
      }
    };
  }
});

// server/intelligence/epm/validators/quality-gate-runner.ts
var QualityGateRunner, qualityGateRunner;
var init_quality_gate_runner = __esm({
  "server/intelligence/epm/validators/quality-gate-runner.ts"() {
    "use strict";
    init_validator_registry();
    init_dependency_validator();
    init_industry_validator();
    init_completeness_validator();
    QualityGateRunner = class {
      registry;
      initialized = false;
      constructor(registry) {
        this.registry = registry || validatorRegistry;
      }
      initialize() {
        if (this.initialized) return;
        this.registry.register(new DependencyValidator());
        this.registry.register(new IndustryValidator());
        this.registry.register(new CompletenessValidator());
        this.initialized = true;
        console.log("[QualityGateRunner] Initialized with validators:", this.registry.list().join(", "));
      }
      runQualityGate(workstreams2, timeline, stageGates2, businessContext) {
        if (!this.initialized) {
          this.initialize();
        }
        const context = {
          workstreams: workstreams2,
          timeline,
          stageGates: stageGates2,
          businessContext
        };
        console.log("[QualityGateRunner] Running quality gate with", this.registry.list().length, "validators");
        const report = this.registry.runAll(context);
        this.logReport(report);
        return report;
      }
      runSelectedValidators(workstreams2, timeline, stageGates2, validatorNames, businessContext) {
        if (!this.initialized) {
          this.initialize();
        }
        const context = {
          workstreams: workstreams2,
          timeline,
          stageGates: stageGates2,
          businessContext
        };
        const report = this.registry.runSelected(context, validatorNames);
        this.logReport(report);
        return report;
      }
      logReport(report) {
        const status = report.overallPassed ? "\u2705 PASSED" : "\u274C FAILED";
        console.log(`[QualityGateRunner] Quality Gate ${status}`);
        console.log(`  - Total issues: ${report.totalIssues} (${report.errorCount} errors, ${report.warningCount} warnings, ${report.infoCount} info)`);
        console.log(`  - Duration: ${report.durationMs}ms`);
        if (report.corrections.length > 0) {
          console.log(`  - Auto-corrections: ${report.corrections.length}`);
        }
        for (const result of report.validatorResults) {
          const icon = result.passed ? "\u2713" : "\u2717";
          console.log(`    ${icon} ${result.validatorName}: ${result.issues.length} issues`);
        }
      }
      getAvailableValidators() {
        if (!this.initialized) {
          this.initialize();
        }
        return this.registry.list();
      }
    };
    qualityGateRunner = new QualityGateRunner();
  }
});

// server/services/export/acceptance-gates.ts
function normalizeFramework(value) {
  const key = value.toLowerCase().replace(/[\s-]+/g, "_");
  return FRAMEWORK_ALIASES2[key] || null;
}
function normalizeFrameworkList2(values) {
  const out = [];
  const seen = /* @__PURE__ */ new Set();
  for (const value of values) {
    if (typeof value !== "string") continue;
    const normalized = normalizeFramework(value);
    if (!normalized || seen.has(normalized)) continue;
    seen.add(normalized);
    out.push(normalized);
  }
  return out;
}
function parseJson(value) {
  if (value === null || value === void 0) return null;
  if (typeof value === "object") return value;
  if (typeof value !== "string") return null;
  try {
    return JSON.parse(value);
  } catch {
    return null;
  }
}
function splitCsvRecords(csv) {
  const records = [];
  let current = "";
  let inQuotes = false;
  for (let i = 0; i < csv.length; i += 1) {
    const ch = csv[i];
    if (ch === '"') {
      const next = csv[i + 1];
      if (inQuotes && next === '"') {
        current += '"';
        i += 1;
      } else {
        inQuotes = !inQuotes;
      }
      continue;
    }
    if ((ch === "\n" || ch === "\r") && !inQuotes) {
      if (ch === "\r" && csv[i + 1] === "\n") i += 1;
      records.push(current);
      current = "";
      continue;
    }
    current += ch;
  }
  if (current.length > 0 || csv.endsWith("\n") || csv.endsWith("\r")) {
    records.push(current);
  }
  return records.filter((record) => record.trim().length > 0);
}
function countCsvRows(csv) {
  if (!csv || csv.trim().length === 0) return 0;
  const records = splitCsvRecords(csv);
  if (records.length === 0) return 0;
  return Math.max(0, records.length - 1);
}
function deriveExpectedFrameworks(strategyData) {
  const journeySession = strategyData?.journeySession || {};
  const journeyType = typeof journeySession.journeyType === "string" ? journeySession.journeyType : null;
  if (journeyType) {
    try {
      const journey = getJourney(journeyType);
      if (journey && Array.isArray(journey.frameworks)) {
        const fromJourney = normalizeFrameworkList2(journey.frameworks);
        if (fromJourney.length > 0) return fromJourney;
      }
    } catch {
    }
  }
  const metadata = parseJson(journeySession.metadata) || {};
  if (Array.isArray(metadata.frameworks)) {
    return normalizeFrameworkList2(metadata.frameworks);
  }
  return [];
}
function arraysEqualStrict(a, b) {
  if (a.length !== b.length) return false;
  return a.every((value, index2) => b[index2] === value);
}
function normalizeCriticalPathToIds(criticalPath, workstreams2) {
  const byId = /* @__PURE__ */ new Map();
  const byName = /* @__PURE__ */ new Map();
  for (const ws2 of workstreams2) {
    const id = typeof ws2.id === "string" ? ws2.id : null;
    const name = typeof ws2.name === "string" ? ws2.name : null;
    if (!id) continue;
    byId.set(id.toLowerCase(), id);
    if (name) byName.set(name.toLowerCase(), id);
  }
  const normalized = [];
  for (const item of criticalPath) {
    if (typeof item !== "string") continue;
    const key = item.toLowerCase();
    const matched = byId.get(key) || byName.get(key);
    if (matched) normalized.push(matched);
  }
  return normalized;
}
function computeLongestDependencyChain2(workstreams2) {
  if (!Array.isArray(workstreams2) || workstreams2.length === 0) return [];
  const byId = /* @__PURE__ */ new Map();
  const inDegree = /* @__PURE__ */ new Map();
  const dependents = /* @__PURE__ */ new Map();
  for (const ws2 of workstreams2) {
    if (typeof ws2?.id !== "string") continue;
    byId.set(ws2.id, ws2);
    inDegree.set(ws2.id, 0);
    dependents.set(ws2.id, []);
  }
  for (const ws2 of workstreams2) {
    if (typeof ws2?.id !== "string") continue;
    for (const depId of ws2.dependencies || []) {
      if (!byId.has(depId)) continue;
      inDegree.set(ws2.id, (inDegree.get(ws2.id) || 0) + 1);
      dependents.get(depId)?.push(ws2.id);
    }
  }
  const queue = [];
  inDegree.forEach((degree, id) => {
    if (degree === 0) queue.push(id);
  });
  const topo = [];
  while (queue.length > 0) {
    const id = queue.shift();
    topo.push(id);
    for (const dependentId of dependents.get(id) || []) {
      const next = (inDegree.get(dependentId) || 0) - 1;
      inDegree.set(dependentId, next);
      if (next === 0) queue.push(dependentId);
    }
  }
  if (topo.length !== byId.size) return [];
  const scoreById = /* @__PURE__ */ new Map();
  const predecessorById = /* @__PURE__ */ new Map();
  for (const id of topo) {
    const ws2 = byId.get(id);
    const startMonth = Number(ws2?.startMonth ?? 0);
    const endMonth = Number(ws2?.endMonth ?? startMonth);
    const duration = Math.max(1, endMonth - startMonth + 1);
    let bestPred = null;
    let bestScore = 0;
    for (const depId of ws2.dependencies || []) {
      const depScore = scoreById.get(depId);
      if (depScore === void 0) continue;
      if (depScore > bestScore) {
        bestScore = depScore;
        bestPred = depId;
      }
    }
    scoreById.set(id, duration + bestScore);
    predecessorById.set(id, bestPred);
  }
  let bestId = null;
  let best = -1;
  scoreById.forEach((score, id) => {
    if (score > best) {
      best = score;
      bestId = id;
    }
  });
  if (!bestId) return [];
  const path3 = [];
  let cursor = bestId;
  while (cursor) {
    path3.push(cursor);
    cursor = predecessorById.get(cursor) || null;
  }
  return path3.reverse();
}
function validateExportAcceptance(input) {
  const criticalIssues = [];
  const warnings = [];
  const strategyData = parseJson(input.strategyJson);
  if (!strategyData) {
    return {
      passed: false,
      criticalIssues: [{
        severity: "critical",
        code: "INVALID_STRATEGY_JSON",
        message: "strategy.json is not valid JSON"
      }],
      warnings
    };
  }
  const expectedFrameworks = deriveExpectedFrameworks(strategyData);
  const actualFrameworks = normalizeFrameworkList2(Array.isArray(strategyData.frameworks) ? strategyData.frameworks : []);
  if (expectedFrameworks.length > 0 && !arraysEqualStrict(actualFrameworks, expectedFrameworks)) {
    criticalIssues.push({
      severity: "critical",
      code: "FRAMEWORK_MISMATCH",
      message: "Exported frameworks do not match journey definition exactly",
      details: {
        expected: expectedFrameworks,
        actual: actualFrameworks
      }
    });
  }
  if (!input.epmJson) {
    warnings.push({
      severity: "warning",
      code: "NO_EPM_JSON",
      message: "EPM JSON not present; EPM acceptance gates skipped"
    });
    return { passed: criticalIssues.length === 0, criticalIssues, warnings };
  }
  const epmData = parseJson(input.epmJson);
  if (!epmData) {
    criticalIssues.push({
      severity: "critical",
      code: "INVALID_EPM_JSON",
      message: "epm.json is not valid JSON"
    });
    return { passed: false, criticalIssues, warnings };
  }
  if (!epmData.program || typeof epmData.program !== "object") {
    criticalIssues.push({
      severity: "critical",
      code: "MISSING_EPM_PROGRAM",
      message: "epm.json is missing `program` section"
    });
  }
  const requiredArraySections = ["assignments", "workstreams", "resources", "risks", "benefits"];
  for (const section of requiredArraySections) {
    if (!Array.isArray(epmData[section])) {
      criticalIssues.push({
        severity: "critical",
        code: "MISSING_EPM_SECTION",
        message: `epm.json is missing required array section: ${section}`
      });
    }
  }
  const countChecks = [
    { name: "assignments", jsonCount: Array.isArray(epmData.assignments) ? epmData.assignments.length : 0, csv: input.assignmentsCsv },
    { name: "workstreams", jsonCount: Array.isArray(epmData.workstreams) ? epmData.workstreams.length : 0, csv: input.workstreamsCsv },
    { name: "resources", jsonCount: Array.isArray(epmData.resources) ? epmData.resources.length : 0, csv: input.resourcesCsv },
    { name: "risks", jsonCount: Array.isArray(epmData.risks) ? epmData.risks.length : 0, csv: input.risksCsv },
    { name: "benefits", jsonCount: Array.isArray(epmData.benefits) ? epmData.benefits.length : 0, csv: input.benefitsCsv }
  ];
  for (const check of countChecks) {
    const csvRows = countCsvRows(check.csv);
    if (!check.csv && check.jsonCount > 0) {
      criticalIssues.push({
        severity: "critical",
        code: "CSV_MISSING",
        message: `${check.name}.csv missing while epm.json has ${check.jsonCount} rows`
      });
      continue;
    }
    if (check.csv && csvRows !== check.jsonCount) {
      criticalIssues.push({
        severity: "critical",
        code: "CSV_JSON_COUNT_MISMATCH",
        message: `${check.name} count mismatch between epm.json and CSV`,
        details: { jsonCount: check.jsonCount, csvRows }
      });
    }
  }
  const workstreams2 = Array.isArray(epmData.workstreams) ? epmData.workstreams : [];
  const byId = /* @__PURE__ */ new Map();
  for (const ws2 of workstreams2) {
    if (typeof ws2?.id === "string") byId.set(ws2.id, ws2);
  }
  for (const ws2 of workstreams2) {
    const wsId = typeof ws2?.id === "string" ? ws2.id : "(unknown)";
    const wsName = typeof ws2?.name === "string" ? ws2.name : wsId;
    const startMonth = Number(ws2?.startMonth);
    const endMonth = Number(ws2?.endMonth);
    if (!Number.isFinite(startMonth) || !Number.isFinite(endMonth) || endMonth < startMonth) {
      criticalIssues.push({
        severity: "critical",
        code: "INVALID_TIMELINE_RANGE",
        message: `Workstream "${wsName}" has invalid start/end months`
      });
      continue;
    }
    for (const depId of ws2.dependencies || []) {
      const dep = byId.get(depId);
      if (!dep) {
        criticalIssues.push({
          severity: "critical",
          code: "INVALID_DEPENDENCY_REFERENCE",
          message: `Workstream "${wsName}" depends on missing workstream "${depId}"`
        });
        continue;
      }
      const depEnd = Number(dep.endMonth);
      if (Number.isFinite(depEnd) && depEnd >= startMonth) {
        criticalIssues.push({
          severity: "critical",
          code: "INVALID_DEPENDENCY_TIMING",
          message: `Workstream "${wsName}" starts before dependency "${dep.name || depId}" ends`,
          details: { startMonth, dependencyEndMonth: depEnd }
        });
      }
    }
  }
  const timeline = parseJson(epmData.program?.timeline) || epmData.program?.timeline || {};
  const stageGates2 = parseJson(epmData.program?.stageGates) || epmData.program?.stageGates || { gates: [] };
  const maxWorkstreamEnd = workstreams2.reduce(
    (max3, ws2) => Math.max(max3, Number(ws2?.endMonth) || 0),
    0
  );
  const phaseMaxEnd = Array.isArray(timeline?.phases) ? timeline.phases.reduce(
    (max3, phase) => Math.max(max3, Number(phase?.endMonth) || 0),
    0
  ) : 0;
  const totalMonths = Number(timeline?.totalMonths) || 0;
  if (maxWorkstreamEnd > 0 && (phaseMaxEnd < maxWorkstreamEnd || totalMonths < maxWorkstreamEnd)) {
    criticalIssues.push({
      severity: "critical",
      code: "TIMELINE_PHASE_COVERAGE",
      message: "Timeline phases/total months do not cover full workstream span",
      details: {
        totalMonths,
        phaseMaxEnd,
        maxWorkstreamEnd
      }
    });
  }
  const hasDependencies = workstreams2.some((ws2) => Array.isArray(ws2.dependencies) && ws2.dependencies.length > 0);
  const expectedCriticalPath = computeLongestDependencyChain2(workstreams2);
  const actualCriticalPath = normalizeCriticalPathToIds(Array.isArray(timeline?.criticalPath) ? timeline.criticalPath : [], workstreams2);
  if (hasDependencies && actualCriticalPath.length < 2) {
    criticalIssues.push({
      severity: "critical",
      code: "CRITICAL_PATH_INCOMPLETE",
      message: "Critical path does not include the dependency chain",
      details: { expected: expectedCriticalPath, actual: actualCriticalPath }
    });
  } else if (expectedCriticalPath.length > 0 && !arraysEqualStrict(actualCriticalPath, expectedCriticalPath)) {
    criticalIssues.push({
      severity: "critical",
      code: "CRITICAL_PATH_MISMATCH",
      message: "Critical path does not match the longest dependency chain",
      details: { expected: expectedCriticalPath, actual: actualCriticalPath }
    });
  }
  if (Array.isArray(workstreams2) && workstreams2.length > 0 && timeline && stageGates2) {
    const report = qualityGateRunner.runQualityGate(
      JSON.parse(JSON.stringify(workstreams2)),
      JSON.parse(JSON.stringify(timeline)),
      JSON.parse(JSON.stringify(stageGates2)),
      strategyData?.understanding?.initiativeType || strategyData?.understanding?.userInput || ""
    );
    if (report.errorCount > 0) {
      criticalIssues.push({
        severity: "critical",
        code: "VALIDATOR_CRITICAL_ISSUES",
        message: `Quality gate found ${report.errorCount} error-level issues`
      });
    }
  }
  return {
    passed: criticalIssues.length === 0,
    criticalIssues,
    warnings
  };
}
var FRAMEWORK_ALIASES2;
var init_acceptance_gates = __esm({
  "server/services/export/acceptance-gates.ts"() {
    "use strict";
    init_journey_registry();
    init_quality_gate_runner();
    FRAMEWORK_ALIASES2 = {
      five_whys: "five_whys",
      fivewhys: "five_whys",
      bmc: "bmc",
      bmc_research: "bmc",
      porters: "porters",
      porters_analysis: "porters",
      pestle: "pestle",
      swot: "swot",
      ansoff: "ansoff",
      blue_ocean: "blue_ocean",
      blueocean: "blue_ocean",
      segment_discovery: "segment_discovery",
      competitive_positioning: "competitive_positioning",
      ocean_strategy: "ocean_strategy",
      bcg_matrix: "bcg_matrix",
      value_chain: "value_chain",
      vrio: "vrio",
      scenario_planning: "scenario_planning",
      jobs_to_be_done: "jobs_to_be_done",
      okr_generator: "okr_generator"
    };
  }
});

// server/services/export/index.ts
import archiver from "archiver";
async function generateFullPassExport(request, outputStream) {
  const { sessionId, versionNumber, programId, userId } = request;
  console.log("[Export Service] Starting export generation:", { sessionId, versionNumber, programId, userId });
  console.log("[Export Service] Loading export data...");
  const exportPackage = await loadExportData(sessionId, versionNumber, programId, userId);
  console.log("[Export Service] Data loaded successfully. Version:", exportPackage.metadata.versionNumber);
  const skippedFiles = [];
  console.log("[Export Service] Generating Markdown report...");
  const markdown = generateMarkdownReport(exportPackage);
  console.log("[Export Service] Converting Markdown to HTML...");
  const html = await generateHtmlFromMarkdown(markdown);
  console.log("[Export Service] Generating PDF from HTML...");
  let pdf2 = null;
  try {
    pdf2 = await generatePdfFromHtml(html);
    console.log("[Export Service] PDF generated successfully");
  } catch (error) {
    const err = error;
    const errorMsg = err?.message || String(error);
    const isChromiumMissing = errorMsg.toLowerCase().includes("executable") || errorMsg.toLowerCase().includes("browser");
    if (isChromiumMissing) {
      console.warn("[Export Service] PDF generation skipped - Chromium not available. Install chromium to enable PDF exports.");
    } else {
      console.warn("[Export Service] PDF generation failed:", errorMsg);
    }
    skippedFiles.push(`report.pdf (${isChromiumMissing ? "Chromium not available" : "generation failed"})`);
  }
  console.log("[Export Service] Generating DOCX report...");
  const docx = await generateDocxReport(exportPackage);
  console.log("[Export Service] Generating JSON and CSV exports...");
  const strategyJson = JSON.stringify(buildStrategyJsonPayload(exportPackage.strategy), null, 2);
  const epmJson = exportPackage.epm?.program ? JSON.stringify(buildEpmJsonPayload(exportPackage.epm), null, 2) : null;
  const parseField2 = (field) => {
    if (!field) return null;
    if (typeof field === "object") return field;
    try {
      return JSON.parse(field);
    } catch {
      return null;
    }
  };
  const workstreams2 = parseField2(exportPackage.epm?.program?.workstreams);
  const assignmentsCsv = exportPackage.epm?.assignments ? generateAssignmentsCsv(exportPackage.epm.assignments, workstreams2 || []) : null;
  const workstreamsCsv = workstreams2 && workstreams2.length > 0 ? generateWorkstreamsCsv(workstreams2) : null;
  const resourcePlan = parseField2(exportPackage.epm?.program?.resourcePlan);
  const resourcesCsv = resourcePlan ? generateResourcesCsv(resourcePlan, exportPackage.epm?.assignments || []) : null;
  const riskRegister = parseField2(exportPackage.epm?.program?.riskRegister);
  const risksCsv = riskRegister ? generateRisksCsv(riskRegister) : null;
  const benefitsRealization = parseField2(exportPackage.epm?.program?.benefitsRealization);
  const benefitsCsv = benefitsRealization ? generateBenefitsCsv(benefitsRealization) : null;
  console.log("[Export Service] Running acceptance gates...");
  const acceptanceReport = validateExportAcceptance({
    strategyJson,
    epmJson,
    assignmentsCsv,
    workstreamsCsv,
    resourcesCsv,
    risksCsv,
    benefitsCsv
  });
  if (!acceptanceReport.passed) {
    acceptanceReport.criticalIssues.forEach((issue) => {
      console.error(`[Export Acceptance] ${issue.code}: ${issue.message}`);
      if (issue.details) {
        console.error("[Export Acceptance] Details:", issue.details);
      }
    });
    throw new Error(
      `Export acceptance gates failed with ${acceptanceReport.criticalIssues.length} critical issue(s)`
    );
  }
  console.log("[Export Service] Acceptance gates passed");
  if (acceptanceReport.warnings.length > 0) {
    acceptanceReport.warnings.forEach(
      (warning) => console.warn(`[Export Acceptance] ${warning.code}: ${warning.message}`)
    );
  }
  console.log("[Export Service] Generating UI-styled HTML...");
  const uiHtml = generateUiStyledHtml(exportPackage);
  console.log("[Export Service] Generating UI-styled PDF...");
  let uiPdf = null;
  try {
    uiPdf = await generatePdfFromUiHtml(uiHtml);
    console.log("[Export Service] UI-styled PDF generated successfully");
  } catch (error) {
    const err = error;
    const errorMsg = err?.message || String(error);
    const isChromiumMissing = errorMsg.toLowerCase().includes("executable") || errorMsg.toLowerCase().includes("browser");
    if (isChromiumMissing) {
      console.warn("[Export Service] UI-styled PDF generation skipped - Chromium not available. Install chromium to enable PDF exports.");
    } else {
      console.warn("[Export Service] UI-styled PDF generation failed:", errorMsg);
    }
    skippedFiles.push(`report-ui.pdf (${isChromiumMissing ? "Chromium not available" : "generation failed"})`);
  }
  console.log("[Export Service] Generating UI-styled DOCX...");
  const uiDocx = await generateDocxFromHtml(uiHtml);
  console.log("[Export Service] Generating Excel workbook...");
  let excelBuffer = null;
  try {
    excelBuffer = await generateExcelWorkbook(exportPackage);
    console.log("[Export Service] Excel workbook generated successfully");
  } catch (error) {
    console.warn("[Export Service] Excel generation failed:", error instanceof Error ? error.message : error);
    skippedFiles.push("epm-program.xlsx (generation failed)");
  }
  console.log("[Export Service] Creating ZIP archive...");
  const archive = archiver("zip", {
    zlib: { level: 9 }
  });
  archive.on("warning", (err) => {
    if (err.code === "ENOENT") {
      console.warn("[Export Service] Archive warning:", err);
    } else {
      throw err;
    }
  });
  archive.on("error", (err) => {
    console.error("[Export Service] Archive error:", err);
    throw err;
  });
  archive.pipe(outputStream);
  console.log("[Export Service] Adding files to archive...");
  const includedFiles = [];
  archive.append(markdown, { name: "report.md" });
  includedFiles.push("report.md");
  archive.append(docx, { name: "report.docx" });
  includedFiles.push("report.docx");
  archive.append(uiHtml, { name: "report-ui.html" });
  includedFiles.push("report-ui.html");
  archive.append(uiDocx, { name: "report-ui.docx" });
  includedFiles.push("report-ui.docx");
  if (pdf2) {
    archive.append(pdf2, { name: "report.pdf" });
    includedFiles.push("report.pdf");
  }
  if (uiPdf) {
    archive.append(uiPdf, { name: "report-ui.pdf" });
    includedFiles.push("report-ui.pdf");
  }
  archive.append(strategyJson, { name: "data/strategy.json" });
  includedFiles.push("data/strategy.json");
  if (epmJson) {
    console.log("[Export Service] Adding EPM data...");
    archive.append(epmJson, { name: "data/epm.json" });
    includedFiles.push("data/epm.json");
  }
  if (assignmentsCsv) {
    archive.append(assignmentsCsv, { name: "data/assignments.csv" });
    includedFiles.push("data/assignments.csv");
  }
  if (workstreamsCsv) {
    archive.append(workstreamsCsv, { name: "data/workstreams.csv" });
    includedFiles.push("data/workstreams.csv");
  }
  if (resourcesCsv) {
    archive.append(resourcesCsv, { name: "data/resources.csv" });
    includedFiles.push("data/resources.csv");
  }
  if (risksCsv) {
    archive.append(risksCsv, { name: "data/risks.csv" });
    includedFiles.push("data/risks.csv");
  }
  if (benefitsCsv) {
    archive.append(benefitsCsv, { name: "data/benefits.csv" });
    includedFiles.push("data/benefits.csv");
  }
  if (excelBuffer) {
    archive.append(excelBuffer, { name: "data/epm-program.xlsx" });
    includedFiles.push("data/epm-program.xlsx");
  }
  const readmeContent = `# Export Package Contents

This ZIP archive contains your strategic analysis and EPM program data in multiple formats.

## Included Files (${includedFiles.length}):

${includedFiles.map((f) => `- ${f}`).join("\n")}

${skippedFiles.length > 0 ? `## Note: Some Files Skipped

The following files could not be generated in this environment:

${skippedFiles.map((f) => `- ${f}`).join("\n")}

PDF files require Puppeteer (headless Chrome) which may not be available on mobile devices or certain environments. All other formats (Markdown, Word, HTML, JSON, CSV) are included.
` : ""}

## File Descriptions:

- **report.md** - Full Markdown report with all sections
- **report.docx** - Comprehensive Word document
- **report-ui.html** - HTML report with styled cards and tables
- **report-ui.docx** - Word document with styled layout
- **report.pdf** - PDF version (if available)
- **report-ui.pdf** - Styled PDF version (if available)
- **data/strategy.json** - Strategic analysis data in JSON
- **data/epm.json** - EPM program data (if generated)
- **data/epm-program.xlsx** - Excel workbook with 8 sheets (Summary, WBS, Schedule, Resources, Budget, RACI, Risks, Assumptions)
- **data/*.csv** - Detailed data exports for assignments, workstreams, resources, risks, and benefits

Generated on: ${new Date(exportPackage.metadata.exportedAt).toLocaleString()}
Session ID: ${exportPackage.metadata.sessionId}
${exportPackage.metadata.versionNumber ? `Version: ${exportPackage.metadata.versionNumber}` : ""}
`;
  archive.append(readmeContent, { name: "README.txt" });
  console.log("[Export Service] Finalizing archive...");
  console.log(`[Export Service] Archive contains ${includedFiles.length + 1} files (including README)`);
  if (skippedFiles.length > 0) {
    console.log(`[Export Service] ${skippedFiles.length} files were skipped due to Puppeteer unavailability`);
  }
  await archive.finalize();
  console.log("[Export Service] Export package created successfully");
}
var init_export = __esm({
  "server/services/export/index.ts"() {
    "use strict";
    init_base_exporter();
    init_markdown_exporter();
    init_html_exporter();
    init_pdf_exporter();
    init_docx_exporter();
    init_csv_exporter();
    init_excel_exporter();
    init_base_exporter();
    init_json_payloads();
    init_acceptance_gates();
  }
});

// src/lib/intelligent-planning/task-extractor.ts
function createTaskExtractor(llm2) {
  return new LLMTaskExtractor(llm2);
}
var LLMTaskExtractor;
var init_task_extractor = __esm({
  "src/lib/intelligent-planning/task-extractor.ts"() {
    "use strict";
    LLMTaskExtractor = class {
      constructor(llm2) {
        this.llm = llm2;
      }
      /**
       * Main extraction - converts strategy into executable tasks
       */
      async extract(strategy) {
        console.log("[Task Extractor] About to call LLM for task extraction...");
        const context = strategy.context;
        const businessType = context?.business?.type || "general_business";
        const businessScale = context?.business?.scale || "mid_market";
        const initiativeType = context?.business?.initiativeType;
        const timelineMin = context?.execution?.timeline?.min || 12;
        const timelineMax = context?.execution?.timeline?.max || 24;
        const businessName = context?.business?.name || "the business";
        const initiativeGuidance = this.getInitiativeGuidance(initiativeType);
        const prompt = `
    Analyze this business strategy and decompose it into executable project tasks.
    
    === CRITICAL BUSINESS CONTEXT ===
    Business: ${businessName}
    Type: ${businessType}
    Scale: ${businessScale}
    ${initiativeType ? `Initiative Type: ${initiativeType}` : ""}
    Expected Timeline: ${timelineMin}-${timelineMax} months
    
    IMPORTANT: This is a ${businessScale} business. Generate task durations appropriate for this scale:
    - SMB (small/medium business): Tasks in days/weeks, total project ${timelineMin}-${timelineMax} months
    - Mid-market: Tasks in weeks, total project ${timelineMin}-${timelineMax} months  
    - Enterprise: Tasks in weeks/months, total project ${timelineMin}-${timelineMax} months
    
    The TOTAL timeline across all tasks should fit within ${timelineMin}-${timelineMax} months.
    
    ${initiativeGuidance}
    ===================================
    
    Strategy Context:
    ${JSON.stringify(strategy, null, 2)}
    
    For each workstream or major initiative, create detailed tasks following this reasoning process:
    
    1. DECOMPOSITION LOGIC
    - What are the logical phases? (setup \u2192 execution \u2192 validation \u2192 deployment)
    - What must be built/created/established?
    - What decisions must be made?
    - What validations/approvals needed?
    
    2. DEPENDENCY REASONING
    For each task, think:
    - What information/artifacts does this task need as input?
    - What tasks produce those inputs?
    - What can be done in parallel vs sequential?
    - Are there external dependencies (permits, approvals, third parties)?
    
    3. DURATION ESTIMATION
    Consider:
    - Complexity (simple/medium/complex)
    - Uncertainty (well-understood vs exploratory)
    - Resource constraints (specialized skills needed?)
    - Historical patterns (similar tasks usually take X)
    
    Provide optimistic (if everything goes perfectly),
    likely (realistic expectation),
    and pessimistic (if complications arise) durations.
    
    4. RESOURCE REQUIREMENTS
    - What skills/expertise needed?
    - How many people?
    - Any special tools/systems?
    - External vendors/partners?
    
    5. DELIVERABLES
    - What concrete outputs?
    - What decisions documented?
    - What approvals obtained?
    - What systems deployed?
    
    CRITICAL: Think step-by-step about the logical sequence.
    Don't just list tasks - reason about their relationships.
    
    Example reasoning:
    "To launch the product, we need the platform built.
    To build the platform, we need architecture designed.
    To design architecture, we need requirements gathered.
    Requirements depend on market research being complete."
    
    Return as JSON array of Task objects with all fields populated.
    `;
        const response = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              tasks: {
                type: "array",
                items: this.getTaskSchema()
              }
            }
          }
        });
        console.log("[Task Extractor] LLM responded, parsing tasks...");
        console.log("[Task Extractor] Extracted", response.tasks?.length || 0, "tasks");
        return this.postProcessTasks(response.tasks);
      }
      /**
       * Decompose a single workstream into subtasks
       */
      async decompose(workstream) {
        const prompt = `
    Decompose this workstream into detailed subtasks using work breakdown structure (WBS) principles.
    
    Workstream:
    ${JSON.stringify(workstream, null, 2)}
    
    Apply WBS decomposition rules:
    1. Each task should be 8-80 hours of work (1-10 days)
    2. Each task should have clear start/end conditions
    3. Each task should produce a tangible deliverable
    4. No task should be just "manage" or "oversee"
    
    Think about:
    - Setup tasks (environment, tools, access)
    - Research/analysis tasks
    - Design/planning tasks  
    - Implementation/build tasks
    - Testing/validation tasks
    - Documentation tasks
    - Review/approval tasks
    - Deployment/rollout tasks
    - Training/handover tasks
    
    For each task, reason about:
    - Why is this task necessary?
    - What specific work is involved?
    - What makes it complete?
    - Who needs to be involved?
    
    Return detailed tasks with all attributes.
    `;
        const response = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              tasks: {
                type: "array",
                items: this.getTaskSchema()
              }
            }
          }
        });
        return response.tasks;
      }
      /**
       * Get initiative-specific guidance for task generation
       * Ensures AI generates contextually appropriate tasks
       */
      getInitiativeGuidance(initiativeType) {
        if (!initiativeType) return "";
        const guidanceMap = {
          physical_business_launch: `
    \u26A0\uFE0F PHYSICAL BUSINESS CONTEXT:
    This is launching a physical location (store, restaurant, office, etc.).
    Focus tasks on:
    - Real estate: Site selection, lease negotiation, buildout/renovation
    - Licenses/permits: Health permits, business licenses, inspections
    - Physical setup: Furniture, equipment, signage, utilities
    - Staffing: Hiring, training, scheduling (baristas, servers, sales staff - NOT software engineers)
    - Inventory: Supplier contracts, initial stock, POS systems
    - Grand opening: Marketing, soft launch, opening event
    Typical duration: 4-12 months for SMB, longer for chains`,
          software_development: `
    \u26A0\uFE0F SOFTWARE DEVELOPMENT CONTEXT:
    This is building a software product/platform/app.
    Focus tasks on:
    - Technical setup: Dev environment, CI/CD, infrastructure, repositories
    - Design: UI/UX, system architecture, database design, API design
    - Development: Sprint planning, feature implementation, code reviews
    - Staffing: Developers, QA engineers, DevOps, product managers (NOT baristas or retail staff)
    - Testing: Unit tests, integration tests, UAT, performance testing
    - Deployment: Beta launch, production deployment, monitoring
    Typical duration: 3-12 months for MVP, longer for enterprise systems`,
          digital_transformation: `
    \u26A0\uFE0F DIGITAL TRANSFORMATION CONTEXT:
    This is modernizing an existing business with digital capabilities.
    Focus tasks on:
    - Assessment: Current state analysis, gap identification, requirements
    - Platform selection: Evaluate solutions (e.g., e-commerce, CRM, ERP)
    - Integration: Connect new systems with existing processes/data
    - Change management: Staff training, process redesign, adoption campaigns
    - Staffing: Mix of domain experts and technical implementers
    - Rollout: Phased deployment, parallel operations, cutover
    Typical duration: 6-18 months depending on scope`,
          market_expansion: `
    \u26A0\uFE0F MARKET EXPANSION CONTEXT:
    This is entering new markets/regions with existing offerings.
    Focus tasks on:
    - Market research: Customer analysis, competitive landscape, regulations
    - Localization: Product/service adaptation, pricing, messaging
    - Market entry: Distribution channels, partnerships, local presence
    - Compliance: Legal entity, tax registration, regulatory approvals
    - Staffing: Local teams, regional managers, support staff
    - Launch: Go-to-market strategy, marketing campaigns, customer acquisition
    Typical duration: 6-12 months per new market`,
          product_launch: `
    \u26A0\uFE0F PRODUCT LAUNCH CONTEXT:
    This is introducing a new product to existing/new markets.
    Focus tasks on:
    - Product development: Design, prototyping, testing, refinement
    - Production: Manufacturing setup, supply chain, quality control
    - Marketing: Positioning, campaigns, sales materials, PR
    - Sales enablement: Training, pricing, distribution channels
    - Launch execution: Soft launch, phased rollout, full launch
    Typical duration: 3-9 months from concept to launch`,
          service_launch: `
    \u26A0\uFE0F SERVICE LAUNCH CONTEXT:
    This is introducing new service offerings.
    Focus tasks on:
    - Service design: Process definition, delivery model, quality standards
    - Capability building: Training, certifications, tools/systems
    - Operations: Scheduling, resource allocation, quality monitoring
    - Staffing: Service delivery team, support roles
    - Marketing: Service packaging, pricing, sales collateral
    Typical duration: 2-6 months depending on complexity`,
          process_improvement: `
    \u26A0\uFE0F PROCESS IMPROVEMENT CONTEXT:
    This is optimizing existing operations/workflows.
    Focus tasks on:
    - Analysis: Current state mapping, bottleneck identification, metrics
    - Design: Future state design, efficiency gains, change impact
    - Implementation: Process redesign, system changes, automation
    - Change management: Training, communication, adoption tracking
    - Validation: Metrics monitoring, continuous improvement
    Typical duration: 2-6 months for focused improvements`,
          other: ``
        };
        return guidanceMap[initiativeType] || "";
      }
      /**
       * Infer logical dependencies between tasks using reasoning
       */
      async inferDependencies(tasks2) {
        const prompt = `
    Analyze these tasks and infer logical dependencies using project management reasoning.
    
    Tasks:
    ${JSON.stringify(tasks2.map((t) => ({
          id: t.id,
          name: t.name,
          description: t.description,
          deliverables: t.deliverables
        })), null, 2)}
    
    For each pair of tasks, reason:
    
    1. CAUSAL RELATIONSHIPS
    - Does task B need the output of task A?
    - Does task A create something task B consumes?
    - Must task A's decision be made before B can start?
    
    2. LOGICAL SEQUENCING
    - Design before build
    - Requirements before design
    - Build before test
    - Test before deploy
    - Training before handover
    
    3. RESOURCE CONSTRAINTS
    - Do these tasks need the same person/team?
    - Do they need the same system/environment?
    - Would parallel execution cause conflicts?
    
    4. EXTERNAL CONSTRAINTS
    - Regulatory approvals before certain activities
    - Vendor deliveries before integration
    - Customer signoffs before proceeding
    
    5. BEST PRACTICES
    - Risk mitigation (critical items first)
    - Fast feedback (validate early)
    - Progressive elaboration (detail emerges)
    
    For each task, provide a list of task IDs it depends on,
    with reasoning for why that dependency exists.
    
    Be conservative - only add dependencies that are truly necessary.
    Too many dependencies reduces parallelization opportunities.
    
    Return tasks with updated dependencies array.
    `;
        const response = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              tasks: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    id: { type: "string" },
                    dependencies: {
                      type: "array",
                      items: { type: "string" }
                    },
                    reasoning: { type: "string" }
                  }
                }
              }
            }
          }
        });
        const dependencyMap = new Map(
          response.tasks.map((t) => [t.id, t.dependencies])
        );
        return tasks2.map((task) => ({
          ...task,
          dependencies: dependencyMap.get(task.id) || task.dependencies
        }));
      }
      /**
       * Helper to generate task schema for structured output
       */
      getTaskSchema() {
        return {
          type: "object",
          required: ["id", "name", "duration", "dependencies"],
          properties: {
            id: { type: "string" },
            name: { type: "string" },
            description: { type: "string" },
            duration: {
              type: "object",
              properties: {
                optimistic: { type: "number" },
                likely: { type: "number" },
                pessimistic: { type: "number" },
                unit: { enum: ["days", "weeks", "months"] }
              }
            },
            dependencies: {
              type: "array",
              items: { type: "string" }
            },
            deliverables: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  id: { type: "string" },
                  name: { type: "string" },
                  description: { type: "string" }
                }
              }
            },
            requirements: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  skill: { type: "string" },
                  quantity: { type: "number" },
                  duration: { type: "number" }
                }
              }
            },
            complexity: { enum: ["low", "medium", "high"] },
            risk: { enum: ["low", "medium", "high"] }
          }
        };
      }
      /**
       * Post-process tasks to ensure consistency
       */
      postProcessTasks(tasks2) {
        const usedIds = /* @__PURE__ */ new Set();
        const processedTasks = tasks2.map((task) => {
          let id = task.id;
          let counter = 1;
          while (usedIds.has(id)) {
            id = `${task.id}_${counter}`;
            counter++;
          }
          usedIds.add(id);
          return { ...task, id };
        });
        const validIds = new Set(processedTasks.map((t) => t.id));
        processedTasks.forEach((task) => {
          task.dependencies = task.dependencies.filter((dep) => validIds.has(dep));
        });
        this.removeCircularDependencies(processedTasks);
        return processedTasks;
      }
      /**
       * Remove circular dependencies if any exist
       */
      removeCircularDependencies(tasks2) {
        const visited = /* @__PURE__ */ new Set();
        const recursionStack = /* @__PURE__ */ new Set();
        const hasCycle = (taskId, taskMap2) => {
          visited.add(taskId);
          recursionStack.add(taskId);
          const task = taskMap2.get(taskId);
          if (!task) return false;
          for (const depId of task.dependencies) {
            if (!visited.has(depId)) {
              if (hasCycle(depId, taskMap2)) return true;
            } else if (recursionStack.has(depId)) {
              task.dependencies = task.dependencies.filter((d) => d !== depId);
              console.warn(`Removed circular dependency: ${taskId} -> ${depId}`);
              return true;
            }
          }
          recursionStack.delete(taskId);
          return false;
        };
        const taskMap = new Map(tasks2.map((t) => [t.id, t]));
        for (const task of tasks2) {
          if (!visited.has(task.id)) {
            hasCycle(task.id, taskMap);
          }
          visited.clear();
          recursionStack.clear();
        }
      }
    };
  }
});

// src/lib/intelligent-planning/scheduler.ts
var CPMScheduler, createCPMScheduler;
var init_scheduler = __esm({
  "src/lib/intelligent-planning/scheduler.ts"() {
    "use strict";
    CPMScheduler = class {
      tasks = /* @__PURE__ */ new Map();
      scheduled = /* @__PURE__ */ new Map();
      schedule(tasks2) {
        this.tasks.clear();
        this.scheduled.clear();
        tasks2.forEach((task) => this.tasks.set(task.id, task));
        this.forwardPass();
        this.backwardPass();
        const criticalPath = this.identifyCriticalPath();
        return this.buildSchedule(criticalPath);
      }
      forwardPass() {
        const completed = /* @__PURE__ */ new Set();
        const queue = Array.from(this.tasks.values());
        while (queue.length > 0) {
          const task = queue.shift();
          if (!this.canSchedule(task, completed)) {
            queue.push(task);
            continue;
          }
          const earlyStart = this.calculateEarlyStart(task);
          const duration = this.calculateDuration(task.duration);
          const earlyFinish = earlyStart + duration;
          this.scheduled.set(task.id, {
            ...task,
            earlyStart,
            earlyFinish,
            lateStart: 0,
            // Will be calculated in backward pass
            lateFinish: 0,
            slack: 0,
            startDate: this.monthToDate(earlyStart),
            endDate: this.monthToDate(earlyFinish),
            isCritical: false,
            assignedResources: []
          });
          completed.add(task.id);
        }
      }
      backwardPass() {
        const projectEnd = Math.max(
          ...Array.from(this.scheduled.values()).map((t) => t.earlyFinish)
        );
        const tasks2 = Array.from(this.scheduled.values()).reverse();
        for (const task of tasks2) {
          const successors = this.findSuccessors(task.id);
          if (successors.length === 0) {
            task.lateFinish = projectEnd;
          } else {
            task.lateFinish = Math.min(
              ...successors.map((s) => s.lateStart)
            );
          }
          task.lateStart = task.lateFinish - (task.earlyFinish - task.earlyStart);
          task.slack = task.lateStart - task.earlyStart;
          task.isCritical = task.slack === 0;
        }
      }
      canSchedule(task, completed) {
        return task.dependencies.every((dep) => completed.has(dep));
      }
      calculateEarlyStart(task) {
        if (task.dependencies.length === 0) {
          return 0;
        }
        const predecessorFinishTimes = task.dependencies.map((depId) => this.scheduled.get(depId)).filter(Boolean).map((t) => t.earlyFinish);
        return Math.max(...predecessorFinishTimes);
      }
      calculateDuration(duration) {
        const { optimistic, likely, pessimistic, unit } = duration;
        let conversionFactor = 1;
        if (unit === "days") {
          conversionFactor = 1 / 30;
        } else if (unit === "weeks") {
          conversionFactor = 1 / 4.33;
        }
        const optimisticMonths = optimistic * conversionFactor;
        const likelyMonths = likely * conversionFactor;
        const pessimisticMonths = pessimistic * conversionFactor;
        return Math.round((optimisticMonths + 4 * likelyMonths + pessimisticMonths) / 6 * 10) / 10;
      }
      findSuccessors(taskId) {
        return Array.from(this.scheduled.values()).filter(
          (t) => t.dependencies.includes(taskId)
        );
      }
      identifyCriticalPath() {
        return Array.from(this.scheduled.values()).filter((t) => t.isCritical).map((t) => t.id);
      }
      buildSchedule(criticalPath) {
        const tasks2 = Array.from(this.scheduled.values());
        const startDate = /* @__PURE__ */ new Date();
        const totalDuration = Math.max(...tasks2.map((t) => t.earlyFinish));
        return {
          tasks: tasks2,
          criticalPath,
          totalDuration,
          startDate,
          endDate: this.monthToDate(totalDuration)
        };
      }
      monthToDate(months) {
        const date2 = /* @__PURE__ */ new Date();
        date2.setMonth(date2.getMonth() + months);
        return date2;
      }
    };
    createCPMScheduler = () => new CPMScheduler();
  }
});

// src/lib/intelligent-planning/resource-manager.ts
var ResourceManager, createResourceManager;
var init_resource_manager = __esm({
  "src/lib/intelligent-planning/resource-manager.ts"() {
    "use strict";
    ResourceManager = class {
      resources = /* @__PURE__ */ new Map();
      allocate(schedule, resources2) {
        this.buildResourceMap(resources2);
        const assignments = this.assignResources(schedule.tasks);
        const utilization = this.calculateUtilization(schedule.tasks, resources2);
        const conflicts = this.detectConflicts(schedule, resources2);
        return {
          schedule,
          assignments,
          utilization,
          conflicts
        };
      }
      level(allocation) {
        if (allocation.conflicts.length === 0) {
          return {
            ...allocation.schedule,
            levelingAdjustments: [],
            newConflicts: []
          };
        }
        const adjustments = [];
        const leveledTasks = [...allocation.schedule.tasks];
        const sortedConflicts = [...allocation.conflicts].sort(
          (a, b) => b.overallocation - a.overallocation
        );
        for (const conflict of sortedConflicts) {
          const resolved = this.resolveConflict(
            conflict,
            leveledTasks,
            adjustments
          );
          if (resolved) {
            leveledTasks.splice(0, leveledTasks.length, ...resolved);
          }
        }
        const leveledSchedule = {
          ...allocation.schedule,
          tasks: leveledTasks
        };
        const newConflicts = this.detectConflicts(
          leveledSchedule,
          Array.from(this.resources.values())
        );
        return {
          ...leveledSchedule,
          levelingAdjustments: adjustments,
          newConflicts
        };
      }
      detectConflicts(schedule, resources2) {
        const conflicts = [];
        const periods = this.generateAnalysisPeriods(schedule);
        for (const period of periods) {
          const tasksInPeriod = this.getTasksInPeriod(schedule.tasks, period);
          const required = this.calculateRequiredResources(tasksInPeriod);
          const available = this.calculateAvailableResources(resources2, period);
          if (required > available) {
            conflicts.push({
              period,
              required,
              available,
              overallocation: required - available,
              affectedTasks: tasksInPeriod.map((t) => t.id)
            });
          }
        }
        return conflicts;
      }
      buildResourceMap(resources2) {
        this.resources.clear();
        resources2.forEach((r) => this.resources.set(r.id, r));
      }
      assignResources(tasks2) {
        const assignments = /* @__PURE__ */ new Map();
        for (const task of tasks2) {
          const assigned = this.findBestResources(task);
          const resourceIds = assigned.map((r) => r.id);
          const resourceNames = assigned.map((r) => r.name);
          assignments.set(task.id, resourceIds);
          task.assignedResources = resourceIds;
          task.assignedResourceIds = resourceIds;
          task.assignedResourceNames = resourceNames;
          task.owner = resourceNames[0] || "Unassigned";
        }
        return assignments;
      }
      findBestResources(task) {
        const assigned = [];
        const availableResources = Array.from(this.resources.values());
        if (!task.requirements || task.requirements.length === 0) {
          const cheapest = availableResources.sort(
            (a, b) => (a.costPerUnit || 0) - (b.costPerUnit || 0)
          )[0];
          if (cheapest) {
            return [cheapest];
          }
          return [];
        }
        for (const requirement of task.requirements) {
          let matchedResources = availableResources.filter((r) => {
            if (!r.skills || r.skills.length === 0) return false;
            const reqSkill = requirement.skill.toLowerCase().trim();
            const reqTokens = reqSkill.split(/\s+/);
            const allResourceTokens = r.skills.flatMap(
              (skill) => skill.toLowerCase().trim().split(/\s+/)
            );
            const tokenMatches = (reqToken) => {
              return allResourceTokens.some((resToken) => {
                if (reqToken === resToken) return true;
                if (reqToken.length >= 4 && resToken.length >= 4) {
                  const approvedSuffixes = ["ing", "er", "ed", "ist", "ment", "ness", "ion", "tion", "ation", "ity", "ship", "ful", "less", "s"];
                  if (resToken.startsWith(reqToken)) {
                    const suffix = resToken.slice(reqToken.length);
                    return suffix === "" || approvedSuffixes.some((s) => suffix === s || suffix.startsWith(s));
                  }
                  if (reqToken.startsWith(resToken)) {
                    const suffix = reqToken.slice(resToken.length);
                    return suffix === "" || approvedSuffixes.some((s) => suffix === s || suffix.startsWith(s));
                  }
                }
                return false;
              });
            };
            return reqTokens.every(tokenMatches);
          });
          matchedResources.sort((a, b) => (a.costPerUnit || 0) - (b.costPerUnit || 0));
          if (matchedResources.length === 0) {
            const fallback = availableResources.sort(
              (a, b) => (a.costPerUnit || 0) - (b.costPerUnit || 0)
            )[0];
            if (fallback) {
              matchedResources = [fallback];
            }
          }
          if (matchedResources.length > 0) {
            assigned.push(matchedResources[0]);
          }
        }
        if (assigned.length === 0 && availableResources.length > 0) {
          const cheapest = availableResources.sort(
            (a, b) => (a.costPerUnit || 0) - (b.costPerUnit || 0)
          )[0];
          assigned.push(cheapest);
        }
        return assigned;
      }
      calculateUtilization(tasks2, resources2) {
        const utilizations = [];
        for (const resource of resources2) {
          const periods = this.calculateResourcePeriods(resource, tasks2);
          const avgUtilization = this.calculateAverageUtilization(periods);
          const peakUtilization = Math.max(...periods.map((p) => p.utilization), 0);
          utilizations.push({
            resourceId: resource.id,
            periods,
            averageUtilization: avgUtilization,
            peakUtilization
          });
        }
        return utilizations;
      }
      resolveConflict(conflict, tasks2, adjustments) {
        const movableTasks = tasks2.filter(
          (t) => conflict.affectedTasks.includes(t.id) && !t.isCritical
        );
        if (movableTasks.length === 0) {
          return null;
        }
        movableTasks.sort((a, b) => b.slack - a.slack);
        for (const task of movableTasks) {
          if (task.slack > 0) {
            const adjustment = {
              taskId: task.id,
              originalStart: task.startDate,
              newStart: new Date(task.startDate.getTime() + 864e5 * 7),
              // Move by 1 week
              reason: `Resource conflict resolution in period ${conflict.period.start.toDateString()}`
            };
            task.startDate = adjustment.newStart;
            task.endDate = new Date(task.endDate.getTime() + 864e5 * 7);
            task.slack -= 1;
            adjustments.push(adjustment);
            if (this.isConflictResolved(conflict, tasks2)) {
              break;
            }
          }
        }
        return tasks2;
      }
      generateAnalysisPeriods(schedule) {
        const periods = [];
        const start = schedule.startDate;
        const end = schedule.endDate;
        const current = new Date(start);
        while (current < end) {
          const periodEnd = new Date(current);
          periodEnd.setDate(periodEnd.getDate() + 7);
          periods.push({
            start: new Date(current),
            end: periodEnd > end ? end : periodEnd
          });
          current.setDate(current.getDate() + 7);
        }
        return periods;
      }
      getTasksInPeriod(tasks2, period) {
        return tasks2.filter(
          (t) => t.startDate <= period.end && t.endDate >= period.start
        );
      }
      calculateRequiredResources(tasks2) {
        return tasks2.reduce(
          (sum, task) => sum + task.requirements.reduce(
            (reqSum, req) => reqSum + req.quantity,
            0
          ),
          0
        );
      }
      calculateAvailableResources(resources2, period) {
        return resources2.reduce((sum, resource) => {
          const availability = this.getResourceAvailability(resource, period);
          return sum + resource.capacity * availability;
        }, 0);
      }
      getResourceAvailability(resource, period) {
        const relevantAvailability = resource.availability.find(
          (a) => a.startDate <= period.end && a.endDate >= period.start
        );
        return relevantAvailability?.percentAvailable ?? 1;
      }
      calculateResourcePeriods(resource, tasks2) {
        return [];
      }
      calculateAverageUtilization(periods) {
        if (periods.length === 0) return 0;
        const sum = periods.reduce((s, p) => s + p.utilization, 0);
        return sum / periods.length;
      }
      isConflictResolved(conflict, tasks2) {
        const tasksInPeriod = this.getTasksInPeriod(tasks2, conflict.period);
        const required = this.calculateRequiredResources(tasksInPeriod);
        return required <= conflict.available;
      }
    };
    createResourceManager = () => new ResourceManager();
  }
});

// src/lib/intelligent-planning/optimizer.ts
function createAIOptimizer(llm2, validator, config) {
  const defaultConfig = {
    maxIterations: 10,
    targetScore: 85,
    improvementThreshold: 0.01,
    ...config
  };
  return new AIOptimizer(llm2, validator, defaultConfig);
}
var AIOptimizer;
var init_optimizer = __esm({
  "src/lib/intelligent-planning/optimizer.ts"() {
    "use strict";
    AIOptimizer = class {
      constructor(llm2, validator, config) {
        this.llm = llm2;
        this.validator = validator;
        this.config = config;
      }
      async optimize(schedule, constraints) {
        let currentSchedule = schedule;
        let bestSchedule = schedule;
        let bestScore = 0;
        const adjustments = [];
        for (let iteration = 0; iteration < this.config.maxIterations; iteration++) {
          const validation = await this.validator.validate(currentSchedule);
          if (validation.score.overall > bestScore) {
            bestScore = validation.score.overall;
            bestSchedule = currentSchedule;
          }
          if (bestScore >= this.config.targetScore) {
            console.log(`Optimization complete after ${iteration + 1} iterations`);
            break;
          }
          const improvements = await this.generateImprovements(
            currentSchedule,
            validation,
            constraints
          );
          currentSchedule = await this.applyImprovements(
            currentSchedule,
            improvements
          );
          adjustments.push(...improvements);
          if (this.hasConverged(validation.score.overall, bestScore)) {
            console.log(`Converged after ${iteration + 1} iterations`);
            break;
          }
        }
        return {
          ...bestSchedule,
          optimizationScore: bestScore,
          iterations: adjustments.length,
          adjustments
        };
      }
      async generateImprovements(schedule, validation, constraints) {
        const prompt = this.buildOptimizationPrompt(
          schedule,
          validation,
          constraints
        );
        const response = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              improvements: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    type: { enum: ["move", "extend", "compress", "parallelize", "serialize"] },
                    taskId: { type: "string" },
                    from: { type: "object" },
                    to: { type: "object" },
                    reason: { type: "string" }
                  }
                }
              },
              reasoning: { type: "string" }
            }
          }
        });
        return response.improvements;
      }
      buildOptimizationPrompt(schedule, validation, constraints) {
        return `
      Analyze this project schedule and suggest specific improvements.
      
      Current Schedule:
      - Total Duration: ${schedule.totalDuration} months
      - Critical Path: ${schedule.criticalPath.length} tasks
      - Score: ${JSON.stringify(validation.score)}
      
      Issues Found:
      ${validation.issues.map((i) => `- ${i.severity}: ${i.message}`).join("\n")}
      
      Constraints:
      ${constraints.map((c) => `- ${c.type}: ${c.description}`).join("\n")}
      
      Optimization Goals:
      1. Minimize total duration
      2. Balance resource utilization
      3. Reduce risk concentration
      4. Maintain logical dependencies
      5. Respect hard constraints
      
      Suggest specific task adjustments that will improve the schedule.
      Focus on:
      - Moving non-critical tasks to reduce resource conflicts
      - Parallelizing independent work
      - Compressing durations where possible
      - Adjusting start dates to smooth resource usage
      
      Return specific, actionable adjustments.
    `;
      }
      async applyImprovements(schedule, improvements) {
        const improvedSchedule = { ...schedule };
        const tasks2 = [...schedule.tasks];
        for (const improvement of improvements) {
          const taskIndex = tasks2.findIndex((t) => t.id === improvement.taskId);
          if (taskIndex === -1) continue;
          const task = { ...tasks2[taskIndex] };
          switch (improvement.type) {
            case "move":
              task.startDate = new Date(improvement.to.startDate);
              task.endDate = new Date(improvement.to.endDate);
              break;
            case "compress":
              const newDuration = improvement.to.duration;
              task.endDate = new Date(
                task.startDate.getTime() + newDuration * 24 * 60 * 60 * 1e3
              );
              break;
            case "parallelize":
              task.dependencies = task.dependencies.filter(
                (d) => !improvement.to.removeDependencies?.includes(d)
              );
              break;
            case "extend":
              task.endDate = new Date(improvement.to.endDate);
              break;
            case "serialize":
              task.dependencies.push(...improvement.to.addDependencies || []);
              break;
          }
          tasks2[taskIndex] = task;
        }
        improvedSchedule.tasks = tasks2;
        return improvedSchedule;
      }
      hasConverged(currentScore, bestScore) {
        const improvement = currentScore - bestScore;
        return Math.abs(improvement) < this.config.improvementThreshold;
      }
    };
  }
});

// src/lib/intelligent-planning/validator.ts
function createValidator(llm2) {
  return new LLMValidator(llm2);
}
var LLMValidator;
var init_validator = __esm({
  "src/lib/intelligent-planning/validator.ts"() {
    "use strict";
    LLMValidator = class {
      constructor(llm2) {
        this.llm = llm2;
      }
      /**
       * Main validation - uses LLM to deeply analyze the schedule
       */
      async validate(schedule) {
        const [
          logicalAnalysis,
          dependencyAnalysis,
          resourceAnalysis,
          riskAnalysis,
          timelineAnalysis
        ] = await Promise.all([
          this.analyzeLogicalCoherence(schedule),
          this.analyzeDependencies(schedule),
          this.analyzeResourceAllocation(schedule),
          this.analyzeRisks(schedule),
          this.analyzeTimeline(schedule)
        ]);
        const allIssues = [
          ...logicalAnalysis.issues,
          ...dependencyAnalysis.issues,
          ...resourceAnalysis.issues,
          ...riskAnalysis.issues,
          ...timelineAnalysis.issues
        ];
        const score = this.calculateScore(
          logicalAnalysis.score,
          dependencyAnalysis.score,
          resourceAnalysis.score,
          riskAnalysis.score,
          timelineAnalysis.score
        );
        const suggestions = await this.generateSuggestions(schedule, allIssues);
        return {
          isValid: allIssues.filter((i) => i.severity === "critical").length === 0,
          issues: allIssues,
          score,
          suggestions
        };
      }
      /**
       * Deep rationalization - explains WHY the schedule makes sense (or doesn't)
       */
      async rationalize(schedule) {
        const prompt = `
    Perform a deep rationalization analysis of this project schedule.
    
    Schedule Overview:
    - Total Duration: ${schedule.totalDuration} months
    - Number of Tasks: ${schedule.tasks.length}
    - Critical Path Length: ${schedule.criticalPath.length}
    - Start Date: ${schedule.startDate}
    - End Date: ${schedule.endDate}
    
    Task Details:
    ${JSON.stringify(schedule.tasks.map((t) => ({
          name: t.name,
          duration: t.endDate.getTime() - t.startDate.getTime(),
          dependencies: t.dependencies,
          isCritical: t.isCritical,
          slack: t.slack
        })), null, 2)}
    
    Provide a comprehensive analysis covering:
    
    1. LOGICAL COHERENCE
    - Does the sequence of tasks make business/technical sense?
    - Are there any logical gaps or contradictions?
    - Rate coherence 0-100
    
    2. HIDDEN ASSUMPTIONS
    - What unstated assumptions is this schedule making?
    - Which assumptions are risky?
    - What could invalidate these assumptions?
    
    3. RISK ANALYSIS
    - What are the top 5 risks in this schedule?
    - For each risk: likelihood, impact, and mitigation strategy
    
    4. OPPORTUNITIES
    - Where could we compress the timeline?
    - What tasks could be parallelized?
    - Where might we be over-conservative?
    
    5. CRITICAL INSIGHTS
    - What patterns do you see that humans might miss?
    - Any red flags or concerns?
    - What would an experienced PM say about this?
    
    6. REASONING CHAIN
    - Step through the logic of why this schedule is structured this way
    - Explain the cause-and-effect relationships
    - Identify any circular reasoning or flawed logic
    
    Return as structured JSON.
    `;
        const response = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              logicalCoherence: { type: "number", minimum: 0, maximum: 100 },
              reasoning: { type: "array", items: { type: "string" } },
              assumptions: { type: "array", items: { type: "string" } },
              risks: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    description: { type: "string" },
                    likelihood: { enum: ["low", "medium", "high"] },
                    impact: { enum: ["low", "medium", "high"] },
                    mitigation: { type: "string" }
                  }
                }
              },
              opportunities: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    description: { type: "string" },
                    benefit: { type: "string" },
                    effort: { enum: ["low", "medium", "high"] },
                    recommendation: { type: "string" }
                  }
                }
              },
              criticalInsights: { type: "array", items: { type: "string" } }
            }
          }
        });
        return response;
      }
      /**
       * Analyze logical coherence using LLM reasoning
       */
      async analyzeLogicalCoherence(schedule) {
        const prompt = `
    Analyze the logical coherence of this task sequence:
    
    ${schedule.tasks.map(
          (t) => `${t.name}: ${t.startDate.toLocaleDateString()} to ${t.endDate.toLocaleDateString()}, depends on: ${t.dependencies.join(", ") || "none"}`
        ).join("\n")}
    
    Check for:
    1. Tasks that should logically depend on each other but don't
    2. Dependencies that don't make business sense
    3. Missing tasks (gaps in the logical flow)
    4. Redundant or unnecessary tasks
    5. Tasks in wrong sequence
    
    Return issues found and a coherence score (0-100).
    `;
        const response = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              issues: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    type: { type: "string" },
                    message: { type: "string" },
                    severity: { enum: ["critical", "warning", "info"] },
                    affectedTasks: { type: "array", items: { type: "string" } },
                    suggestedFix: { type: "string" }
                  }
                }
              },
              coherenceScore: { type: "number", minimum: 0, maximum: 100 }
            }
          }
        });
        return {
          issues: response.issues,
          score: response.coherenceScore
        };
      }
      /**
       * Analyze dependencies for logical flaws
       */
      async analyzeDependencies(schedule) {
        const prompt = `
    Analyze the dependency structure of this schedule.
    
    Tasks and their dependencies:
    ${JSON.stringify(schedule.tasks.map((t) => ({
          id: t.id,
          name: t.name,
          dependencies: t.dependencies
        })), null, 2)}
    
    Check for:
    1. Circular dependencies
    2. Unnecessary dependencies (tasks that could be parallel)
    3. Missing critical dependencies
    4. Dependency chains that are too long
    5. Single points of failure
    
    Score the dependency structure (0-100) and list issues.
    `;
        const response = await this.llm.generateStructured({ prompt, schema: this.getValidationSchema() });
        return response;
      }
      /**
       * Generate intelligent suggestions based on issues found
       */
      async generateSuggestions(schedule, issues) {
        if (issues.length === 0) {
          return ["Schedule appears well-optimized. Consider adding buffer time for critical tasks."];
        }
        const prompt = `
    Based on these schedule issues, provide actionable suggestions:
    
    Issues:
    ${issues.map((i) => `- ${i.severity}: ${i.message}`).join("\n")}
    
    Schedule context:
    - Duration: ${schedule.totalDuration} months
    - Critical path: ${schedule.criticalPath.length} tasks
    - Total tasks: ${schedule.tasks.length}
    
    Provide 3-5 specific, actionable suggestions to improve this schedule.
    Focus on practical fixes that maintain project goals.
    `;
        const response = await this.llm.generate(prompt);
        const suggestions = response.split("\n").filter((line) => line.trim().startsWith("-") || line.trim().match(/^\d+\./)).map((line) => line.replace(/^[-\d.]\s*/, "").trim()).filter((s) => s.length > 0);
        return suggestions.length > 0 ? suggestions : ["Review critical path for optimization opportunities"];
      }
      calculateScore(...scores) {
        const avg = scores.reduce((a, b) => a + b, 0) / scores.length;
        return {
          feasibility: scores[0] || 0,
          efficiency: scores[1] || 0,
          riskLevel: 100 - (scores[2] || 0),
          // Invert risk score
          resourceUtilization: scores[3] || 0,
          overall: avg
        };
      }
      getValidationSchema() {
        return {
          type: "object",
          properties: {
            issues: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  severity: { enum: ["critical", "warning", "info"] },
                  type: { type: "string" },
                  message: { type: "string" },
                  affectedTasks: { type: "array", items: { type: "string" } },
                  suggestedFix: { type: "string" }
                }
              }
            },
            score: { type: "number", minimum: 0, maximum: 100 }
          }
        };
      }
      // Stub implementations for other analysis methods
      async analyzeResourceAllocation(schedule) {
        return { issues: [], score: 75 };
      }
      async analyzeRisks(schedule) {
        return { issues: [], score: 70 };
      }
      async analyzeTimeline(schedule) {
        return { issues: [], score: 80 };
      }
    };
  }
});

// src/lib/intelligent-planning/orchestrator.ts
import { EventEmitter } from "events";
function createOrchestrator(dependencies) {
  return new ProjectPlanningOrchestrator(
    dependencies.extractor,
    dependencies.scheduler,
    dependencies.resourceManager,
    dependencies.optimizer,
    dependencies.validator
  );
}
var ProjectPlanningOrchestrator;
var init_orchestrator = __esm({
  "src/lib/intelligent-planning/orchestrator.ts"() {
    "use strict";
    ProjectPlanningOrchestrator = class extends EventEmitter {
      constructor(extractor, scheduler, resourceManager, optimizer, validator) {
        super();
        this.extractor = extractor;
        this.scheduler = scheduler;
        this.resourceManager = resourceManager;
        this.optimizer = optimizer;
        this.validator = validator;
      }
      steps = [];
      async plan(request) {
        const startTime = Date.now();
        this.steps = [];
        try {
          const tasks2 = await this.executeStep(
            "extract-tasks",
            () => this.extractor.extract(request.strategy)
          );
          const schedule = await this.executeStep(
            "schedule",
            () => this.scheduler.schedule(tasks2)
          );
          const allocation = await this.executeStep(
            "allocate-resources",
            () => this.resourceManager.allocate(schedule, request.resources)
          );
          let leveledSchedule = allocation.schedule;
          if (allocation.conflicts.length > 0 && request.options?.enableResourceLeveling) {
            const leveled = await this.executeStep(
              "level-resources",
              () => this.resourceManager.level(allocation)
            );
            leveledSchedule = leveled;
          }
          let optimizedSchedule = leveledSchedule;
          if (request.options?.enableOptimization) {
            optimizedSchedule = await this.executeStep(
              "optimize",
              () => this.optimizer.optimize(leveledSchedule, request.constraints)
            );
          }
          const validation = await this.executeStep(
            "validate",
            () => this.validator.validate(optimizedSchedule)
          );
          const duration = Date.now() - startTime;
          if (validation.isValid) {
            return {
              success: true,
              schedule: optimizedSchedule,
              recommendations: validation.suggestions,
              metadata: {
                duration,
                iterations: this.steps.length,
                score: validation.score.overall
              }
            };
          } else {
            const adjustments = await this.identifyStrategyAdjustments(
              optimizedSchedule,
              validation,
              request
            );
            return {
              success: false,
              schedule: optimizedSchedule,
              issues: validation.issues.map((i) => i.message),
              strategyAdjustments: adjustments,
              metadata: {
                duration,
                iterations: this.steps.length,
                score: validation.score.overall
              }
            };
          }
        } catch (error) {
          this.emit("error", error);
          return {
            success: false,
            issues: [error instanceof Error ? error.message : "Unknown error"],
            metadata: {
              duration: Date.now() - startTime,
              iterations: this.steps.length,
              score: 0
            }
          };
        }
      }
      async executeStep(name, executor) {
        const step = {
          name,
          status: "pending"
        };
        this.steps.push(step);
        this.emit("step-start", step);
        try {
          step.status = "running";
          step.startTime = /* @__PURE__ */ new Date();
          const result = await executor();
          step.status = "complete";
          step.endTime = /* @__PURE__ */ new Date();
          step.result = result;
          this.emit("step-complete", step);
          return result;
        } catch (error) {
          step.status = "failed";
          step.endTime = /* @__PURE__ */ new Date();
          step.error = error instanceof Error ? error : new Error(String(error));
          this.emit("step-failed", step);
          throw error;
        }
      }
      async identifyStrategyAdjustments(schedule, validation, request) {
        const adjustments = [];
        const deadlineConstraint = request.constraints.find((c) => c.type === "deadline");
        if (deadlineConstraint && schedule.endDate > deadlineConstraint.value) {
          const monthsOver = Math.ceil(
            (schedule.endDate.getTime() - deadlineConstraint.value.getTime()) / (1e3 * 60 * 60 * 24 * 30)
          );
          adjustments.push(
            `Timeline adjustment needed: Project requires ${monthsOver} additional months`
          );
        }
        const budgetConstraint = request.constraints.find((c) => c.type === "budget");
        if (budgetConstraint && schedule.totalCost && schedule.totalCost > budgetConstraint.value) {
          const overBudget = schedule.totalCost - budgetConstraint.value;
          adjustments.push(
            `Budget adjustment needed: Additional $${overBudget.toLocaleString()} required`
          );
        }
        const resourceIssues = validation.issues.filter((i) => i.type === "resource");
        if (resourceIssues.length > 0) {
          adjustments.push(
            `Resource adjustment needed: ${resourceIssues[0].message}`
          );
        }
        const criticalIssues = validation.issues.filter((i) => i.severity === "critical");
        criticalIssues.forEach((issue) => {
          if (issue.suggestedFix) {
            adjustments.push(issue.suggestedFix);
          }
        });
        return adjustments;
      }
      getSteps() {
        return this.steps;
      }
      getLastError() {
        const failedStep = this.steps.find((s) => s.status === "failed");
        return failedStep?.error;
      }
    };
  }
});

// src/lib/intelligent-planning/types.ts
var init_types = __esm({
  "src/lib/intelligent-planning/types.ts"() {
    "use strict";
  }
});

// src/lib/intelligent-planning/interfaces.ts
var init_interfaces2 = __esm({
  "src/lib/intelligent-planning/interfaces.ts"() {
    "use strict";
  }
});

// src/lib/intelligent-planning/index.ts
function createPlanningSystem(config) {
  const llm2 = createOpenAIProvider({
    apiKey: config.openaiApiKey,
    model: "gpt-4-turbo-preview"
  });
  const extractor = createTaskExtractor(llm2);
  const scheduler = createCPMScheduler();
  const resourceManager = createResourceManager();
  const validator = createValidator(llm2);
  const optimizer = createAIOptimizer(llm2, validator, {
    maxIterations: config.maxIterations || 10,
    targetScore: config.targetScore || 85
  });
  const orchestrator = createOrchestrator({
    extractor,
    scheduler,
    resourceManager,
    optimizer,
    validator
  });
  return {
    async plan(request) {
      return orchestrator.plan(request);
    },
    // Expose individual modules for direct use if needed
    modules: {
      extractor,
      scheduler,
      resourceManager,
      optimizer,
      validator
    },
    // Event subscription for progress tracking
    on: orchestrator.on.bind(orchestrator),
    off: orchestrator.off.bind(orchestrator)
  };
}
var init_intelligent_planning = __esm({
  "src/lib/intelligent-planning/index.ts"() {
    "use strict";
    init_task_extractor();
    init_scheduler();
    init_resource_manager();
    init_optimizer();
    init_validator();
    init_orchestrator();
    init_llm_provider();
    init_types();
    init_orchestrator();
    init_interfaces2();
  }
});

// src/lib/intelligent-planning/epm-integration.ts
async function replaceTimelineGeneration(epmProgram, planningContext, config, onProgress) {
  try {
    console.log("Starting intelligent timeline generation...");
    console.log(`Business: ${planningContext.business.name} (${planningContext.business.type})`);
    console.log(`Scale: ${planningContext.business.scale}`);
    console.log(`Timeline range: ${planningContext.execution.timeline.min}-${planningContext.execution.timeline.max} months`);
    const strategy = {
      workstreams: epmProgram.workstreams || [],
      objectives: epmProgram.executiveSummary?.objectives || [],
      context: planningContext,
      // Pass full context instead of raw businessContext
      timeline: epmProgram.timeline,
      financialPlan: epmProgram.financialPlan,
      riskRegister: epmProgram.riskRegister
    };
    const constraints = buildConstraints(epmProgram, config);
    const resources2 = buildResources(epmProgram.resourcePlan, config);
    const planningResult = await generateIntelligentSchedule(
      strategy,
      constraints,
      resources2,
      onProgress
    );
    if (!planningResult.success || !planningResult.schedule) {
      console.warn("[Intelligent Planning] \u274C Planning failed or no schedule generated");
      console.log("=== PLANNING FAILURE DETAILS ===");
      console.log("Success:", planningResult.success);
      console.log("Confidence Score:", planningResult.metadata?.score);
      console.log("Schedule Data:", planningResult.schedule ? "Present" : "Missing");
      if (planningResult.recommendations?.length) {
        console.log("Warnings:", planningResult.recommendations.length);
      }
      if (planningResult.strategyAdjustments?.length) {
        console.log("Adjustments Needed:", planningResult.strategyAdjustments.length);
      }
      console.log("=== END PLANNING FAILURE DETAILS ===");
      return {
        success: false,
        program: epmProgram,
        warnings: planningResult.recommendations || ["Planning validation failed or timed out"],
        adjustments: planningResult.strategyAdjustments || [],
        confidence: planningResult.metadata?.score || 0
      };
    }
    const updatedProgram = integrateScheduleIntoEPM(
      epmProgram,
      planningResult.schedule
    );
    console.log(`Timeline generated successfully with ${planningResult.metadata.score}% confidence`);
    return {
      success: true,
      program: updatedProgram,
      warnings: planningResult.recommendations || [],
      confidence: planningResult.metadata.score
    };
  } catch (error) {
    console.error("Timeline generation failed:", error);
    return {
      success: false,
      program: epmProgram,
      warnings: ["Intelligent planning failed, using basic timeline"],
      adjustments: [],
      confidence: 0
    };
  }
}
async function generateIntelligentSchedule(strategy, constraints, resources2, onProgress) {
  const planner = createPlanningSystem({
    openaiApiKey: process.env.OPENAI_API_KEY,
    maxIterations: parseInt(process.env.MAX_PLANNING_ITERATIONS || "10"),
    targetScore: parseInt(process.env.TARGET_PLANNING_SCORE || "85")
  });
  const steps = [
    { id: "extract-tasks", name: "Extracting Tasks", description: "Breaking down workstreams into detailed tasks" },
    { id: "schedule", name: "Building Schedule", description: "Creating timeline with Critical Path Method" },
    { id: "allocate-resources", name: "Allocating Resources", description: "Matching skills to tasks and checking availability" },
    { id: "level-resources", name: "Optimizing Resources", description: "Resolving conflicts and leveling workload" },
    { id: "optimize", name: "AI Optimization", description: "Using AI to improve timeline and efficiency" },
    { id: "validate", name: "Final Validation", description: "Checking for issues and calculating confidence" }
  ];
  let currentStepIndex = 0;
  const startTime = Date.now();
  planner.on("step-start", (step) => {
    console.log(`Planning step started: ${step.name}`);
    const stepInfo = steps.find((s) => s.id === step.name);
    if (stepInfo && onProgress) {
      currentStepIndex++;
      const progress = Math.round(currentStepIndex / steps.length * 100);
      const elapsedSeconds = Math.round((Date.now() - startTime) / 1e3);
      onProgress({
        type: "step-start",
        step: step.name,
        stepNumber: currentStepIndex,
        totalSteps: steps.length,
        progress,
        name: stepInfo.name,
        description: stepInfo.description,
        elapsedSeconds
      });
    }
  });
  planner.on("step-complete", (step) => {
    console.log(`Planning step completed: ${step.name}`);
    const stepInfo = steps.find((s) => s.id === step.name);
    if (stepInfo && onProgress) {
      const durationSeconds = step.endTime && step.startTime ? Math.round((step.endTime.getTime() - step.startTime.getTime()) / 1e3) : 0;
      onProgress({
        type: "step-complete",
        step: step.name,
        stepNumber: currentStepIndex,
        totalSteps: steps.length,
        name: stepInfo.name,
        durationSeconds
      });
    }
  });
  planner.on("error", (error) => {
    console.error(`Planning error: ${error.message}`);
    if (onProgress) {
      onProgress({
        type: "error",
        message: error.message
      });
    }
  });
  const request = {
    strategy,
    constraints,
    resources: resources2,
    options: {
      enableOptimization: true,
      enableResourceLeveling: true,
      verboseLogging: process.env.NODE_ENV === "development"
    }
  };
  const result = await planner.plan(request);
  return {
    success: result.success,
    schedule: result.schedule ? transformScheduleForEPM(result.schedule) : void 0,
    recommendations: result.recommendations,
    strategyAdjustments: result.strategyAdjustments,
    metadata: result.metadata
  };
}
function buildConstraints(epmProgram, config) {
  const constraints = [];
  const targetDuration = config?.maxDuration || epmProgram.timeline?.totalMonths || 12;
  constraints.push({
    id: "timeline",
    type: "deadline",
    description: `Complete within ${targetDuration} months`,
    value: new Date(Date.now() + targetDuration * 30 * 24 * 60 * 60 * 1e3),
    isHard: false
  });
  const budget = config?.budget || epmProgram.financialPlan?.totalInvestment || 5e5;
  constraints.push({
    id: "budget",
    type: "budget",
    description: `Stay within $${budget} budget`,
    value: budget,
    isHard: true
  });
  if (epmProgram.stageGates?.gates) {
    epmProgram.stageGates.gates.forEach((gate, index2) => {
      constraints.push({
        id: `gate-${index2}`,
        type: "milestone",
        description: gate.name,
        value: {
          date: gate.date || gate.month,
          criteria: gate.criteria
        },
        isHard: true
      });
    });
  }
  return constraints;
}
function buildResources(resourcePlan, config) {
  const resources2 = [];
  if (!resourcePlan?.teamStructure) {
    const teamSize = config?.teamSize || 5;
    resources2.push({
      id: "default-team",
      name: "Development Team",
      capacity: teamSize,
      skills: ["development", "testing", "design"],
      availability: [{
        startDate: /* @__PURE__ */ new Date(),
        endDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3),
        percentAvailable: 1
      }],
      costPerUnit: 15e4
    });
    return resources2;
  }
  if (Array.isArray(resourcePlan.teamStructure)) {
    resourcePlan.teamStructure.forEach((role, index2) => {
      resources2.push({
        id: `resource-${index2}`,
        name: role.title || role.role,
        capacity: role.quantity || 1,
        skills: role.skills || [role.expertise],
        availability: [{
          startDate: /* @__PURE__ */ new Date(),
          endDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1e3),
          percentAvailable: 1
        }],
        costPerUnit: role.cost || 1e5
      });
    });
  }
  return resources2;
}
function transformScheduleForEPM(schedule) {
  const projectStartDate = schedule.tasks.reduce((earliest, task) => {
    const taskStart = new Date(task.startDate);
    return taskStart < earliest ? taskStart : earliest;
  }, new Date(schedule.tasks[0]?.startDate || Date.now()));
  const projectStartTime = projectStartDate.getTime();
  console.log("[EPM Integration] Project start date:", projectStartDate.toISOString());
  console.log("[EPM Integration] Total duration from schedule:", schedule.totalDuration, "months");
  return {
    tasks: schedule.tasks.map((task) => {
      const taskStartTime = new Date(task.startDate).getTime();
      const taskEndTime = new Date(task.endDate).getTime();
      const startMonth = Math.floor((taskStartTime - projectStartTime) / (30 * 24 * 60 * 60 * 1e3));
      const endMonth = Math.floor((taskEndTime - projectStartTime) / (30 * 24 * 60 * 60 * 1e3));
      return {
        id: task.id,
        name: task.name,
        startDate: task.startDate,
        endDate: task.endDate,
        startMonth,
        endMonth,
        confidence: task.isCritical ? 0.7 : 0.85,
        // FIXED: Use decimals (0-1) not percentages
        dependencies: task.dependencies,
        deliverables: task.deliverables || [],
        owner: task.owner || task.assignedResourceNames?.[0] || "Unassigned",
        assignedResourceIds: task.assignedResourceIds || [],
        assignedResourceNames: task.assignedResourceNames || [],
        description: task.description,
        requirements: task.requirements || [],
        // Preserve skill requirements for assignment generation
        skills: task.skills || []
        // Also preserve direct skills array if present
      };
    }),
    totalMonths: schedule.totalDuration,
    criticalPath: schedule.criticalPath,
    phases: generatePhasesFromSchedule(schedule),
    milestones: extractMilestonesFromSchedule(schedule, projectStartDate)
  };
}
function integrateScheduleIntoEPM(epmProgram, schedule) {
  console.log(`[EPM Integration] integrateScheduleIntoEPM called`);
  console.log(`[EPM Integration] Schedule has tasks: ${schedule?.tasks ? "YES" : "NO"}`);
  console.log(`[EPM Integration] Task count: ${schedule?.tasks?.length || 0}`);
  const updatedProgram = { ...epmProgram };
  if (schedule?.tasks) {
    console.log(`[EPM Integration] Starting workstream integration...`);
    console.log(`[EPM Integration] Original workstreams: ${epmProgram.workstreams?.length || 0}`);
    console.log(`[EPM Integration] Schedule tasks: ${schedule.tasks.length}`);
    const workstreamMap = /* @__PURE__ */ new Map();
    if (epmProgram.workstreams) {
      epmProgram.workstreams.forEach((ws2) => {
        workstreamMap.set(ws2.id, ws2);
      });
    }
    updatedProgram.workstreams = schedule.tasks.map((task, index2) => {
      const originalWorkstream = workstreamMap.get(task.id) || epmProgram.workstreams?.[index2] || {};
      const deliverablesToUse = originalWorkstream.deliverables || task.deliverables || [];
      console.log(`[EPM Integration] Task ${task.id}: Using ${deliverablesToUse.length} deliverables (original had ${originalWorkstream.deliverables?.length || 0})`);
      return {
        ...originalWorkstream,
        id: task.id,
        name: task.name,
        startMonth: task.startMonth,
        endMonth: task.endMonth,
        confidence: task.confidence,
        dependencies: task.dependencies,
        deliverables: ensureDeliverablesWithinBounds(
          deliverablesToUse,
          task.startMonth,
          task.endMonth
        ),
        owner: task.owner || originalWorkstream.owner,
        assignedResourceIds: task.assignedResourceIds || [],
        assignedResourceNames: task.assignedResourceNames || [],
        description: task.description || originalWorkstream.description,
        requirements: task.requirements || [],
        // CRITICAL: Preserve requirements for assignment generation
        skills: task.skills || [],
        // CRITICAL: Preserve skills for assignment generation
        startDate: task.startDate,
        // Add explicit dates for assignment engine
        endDate: task.endDate
      };
    });
  }
  const actualMaxEndMonth = updatedProgram.workstreams?.length > 0 ? Math.max(...updatedProgram.workstreams.map((w) => w.endMonth || 0)) : 0;
  const actualTotalMonths = actualMaxEndMonth > 0 ? actualMaxEndMonth + 1 : schedule.totalMonths || 12;
  console.log(`[EPM Integration] Timeline recalculation:`);
  console.log(`  - schedule.totalMonths: ${schedule.totalMonths}`);
  console.log(`  - Actual max workstream endMonth: ${actualMaxEndMonth}`);
  console.log(`  - Corrected totalMonths: ${actualTotalMonths}`);
  const correctedPhases = generatePhasesFromActualWorkstreams(
    actualTotalMonths,
    updatedProgram.workstreams || []
  );
  updatedProgram.timeline = {
    ...epmProgram.timeline,
    totalMonths: actualTotalMonths,
    phases: correctedPhases,
    criticalPath: schedule.criticalPath,
    milestones: schedule.milestones
  };
  if (updatedProgram.stageGates?.gates) {
    updatedProgram.stageGates.gates = updatedProgram.stageGates.gates.map((gate, index2) => {
      const phase = correctedPhases[index2];
      if (phase) {
        return {
          ...gate,
          month: phase.endMonth,
          date: phase.endDate
        };
      }
      return gate;
    });
  }
  return updatedProgram;
}
function generatePhasesFromActualWorkstreams(totalMonths, workstreams2) {
  const phaseCount = totalMonths <= 4 ? 2 : totalMonths <= 8 ? 3 : 4;
  const phaseDuration = Math.ceil(totalMonths / phaseCount);
  const phaseConfigs = [
    { name: "Planning & Foundation", description: "Initial setup, team assembly, detailed planning" },
    { name: "Development & Execution", description: "Core workstream execution, deliverable development" },
    { name: "Integration & Testing", description: "Integration of deliverables, testing, refinement" },
    { name: "Deployment & Stabilization", description: "Launch, monitoring, optimization" }
  ];
  const phases = [];
  const projectStartDate = /* @__PURE__ */ new Date();
  for (let i = 0; i < phaseCount; i++) {
    const phaseStart = i * phaseDuration;
    const phaseEnd = Math.min((i + 1) * phaseDuration, totalMonths);
    const config = phaseConfigs[i] || phaseConfigs[phaseConfigs.length - 1];
    const phaseWorkstreams = workstreams2.filter(
      (w) => w.startMonth < phaseEnd && w.endMonth >= phaseStart
    );
    phases.push({
      phase: i + 1,
      name: config.name,
      startMonth: phaseStart,
      endMonth: phaseEnd,
      description: config.description,
      startDate: new Date(projectStartDate.getTime() + phaseStart * 30 * 24 * 60 * 60 * 1e3),
      endDate: new Date(projectStartDate.getTime() + (phaseEnd + 1) * 30 * 24 * 60 * 60 * 1e3),
      workstreamIds: phaseWorkstreams.map((w) => w.id),
      keyMilestones: [`${config.name} Complete`]
    });
  }
  console.log(`[EPM Integration] Generated ${phaseCount} phases for ${totalMonths} month program`);
  phases.forEach((p) => {
    console.log(`  Phase ${p.phase} (M${p.startMonth}-M${p.endMonth}): ${p.workstreamIds.length} workstreams`);
  });
  return phases;
}
function ensureDeliverablesWithinBounds(deliverables, startMonth, endMonth) {
  console.log(`[EPM Integration] Fixing deliverables: ${deliverables.length} items, range M${startMonth}-M${endMonth}`);
  if (!deliverables || deliverables.length === 0) return [];
  const totalMonths = endMonth - startMonth;
  return deliverables.map((d, index2) => {
    if (typeof d === "string") {
      const progressPercent = (index2 + 1) / deliverables.length;
      const dueMonth = startMonth + Math.floor(totalMonths * progressPercent);
      return {
        id: `D${index2 + 1}`,
        name: d,
        dueMonth: Math.min(dueMonth, endMonth)
      };
    }
    const existingDueMonth = typeof d.dueMonth === "number" && !isNaN(d.dueMonth) ? d.dueMonth : null;
    let finalDueMonth;
    if (existingDueMonth !== null) {
      finalDueMonth = Math.max(startMonth, Math.min(endMonth, existingDueMonth));
    } else {
      const progressPercent = (index2 + 1) / deliverables.length;
      finalDueMonth = startMonth + Math.floor(totalMonths * progressPercent);
      finalDueMonth = Math.min(finalDueMonth, endMonth);
    }
    return {
      ...d,
      dueMonth: finalDueMonth
    };
  });
}
function generatePhasesFromSchedule(schedule) {
  const totalMonths = schedule.totalDuration;
  const phases = [];
  const phaseCount = totalMonths <= 6 ? 2 : totalMonths <= 12 ? 3 : 4;
  const monthsPerPhase = Math.ceil(totalMonths / phaseCount);
  const phaseNames = [
    "Planning & Setup",
    "Development & Execution",
    "Testing & Validation",
    "Deployment & Handover"
  ];
  for (let i = 0; i < phaseCount; i++) {
    const startMonth = i * monthsPerPhase;
    const endMonth = Math.min((i + 1) * monthsPerPhase - 1, totalMonths - 1);
    phases.push({
      phase: i + 1,
      name: phaseNames[i],
      startMonth,
      endMonth,
      startDate: new Date(Date.now() + startMonth * 30 * 24 * 60 * 60 * 1e3),
      endDate: new Date(Date.now() + (endMonth + 1) * 30 * 24 * 60 * 60 * 1e3)
    });
  }
  return phases;
}
function extractMilestonesFromSchedule(schedule, projectStartDate) {
  const milestones = [];
  const projectStartTime = projectStartDate.getTime();
  schedule.tasks.forEach((task) => {
    if (task.deliverables?.length > 0) {
      task.deliverables.forEach((deliverable) => {
        milestones.push({
          id: deliverable.id,
          name: deliverable.name,
          date: new Date(projectStartTime + deliverable.dueMonth * 30 * 24 * 60 * 60 * 1e3),
          type: "deliverable",
          workstreamId: task.id
        });
      });
    }
  });
  const phases = generatePhasesFromSchedule(schedule);
  phases.forEach((phase) => {
    milestones.push({
      id: `phase-${phase.phase}-complete`,
      name: `${phase.name} Complete`,
      date: phase.endDate,
      type: "phase",
      phaseId: phase.phase
    });
  });
  return milestones;
}
var init_epm_integration = __esm({
  "src/lib/intelligent-planning/epm-integration.ts"() {
    "use strict";
    init_intelligent_planning();
  }
});

// server/intelligence/epm/context-builder.ts
var ContextBuilder;
var init_context_builder = __esm({
  "server/intelligence/epm/context-builder.ts"() {
    "use strict";
    ContextBuilder = class {
      /**
       * Build planning context from journey insights
       * Now ASYNC to fetch initiative type from database
       */
      static async fromJourneyInsights(insights, journeyType = "strategy_workspace", sessionId) {
        const scale = this.inferScale(insights);
        const timelineRange = this.inferTimelineRange(scale, insights);
        const budgetRange = this.inferBudgetRange(scale, insights);
        let initiativeType = void 0;
        let businessName = "Unnamed Business";
        let businessDescription = "";
        let userInput = "";
        if (sessionId) {
          try {
            const { db: db2 } = await Promise.resolve().then(() => (init_db(), db_exports));
            const { strategicUnderstanding: strategicUnderstanding7 } = await Promise.resolve().then(() => (init_schema(), schema_exports));
            const { eq: eq37 } = await import("drizzle-orm");
            const understanding = await db2.select({
              initiativeType: strategicUnderstanding7.initiativeType,
              title: strategicUnderstanding7.title,
              initiativeDescription: strategicUnderstanding7.initiativeDescription,
              userInput: strategicUnderstanding7.userInput
            }).from(strategicUnderstanding7).where(eq37(strategicUnderstanding7.sessionId, sessionId)).limit(1);
            console.log("[ContextBuilder] INPUT:", {
              sessionId,
              understandingFound: understanding.length > 0,
              title: understanding[0]?.title?.substring(0, 50),
              userInput: understanding[0]?.userInput?.substring(0, 100),
              initiativeType: understanding[0]?.initiativeType
            });
            if (understanding.length > 0) {
              if (understanding[0].initiativeType) {
                initiativeType = understanding[0].initiativeType;
                console.log(`[ContextBuilder] \u{1F3AF} Retrieved initiative type from DB: ${initiativeType}`);
              }
              if (understanding[0].title && understanding[0].title !== "Untitled" && understanding[0].title.length > 3) {
                businessName = understanding[0].title;
                console.log(`[ContextBuilder] \u{1F3E2} Retrieved business name from title: "${businessName}"`);
              } else if (understanding[0].userInput) {
                businessName = this.extractBusinessNameFromInput(understanding[0].userInput);
                console.log(`[ContextBuilder] \u{1F3E2} Extracted business name from userInput: "${businessName}"`);
              }
              if (understanding[0].initiativeDescription) {
                businessDescription = understanding[0].initiativeDescription;
                console.log(`[ContextBuilder] \u{1F4DD} Retrieved business description from DB`);
              }
              if (understanding[0].userInput) {
                userInput = understanding[0].userInput;
              }
            } else {
              console.log("[ContextBuilder] \u26A0\uFE0F No strategic understanding found for id:", sessionId);
            }
          } catch (error) {
            console.error("[ContextBuilder] Error fetching strategic understanding:", error);
          }
        } else {
          console.log("[ContextBuilder] \u26A0\uFE0F No sessionId provided, cannot fetch strategic context");
        }
        const businessType = this.inferBusinessType(insights);
        const industry = insights.marketContext?.industry || this.inferIndustryFromType(businessType);
        console.log("[ContextBuilder] OUTPUT:", {
          businessName,
          businessType,
          industry
        });
        return {
          business: {
            name: businessName,
            type: businessType,
            industry,
            description: businessDescription || userInput,
            scale,
            initiativeType
          },
          strategic: {
            insights,
            constraints: [],
            objectives: this.extractObjectives(insights)
          },
          execution: {
            timeline: timelineRange,
            budget: budgetRange,
            resources: []
          },
          meta: {
            journeyType,
            confidence: insights.overallConfidence || 0.75,
            version: "1.0"
          }
        };
      }
      /**
       * Infer business scale using multiple signals
       */
      static inferScale(insights) {
        const contextText = insights.insights.map((i) => i.content).join(" ").toLowerCase();
        let smb_score = 0;
        let enterprise_score = 0;
        if (contextText.match(/\b(shop|store|cafe|coffee|local|small|startup|boutique|restaurant)\b/g)) {
          smb_score += 3;
        }
        if (contextText.match(/\b(single location|one location|neighborhood|community)\b/g)) {
          smb_score += 2;
        }
        if (contextText.match(/\b(under \$\d+k|small budget|limited budget|bootstrap)\b/g)) {
          smb_score += 2;
        }
        if (contextText.match(/\b(1-5 employees|small team|solo|founder)\b/g)) {
          smb_score += 2;
        }
        if (contextText.match(/\b(enterprise|corporation|global|multinational|platform|saas)\b/g)) {
          enterprise_score += 3;
        }
        if (contextText.match(/\b(multi-location|nationwide|international|multiple markets)\b/g)) {
          enterprise_score += 2;
        }
        if (contextText.match(/\b(million|series [abc]|vc funded|enterprise software)\b/g)) {
          enterprise_score += 2;
        }
        if (contextText.match(/\b(100\+ employees|large team|department)\b/g)) {
          enterprise_score += 2;
        }
        if (smb_score >= 4 && smb_score > enterprise_score) {
          return "smb";
        }
        if (enterprise_score >= 4 && enterprise_score > smb_score) {
          return "enterprise";
        }
        return "mid_market";
      }
      /**
       * Infer timeline range based on scale
       */
      static inferTimelineRange(scale, insights) {
        const contextText = insights.insights.map((i) => i.content).join(" ").toLowerCase();
        const monthsMatch = contextText.match(/(\d+)\s*months?/);
        if (monthsMatch) {
          const explicitMonths = parseInt(monthsMatch[1]);
          return {
            min: Math.max(3, Math.floor(explicitMonths * 0.75)),
            max: Math.ceil(explicitMonths * 1.5)
          };
        }
        switch (scale) {
          case "smb":
            return { min: 6, max: 12 };
          case "mid_market":
            return { min: 12, max: 24 };
          case "enterprise":
            return { min: 24, max: 48 };
        }
      }
      /**
       * Infer budget range based on scale and context
       */
      static inferBudgetRange(scale, insights) {
        const contextText = insights.insights.map((i) => i.content).join(" ").toLowerCase();
        const budgetMatch = contextText.match(/\$(\d+(?:,\d+)*)\s*(k|thousand|million|mm|m(?=\s|$))?/i);
        if (budgetMatch) {
          const amount = parseInt(budgetMatch[1].replace(/,/g, ""));
          const unit = (budgetMatch[2] || "").toLowerCase();
          const multiplier = unit === "million" || unit === "mm" || unit === "m" ? 1e6 : unit === "k" || unit === "thousand" ? 1e3 : 1;
          const budget = amount * multiplier;
          return {
            min: budget * 0.75,
            max: budget * 1.25
          };
        }
        switch (scale) {
          case "smb":
            return { min: 5e4, max: 25e4 };
          case "mid_market":
            return { min: 25e4, max: 2e6 };
          case "enterprise":
            return { min: 2e6, max: 1e7 };
        }
      }
      /**
       * Infer business type from insights
       * Uses a more intelligent approach: check for specific industry context BEFORE generic patterns
       */
      static inferBusinessType(insights) {
        const contextText = insights.insights.map((i) => i.content).join(" ").toLowerCase();
        if (contextText.match(/\b(sneaker|shoe|footwear|athletic|sportswear|nike|adidas|apparel|clothing|fashion)\b/)) {
          return "retail_specialty";
        }
        if (contextText.match(/\b(electronics|phone|computer|laptop|gadget|tech.*store|tech.*shop)\b/)) {
          return "retail_electronics";
        }
        if (contextText.match(/\b(furniture|home.*store|home.*shop|decor|interior)\b/)) {
          return "retail_home_goods";
        }
        if (contextText.match(/\b(retail|merchandise|department|boutique)\b/) && !contextText.match(/\b(food|cafe|coffee|restaurant|bakery|grocery|kitchen|perishable)\b/)) {
          return "retail_general";
        }
        if (contextText.match(/\b(coffee|cafe|restaurant|bakery|food.*service|grocery|kitchen|dining|cuisine|menu)\b/)) {
          return "retail_food_service";
        }
        if (contextText.match(/\b(saas|software|platform|app(?:lication)?|tech(?:nology)?)\b/) && !contextText.match(/\b(store|shop|retail)\b/)) {
          return "saas_platform";
        }
        if (contextText.match(/\b(consulting|service|agency|advisory)\b/)) return "professional_services";
        if (contextText.match(/\b(manufacturing|factory|production|assembly)\b/)) return "manufacturing";
        if (contextText.match(/\b(ecommerce|e-commerce|online.*store|marketplace)\b/)) return "ecommerce";
        if (contextText.match(/\b(store|shop)\b/) && !contextText.match(/\b(food|cafe|coffee|restaurant|bakery|grocery)\b/)) {
          return "retail_general";
        }
        return "general_business";
      }
      /**
       * Extract objectives from insights
       */
      static extractObjectives(insights) {
        return insights.insights.filter((i) => i.type === "workstream" || i.source?.includes("objective")).slice(0, 5).map((i) => i.content.split("\n")[0]);
      }
      /**
       * Extract business name from user input if title is not set
       * Looks for common patterns like "Basketball Sneaker Store" or "a sneaker store called X"
       */
      static extractBusinessNameFromInput(userInput) {
        console.log("[extractBusinessName] Input:", userInput?.substring(0, 100));
        if (!userInput || userInput.trim().length === 0) {
          return "the business";
        }
        let cleanInput = userInput.trim();
        const sentenceStarters = [
          /^i\s+(?:want\s+to|am\s+planning\s+to|plan\s+to|would\s+like\s+to|need\s+to)\s+(?:open|start|build|launch|create)\s+(?:a\s+)?/i,
          /^we\s+(?:want\s+to|are\s+planning\s+to|plan\s+to|would\s+like\s+to|need\s+to)\s+(?:open|start|build|launch|create)\s+(?:a\s+)?/i,
          /^(?:opening|starting|launching|building|creating)\s+(?:a\s+)?/i,
          /^(?:open|start|build|launch|create)\s+(?:a\s+)?/i,
          /^(?:a\s+|an\s+|the\s+)/i
        ];
        for (const starter of sentenceStarters) {
          cleanInput = cleanInput.replace(starter, "");
        }
        const quotedMatch = userInput.match(/["']([^"']+)["']/);
        if (quotedMatch && quotedMatch[1].length <= 60) {
          console.log("[extractBusinessName] Found quoted name:", quotedMatch[1]);
          return quotedMatch[1];
        }
        const storePattern = cleanInput.match(/^(.+?(?:store|shop|boutique|cafe|restaurant|business))/i);
        if (storePattern && storePattern[1]) {
          const extracted = storePattern[1].trim();
          if (extracted.length > 3 && extracted.length <= 60) {
            console.log("[extractBusinessName] Store pattern matched:", extracted);
            return extracted;
          }
        }
        const locationPattern = cleanInput.match(/^(.+?)\s+(?:in|at|for|located\s+in)\s+/i);
        if (locationPattern && locationPattern[1]) {
          const extracted = locationPattern[1].trim();
          if (extracted.length > 3 && extracted.length <= 60) {
            console.log("[extractBusinessName] Location pattern matched:", extracted);
            return extracted;
          }
        }
        const namedPattern = userInput.match(/(?:called|named)\s+["']?([^"']+?)["']?(?:\s+in|\s+at|\s*$)/i);
        if (namedPattern && namedPattern[1]) {
          const extracted = namedPattern[1].trim();
          if (extracted.length > 2 && extracted.length <= 60) {
            console.log("[extractBusinessName] Named pattern matched:", extracted);
            return extracted;
          }
        }
        if (cleanInput.length > 3 && cleanInput.length <= 60) {
          console.log("[extractBusinessName] Using cleaned input:", cleanInput);
          return cleanInput;
        }
        const words = cleanInput.split(/\s+/).filter((w) => !["a", "an", "the", "i", "we"].includes(w.toLowerCase()));
        const result = words.slice(0, 5).join(" ");
        if (result.length > 3) {
          console.log("[extractBusinessName] Fallback words:", result);
          return result;
        }
        console.log("[extractBusinessName] Final fallback to cleaned input");
        return cleanInput || "the business";
      }
      /**
       * Infer human-readable industry from business type
       */
      static inferIndustryFromType(businessType) {
        const industryMap = {
          "retail_specialty": "Specialty Retail",
          "retail_electronics": "Electronics Retail",
          "retail_home_goods": "Home Goods Retail",
          "retail_general": "General Retail",
          "retail_food_service": "Food & Beverage",
          "saas_platform": "Technology / SaaS",
          "professional_services": "Professional Services",
          "manufacturing": "Manufacturing",
          "ecommerce": "E-Commerce",
          "general_business": "General Business"
        };
        return industryMap[businessType] || "General Business";
      }
      /**
       * Create a StrategyContext from PlanningContext
       * Architecture Spec Section 5.2
       *
       * This is the context object that flows through ALL downstream EPM components.
       */
      static toStrategyContext(planningContext, sessionId, journeyType = "strategy_workspace") {
        const businessType = planningContext.business.type || "general_business";
        const categoryMap = {
          "retail_specialty": "retail_specialty",
          "retail_electronics": "retail_electronics",
          "retail_home_goods": "retail_home_goods",
          "retail_general": "retail_general",
          "retail_food_service": "food_beverage",
          "saas_platform": "saas_platform",
          "professional_services": "professional_services",
          "manufacturing": "manufacturing",
          "ecommerce": "ecommerce",
          "general_business": "generic"
        };
        const category = categoryMap[businessType] || "generic";
        const subcategory = this.inferSubcategoryFromText(
          `${planningContext.business.name} ${planningContext.business.description || ""}`
        );
        const keywords = this.extractKeywords(
          planningContext.business.name,
          planningContext.business.description
        );
        return {
          sessionId,
          journeyType,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          businessType: {
            name: planningContext.business.name,
            category,
            subcategory
          },
          industry: {
            name: planningContext.business.industry || this.inferIndustryFromType(businessType),
            keywords
          },
          region: {
            country: "Unknown",
            // Would need to be extracted from input
            city: void 0
          },
          originalInput: planningContext.business.description || planningContext.business.name,
          strategicSummary: {
            primaryObjective: planningContext.strategic?.objectives?.[0],
            keyConstraints: planningContext.strategic?.constraints
          }
        };
      }
      /**
       * Infer subcategory from business description text
       */
      static inferSubcategoryFromText(text2) {
        const lower = text2.toLowerCase();
        if (lower.match(/basketball|sneaker|footwear|athletic|shoe/)) {
          return "athletic_footwear";
        }
        if (lower.match(/fashion|apparel|clothing|boutique/)) {
          return "fashion_apparel";
        }
        if (lower.match(/electronics|gadget|phone|computer/)) {
          return "electronics";
        }
        if (lower.match(/cafe|coffee|espresso/)) {
          return "cafe_coffee_shop";
        }
        if (lower.match(/restaurant|dining|cuisine/)) {
          return "restaurant";
        }
        if (lower.match(/catering|corporate.*food|event.*food/)) {
          return "catering";
        }
        if (lower.match(/consulting|consultancy|advisory/)) {
          return "consulting";
        }
        return void 0;
      }
      /**
       * Extract industry keywords from business name and description
       */
      static extractKeywords(name, description) {
        const text2 = `${name} ${description || ""}`.toLowerCase();
        const keywords = [];
        const patterns = {
          basketball: /basketball/,
          sneaker: /sneaker/,
          athletic: /athletic/,
          footwear: /footwear|shoe/,
          retail: /retail|store|shop/,
          cafe: /cafe|coffee/,
          restaurant: /restaurant|dining/,
          technology: /tech|software|saas/,
          fashion: /fashion|apparel|clothing/,
          premium: /premium|luxury|high.end/
        };
        for (const [keyword, pattern] of Object.entries(patterns)) {
          if (pattern.test(text2)) {
            keywords.push(keyword);
          }
        }
        return keywords.length > 0 ? keywords : ["business"];
      }
    };
  }
});

// server/intelligence/epm/validator.ts
var EPMValidator;
var init_validator2 = __esm({
  "server/intelligence/epm/validator.ts"() {
    "use strict";
    EPMValidator = class {
      industryKeywords = {
        food_service: ["food safety", "kitchen", "restaurant", "menu", "chef", "dining", "catering", "culinary", "food handling", "haccp"],
        healthcare: ["hipaa", "patient", "clinical", "medical", "healthcare", "pharmacy", "hospital", "diagnosis", "treatment"],
        finance: ["banking", "trading", "securities", "investment", "loan", "credit", "forex", "asset management"],
        manufacturing: ["assembly line", "production floor", "quality control", "lean manufacturing", "six sigma", "warehouse"],
        retail: ["inventory", "point of sale", "merchandising", "storefront", "e-commerce", "fulfillment"],
        technology: ["software development", "devops", "api", "database", "cloud", "agile", "sprint"],
        education: ["curriculum", "enrollment", "student", "faculty", "academic", "campus"],
        construction: ["site safety", "building permit", "contractor", "blueprints", "construction site"],
        hospitality: ["hotel", "guest services", "booking", "concierge", "housekeeping"],
        transportation: ["logistics", "fleet management", "route optimization", "cargo", "freight"]
      };
      /**
       * Comprehensive data validation and auto-correction
       * Validates all logical constraints: deliverables, dependencies, phases, gates
       */
      validate(workstreams2, timeline, stageGates2, businessContext) {
        const errors = [];
        const corrections = [];
        const warnings = [];
        this.validateDeliverables(workstreams2, errors, corrections);
        this.validateDependencies(workstreams2, errors, corrections);
        this.revalidateDeliverablesAfterAdjustment(workstreams2, corrections);
        this.validatePhases(timeline, errors, corrections);
        this.validateStageGates(stageGates2, timeline, errors, corrections);
        this.validateIndustryAlignment(workstreams2, businessContext, warnings);
        return {
          valid: errors.length === 0,
          errors,
          warnings,
          corrections
        };
      }
      validateIndustryAlignment(workstreams2, businessContext, warnings) {
        if (!businessContext) return;
        const contextLower = businessContext.toLowerCase();
        const detectedIndustries = [];
        for (const [industry, keywords] of Object.entries(this.industryKeywords)) {
          if (keywords.some((kw) => contextLower.includes(kw))) {
            detectedIndustries.push(industry);
          }
        }
        for (const workstream of workstreams2) {
          const wsContent = `${workstream.name} ${workstream.description || ""}`.toLowerCase();
          for (const [industry, keywords] of Object.entries(this.industryKeywords)) {
            if (detectedIndustries.includes(industry)) continue;
            const matchedKeyword = keywords.find((kw) => wsContent.includes(kw));
            if (matchedKeyword) {
              warnings.push(
                `Industry mismatch: Workstream "${workstream.name}" contains "${matchedKeyword}" (${industry} industry term) which may not match your business context`
              );
            }
          }
        }
      }
      validateDeliverables(workstreams2, errors, corrections) {
        for (const workstream of workstreams2) {
          for (const deliverable of workstream.deliverables) {
            if (deliverable.dueMonth < workstream.startMonth || deliverable.dueMonth > workstream.endMonth) {
              const originalDueMonth = deliverable.dueMonth;
              deliverable.dueMonth = Math.max(
                workstream.startMonth,
                Math.min(deliverable.dueMonth, workstream.endMonth)
              );
              errors.push(
                `Deliverable "${deliverable.name}" at M${originalDueMonth} outside workstream "${workstream.name}" (M${workstream.startMonth}-M${workstream.endMonth})`
              );
              corrections.push(`Clamped deliverable "${deliverable.name}" to M${deliverable.dueMonth}`);
            }
          }
        }
      }
      validateDependencies(workstreams2, errors, corrections) {
        for (const workstream of workstreams2) {
          const validDependencies = [];
          for (const depId of workstream.dependencies) {
            const dependency = workstreams2.find((w) => w.id === depId);
            if (!dependency) {
              errors.push(`Workstream "${workstream.name}" depends on non-existent "${depId}"`);
              corrections.push(`Removed invalid dependency "${depId}" from "${workstream.name}"`);
              continue;
            }
            if (dependency.endMonth >= workstream.startMonth) {
              errors.push(
                `Invalid dependency: "${workstream.name}" (M${workstream.startMonth}) starts before "${dependency.name}" ends (M${dependency.endMonth})`
              );
              const oldStart = workstream.startMonth;
              workstream.startMonth = dependency.endMonth + 1;
              const duration = workstream.endMonth - oldStart;
              workstream.endMonth = workstream.startMonth + duration;
              corrections.push(
                `Adjusted "${workstream.name}" to M${workstream.startMonth}-M${workstream.endMonth} to respect dependency on "${dependency.name}"`
              );
            }
            validDependencies.push(depId);
          }
          workstream.dependencies = validDependencies;
        }
      }
      revalidateDeliverablesAfterAdjustment(workstreams2, corrections) {
        for (const workstream of workstreams2) {
          for (const deliverable of workstream.deliverables) {
            if (deliverable.dueMonth < workstream.startMonth || deliverable.dueMonth > workstream.endMonth) {
              deliverable.dueMonth = Math.max(
                workstream.startMonth,
                Math.min(deliverable.dueMonth, workstream.endMonth)
              );
              corrections.push(
                `Re-clamped deliverable "${deliverable.name}" to M${deliverable.dueMonth} after "${workstream.name}" date adjustment`
              );
            }
          }
        }
      }
      validatePhases(timeline, errors, corrections) {
        const sortedPhases = [...timeline.phases].sort((a, b) => a.phase - b.phase);
        for (let i = 1; i < sortedPhases.length; i++) {
          const prevPhase = sortedPhases[i - 1];
          const currPhase = sortedPhases[i];
          if (currPhase.startMonth <= prevPhase.endMonth) {
            errors.push(
              `Phase ${currPhase.phase} "${currPhase.name}" overlaps with Phase ${prevPhase.phase} "${prevPhase.name}"`
            );
            const oldStart = currPhase.startMonth;
            currPhase.startMonth = prevPhase.endMonth + 1;
            corrections.push(
              `Adjusted Phase ${currPhase.phase} start from M${oldStart} to M${currPhase.startMonth}`
            );
          }
        }
      }
      validateStageGates(stageGates2, timeline, errors, corrections) {
        for (const gate of stageGates2.gates) {
          const phase = timeline.phases.find(
            (p) => gate.month >= p.startMonth && gate.month <= p.endMonth
          );
          if (!phase) {
            errors.push(`Stage gate ${gate.gate} at M${gate.month} not within any phase`);
            const nearestPhase = timeline.phases.reduce(
              (prev, curr) => Math.abs(curr.endMonth - gate.month) < Math.abs(prev.endMonth - gate.month) ? curr : prev
            );
            const oldMonth = gate.month;
            gate.month = nearestPhase.endMonth;
            corrections.push(
              `Moved gate ${gate.gate} from M${oldMonth} to M${gate.month} (end of Phase ${nearestPhase.phase})`
            );
          }
        }
      }
      /**
       * Planning Grid Analysis
       * Creates month-by-month view to identify resource conflicts
       */
      analyzePlanningGrid(workstreams2, timeline) {
        const grid = [];
        const conflicts = [];
        for (let m = 0; m <= timeline.totalMonths; m++) {
          const phase = timeline.phases.find((p) => m >= p.startMonth && m <= p.endMonth);
          grid[m] = {
            month: m,
            tasks: [],
            deliverables: [],
            phase: phase?.name || null,
            utilization: 0
          };
        }
        for (const ws2 of workstreams2) {
          for (let m = ws2.startMonth; m <= ws2.endMonth; m++) {
            if (grid[m]) {
              grid[m].tasks.push({
                id: ws2.id,
                name: ws2.name,
                confidence: ws2.confidence
              });
              grid[m].utilization += 1;
            }
          }
          for (const deliverable of ws2.deliverables) {
            if (grid[deliverable.dueMonth]) {
              grid[deliverable.dueMonth].deliverables.push({
                id: deliverable.id,
                name: deliverable.name,
                workstreamId: ws2.id
              });
            }
          }
        }
        for (const month of grid) {
          if (month.utilization > 3) {
            conflicts.push(
              `Month ${month.month} (${month.phase || "No phase"}): ${month.utilization} parallel tasks (max recommended: 3)`
            );
          }
          if (month.deliverables.length > 5) {
            conflicts.push(
              `Month ${month.month}: ${month.deliverables.length} deliverables due (may overwhelm review capacity)`
            );
          }
        }
        return {
          grid,
          conflicts,
          maxUtilization: Math.max(...grid.map((m) => m.utilization)),
          totalTasks: workstreams2.length
        };
      }
    };
  }
});

// server/intelligence/epm/timeline-calculator.ts
var TimelineCalculator;
var init_timeline_calculator = __esm({
  "server/intelligence/epm/timeline-calculator.ts"() {
    "use strict";
    TimelineCalculator = class {
      /**
       * Generate timeline from insights and workstreams
       */
      async calculate(insights, workstreams2, userContext) {
        const timelineInsight = insights.insights.find((i) => i.type === "timeline");
        let baseMonths = 12;
        if (insights.marketContext.urgency === "ASAP") {
          baseMonths = 6;
        } else if (insights.marketContext.urgency === "Exploratory") {
          baseMonths = 18;
        }
        let deadlineMonths = baseMonths;
        if (userContext?.hardDeadlines && userContext.hardDeadlines.length > 0) {
          const earliestDeadline = Math.min(...userContext.hardDeadlines.map(
            (d) => Math.ceil((d.date.getTime() - Date.now()) / (30 * 24 * 60 * 60 * 1e3))
          ));
          deadlineMonths = earliestDeadline;
        }
        let maxWorkstreamEnd = 0;
        if (workstreams2.length > 0) {
          maxWorkstreamEnd = Math.max(...workstreams2.map((w) => w.endMonth));
        }
        const effectiveDuration = maxWorkstreamEnd > 0 ? maxWorkstreamEnd + 1 : baseMonths;
        const totalMonths = Math.max(effectiveDuration, 3);
        console.log(`[TimelineCalculator] \u{1F4CA} Timeline calculation:`);
        console.log(`  - Workstream count: ${workstreams2.length}`);
        console.log(`  - Max workstream end: M${maxWorkstreamEnd}`);
        console.log(`  - Base months (from urgency): ${baseMonths}`);
        console.log(`  - Effective duration: ${effectiveDuration}`);
        console.log(`  - Total months: ${totalMonths}`);
        if (deadlineMonths < totalMonths && userContext?.hardDeadlines) {
          console.warn(
            `[TimelineCalculator] Hard deadline at M${deadlineMonths} exceeded by corrected schedule (M${totalMonths}). Consider resource optimization or deadline renegotiation.`
          );
        }
        const phases = this.generatePhases(totalMonths, workstreams2);
        const criticalPath = this.identifyCriticalPath(workstreams2);
        return {
          totalMonths,
          phases,
          criticalPath,
          confidence: timelineInsight?.confidence || 0.65
        };
      }
      /**
       * Generate project phases aligned with actual workstream execution windows
       *
       * Phases are divided evenly across the program duration, and workstreams
       * are assigned to phases based on when they EXECUTE (overlap with phase window),
       * not just when they start.
       */
      generatePhases(totalMonths, workstreams2) {
        const phaseCount = totalMonths <= 4 ? 2 : totalMonths <= 8 ? 3 : 4;
        const phaseDuration = Math.ceil(totalMonths / phaseCount);
        const phaseConfigs = [
          { name: "Planning & Foundation", description: "Initial setup, team assembly, detailed planning", milestones: ["Project kickoff", "Team onboarded", "Detailed plan approved"] },
          { name: "Development & Execution", description: "Core workstream execution, deliverable development", milestones: ["Key deliverables completed", "Progress review", "Adjustments made"] },
          { name: "Integration & Testing", description: "Integration of deliverables, testing, refinement", milestones: ["Integration complete", "Testing passed", "Stakeholder approval"] },
          { name: "Deployment & Stabilization", description: "Launch, monitoring, optimization", milestones: ["Launch complete", "Performance validated", "Benefits tracking"] }
        ];
        const phases = [];
        for (let i = 0; i < phaseCount; i++) {
          const phaseStart = i * phaseDuration;
          const phaseEnd = Math.min((i + 1) * phaseDuration, totalMonths);
          const config = phaseConfigs[i] || phaseConfigs[phaseConfigs.length - 1];
          const phaseWorkstreams = workstreams2.filter(
            (w) => w.startMonth < phaseEnd && w.endMonth >= phaseStart
          );
          phases.push({
            phase: i + 1,
            name: config.name,
            startMonth: phaseStart,
            endMonth: phaseEnd,
            description: config.description,
            keyMilestones: config.milestones,
            workstreamIds: phaseWorkstreams.map((w) => w.id)
          });
        }
        console.log(`[TimelineCalculator] Generated ${phaseCount} phases for ${totalMonths} month program:`);
        phases.forEach((p) => {
          console.log(`  Phase ${p.phase} (M${p.startMonth}-M${p.endMonth}): ${p.workstreamIds.length} workstreams`);
        });
        return phases;
      }
      /**
       * Identify critical path (longest dependency chain)
       */
      identifyCriticalPath(workstreams2) {
        if (workstreams2.length === 0) return [];
        const byId = new Map(workstreams2.map((ws2) => [ws2.id, ws2]));
        const inDegree = /* @__PURE__ */ new Map();
        const dependents = /* @__PURE__ */ new Map();
        for (const ws2 of workstreams2) {
          inDegree.set(ws2.id, 0);
          dependents.set(ws2.id, []);
        }
        for (const ws2 of workstreams2) {
          for (const depId of ws2.dependencies || []) {
            if (!byId.has(depId)) continue;
            inDegree.set(ws2.id, (inDegree.get(ws2.id) || 0) + 1);
            dependents.get(depId)?.push(ws2.id);
          }
        }
        const queue = workstreams2.filter((ws2) => (inDegree.get(ws2.id) || 0) === 0).map((ws2) => ws2.id);
        const topo = [];
        while (queue.length > 0) {
          const id = queue.shift();
          topo.push(id);
          for (const dependentId of dependents.get(id) || []) {
            const nextDegree = (inDegree.get(dependentId) || 0) - 1;
            inDegree.set(dependentId, nextDegree);
            if (nextDegree === 0) queue.push(dependentId);
          }
        }
        if (topo.length !== workstreams2.length) {
          const longest = [...workstreams2].sort(
            (a, b) => b.endMonth - b.startMonth - (a.endMonth - a.startMonth)
          )[0];
          return longest ? [longest.id] : [];
        }
        const scoreById = /* @__PURE__ */ new Map();
        const predecessorById = /* @__PURE__ */ new Map();
        for (const id of topo) {
          const ws2 = byId.get(id);
          const duration = Math.max(1, ws2.endMonth - ws2.startMonth + 1);
          let bestPredecessor = null;
          let bestPredecessorScore = 0;
          for (const depId of ws2.dependencies || []) {
            const depScore = scoreById.get(depId);
            if (depScore === void 0) continue;
            if (depScore > bestPredecessorScore) {
              bestPredecessorScore = depScore;
              bestPredecessor = depId;
            }
          }
          scoreById.set(id, duration + bestPredecessorScore);
          predecessorById.set(id, bestPredecessor);
        }
        let criticalEndId = null;
        let maxScore = -1;
        scoreById.forEach((score, id) => {
          if (score > maxScore) {
            maxScore = score;
            criticalEndId = id;
          }
        });
        if (!criticalEndId) return [];
        const path3 = [];
        let cursor = criticalEndId;
        while (cursor) {
          path3.push(cursor);
          cursor = predecessorById.get(cursor) || null;
        }
        return path3.reverse();
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/analyzers/strategy-signal-extractor.ts
var strategy_signal_extractor_exports = {};
__export(strategy_signal_extractor_exports, {
  StrategySignalExtractor: () => StrategySignalExtractor
});
var StrategySignalExtractor;
var init_strategy_signal_extractor = __esm({
  "src/lib/intelligent-planning/wbs-builder/analyzers/strategy-signal-extractor.ts"() {
    "use strict";
    StrategySignalExtractor = class {
      /**
       * Extract digital transformation signals from BMC insights
       */
      static extract(insights) {
        console.log("[Strategy Signal Extractor] Analyzing BMC insights for digital signals...");
        const signals = {
          platformNeeds: [],
          digitalChannels: [],
          digitalValueProps: [],
          techRevenue: [],
          techResources: [],
          customerTech: [],
          revenueDigitization: [],
          digitalIntensity: 0
        };
        if (!insights || !insights.insights || !Array.isArray(insights.insights)) {
          console.warn("[Strategy Signal Extractor] Invalid insights structure, returning empty signals");
          console.warn("[Strategy Signal Extractor] Received:", JSON.stringify(insights, null, 2).substring(0, 200));
          return signals;
        }
        insights.insights.forEach((insight) => {
          if (!insight || typeof insight.content !== "string") {
            console.warn("[Strategy Signal Extractor] Skipping malformed insight:", insight);
            return;
          }
          const content = insight.content.toLowerCase();
          const category = (insight.metadata?.category || insight.source || "").toLowerCase();
          if (content.includes("platform") || content.includes("mobile app") || content.includes("web app") || content.includes("digital platform") || content.includes("software") || content.includes("saas")) {
            signals.platformNeeds.push(insight.content);
          }
          if (category.includes("channel") && (content.includes("online") || content.includes("digital") || content.includes("website") || content.includes("mobile") || content.includes("app") || content.includes("social media") || content.includes("e-commerce"))) {
            signals.digitalChannels.push(insight.content);
          }
          if (category.includes("value") && (content.includes("digital") || content.includes("online") || content.includes("automated") || content.includes("instant") || content.includes("24/7") || content.includes("real-time"))) {
            signals.digitalValueProps.push(insight.content);
          }
          if (category.includes("revenue") && (content.includes("subscription") || content.includes("digital") || content.includes("online") || content.includes("platform fee") || content.includes("transaction fee") || content.includes("freemium"))) {
            signals.techRevenue.push(insight.content);
          }
          if (category.includes("resource") && (content.includes("technology") || content.includes("platform") || content.includes("software") || content.includes("data") || content.includes("algorithm") || content.includes("api"))) {
            signals.techResources.push(insight.content);
          }
          if (category.includes("customer relationship") && (content.includes("app") || content.includes("digital") || content.includes("automated") || content.includes("self-service") || content.includes("personalization") || content.includes("crm"))) {
            signals.customerTech.push(insight.content);
          }
        });
        signals.digitalIntensity = this.calculateDigitalIntensity(signals);
        console.log(`[Strategy Signal Extractor] Digital intensity: ${signals.digitalIntensity}%`);
        console.log(`[Strategy Signal Extractor] Platform needs: ${signals.platformNeeds.length}`);
        console.log(`[Strategy Signal Extractor] Digital channels: ${signals.digitalChannels.length}`);
        return signals;
      }
      /**
       * Calculate digital intensity score from signals
       */
      static calculateDigitalIntensity(signals) {
        let score = 0;
        if (signals.platformNeeds.length > 0) score += 25;
        if (signals.digitalChannels.length > 0) score += 20;
        if (signals.digitalValueProps.length > 0) score += 15;
        if (signals.techRevenue.length > 0) score += 15;
        if (signals.techResources.length > 0) score += 15;
        if (signals.customerTech.length > 0) score += 10;
        return Math.min(100, score);
      }
      /**
       * Determine if strategy recommends platform development
       */
      static needsPlatform(signals) {
        return signals.platformNeeds.length > 0 || signals.digitalIntensity >= 40;
      }
      /**
       * Determine strategic archetype
       */
      static getArchetype(signals) {
        if (signals.digitalIntensity >= 70) return "digital_first";
        if (signals.digitalIntensity >= 30) return "hybrid";
        return "traditional";
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/analyzers/strategy-profiler.ts
var strategy_profiler_exports = {};
__export(strategy_profiler_exports, {
  StrategyProfiler: () => StrategyProfiler
});
var StrategyProfiler;
var init_strategy_profiler = __esm({
  "src/lib/intelligent-planning/wbs-builder/analyzers/strategy-profiler.ts"() {
    "use strict";
    StrategyProfiler = class {
      /**
       * Build strategy profile from signals
       */
      static buildProfile(signals) {
        console.log("[Strategy Profiler] Building strategy profile...");
        const archetype = this.determineArchetype(signals);
        const needsPlatform = this.assessPlatformNeed(signals);
        const technologyRoleOverride = this.determineTechRole(signals, archetype);
        const recommendedCategories = this.extractRecommendedCategories(signals);
        const effortAdjustments = this.calculateEffortAdjustments(signals, archetype);
        const profile = {
          digitalIntensity: signals.digitalIntensity,
          archetype,
          needsPlatform,
          technologyRoleOverride,
          recommendedCategories,
          effortAdjustments
        };
        console.log(`[Strategy Profiler] Archetype: ${archetype}`);
        console.log(`[Strategy Profiler] Needs platform: ${needsPlatform}`);
        console.log(`[Strategy Profiler] Tech role: ${technologyRoleOverride || "none"}`);
        return profile;
      }
      /**
       * Determine strategic archetype
       */
      static determineArchetype(signals) {
        if (signals.digitalIntensity >= 70) return "digital_first";
        if (signals.digitalIntensity >= 30) return "hybrid";
        return "traditional";
      }
      /**
       * Assess if platform development is needed
       */
      static assessPlatformNeed(signals) {
        if (signals.platformNeeds.length > 0) return true;
        const digitalSignalCount = signals.digitalChannels.length + signals.digitalValueProps.length + signals.techRevenue.length + signals.customerTech.length;
        return digitalSignalCount >= 3 || signals.digitalIntensity >= 40;
      }
      /**
       * Determine technology role based on strategy
       */
      static determineTechRole(signals, archetype) {
        if (archetype === "digital_first") {
          return "core_product";
        }
        if (archetype === "hybrid" && signals.platformNeeds.length > 0) {
          return "operational_tool";
        }
        return void 0;
      }
      /**
       * Extract recommended workstream categories from signals
       */
      static extractRecommendedCategories(signals) {
        const categories = /* @__PURE__ */ new Set();
        if (signals.platformNeeds.length > 0) {
          categories.add("technology_systems");
        }
        if (signals.digitalChannels.length > 0) {
          categories.add("marketing_sales");
          categories.add("technology_systems");
        }
        if (signals.customerTech.length > 0) {
          categories.add("technology_systems");
        }
        return Array.from(categories);
      }
      /**
       * Calculate effort allocation adjustments based on strategy
       */
      static calculateEffortAdjustments(signals, archetype) {
        const adjustments = /* @__PURE__ */ new Map();
        switch (archetype) {
          case "traditional":
            break;
          case "hybrid":
            adjustments.set("technology_systems", 35);
            adjustments.set("physical_infrastructure", 20);
            adjustments.set("operations", 25);
            adjustments.set("marketing_sales", 15);
            break;
          case "digital_first":
            adjustments.set("technology_systems", 50);
            adjustments.set("physical_infrastructure", 10);
            adjustments.set("operations", 15);
            adjustments.set("marketing_sales", 20);
            break;
        }
        return adjustments;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/providers/adaptive-pattern-weighter.ts
var adaptive_pattern_weighter_exports = {};
__export(adaptive_pattern_weighter_exports, {
  AdaptivePatternWeighter: () => AdaptivePatternWeighter
});
var AdaptivePatternWeighter;
var init_adaptive_pattern_weighter = __esm({
  "src/lib/intelligent-planning/wbs-builder/providers/adaptive-pattern-weighter.ts"() {
    "use strict";
    AdaptivePatternWeighter = class {
      /**
       * Apply strategy-based adjustments to base pattern
       * 
       * Example: Coffee shop base pattern (35% physical, 10% tech)
       *   + Traditional strategy  No change (35% physical, 10% tech)
       *   + Hybrid strategy  Adjusted (20% physical, 35% platform, 25% operations)
       *   + Digital-first strategy  Adjusted (15% physical, 45% platform, 20% digital marketing)
       */
      static adjustPattern(basePattern, strategyProfile) {
        console.log("[Adaptive Pattern Weighter] Applying strategy adjustments...");
        console.log(`[Adaptive Pattern Weighter] Base pattern: ${basePattern.initiativeType}`);
        console.log(`[Adaptive Pattern Weighter] Strategy archetype: ${strategyProfile.archetype}`);
        if (strategyProfile.archetype === "traditional") {
          console.log("[Adaptive Pattern Weighter] Traditional strategy - using base pattern");
          return basePattern;
        }
        const adjustedPattern = {
          initiativeType: basePattern.initiativeType,
          streams: basePattern.streams.map((s) => ({ ...s })),
          totalWeight: 0
        };
        if (strategyProfile.effortAdjustments.size > 0) {
          console.log("[Adaptive Pattern Weighter] Applying strategy effort adjustments...");
          strategyProfile.effortAdjustments.forEach((targetEffort, category) => {
            const stream = adjustedPattern.streams.find((s) => s.category === category);
            if (stream) {
              const oldEffort = stream.weight;
              stream.weight = targetEffort;
              console.log(`[Adaptive Pattern Weighter]   ${category}: ${oldEffort}% \u2192 ${targetEffort}%`);
            } else {
              console.log(`[Adaptive Pattern Weighter]   Adding new category: ${category} (${targetEffort}%)`);
              adjustedPattern.streams.push({
                category,
                weight: targetEffort,
                priority: "high",
                description: `Strategic ${category} workstream`
              });
            }
          });
        }
        const total = adjustedPattern.streams.reduce((sum, s) => sum + s.weight, 0);
        if (Math.abs(total - 100) > 1) {
          console.log(`[Adaptive Pattern Weighter] Normalizing total from ${total}% to 100%`);
          adjustedPattern.streams.forEach((s) => {
            s.weight = s.weight / total * 100;
          });
        }
        adjustedPattern.totalWeight = 100;
        console.log("[Adaptive Pattern Weighter] \u2713 Pattern adjusted for strategy");
        return adjustedPattern;
      }
      /**
       * Check if platform development should be included
       */
      static shouldIncludePlatform(strategyProfile) {
        return strategyProfile.needsPlatform;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/core/wbs-builder.ts
var WBSBuilder;
var init_wbs_builder = __esm({
  "src/lib/intelligent-planning/wbs-builder/core/wbs-builder.ts"() {
    "use strict";
    WBSBuilder = class {
      /**
       * Constructor uses dependency injection for all components
       */
      constructor(analyzer, patternProvider, optimizer, validator) {
        this.analyzer = analyzer;
        this.patternProvider = patternProvider;
        this.optimizer = optimizer;
        this.validator = validator;
        console.log("[WBS Builder] Initialized with all components");
      }
      /**
       * Build complete WBS from insights and context
       * STRATEGY-AWARE: Extracts BMC strategic recommendations before analysis
       */
      async buildWBS(insights, context) {
        console.log("[WBS Builder] Starting WBS generation...");
        console.log(`[WBS Builder] Business: ${context.business.name}`);
        console.log(`[WBS Builder] Scale: ${context.business.scale}`);
        console.log(`[WBS Builder] Input insights count: ${insights?.insights?.length || 0}`);
        let currentStep = "initialization";
        let partialWorkstreams = [];
        let intent = null;
        let pattern = null;
        try {
          currentStep = "strategy-extraction";
          let strategyProfile = void 0;
          try {
            const { StrategySignalExtractor: StrategySignalExtractor2 } = await Promise.resolve().then(() => (init_strategy_signal_extractor(), strategy_signal_extractor_exports));
            const { StrategyProfiler: StrategyProfiler2 } = await Promise.resolve().then(() => (init_strategy_profiler(), strategy_profiler_exports));
            const signals = StrategySignalExtractor2.extract(insights);
            strategyProfile = StrategyProfiler2.buildProfile(signals);
            console.log("[WBS Builder] Strategy profile extracted:");
            console.log(`  - Archetype: ${strategyProfile.archetype}`);
            console.log(`  - Digital intensity: ${strategyProfile.digitalIntensity}%`);
            console.log(`  - Platform needed: ${strategyProfile.needsPlatform}`);
          } catch (error) {
            console.warn("[WBS Builder] Failed to extract strategy profile, using base patterns:", error);
            strategyProfile = void 0;
          }
          currentStep = "business-analysis";
          console.log("[WBS Builder] Step 1: Analyzing business intent...");
          const analysisInput = { insights, context, strategyProfile };
          intent = await this.analyzer.process(analysisInput);
          console.log(`[WBS Builder] Step 1 complete: initiativeType=${intent.initiativeType}, confidence=${intent.confidence}`);
          currentStep = "pattern-selection";
          console.log("[WBS Builder] Step 2: Selecting work breakdown pattern...");
          pattern = await this.patternProvider.process(intent);
          console.log(`[WBS Builder] Step 2 complete: patternId=${pattern.patternId}, streams=${pattern.streams?.length || 0}`);
          if (strategyProfile) {
            currentStep = "pattern-adjustment";
            const { AdaptivePatternWeighter: AdaptivePatternWeighter2 } = await Promise.resolve().then(() => (init_adaptive_pattern_weighter(), adaptive_pattern_weighter_exports));
            pattern = AdaptivePatternWeighter2.adjustPattern(pattern, strategyProfile);
          } else {
            console.log("[WBS Builder] No strategy profile, using base pattern as-is");
          }
          currentStep = "stream-optimization";
          console.log("[WBS Builder] Step 3: Optimizing pattern into workstreams...");
          const optimizationInput = { pattern, context, insights };
          const workstreams2 = await this.optimizer.process(optimizationInput);
          partialWorkstreams = workstreams2;
          console.log(`[WBS Builder] Step 3 complete: generated ${workstreams2.length} workstreams`);
          workstreams2.forEach((ws2, i) => {
            console.log(`  [${i + 1}] ${ws2.name} (${ws2.id}) - ${ws2.deliverables?.length || 0} deliverables`);
          });
          currentStep = "semantic-validation";
          console.log("[WBS Builder] Step 4: Validating semantic coherence...");
          const validationInput = {
            objective: context.business.description,
            context,
            workstreams: workstreams2
          };
          const validationReport = await this.validator.process(validationInput);
          console.log(`[WBS Builder] Step 4 complete: isValid=${validationReport.isValid}, coherenceScore=${validationReport.coherenceScore}`);
          currentStep = "confidence-calculation";
          console.log("[WBS Builder] Step 5: Calculating confidence...");
          const confidence = this.calculateConfidence(
            intent.confidence,
            validationReport.coherenceScore,
            workstreams2
          );
          console.log(`[WBS Builder] Step 5 complete: confidence=${confidence}`);
          const wbs = {
            intent,
            pattern,
            workstreams: workstreams2,
            confidence,
            validationReport
          };
          console.log("[WBS Builder] \u2713 WBS generation complete");
          console.log(`[WBS Builder] Initiative type: ${intent.initiativeType}`);
          console.log(`[WBS Builder] Workstreams: ${workstreams2.length}`);
          console.log(`[WBS Builder] Confidence: ${(confidence * 100).toFixed(1)}%`);
          console.log(`[WBS Builder] Validation: ${validationReport.isValid ? "PASSED" : "FAILED"}`);
          if (!validationReport.isValid) {
            console.warn("[WBS Builder] Validation issues detected:");
            validationReport.issues.forEach((issue) => {
              console.warn(`  - ${issue.severity.toUpperCase()}: ${issue.message}`);
            });
          }
          return wbs;
        } catch (error) {
          console.error("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
          console.error("\u2551 [WBS Builder] \u274C CRITICAL FAILURE - FULL DIAGNOSTIC                            \u2551");
          console.error("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563");
          console.error(`\u2551 Failed at step: ${currentStep}`);
          console.error(`\u2551 Error message: ${error?.message || "Unknown error"}`);
          console.error(`\u2551 Partial workstreams generated: ${partialWorkstreams.length}`);
          console.error(`\u2551 Intent captured: ${intent ? "Yes - " + intent.initiativeType : "No"}`);
          console.error(`\u2551 Pattern captured: ${pattern ? "Yes - " + pattern.patternId : "No"}`);
          console.error("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563");
          console.error("\u2551 FULL STACK TRACE:");
          console.error("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D");
          console.error(error?.stack || error);
          throw error;
        }
      }
      /**
       * Calculate overall confidence score
       */
      calculateConfidence(intentConfidence, coherenceScore, workstreams2) {
        const avgWorkstreamConfidence = workstreams2.reduce((sum, ws2) => sum + ws2.confidence, 0) / workstreams2.length;
        const overall = intentConfidence * 0.3 + coherenceScore * 0.4 + avgWorkstreamConfidence * 0.3;
        return Math.min(1, Math.max(0, overall));
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/analyzers/business-analyzer.ts
var BusinessAnalyzer;
var init_business_analyzer = __esm({
  "src/lib/intelligent-planning/wbs-builder/analyzers/business-analyzer.ts"() {
    "use strict";
    BusinessAnalyzer = class {
      constructor(llm2) {
        this.llm = llm2;
      }
      name = "BusinessAnalyzer";
      /**
       * Analyze business intent from strategic insights
       * STRATEGY-AWARE: Uses BMC strategic recommendations to override assumptions
       */
      async process(input) {
        const { insights, context, strategyProfile } = input;
        console.log(`[${this.name}] Analyzing business intent...`);
        console.log(`[${this.name}] Business: ${context.business.name}`);
        console.log(`[${this.name}] Type hint: ${context.business.type}`);
        if (strategyProfile) {
          console.log(`[${this.name}] STRATEGY OVERRIDE: Archetype=${strategyProfile.archetype}, Digital Intensity=${strategyProfile.digitalIntensity}%`);
        }
        const prompt = this.buildAnalysisPrompt(insights, context, strategyProfile);
        const result = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              initiativeType: {
                type: "string",
                enum: ["business_launch", "software_development", "digital_transformation", "market_expansion", "product_launch", "general"]
              },
              technologyRole: {
                type: "string",
                enum: ["core_product", "operational_tool", "minimal"]
              },
              businessModel: { type: "string" },
              primaryValueCreation: { type: "string" },
              isPhysical: { type: "boolean" },
              isDigital: { type: "boolean" },
              confidence: { type: "number", minimum: 0, maximum: 1 }
            },
            required: ["initiativeType", "technologyRole", "businessModel", "primaryValueCreation", "isPhysical", "isDigital", "confidence"]
          }
        });
        if (strategyProfile?.technologyRoleOverride) {
          console.log(`[${this.name}] Applying strategy tech role override: ${strategyProfile.technologyRoleOverride}`);
          result.technologyRole = strategyProfile.technologyRoleOverride;
        }
        console.log(`[${this.name}] Detected initiative type: ${result.initiativeType}`);
        console.log(`[${this.name}] Technology role: ${result.technologyRole}`);
        console.log(`[${this.name}] Confidence: ${(result.confidence * 100).toFixed(1)}%`);
        return result;
      }
      /**
       * Build analysis prompt with business context
       * STRATEGY-AWARE: Includes BMC strategic recommendations
       */
      buildAnalysisPrompt(insights, context, strategyProfile) {
        let strategySection = "";
        if (strategyProfile) {
          strategySection = `

=== STRATEGIC ANALYSIS (BMC RECOMMENDATIONS) ===
Digital Intensity: ${strategyProfile.digitalIntensity}%
Strategic Archetype: ${strategyProfile.archetype}
Platform Development Needed: ${strategyProfile.needsPlatform ? "YES" : "NO"}
Recommended Tech Role: ${strategyProfile.technologyRoleOverride || "To be determined"}

CRITICAL: The BMC analysis has determined that this business should follow a ${strategyProfile.archetype} model.
This means the strategy RECOMMENDS ${strategyProfile.needsPlatform ? "building platform/technology capabilities" : "minimal technology focus"}.

You MUST respect the strategic recommendations above. If BMC says platform development is needed,
then technology is a strategic enabler regardless of the base business type.
`;
        }
        return `
You are analyzing a business initiative to understand its fundamental nature.

=== BUSINESS CONTEXT ===
Name: ${context.business.name}
Description: ${context.business.description}
Industry: ${context.business.industry}
Scale: ${context.business.scale}
${strategySection}
=== STRATEGIC INSIGHTS ===
${JSON.stringify(insights, null, 2)}

Your task: Determine the FUNDAMENTAL NATURE of what's being done, RESPECTING the strategic recommendations above.

Critical distinctions to make:

1. INITIATIVE TYPE:
   - business_launch: Opening/starting a NEW physical or service business (restaurant, coffee shop, retail store, service company)
   - software_development: Building SOFTWARE PRODUCTS (SaaS platform, mobile app, web application)
   - digital_transformation: Adding digital capabilities to EXISTING business
   - market_expansion: Expanding existing business to new markets
   - product_launch: Launching a new product line
   - general: Other/unclear initiatives

2. TECHNOLOGY'S ROLE:
   - core_product: Technology IS the product being sold (e.g., SaaS platform, mobile app)
   - operational_tool: Technology SUPPORTS the business (e.g., POS system in coffee shop, inventory system in retail)
   - minimal: Very little technology involved

3. VALUE CREATION:
   - What is the PRIMARY way this business creates value for customers?
   - Is it a physical product, a service, software, or combination?

=== CRITICAL REASONING ===

Example 1: "Open a coffee shop in Brooklyn"
- Initiative type: business_launch (opening a NEW business)
- Technology role: operational_tool (POS, inventory are tools, not the product)
- Is physical: true (physical location, equipment, inventory)
- Is digital: false (not selling software)
- Primary value: Selling coffee and food in a physical space

Example 2: "Build a project management SaaS platform"
- Initiative type: software_development (building software)
- Technology role: core_product (software IS what's being sold)
- Is physical: false (no physical location needed)
- Is digital: true (entirely digital product)
- Primary value: Software that helps teams manage projects

Example 3: "Add online ordering to existing restaurant"
- Initiative type: digital_transformation (adding digital to existing)
- Technology role: operational_tool (online ordering supports restaurant)
- Is physical: true (restaurant still serves physical food)
- Is digital: true (adding digital ordering)
- Primary value: Restaurant food + convenience of online ordering

=== YOUR ANALYSIS ===

Based on the context above, provide a structured BusinessIntent object.

IMPORTANT CHECKS:
- If opening a physical business (coffee shop, restaurant, retail), initiative type = business_launch
- If building software/platform/app, initiative type = software_development
- If software is mentioned but it's just USING software (not building it), technology role = operational_tool
- Be very careful not to confuse "using POS software" with "building software"

Return the BusinessIntent JSON object.
    `.trim();
      }
      /**
       * Optional: Validate input before processing
       */
      async validate(input) {
        if (!input.insights || !input.context) {
          console.error(`[${this.name}] Invalid input: missing insights or context`);
          return false;
        }
        return true;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/providers/pattern-registry.ts
var PatternRegistry;
var init_pattern_registry = __esm({
  "src/lib/intelligent-planning/wbs-builder/providers/pattern-registry.ts"() {
    "use strict";
    PatternRegistry = class {
      patterns = /* @__PURE__ */ new Map();
      /**
       * Register a pattern plugin
       */
      register(plugin) {
        if (this.patterns.has(plugin.type)) {
          console.warn(`[Pattern Registry] Overwriting existing pattern: ${plugin.type}`);
        }
        this.patterns.set(plugin.type, plugin);
        console.log(`[Pattern Registry] Registered pattern: ${plugin.type} (${plugin.name})`);
      }
      /**
       * Get pattern plugin by initiative type
       */
      getPattern(type) {
        return this.patterns.get(type);
      }
      /**
       * Get all registered patterns
       */
      getAllPatterns() {
        return Array.from(this.patterns.values());
      }
      /**
       * Check if pattern exists for initiative type
       */
      hasPattern(type) {
        return this.patterns.has(type);
      }
      /**
       * Get list of registered initiative types
       */
      getRegisteredTypes() {
        return Array.from(this.patterns.keys());
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/providers/pattern-provider.ts
var PatternProvider;
var init_pattern_provider = __esm({
  "src/lib/intelligent-planning/wbs-builder/providers/pattern-provider.ts"() {
    "use strict";
    PatternProvider = class {
      constructor(registry, llm2) {
        this.registry = registry;
        this.llm = llm2;
      }
      name = "PatternProvider";
      /**
       * Provide work stream pattern based on business intent
       */
      async process(intent) {
        console.log(`[${this.name}] Selecting pattern for initiative type: ${intent.initiativeType}`);
        const plugin = this.registry.getPattern(intent.initiativeType);
        if (plugin) {
          console.log(`[${this.name}] Using registered pattern plugin: ${plugin.name}`);
          const pattern = await plugin.analyze(intent);
          const isValid = await this.validatePattern(pattern);
          if (!isValid) {
            console.warn(`[${this.name}] Pattern validation failed, falling back to LLM generation`);
            return await this.generatePatternFromLLM(intent);
          }
          return pattern;
        }
        console.log(`[${this.name}] No registered pattern found, using LLM generation`);
        return await this.generatePatternFromLLM(intent);
      }
      /**
       * Generate pattern using LLM for unknown initiative types
       */
      async generatePatternFromLLM(intent) {
        const prompt = `
Generate a work breakdown structure pattern for this business initiative:

Initiative Type: ${intent.initiativeType}
Technology Role: ${intent.technologyRole}
Business Model: ${intent.businessModel}
Primary Value Creation: ${intent.primaryValueCreation}
Is Physical: ${intent.isPhysical}
Is Digital: ${intent.isDigital}

Generate work stream categories with proportional effort allocations (as percentages).

Common work stream categories:
- physical_infrastructure: Location, equipment, buildout, facilities
- technology_systems: Software, platforms, IT systems
- operations: Day-to-day business processes, procedures
- human_resources: Hiring, training, org structure
- marketing_sales: Go-to-market, customer acquisition
- legal_compliance: Permits, licenses, regulatory compliance
- financial_management: Budgeting, accounting, funding
- supply_chain: Suppliers, inventory, logistics

Allocate percentages based on what makes sense for this initiative.
Total should sum to approximately 100%.

Return as WorkStreamPattern JSON object.
    `.trim();
        const pattern = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              initiativeType: { type: "string" },
              streams: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    category: { type: "string" },
                    weight: { type: "number", minimum: 0, maximum: 100 },
                    priority: { type: "string", enum: ["critical", "high", "medium", "low"] },
                    description: { type: "string" }
                  },
                  required: ["category", "weight", "priority"]
                }
              }
            },
            required: ["initiativeType", "streams"]
          }
        });
        pattern.totalWeight = pattern.streams.reduce((sum, s) => sum + s.weight, 0);
        return pattern;
      }
      /**
       * Validate that pattern weights sum to approximately 100%
       */
      async validatePattern(pattern) {
        const totalWeight = pattern.streams.reduce((sum, s) => sum + s.weight, 0);
        pattern.totalWeight = totalWeight;
        const isValid = Math.abs(totalWeight - 100) <= 5;
        if (!isValid) {
          console.error(`[${this.name}] Pattern validation failed: total weight = ${totalWeight}%, expected ~100%`);
        }
        return isValid;
      }
      /**
       * Optional: Validate input before processing
       */
      async validate(intent) {
        if (!intent.initiativeType || !intent.technologyRole) {
          console.error(`[${this.name}] Invalid intent: missing required fields`);
          return false;
        }
        return true;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/optimizers/stream-optimizer.ts
var StreamOptimizer;
var init_stream_optimizer = __esm({
  "src/lib/intelligent-planning/wbs-builder/optimizers/stream-optimizer.ts"() {
    "use strict";
    init_llm_provider();
    StreamOptimizer = class {
      constructor(llm2, onProgress) {
        this.llm = llm2;
        this.onProgress = onProgress;
      }
      name = "StreamOptimizer";
      onProgress;
      /**
       * Infer basic sequential dependencies when LLM dependency generation fails
       * Preserves original workstream order while adding sensible dependency chains
       */
      inferBasicDependencies(workstreams2) {
        console.log(`[${this.name}] Inferring basic sequential dependencies for ${workstreams2.length} workstreams`);
        const priorityOrder = ["legal_compliance", "physical_infrastructure", "technology_systems", "human_resources", "operations", "marketing_sales"];
        const getPriority = (category) => {
          const idx = priorityOrder.indexOf(category);
          return idx === -1 ? 99 : idx;
        };
        const sortedByPriority = [...workstreams2].sort((a, b) => getPriority(a.category) - getPriority(b.category));
        const dependencyMap = /* @__PURE__ */ new Map();
        sortedByPriority.forEach((ws2, i) => {
          dependencyMap.set(ws2.id, i === 0 ? [] : [sortedByPriority[i - 1].id]);
        });
        return workstreams2.map((ws2) => ({
          ...ws2,
          dependencies: dependencyMap.get(ws2.id) || []
        }));
      }
      /**
       * Convert pattern weights into concrete workstreams with deliverables
       */
      async process(input) {
        const { pattern, context, insights } = input;
        console.log(`[${this.name}] Optimizing ${pattern.streams.length} work stream categories...`);
        const workstreams2 = [];
        for (let i = 0; i < pattern.streams.length; i++) {
          const streamCategory = pattern.streams[i];
          console.log(`[${this.name}] Generating workstream ${i + 1}/${pattern.streams.length}: ${streamCategory.category}`);
          const workstream = await this.generateWorkstream(streamCategory, context, insights, i);
          workstreams2.push(workstream);
          if (this.onProgress) {
            this.onProgress(i + 1, pattern.streams.length, workstream.name);
          }
        }
        const workstreamsWithDeps = await this.generateDependencies(workstreams2, context);
        console.log(`[${this.name}] Generated ${workstreamsWithDeps.length} workstreams with dependencies`);
        return workstreamsWithDeps;
      }
      /**
       * Generate a concrete workstream from category
       */
      async generateWorkstream(category, context, insights, index2) {
        const prompt = `
Generate a concrete workstream for this category:

Category: ${category.category}
Effort Allocation: ${category.weight.toFixed(1)}%
Priority: ${category.priority}

Business Context:
- Name: ${context.business.name}
- Industry: ${context.business.industry || context.business.type}
- Type: ${context.business.type}
- Scale: ${context.business.scale}
- Description: ${context.business.description}

CRITICAL: Generate content SPECIFICALLY for the "${context.business.industry || context.business.type}" industry.
Do NOT use generic examples or copy from other industries.
All deliverables must be relevant to ${context.business.name} in the ${context.business.industry || context.business.type} sector.

Generate:
1. A clear, actionable name (e.g., "Location Scouting & Lease Negotiation" not just "Physical Infrastructure")
2. A detailed description of what this workstream entails for THIS specific business
3. 3-5 key deliverables (concrete outputs specific to ${context.business.industry || context.business.type})

The deliverables should be specific, measurable, and industry-appropriate.

Return as JSON object with name, description, and deliverables array.
    `.trim();
        const result = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              name: { type: "string" },
              description: { type: "string" },
              deliverables: {
                type: "array",
                items: { type: "string" },
                minItems: 3,
                maxItems: 5
              }
            },
            required: ["name", "description", "deliverables"]
          }
        });
        const priorityConfidence = {
          "critical": 0.95,
          "high": 0.9,
          "medium": 0.85,
          "low": 0.8
        };
        const baseConfidence = priorityConfidence[category.priority] || 0.85;
        const effortBonus = Math.min(category.weight / 100 * 0.05, 0.05);
        const confidence = Math.min(baseConfidence + effortBonus, 0.98);
        return {
          id: `WS${String(index2 + 1).padStart(3, "0")}`,
          name: result.name,
          category: category.category,
          description: result.description,
          proportionalEffort: category.weight,
          priority: category.priority,
          deliverables: result.deliverables,
          dependencies: [],
          // Will be filled by generateDependencies
          confidence: parseFloat(confidence.toFixed(2))
        };
      }
      /**
       * Generate logical dependencies between workstreams
       * Uses gpt-4o-mini for fast, cheap dependency inference
       * Falls back to basic sequential dependencies if LLM fails
       */
      async generateDependencies(workstreams2, context) {
        const prompt = `
Analyze these workstreams and determine logical dependencies:

${workstreams2.map((ws2, i) => `
${i + 1}. ${ws2.name} (ID: ${ws2.id})
   Category: ${ws2.category}
   Deliverables: ${ws2.deliverables.join(", ")}
`).join("\n")}

For each workstream, determine what other workstreams must complete BEFORE it can start.

Common dependency patterns:
- Legal/compliance often comes first (can't operate without permits)
- Physical infrastructure before operations (need location before opening)
- Hiring before operations (need staff before launching)
- Technology systems can often run in parallel with physical work
- Marketing can start early but ramp up near launch

Return array of objects with:
- workstreamId: The ID of the workstream
- dependsOn: Array of IDs this workstream depends on (can be empty)

Only include dependencies where one MUST finish before another starts.
Don't create circular dependencies.
    `.trim();
        try {
          let dependencyLLM = this.llm;
          if (this.llm instanceof OpenAIProvider) {
            console.log(`[${this.name}] Switching to ${MODEL_CONFIG.dependencyLinkage} for dependency generation`);
            dependencyLLM = this.llm.withModel(MODEL_CONFIG.dependencyLinkage);
          }
          const depResult = await dependencyLLM.generateStructured({
            prompt,
            schema: {
              type: "object",
              properties: {
                dependencies: {
                  type: "array",
                  items: {
                    type: "object",
                    properties: {
                      workstreamId: { type: "string" },
                      dependsOn: { type: "array", items: { type: "string" } }
                    },
                    required: ["workstreamId", "dependsOn"]
                  }
                }
              },
              required: ["dependencies"]
            }
          });
          const result = workstreams2.map((ws2) => {
            const dep = depResult.dependencies.find((d) => d.workstreamId === ws2.id);
            if (dep) {
              return { ...ws2, dependencies: dep.dependsOn };
            }
            return ws2;
          });
          console.log(`[${this.name}] Successfully generated AI-based dependencies`);
          return result;
        } catch (error) {
          console.warn(`[${this.name}] Dependency generation failed: ${error.message}`);
          console.warn(`[${this.name}] Falling back to basic sequential dependencies`);
          return this.inferBasicDependencies(workstreams2);
        }
      }
      /**
       * Optional: Validate input before processing
       */
      async validate(input) {
        if (!input.pattern || !input.pattern.streams || input.pattern.streams.length === 0) {
          console.error(`[${this.name}] Invalid input: missing pattern or streams`);
          return false;
        }
        return true;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/validators/semantic-validator.ts
var SemanticValidator;
var init_semantic_validator = __esm({
  "src/lib/intelligent-planning/wbs-builder/validators/semantic-validator.ts"() {
    "use strict";
    SemanticValidator = class {
      constructor(llm2) {
        this.llm = llm2;
      }
      name = "SemanticValidator";
      /**
       * Validate semantic coherence of work streams against business objective
       */
      async process(input) {
        console.log(`[${this.name}] Validating semantic coherence...`);
        const prompt = this.buildValidationPrompt(input);
        const result = await this.llm.generateStructured({
          prompt,
          schema: {
            type: "object",
            properties: {
              isValid: { type: "boolean" },
              coherenceScore: { type: "number", minimum: 0, maximum: 1 },
              issues: {
                type: "array",
                items: {
                  type: "object",
                  properties: {
                    severity: { type: "string", enum: ["critical", "warning", "info"] },
                    message: { type: "string" },
                    affectedStreams: { type: "array", items: { type: "string" } }
                  },
                  required: ["severity", "message", "affectedStreams"]
                }
              },
              warnings: { type: "array", items: { type: "string" } },
              suggestions: { type: "array", items: { type: "string" } }
            },
            required: ["isValid", "coherenceScore", "issues", "warnings", "suggestions"]
          }
        });
        console.log(`[${this.name}] Coherence score: ${(result.coherenceScore * 100).toFixed(1)}%`);
        console.log(`[${this.name}] Critical issues: ${result.issues.filter((i) => i.severity === "critical").length}`);
        console.log(`[${this.name}] Warnings: ${result.warnings.length}`);
        return result;
      }
      /**
       * Build validation prompt
       */
      buildValidationPrompt(input) {
        const { objective, context, workstreams: workstreams2 } = input;
        return `
You are validating the semantic coherence of a work breakdown structure.

=== ORIGINAL BUSINESS OBJECTIVE ===
${objective}

Business: ${context.business.name}
Type: ${context.business.type}
Scale: ${context.business.scale}
Description: ${context.business.description}

=== GENERATED WORK STREAMS ===
${workstreams2.map((ws2, i) => `
${i + 1}. ${ws2.name} (${ws2.proportionalEffort.toFixed(1)}% effort)
   Category: ${ws2.category}
   Priority: ${ws2.priority}
   Description: ${ws2.description}
`).join("\n")}

=== YOUR TASK ===

Validate semantic coherence by checking:

1. **Intent-Stream Alignment**
   - Do the workstreams match the business objective?
   - Are they addressing the right problem?
   
   Example MISMATCH:
   - Objective: "Open a coffee shop"
   - Workstream: "Platform Development" (60% effort)
   - Issue: Coffee shops don't build platforms, they serve coffee
   
   Example MATCH:
   - Objective: "Open a coffee shop"
   - Workstream: "Location & Buildout" (35% effort)
   - Valid: Physical business needs physical infrastructure

2. **Effort Proportions**
   - Are effort allocations reasonable for this business type?
   
   Red flags:
   - Coffee shop with 60% technology effort
   - SaaS platform with 60% physical infrastructure effort
   - Retail store with 50% software development effort
   
   Green flags:
   - Physical business: 30-40% infrastructure, 10% technology
   - Software business: 55-65% technology, 5% infrastructure
   - Service business: 25-35% human resources

3. **Missing Critical Streams**
   - Are any essential work streams missing?
   
   Examples:
   - Physical business without location/permits
   - Any business without operations/hiring
   - Software business without technology platform

4. **Inappropriate Streams**
   - Are there work streams that don't make sense?
   
   Examples:
   - "Software Platform Development" for a physical coffee shop
   - "Retail Buildout" for a SaaS product
   - "Manufacturing Setup" for a consulting service

Return a ValidationResult with:
- isValid: true if semantically coherent, false if major mismatches
- coherenceScore: 0-1 score of how well streams match objective
- issues: List critical/warning issues found
- warnings: General concerns (but not blocking)
- suggestions: How to improve the work breakdown

Be strict but fair. A score above 0.8 is excellent, 0.6-0.8 is acceptable, below 0.6 indicates problems.
    `.trim();
      }
      /**
       * Optional: Validate input before processing
       */
      async validate(input) {
        if (!input.objective || !input.workstreams || input.workstreams.length === 0) {
          console.error(`[${this.name}] Invalid input: missing objective or workstreams`);
          return false;
        }
        return true;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/patterns/pattern-plugin.ts
var PatternPlugin;
var init_pattern_plugin = __esm({
  "src/lib/intelligent-planning/wbs-builder/patterns/pattern-plugin.ts"() {
    "use strict";
    PatternPlugin = class {
      /**
       * Validate generated work streams
       * Default implementation checks total effort allocation
       */
      async validate(streams) {
        const totalEffort = streams.reduce((sum, s) => sum + s.proportionalEffort, 0);
        const isValid = Math.abs(totalEffort - 100) <= 5;
        if (!isValid) {
          console.error(`[${this.name}] Validation failed: total effort = ${totalEffort}%, expected ~100%`);
        }
        return isValid;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/patterns/business-launch.ts
var BusinessLaunchPattern;
var init_business_launch = __esm({
  "src/lib/intelligent-planning/wbs-builder/patterns/business-launch.ts"() {
    "use strict";
    init_pattern_plugin();
    BusinessLaunchPattern = class extends PatternPlugin {
      type = "business_launch";
      name = "Business Launch Pattern";
      /**
       * Generate work breakdown pattern for business launch initiatives
       */
      async analyze(context) {
        const isPhysical = context.isPhysical;
        const usesTech = context.technologyRole === "operational_tool";
        const isService = context.businessModel.toLowerCase().includes("service");
        const pattern = {
          initiativeType: this.type,
          streams: []
        };
        if (isPhysical) {
          pattern.streams.push({
            category: "physical_infrastructure",
            weight: 35,
            // Major focus for physical businesses
            priority: "critical",
            description: "Location scouting, lease negotiation, buildout, equipment procurement"
          });
        }
        pattern.streams.push({
          category: "technology_systems",
          weight: 10,
          // Operational tools, not core product
          priority: "medium",
          description: "POS systems, inventory management, basic technology setup"
        });
        pattern.streams.push({
          category: "operations",
          weight: 25,
          // Critical for any business
          priority: "critical",
          description: "Operating procedures, vendor relationships, daily operations setup"
        });
        pattern.streams.push({
          category: "human_resources",
          weight: 15,
          // Standard for physical businesses
          priority: "high",
          description: "Hiring, training, team structure, HR policies"
        });
        pattern.streams.push({
          category: "marketing_sales",
          weight: 10,
          // Standard for physical businesses
          priority: "high",
          description: "Brand development, marketing strategy, customer acquisition"
        });
        pattern.streams.push({
          category: "legal_compliance",
          weight: 5,
          // Essential for new businesses
          priority: "critical",
          description: "Business licenses, permits, insurance, regulatory compliance"
        });
        pattern.totalWeight = 100;
        return pattern;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/patterns/software-development.ts
var SoftwareDevelopmentPattern;
var init_software_development = __esm({
  "src/lib/intelligent-planning/wbs-builder/patterns/software-development.ts"() {
    "use strict";
    init_pattern_plugin();
    SoftwareDevelopmentPattern = class extends PatternPlugin {
      type = "software_development";
      name = "Software Development Pattern";
      /**
       * Generate work breakdown pattern for software development initiatives
       */
      async analyze(context) {
        const isSaaS = context.businessModel.toLowerCase().includes("saas") || context.businessModel.toLowerCase().includes("platform");
        const isEnterprise = context.businessModel.toLowerCase().includes("enterprise");
        const pattern = {
          initiativeType: this.type,
          streams: []
        };
        pattern.streams.push({
          category: "technology_systems",
          weight: 60,
          // Technology IS the product
          priority: "critical",
          description: "Platform architecture, core features, infrastructure, security, scalability"
        });
        pattern.streams.push({
          category: "operations",
          weight: 10,
          priority: "high",
          description: "DevOps, CI/CD, monitoring, customer support systems"
        });
        pattern.streams.push({
          category: "human_resources",
          weight: 15,
          priority: "high",
          description: "Engineering hiring, team structure, development processes"
        });
        pattern.streams.push({
          category: "marketing_sales",
          weight: 10,
          // Standard for software businesses
          priority: "high",
          description: "Product marketing, sales enablement, go-to-market strategy"
        });
        pattern.streams.push({
          category: "legal_compliance",
          weight: 5,
          // Essential for software (GDPR, SOC2, etc.)
          priority: "high",
          description: "Data privacy, security compliance, terms of service, SLAs"
        });
        pattern.totalWeight = 100;
        return pattern;
      }
    };
  }
});

// src/lib/intelligent-planning/wbs-builder/interfaces.ts
var init_interfaces3 = __esm({
  "src/lib/intelligent-planning/wbs-builder/interfaces.ts"() {
    "use strict";
  }
});

// src/lib/intelligent-planning/wbs-builder/types.ts
var init_types2 = __esm({
  "src/lib/intelligent-planning/wbs-builder/types.ts"() {
    "use strict";
  }
});

// src/lib/intelligent-planning/wbs-builder/index.ts
function createWBSBuilder(llm2, onWorkstreamProgress) {
  console.log("[WBS Builder Factory] Creating WBS Builder...");
  const registry = new PatternRegistry();
  registry.register(new BusinessLaunchPattern());
  registry.register(new SoftwareDevelopmentPattern());
  console.log(`[WBS Builder Factory] Registered ${registry.getAllPatterns().length} patterns`);
  const analyzer = new BusinessAnalyzer(llm2);
  const patternProvider = new PatternProvider(registry, llm2);
  const optimizer = new StreamOptimizer(llm2, onWorkstreamProgress);
  const validator = new SemanticValidator(llm2);
  const builder = new WBSBuilder(
    analyzer,
    patternProvider,
    optimizer,
    validator
  );
  console.log("[WBS Builder Factory] \u2713 WBS Builder created");
  return builder;
}
var init_wbs_builder2 = __esm({
  "src/lib/intelligent-planning/wbs-builder/index.ts"() {
    "use strict";
    init_wbs_builder();
    init_business_analyzer();
    init_pattern_registry();
    init_pattern_provider();
    init_stream_optimizer();
    init_semantic_validator();
    init_business_launch();
    init_software_development();
    init_interfaces3();
    init_types2();
  }
});

// server/intelligence/epm/workstream-generator.ts
var WorkstreamGenerator;
var init_workstream_generator = __esm({
  "server/intelligence/epm/workstream-generator.ts"() {
    "use strict";
    init_context_builder();
    init_wbs_builder2();
    WorkstreamGenerator = class {
      llm;
      constructor(llm2) {
        this.llm = llm2;
      }
      /**
       * Generate workstreams using WBS Builder for semantic analysis
       */
      async generate(insights, userContext, onProgress, startTime) {
        console.log("\n" + "=".repeat(80));
        console.log("[WorkstreamGenerator] \u{1F4CA} GENERATING WORKSTREAMS USING WBS BUILDER");
        console.log("=".repeat(80));
        const processStartTime = startTime || Date.now();
        try {
          console.log("[WorkstreamGenerator] Step 1: Building planning context from insights...");
          const planningContext = await ContextBuilder.fromJourneyInsights(
            insights,
            insights.frameworkType || "strategy_workspace",
            userContext?.sessionId
          );
          console.log("[WorkstreamGenerator] \u2713 Planning Context Created:");
          console.log(`  Business Name: "${planningContext.business.name}"`);
          console.log(`  Business Type: ${planningContext.business.type}`);
          console.log(`  Business Scale: ${planningContext.business.scale}`);
          console.log(`  Timeline Range: ${planningContext.execution.timeline.min}-${planningContext.execution.timeline.max} months`);
          console.log(`  Budget Range: $${planningContext.execution.budget?.min || "N/A"} - $${planningContext.execution.budget?.max || "N/A"}`);
          console.log(`  Total Insights: ${insights.insights.length}`);
          console.log(`  Framework Type: ${insights.frameworkType}`);
          console.log("\n[WorkstreamGenerator] Step 2: Creating WBS Builder with LLM provider...");
          const wbsBuilder = createWBSBuilder(this.llm, (current, total, workstreamName) => {
            if (onProgress) {
              const elapsedSeconds = Math.round((Date.now() - processStartTime) / 1e3);
              onProgress({
                type: "step-start",
                step: "wbs-generation",
                progress: Math.round(current / total * 100),
                description: `Generating workstream ${current}/${total}: ${workstreamName}`,
                elapsedSeconds
              });
            }
          });
          console.log("[WorkstreamGenerator] \u2713 WBS Builder created");
          console.log("\n[WorkstreamGenerator] Step 3: Calling WBS Builder to generate workstreams...");
          console.log("[WorkstreamGenerator] >>> Passing to WBS Builder:");
          console.log(`  - Insights count: ${insights.insights.length}`);
          console.log(`  - Planning context: Business=${planningContext.business.name}, Scale=${planningContext.business.scale}`);
          const wbs = await wbsBuilder.buildWBS(insights, planningContext);
          console.log("\n[WorkstreamGenerator] \u2713 WBS Builder Completed Successfully!");
          console.log("[WorkstreamGenerator] \u{1F4CB} WBS BUILDER RESULTS:");
          console.log("\u2500".repeat(80));
          console.log(`  Initiative Type: ${wbs.intent.initiativeType}`);
          console.log(`  Technology Role: ${wbs.intent.technologyRole}`);
          console.log(`  Total Workstreams: ${wbs.workstreams.length}`);
          console.log(`  Validation Status: ${wbs.validationReport.isValid ? "\u2713 PASSED" : "\u2717 FAILED"}`);
          console.log(`  Coherence Score: ${(wbs.validationReport.coherenceScore * 100).toFixed(1)}%`);
          console.log(`  Confidence: ${(wbs.intent.confidence * 100).toFixed(1)}%`);
          console.log("\n[WorkstreamGenerator] \u{1F4E6} WORKSTREAMS GENERATED BY WBS:");
          wbs.workstreams.forEach((ws2, idx) => {
            console.log(`
  Workstream ${idx + 1}: ${ws2.name} (${ws2.id})`);
            console.log(`    Description: ${ws2.description.substring(0, 100)}...`);
            console.log(`    Deliverables: ${ws2.deliverables.length}`);
            ws2.deliverables.forEach((d, di) => {
              const delivName = typeof d === "string" ? d : d.name || "Unknown";
              console.log(`      ${di + 1}. ${delivName}`);
            });
            console.log(`    Dependencies: ${ws2.dependencies.length > 0 ? ws2.dependencies.join(", ") : "None"}`);
            console.log(`    Confidence: ${(ws2.confidence * 100).toFixed(1)}%`);
          });
          console.log("\n[WorkstreamGenerator] Step 4: Converting WBS workstreams to EPM format...");
          const workstreams2 = wbs.workstreams.map((ws2, index2) => {
            const baseDuration = 3;
            const overlapFactor = 0.5;
            let startMonth = 1;
            if (ws2.dependencies.length > 0) {
              const depWorkstreams = wbs.workstreams.filter(
                (w) => ws2.dependencies.includes(w.id)
              );
              if (depWorkstreams.length > 0) {
                const depIndex = wbs.workstreams.indexOf(depWorkstreams[depWorkstreams.length - 1]);
                startMonth = Math.max(1, depIndex * baseDuration * overlapFactor + 1);
              }
            } else {
              startMonth = Math.max(1, Math.floor(index2 * baseDuration * overlapFactor) + 1);
            }
            const endMonth = startMonth + baseDuration - 1;
            const deliverables = ws2.deliverables.map((delivName, delIndex) => {
              const progress = (delIndex + 1) / ws2.deliverables.length;
              const dueMonth = Math.floor(startMonth + (endMonth - startMonth) * progress);
              return {
                id: `${ws2.id}-D${delIndex + 1}`,
                name: delivName,
                description: delivName,
                dueMonth,
                effort: "1 person-month"
              };
            });
            return {
              id: ws2.id,
              name: ws2.name,
              description: ws2.description,
              deliverables,
              startMonth,
              endMonth,
              dependencies: ws2.dependencies,
              confidence: ws2.confidence
            };
          });
          if (workstreams2.length < 3) {
            console.warn("[WorkstreamGenerator] WBS generated less than 3 workstreams, adding defaults");
            workstreams2.push(...this.generateDefaultWorkstreams(3 - workstreams2.length));
          }
          console.log(`
[WorkstreamGenerator] \u2713 Successfully converted ${workstreams2.length} workstreams to EPM format`);
          console.log("[WorkstreamGenerator] \u{1F4CA} EPM WORKSTREAMS READY FOR INTELLIGENT PLANNING:");
          workstreams2.forEach((ws2, idx) => {
            console.log(`  ${idx + 1}. ${ws2.name} (${ws2.id})`);
            console.log(`     - Deliverables: ${ws2.deliverables.length}`);
            console.log(`     - Dependencies: ${ws2.dependencies.length > 0 ? ws2.dependencies.join(", ") : "None"}`);
          });
          console.log("=".repeat(80) + "\n");
          return workstreams2;
        } catch (error) {
          console.error("\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
          console.error("\u2551 [WorkstreamGenerator] \u274C CRITICAL FAILURE - WBS BUILDER FAILED                 \u2551");
          console.error("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563");
          console.error(`\u2551 Session ID: ${userContext?.sessionId || "N/A"}`);
          console.error(`\u2551 Insights count: ${insights?.insights?.length || 0}`);
          console.error(`\u2551 Framework type: ${insights?.frameworkType || "N/A"}`);
          console.error(`\u2551 Error: ${error?.message || "Unknown error"}`);
          console.error("\u2560\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2563");
          console.error("\u2551 FULL STACK TRACE:");
          console.error("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D");
          console.error(error?.stack || error);
          throw new Error(`WBS Builder failed: ${error?.message || "Unknown error"}. Session: ${userContext?.sessionId || "N/A"}`);
        }
      }
      /**
       * Generate deliverables from insight
       */
      generateDeliverables(insight, workstreamIndex) {
        const lines = insight.content.split("\n").filter((l) => l.trim());
        const deliverableLines = lines.slice(1, 4);
        return deliverableLines.map((line, idx) => ({
          id: `D${String(workstreamIndex + 1).padStart(3, "0")}.${idx + 1}`,
          name: line.replace(/^[-]\s*/, "").trim(),
          description: line.replace(/^[-]\s*/, "").trim(),
          dueMonth: workstreamIndex + idx + 2,
          effort: this.estimateEffort(line)
        }));
      }
      /**
       * Generate default workstreams
       */
      generateDefaultWorkstreams(count2) {
        const defaults = [
          { name: "Program Management", description: "Overall program coordination, governance, and stakeholder management" },
          { name: "Change Management", description: "Organizational change, training, and adoption support" },
          { name: "Quality Assurance", description: "Quality reviews, testing, and validation" }
        ];
        return defaults.slice(0, count2).map((def, idx) => ({
          id: `WS${String(idx + 100).padStart(3, "0")}`,
          name: def.name,
          description: def.description,
          deliverables: [],
          startMonth: 1,
          endMonth: 12,
          dependencies: [],
          confidence: 0.7
        }));
      }
      /**
       * Estimate effort for a deliverable
       */
      estimateEffort(deliverable) {
        const words = deliverable.split(" ").length;
        if (words < 5) return "5-10 person-days";
        if (words < 10) return "10-20 person-days";
        return "20-40 person-days";
      }
    };
  }
});

// server/intelligence/normalizers/fte-normalizer.ts
function normalizeFTE(value) {
  if (value > 10) return Math.round(value / 100 * 100) / 100;
  if (value > 1) return 1;
  if (value < 0) return 0;
  return Math.round(value * 100) / 100;
}
function normalizeResourceFTEs(resources2) {
  const fixes = [];
  const normalized = resources2.map((r) => {
    const fixed = normalizeFTE(r.fteAllocation);
    if (r.fteAllocation !== fixed) {
      fixes.push(`${r.role}: ${r.fteAllocation} \u2192 ${fixed}`);
    }
    return { ...r, fteAllocation: fixed };
  });
  return { normalized, fixes, hasIssues: fixes.length > 0 };
}
var init_fte_normalizer = __esm({
  "server/intelligence/normalizers/fte-normalizer.ts"() {
    "use strict";
  }
});

// server/intelligence/epm/role-templates.ts
function selectRoles(context) {
  const category = context.businessType.category;
  const subcategory = context.businessType.subcategory;
  console.log(`[RoleTemplates] Selecting roles for category="${category}", subcategory="${subcategory}"`);
  if (subcategory && ROLE_TEMPLATES[category]?.[subcategory]) {
    console.log(`[RoleTemplates] Using exact subcategory match: ${category}.${subcategory}`);
    return ROLE_TEMPLATES[category][subcategory];
  }
  if (ROLE_TEMPLATES[category]?.default) {
    console.log(`[RoleTemplates] Using category default: ${category}.default`);
    return ROLE_TEMPLATES[category].default;
  }
  console.log(`[RoleTemplates] Using generic fallback`);
  return ROLE_TEMPLATES.generic.default;
}
function inferSubcategory(context) {
  const name = context.businessType.name.toLowerCase();
  const keywords = context.industry.keywords.map((k) => k.toLowerCase());
  const allText = `${name} ${keywords.join(" ")}`;
  if (context.businessType.category === "retail_specialty") {
    if (allText.match(/basketball|sneaker|footwear|athletic|shoe/)) {
      return "athletic_footwear";
    }
    if (allText.match(/fashion|apparel|clothing|boutique/)) {
      return "fashion_apparel";
    }
    if (allText.match(/electronics|gadget|phone|computer/)) {
      return "electronics";
    }
  }
  if (context.businessType.category === "food_beverage") {
    if (allText.match(/cafe|coffee|espresso/)) {
      return "cafe_coffee_shop";
    }
    if (allText.match(/restaurant|dining|cuisine/)) {
      return "restaurant";
    }
    if (allText.match(/catering|corporate.*food|event.*food/)) {
      return "catering";
    }
  }
  if (context.businessType.category === "professional_services") {
    if (allText.match(/consulting|consultancy|advisory/)) {
      return "consulting";
    }
  }
  return void 0;
}
function findRiskOwner(riskCategory, availableRoles, usedOwners = /* @__PURE__ */ new Map()) {
  const candidateRoles = RISK_CATEGORY_OWNER_MAP[riskCategory] || [];
  const rolesLower = availableRoles.map((r) => r.toLowerCase());
  let bestMatch = null;
  for (const candidate of candidateRoles) {
    const matchIdx = rolesLower.findIndex((r) => r.includes(candidate.toLowerCase()));
    if (matchIdx >= 0) {
      const actualRole = availableRoles[matchIdx];
      const usageCount = usedOwners.get(actualRole) || 0;
      if (!bestMatch || usageCount < bestMatch.count) {
        bestMatch = { role: actualRole, count: usageCount };
      }
    }
  }
  if (bestMatch) {
    return bestMatch.role;
  }
  let leastUsed = availableRoles[0];
  let leastCount = usedOwners.get(availableRoles[0]) || 0;
  for (const role of availableRoles) {
    const count2 = usedOwners.get(role) || 0;
    if (count2 < leastCount) {
      leastUsed = role;
      leastCount = count2;
    }
  }
  return leastUsed || "Project Lead";
}
function findBenefitOwner(benefitCategory, availableRoles, usedOwners = /* @__PURE__ */ new Map()) {
  const candidateRoles = BENEFIT_CATEGORY_OWNER_MAP[benefitCategory] || BENEFIT_CATEGORY_OWNER_MAP["Operational"] || [];
  const rolesLower = availableRoles.map((r) => r.toLowerCase());
  let bestMatch = null;
  for (const candidate of candidateRoles) {
    const matchIdx = rolesLower.findIndex((r) => r.includes(candidate.toLowerCase()));
    if (matchIdx >= 0) {
      const actualRole = availableRoles[matchIdx];
      const usageCount = usedOwners.get(actualRole) || 0;
      if (!bestMatch || usageCount < bestMatch.count) {
        bestMatch = { role: actualRole, count: usageCount };
      }
    }
  }
  if (bestMatch) {
    return bestMatch.role;
  }
  let leastUsed = availableRoles[0];
  let leastCount = usedOwners.get(availableRoles[0]) || 0;
  for (const role of availableRoles) {
    const count2 = usedOwners.get(role) || 0;
    if (count2 < leastCount) {
      leastUsed = role;
      leastCount = count2;
    }
  }
  return leastUsed || "Project Lead";
}
var ROLE_TEMPLATES, RISK_CATEGORY_OWNER_MAP, BENEFIT_CATEGORY_OWNER_MAP;
var init_role_templates = __esm({
  "server/intelligence/epm/role-templates.ts"() {
    "use strict";
    ROLE_TEMPLATES = {
      food_beverage: {
        cafe_coffee_shop: [
          // Core Operations
          { role: "Cafe Operations Manager", fte: 1, skills: ["cafe operations", "staff management", "inventory control", "P&L"] },
          { role: "Head Barista", fte: 0.8, skills: ["espresso preparation", "latte art", "quality control", "training"] },
          // Launch/Project Functional Roles
          { role: "Cafe Design & Construction Lead", fte: 0.7, skills: ["interior design", "contractor management", "buildout", "permits"] },
          { role: "Technology & Systems Specialist", fte: 0.6, skills: ["POS systems", "WiFi infrastructure", "digital integration", "customer experience tech"] },
          { role: "HR & Training Coordinator", fte: 0.6, skills: ["recruitment", "barista training", "onboarding", "staff scheduling"] },
          { role: "Marketing & Community Manager", fte: 0.6, skills: ["local marketing", "social media", "community events", "brand building"] },
          { role: "Compliance & Licensing Specialist", fte: 0.5, skills: ["food safety", "health permits", "regulatory compliance", "inspections"] }
        ],
        restaurant: [
          // Core Operations
          { role: "Restaurant Operations Manager", fte: 1, skills: ["restaurant operations", "P&L management", "vendor relations"] },
          { role: "Executive Chef", fte: 1, skills: ["menu development", "kitchen management", "food costing"] },
          { role: "Front of House Manager", fte: 0.8, skills: ["customer service", "reservations", "staff supervision"] },
          // Launch/Project Functional Roles
          { role: "Restaurant Design & Buildout Lead", fte: 0.7, skills: ["interior design", "kitchen layout", "contractor management"] },
          { role: "Technology & POS Specialist", fte: 0.5, skills: ["POS systems", "reservation systems", "inventory tech"] },
          { role: "HR & Training Manager", fte: 0.6, skills: ["recruitment", "server training", "kitchen staff onboarding"] },
          { role: "Marketing & PR Coordinator", fte: 0.6, skills: ["restaurant marketing", "social media", "PR", "events"] },
          { role: "Compliance & Health Safety Lead", fte: 0.5, skills: ["food safety", "health inspections", "licensing", "HACCP"] }
        ],
        catering: [
          { role: "Catering Operations Manager", fte: 1, skills: ["event coordination", "logistics"] },
          { role: "Corporate Sales Manager", fte: 1, skills: ["B2B sales", "account management"] },
          { role: "Executive Chef", fte: 1, skills: ["menu planning", "large-scale cooking"] },
          { role: "Event Coordinator", fte: 0.8, skills: ["client relations", "event planning"] }
        ],
        default: [
          { role: "Operations Manager", fte: 1, skills: ["food service operations", "staff management"] },
          { role: "Kitchen Manager", fte: 0.8, skills: ["food preparation", "inventory"] },
          { role: "Service Lead", fte: 0.6, skills: ["customer service", "team coordination"] }
        ]
      },
      retail_specialty: {
        athletic_footwear: [
          { role: "Store Manager", fte: 1, skills: ["retail management", "visual merchandising", "P&L"] },
          { role: "Assistant Store Manager", fte: 0.8, skills: ["inventory management", "staff scheduling"] },
          { role: "Visual Merchandising Lead", fte: 0.6, skills: ["product display", "brand presentation"] },
          { role: "Sales Associate Lead", fte: 0.6, skills: ["footwear fitting", "product knowledge", "upselling"] },
          { role: "Inventory Specialist", fte: 0.5, skills: ["stock management", "receiving", "POS systems"] },
          { role: "Marketing Coordinator", fte: 0.5, skills: ["social media", "local marketing", "events"] }
        ],
        fashion_apparel: [
          { role: "Store Manager", fte: 1, skills: ["fashion retail", "visual merchandising"] },
          { role: "Fashion Stylist", fte: 0.8, skills: ["personal styling", "trend awareness"] },
          { role: "Visual Merchandiser", fte: 0.6, skills: ["window displays", "store layout"] },
          { role: "Sales Associate", fte: 0.5, skills: ["customer service", "product knowledge"] }
        ],
        electronics: [
          { role: "Store Manager", fte: 1, skills: ["electronics retail", "technical knowledge"] },
          { role: "Technical Sales Specialist", fte: 0.8, skills: ["product demos", "troubleshooting"] },
          { role: "Service Technician", fte: 0.6, skills: ["repairs", "warranties"] },
          { role: "Sales Associate", fte: 0.5, skills: ["customer service", "upselling"] }
        ],
        default: [
          { role: "Store Manager", fte: 1, skills: ["retail operations", "staff management", "inventory"] },
          { role: "Assistant Manager", fte: 0.8, skills: ["daily operations", "customer service"] },
          { role: "Sales Lead", fte: 0.6, skills: ["sales", "product knowledge", "customer relations"] },
          { role: "Visual Merchandiser", fte: 0.5, skills: ["product display", "store presentation"] },
          { role: "Sales Associate", fte: 0.4, skills: ["customer service", "sales"] }
        ]
      },
      retail_general: {
        default: [
          { role: "Store Manager", fte: 1, skills: ["retail management", "P&L responsibility"] },
          { role: "Assistant Manager", fte: 0.8, skills: ["staff supervision", "inventory"] },
          { role: "Department Lead", fte: 0.6, skills: ["category management", "customer service"] },
          { role: "Cashier/Sales Associate", fte: 0.4, skills: ["POS operations", "customer assistance"] }
        ]
      },
      retail_electronics: {
        default: [
          { role: "Store Manager", fte: 1, skills: ["electronics retail", "technical sales"] },
          { role: "Technical Sales Manager", fte: 0.8, skills: ["product expertise", "consultative selling"] },
          { role: "Service & Support Lead", fte: 0.6, skills: ["troubleshooting", "warranties", "repairs"] },
          { role: "Sales Consultant", fte: 0.5, skills: ["product demos", "customer education"] }
        ]
      },
      retail_home_goods: {
        default: [
          { role: "Store Manager", fte: 1, skills: ["home retail", "visual merchandising"] },
          { role: "Design Consultant", fte: 0.8, skills: ["interior design", "customer consultation"] },
          { role: "Warehouse/Receiving Lead", fte: 0.6, skills: ["logistics", "inventory management"] },
          { role: "Sales Associate", fte: 0.5, skills: ["customer service", "product knowledge"] }
        ]
      },
      professional_services: {
        consulting: [
          { role: "Managing Director", fte: 1, skills: ["client relations", "business development"] },
          { role: "Senior Consultant", fte: 0.8, skills: ["strategy", "analysis", "presentations"] },
          { role: "Consultant", fte: 0.6, skills: ["research", "analysis", "client delivery"] },
          { role: "Business Analyst", fte: 0.5, skills: ["data analysis", "documentation"] }
        ],
        default: [
          { role: "Practice Lead", fte: 1, skills: ["service delivery", "client management"] },
          { role: "Senior Specialist", fte: 0.8, skills: ["domain expertise", "project management"] },
          { role: "Specialist", fte: 0.6, skills: ["service delivery", "client support"] },
          { role: "Coordinator", fte: 0.4, skills: ["scheduling", "administration"] }
        ]
      },
      saas_platform: {
        default: [
          { role: "Product Manager", fte: 1, skills: ["product strategy", "roadmap planning"] },
          { role: "Tech Lead", fte: 1, skills: ["architecture", "code review", "technical decisions"] },
          { role: "Full Stack Developer", fte: 0.8, skills: ["frontend", "backend", "APIs"] },
          { role: "UX Designer", fte: 0.6, skills: ["user research", "UI design", "prototyping"] },
          { role: "Customer Success Manager", fte: 0.6, skills: ["onboarding", "retention", "support"] },
          { role: "DevOps Engineer", fte: 0.5, skills: ["CI/CD", "cloud infrastructure", "monitoring"] }
        ]
      },
      manufacturing: {
        default: [
          { role: "Plant Manager", fte: 1, skills: ["manufacturing operations", "lean principles"] },
          { role: "Production Supervisor", fte: 0.8, skills: ["line management", "quality control"] },
          { role: "Quality Assurance Lead", fte: 0.6, skills: ["QA/QC", "compliance", "testing"] },
          { role: "Maintenance Technician", fte: 0.5, skills: ["equipment maintenance", "troubleshooting"] },
          { role: "Supply Chain Coordinator", fte: 0.5, skills: ["procurement", "logistics"] }
        ]
      },
      ecommerce: {
        default: [
          { role: "E-commerce Manager", fte: 1, skills: ["online retail", "platform management"] },
          { role: "Digital Marketing Manager", fte: 0.8, skills: ["SEO/SEM", "paid advertising", "email"] },
          { role: "Fulfillment Lead", fte: 0.6, skills: ["warehouse ops", "shipping", "returns"] },
          { role: "Customer Service Lead", fte: 0.5, skills: ["support tickets", "chat", "returns"] },
          { role: "Content Specialist", fte: 0.4, skills: ["product descriptions", "photography"] }
        ]
      },
      generic: {
        default: [
          { role: "General Manager", fte: 1, skills: ["business operations", "P&L management"] },
          { role: "Operations Manager", fte: 0.8, skills: ["day-to-day operations", "process improvement"] },
          { role: "Marketing Manager", fte: 0.6, skills: ["marketing strategy", "brand management"] },
          { role: "Finance/Admin Lead", fte: 0.5, skills: ["bookkeeping", "reporting", "administration"] },
          { role: "Team Lead", fte: 0.5, skills: ["team coordination", "customer relations"] }
        ]
      }
    };
    RISK_CATEGORY_OWNER_MAP = {
      strategic: ["General Manager", "CEO", "Managing Director", "Store Manager", "Practice Lead"],
      operational: ["Operations Manager", "Store Manager", "Plant Manager", "Cafe Manager"],
      financial: ["Finance Manager", "CFO", "Controller", "General Manager", "Finance/Admin Lead"],
      compliance: ["Compliance Officer", "Legal", "Operations Manager", "Quality Assurance Lead"],
      reputational: ["Marketing Manager", "PR Manager", "General Manager", "Customer Success Manager"],
      execution: ["Project Manager", "Program Manager", "Operations Manager", "Tech Lead"]
    };
    BENEFIT_CATEGORY_OWNER_MAP = {
      Financial: ["Finance Manager", "CFO", "General Manager", "Store Manager"],
      Strategic: ["General Manager", "CEO", "Managing Director", "Practice Lead"],
      Operational: ["Operations Manager", "Store Manager", "Plant Manager"],
      "Risk Mitigation": ["Operations Manager", "Compliance Officer", "Quality Assurance Lead"],
      Revenue: ["Sales Manager", "Marketing Manager", "Store Manager", "E-commerce Manager"],
      "Customer Experience": ["Customer Success Manager", "Store Manager", "Service Lead"],
      Brand: ["Marketing Manager", "Marketing Coordinator", "General Manager"]
    };
  }
});

// server/intelligence/epm/resource-allocator.ts
var ResourceAllocator;
var init_resource_allocator = __esm({
  "server/intelligence/epm/resource-allocator.ts"() {
    "use strict";
    init_ai_clients();
    init_fte_normalizer();
    init_role_templates();
    ResourceAllocator = class {
      /**
       * Generate resource plan with internal team and external resources
       *
       * CONTEXT-AWARE ROLE SELECTION:
       * 1. If strategyContext is provided, use ROLE_TEMPLATES (cafe  cafe roles, restaurant  restaurant roles)
       * 2. Fallback to LLM generation if no context
       * 3. Final fallback to initiative-type templates
       */
      async allocate(insights, workstreams2, userContext, initiativeType, strategyContext) {
        const resourceInsights = insights.insights.filter((i) => i.type === "resource");
        const estimatedFTEs = Math.max(8, Math.min(workstreams2.length * 2, 20));
        const finalInitiativeType = initiativeType || "other";
        console.log("[ResourceAllocator] \u{1F3AF} Resource allocation context:");
        console.log(`  Initiative type: ${finalInitiativeType}`);
        console.log(`  Strategy context: ${strategyContext ? `${strategyContext.businessType.category}/${strategyContext.businessType.subcategory || "default"}` : "NOT PROVIDED"}`);
        let internalTeam;
        if (strategyContext) {
          console.log("[ResourceAllocator] \u2705 Using context-aware ROLE_TEMPLATES");
          internalTeam = this.getRolesFromContext(strategyContext, workstreams2);
        } else {
          console.log("[ResourceAllocator] \u26A0\uFE0F No StrategyContext, falling back to LLM/templates");
          internalTeam = await this.generateInternalTeam(
            estimatedFTEs,
            workstreams2,
            resourceInsights,
            finalInitiativeType,
            insights
          );
        }
        const externalResources = this.generateExternalResources(insights, userContext);
        const criticalSkills = Array.from(new Set(internalTeam.flatMap((r) => r.skills)));
        return {
          internalTeam,
          externalResources,
          criticalSkills,
          totalFTEs: estimatedFTEs,
          confidence: strategyContext ? 0.85 : resourceInsights.length > 0 ? 0.7 : 0.6
        };
      }
      /**
       * Initiative-aware internal team generation
       */
      async generateInternalTeam(estimatedFTEs, workstreams2, resourceInsights, initiativeType, insights) {
        console.log(`[ResourceAllocator] \u{1F3AF} Generating team for initiative type: ${initiativeType}`);
        try {
          const llmRoles = await this.generateRolesWithLLM(
            initiativeType,
            estimatedFTEs,
            workstreams2,
            insights
          );
          if (llmRoles && llmRoles.length > 0) {
            console.log(`[ResourceAllocator] \u2705 LLM generated ${llmRoles.length} initiative-appropriate roles`);
            return llmRoles;
          }
          console.warn("[ResourceAllocator] \u26A0\uFE0F LLM returned empty roles, falling back to templates");
        } catch (error) {
          console.error("[ResourceAllocator] \u26A0\uFE0F LLM generation failed, using fallback templates:", error);
          console.error("[ResourceAllocator] Error details:", error instanceof Error ? error.message : String(error));
        }
        console.log(`[ResourceAllocator] \u{1F4CB} Using fallback template for ${initiativeType}`);
        console.log("[ResourceAllocator] \u26A0\uFE0F NOTE: Fallback roles are generic - LLM should be fixed to provide context-appropriate roles");
        return this.getFallbackRoles(initiativeType, estimatedFTEs, workstreams2);
      }
      /**
       * Generate roles using LLM for context-aware team composition
       */
      async generateRolesWithLLM(initiativeType, estimatedFTEs, workstreams2, insights) {
        const workstreamSummary = workstreams2.map((w) => `- ${w.name} (${w.deliverables.length} deliverables)`).join("\n");
        const timeline = workstreams2[0]?.endMonth || 12;
        const businessDescription = insights.insights.find((i) => i.type === "other" || i.content.includes("business") || i.content.includes("initiative"))?.content.substring(0, 200)?.trim() || "a new business initiative";
        console.log(`[ResourceAllocator] Business context: "${businessDescription.substring(0, 100)}..."`);
        console.log(`[ResourceAllocator] Initiative type: ${initiativeType}`);
        const prompt = `Generate an internal team structure for this initiative.

BUSINESS DESCRIPTION: ${businessDescription}
INITIATIVE TYPE: ${initiativeType}
WORKSTREAMS (${workstreams2.length}):
${workstreamSummary}

PROJECT TIMELINE: ${timeline} months
ESTIMATED TEAM SIZE: ${estimatedFTEs} FTEs

Generate ${Math.min(6, estimatedFTEs)} key roles that are APPROPRIATE for this specific business and initiative type.

CRITICAL: Match roles to the ACTUAL BUSINESS described above, not generic templates:
- For physical retail/food businesses: Store Manager, Barista, Server, Chef, Sales Associate, etc.
- For educational/training facilities: Director of Education, Lead Instructor, Curriculum Developer, Student Advisor, etc.
- For software development: Software Engineer, DevOps Engineer, QA Engineer, Product Manager, UX Designer, etc.
- For digital transformation: Digital Strategy Lead, Change Manager, Integration Specialist, Training Coordinator, etc.
- For market expansion: Market Research Analyst, Regional Manager, Business Development, Localization Specialist, etc.
- For product launch: Product Manager, Marketing Manager, Supply Chain Coordinator, Sales Enablement, etc.
- For service launch: Service Designer, Operations Manager, Training Specialist, Customer Success Manager, etc.

For each role, provide:
- role: Job title (MUST match the actual business - e.g., "Lead AI Tutor" for tutoring center, NOT "Barista")
- allocation: % time (50-100)
- months: Duration on project (1-${timeline})
- skills: Array of 3-5 relevant skills
- justification: Why this role is needed

Return ONLY valid JSON array of role objects. NO markdown, NO code blocks, ONLY the JSON array.`;
        const response = await aiClients.callWithFallback({
          systemPrompt: "You are an HR and resource planning expert. Generate ONLY valid JSON matching the requested format. NO markdown code blocks. The roles MUST match the specific business being described.",
          userMessage: prompt,
          maxTokens: 2e3
        });
        const content = response.content;
        try {
          const roles = JSON.parse(content);
          if (Array.isArray(roles) && roles.length > 0) {
            console.log(`[ResourceAllocator] \u2705 Successfully generated ${roles.length} context-appropriate roles`);
            const mappedForNormalization = roles.map((r) => ({
              role: r.role,
              fteAllocation: r.allocation,
              ...r
            }));
            const { normalized, fixes } = normalizeResourceFTEs(mappedForNormalization);
            if (fixes.length > 0) {
              console.log("[ResourceAllocator] FTE normalization fixes:", fixes);
            }
            const normalizedRoles = normalized.map((r) => ({
              role: r.role,
              allocation: r.fteAllocation,
              months: r.months,
              skills: r.skills,
              justification: r.justification
            }));
            return normalizedRoles;
          }
        } catch (parseError) {
          console.error("[ResourceAllocator] Failed to parse LLM response:", parseError);
          console.error("[ResourceAllocator] Raw response:", content);
        }
        return [];
      }
      /**
       * Get roles from context-aware ROLE_TEMPLATES when StrategyContext is available
       * This is the PREFERRED method as it provides business-appropriate roles
       */
      getRolesFromContext(context, workstreams2) {
        const timeline = workstreams2[0]?.endMonth || 12;
        const justification = `Required for ${workstreams2.length} workstreams across ${timeline} months`;
        if (!context.businessType.subcategory) {
          context.businessType.subcategory = inferSubcategory(context);
        }
        const roleTemplates = selectRoles(context);
        console.log(`[ResourceAllocator] Using ROLE_TEMPLATES for ${context.businessType.category}/${context.businessType.subcategory || "default"}`);
        return roleTemplates.map((template) => ({
          role: template.role,
          allocation: template.fte,
          months: Math.ceil(timeline * template.fte),
          // Scale months by FTE
          skills: template.skills,
          justification: template.responsibilities?.join("; ") || justification
        }));
      }
      /**
       * Fallback role templates for each initiative type
       * Used when StrategyContext is not available
       */
      getFallbackRoles(initiativeType, estimatedFTEs, workstreams2) {
        const timeline = workstreams2[0]?.endMonth || 12;
        const justification = `Required for ${workstreams2.length} workstreams across ${timeline} months`;
        const initiativeToCategoryMap = {
          "physical_business_launch": "retail_general",
          "retail_launch": "retail_specialty",
          "cafe_launch": "food_beverage",
          "restaurant_launch": "food_beverage",
          "software_development": "saas_platform",
          "digital_transformation": "saas_platform",
          "market_expansion": "retail_general",
          "ecommerce": "ecommerce",
          "professional_services": "professional_services"
        };
        const category = initiativeToCategoryMap[initiativeType];
        if (category && ROLE_TEMPLATES[category]?.default) {
          console.log(`[ResourceAllocator] Using ROLE_TEMPLATES fallback for category: ${category}`);
          const templates3 = ROLE_TEMPLATES[category].default;
          return templates3.map((t) => ({
            role: t.role,
            allocation: t.fte,
            months: Math.ceil(timeline * t.fte),
            skills: t.skills,
            justification
          }));
        }
        const templates2 = {
          physical_business_launch: [
            { role: "Operations Manager", allocation: 1, months: timeline, skills: ["Business operations", "Team leadership", "Resource management"], justification },
            { role: "Program Manager", allocation: 1, months: timeline, skills: ["Program planning", "Stakeholder management", "Project coordination"], justification },
            { role: "Operations Coordinator", allocation: 0.75, months: Math.floor(timeline * 0.8), skills: ["Logistics", "Vendor management", "Process optimization"], justification },
            { role: "Business Development Lead", allocation: 0.75, months: Math.floor(timeline * 0.7), skills: ["Strategy", "Partnership development", "Market analysis"], justification },
            { role: "Marketing Coordinator", allocation: 0.5, months: Math.floor(timeline * 0.5), skills: ["Local marketing", "Social media", "Community engagement"], justification }
          ],
          software_development: [
            { role: "Product Manager", allocation: 1, months: timeline, skills: ["Product strategy", "Roadmap planning", "Stakeholder management"], justification },
            { role: "Tech Lead/Architect", allocation: 1, months: timeline, skills: ["System architecture", "Technical leadership", "Code review"], justification },
            { role: "Software Engineer", allocation: 1, months: timeline, skills: ["Full-stack development", "API design", "Database design"], justification },
            { role: "DevOps Engineer", allocation: 0.75, months: Math.floor(timeline * 0.8), skills: ["CI/CD", "Infrastructure", "Deployment automation"], justification },
            { role: "QA Engineer", allocation: 0.75, months: Math.floor(timeline * 0.7), skills: ["Test automation", "Quality assurance", "Bug tracking"], justification },
            { role: "UX/UI Designer", allocation: 0.5, months: Math.floor(timeline * 0.6), skills: ["User research", "Interface design", "Prototyping"], justification }
          ],
          digital_transformation: [
            { role: "Digital Transformation Lead", allocation: 1, months: timeline, skills: ["Change leadership", "Digital strategy", "Stakeholder alignment"], justification },
            { role: "Business Process Analyst", allocation: 1, months: timeline, skills: ["Process mapping", "Gap analysis", "Requirements gathering"], justification },
            { role: "Integration Specialist", allocation: 1, months: Math.floor(timeline * 0.8), skills: ["Systems integration", "API development", "Data migration"], justification },
            { role: "Change Manager", allocation: 0.75, months: timeline, skills: ["Change management", "Training delivery", "Communication"], justification },
            { role: "Technical Consultant", allocation: 0.75, months: Math.floor(timeline * 0.7), skills: ["Platform implementation", "Configuration", "Technical training"], justification }
          ],
          market_expansion: [
            { role: "Market Expansion Lead", allocation: 1, months: timeline, skills: ["Market entry strategy", "Partnership development", "Regional planning"], justification },
            { role: "Market Research Analyst", allocation: 1, months: Math.floor(timeline * 0.6), skills: ["Market analysis", "Competitive research", "Customer insights"], justification },
            { role: "Regional Manager", allocation: 1, months: Math.floor(timeline * 0.8), skills: ["Regional operations", "Team building", "Local execution"], justification },
            { role: "Business Development Manager", allocation: 0.75, months: timeline, skills: ["Partnership development", "Sales strategy", "Relationship management"], justification },
            { role: "Localization Specialist", allocation: 0.5, months: Math.floor(timeline * 0.5), skills: ["Cultural adaptation", "Translation", "Local compliance"], justification }
          ],
          product_launch: [
            { role: "Product Launch Manager", allocation: 1, months: timeline, skills: ["Launch planning", "Cross-functional coordination", "Go-to-market"], justification },
            { role: "Product Marketing Manager", allocation: 1, months: Math.floor(timeline * 0.8), skills: ["Positioning", "Messaging", "Campaign management"], justification },
            { role: "Supply Chain Coordinator", allocation: 0.75, months: Math.floor(timeline * 0.7), skills: ["Inventory planning", "Vendor management", "Logistics"], justification },
            { role: "Sales Enablement Specialist", allocation: 0.75, months: Math.floor(timeline * 0.6), skills: ["Sales training", "Collateral development", "Channel support"], justification },
            { role: "Customer Success Manager", allocation: 0.5, months: Math.floor(timeline * 0.5), skills: ["Customer onboarding", "Support", "Feedback collection"], justification }
          ],
          service_launch: [
            { role: "Service Design Lead", allocation: 1, months: timeline, skills: ["Service design", "Process definition", "Quality standards"], justification },
            { role: "Operations Manager", allocation: 1, months: timeline, skills: ["Service delivery", "Resource allocation", "Performance management"], justification },
            { role: "Training Specialist", allocation: 0.75, months: Math.floor(timeline * 0.7), skills: ["Training program design", "Delivery", "Certification"], justification },
            { role: "Service Coordinator", allocation: 0.75, months: Math.floor(timeline * 0.8), skills: ["Scheduling", "Client communication", "Service tracking"], justification },
            { role: "Quality Assurance Manager", allocation: 0.5, months: Math.floor(timeline * 0.6), skills: ["Quality monitoring", "Process improvement", "Auditing"], justification }
          ],
          process_improvement: [
            { role: "Process Improvement Lead", allocation: 1, months: timeline, skills: ["Lean Six Sigma", "Process mapping", "Change leadership"], justification },
            { role: "Business Analyst", allocation: 1, months: timeline, skills: ["Requirements analysis", "Data analysis", "Process documentation"], justification },
            { role: "Operations Analyst", allocation: 0.75, months: Math.floor(timeline * 0.8), skills: ["Metrics analysis", "Bottleneck identification", "Efficiency optimization"], justification },
            { role: "Change Manager", allocation: 0.75, months: Math.floor(timeline * 0.7), skills: ["Stakeholder engagement", "Training", "Adoption tracking"], justification },
            { role: "Process Automation Specialist", allocation: 0.5, months: Math.floor(timeline * 0.6), skills: ["RPA", "Workflow automation", "Tool implementation"], justification }
          ],
          other: [
            { role: "Program Manager", allocation: 1, months: timeline, skills: ["Program management", "Stakeholder management", "Risk management"], justification },
            { role: "Business Analyst", allocation: 1, months: Math.floor(timeline * 0.8), skills: ["Requirements analysis", "Process mapping", "Documentation"], justification },
            { role: "Project Coordinator", allocation: 0.75, months: timeline, skills: ["Coordination", "Tracking", "Communication"], justification },
            { role: "Subject Matter Expert", allocation: 0.75, months: Math.floor(timeline * 0.7), skills: ["Domain expertise", "Advisory", "Validation"], justification },
            { role: "Change Manager", allocation: 0.5, months: Math.floor(timeline * 0.6), skills: ["Change management", "Training", "Support"], justification }
          ]
        };
        const roles = templates2[initiativeType] || templates2.other;
        return roles.slice(0, Math.min(estimatedFTEs, roles.length));
      }
      /**
       * Generate external resources
       */
      generateExternalResources(insights, userContext) {
        const defaultBudget = userContext?.budgetRange?.max || 1e6;
        return [
          {
            type: "Consultant",
            description: "Strategic advisory and specialized expertise",
            estimatedCost: Math.floor(defaultBudget * 0.15),
            timing: "Months 0-3",
            justification: "Domain expertise and methodology guidance"
          },
          {
            type: "Software",
            description: "Project management and collaboration tools",
            estimatedCost: Math.floor(defaultBudget * 0.05),
            timing: "Months 0-12",
            justification: "Enable effective team collaboration and tracking"
          }
        ];
      }
    };
  }
});

// server/lib/llm-provider.ts
function getLLMProvider() {
  return {
    async generateStructuredResponse(prompt, schema) {
      try {
        const response = await aiClients.callWithFallback({
          systemPrompt: "You are a strategic planning expert. Return ONLY valid JSON matching the requested format. Do not include markdown code blocks or explanations.",
          userMessage: prompt,
          maxTokens: 2e3
        });
        const parsed = JSON.parse(response.content);
        return parsed;
      } catch (error) {
        console.error("[LLM Provider] Failed to parse JSON response:", error);
        if (schema.recommendations) {
          return { recommendations: [] };
        }
        throw error;
      }
    }
  };
}
var init_llm_provider2 = __esm({
  "server/lib/llm-provider.ts"() {
    "use strict";
    init_ai_clients();
  }
});

// server/intelligence/epm/assignment-generator.ts
var AssignmentGenerator;
var init_assignment_generator = __esm({
  "server/intelligence/epm/assignment-generator.ts"() {
    "use strict";
    init_llm_provider2();
    AssignmentGenerator = class {
      llm = getLLMProvider();
      async generate(epmProgram, programId) {
        const assignments = [];
        console.log("[AssignmentGenerator] Starting AI-based assignment generation...");
        console.log(`[AssignmentGenerator] Program ID: ${programId}`);
        const workstreams2 = epmProgram.workstreams || [];
        const resourcePlan = epmProgram.resourcePlan;
        const programContext = {
          name: epmProgram.name || "Strategic Program",
          description: epmProgram.description || ""
        };
        if (!workstreams2.length) {
          console.log("[AssignmentGenerator] No workstreams found, skipping assignments");
          return [];
        }
        const internalTeam = resourcePlan?.internalTeam || [];
        const externalResources = resourcePlan?.externalResources || [];
        const allResources = [
          ...internalTeam.map((r, i) => ({
            ...r,
            id: r.id || `INT-${String(i + 1).padStart(3, "0")}`,
            type: "internal"
          })),
          ...externalResources.map((r, i) => ({
            ...r,
            id: r.id || `EXT-${String(i + 1).padStart(3, "0")}`,
            role: r.role || r.type || "External Consultant",
            // Map type to role for external resources
            type: "external"
          }))
        ];
        if (!allResources.length) {
          console.log("[AssignmentGenerator] No resources found, skipping assignments");
          return [];
        }
        console.log(`[AssignmentGenerator] Found ${workstreams2.length} workstreams and ${allResources.length} resources`);
        const allTasks = [];
        for (const workstream of workstreams2) {
          const deliverables = workstream.deliverables || [];
          const wsStartMonth = workstream.startMonth ?? 0;
          const wsEndMonth = workstream.endMonth ?? 3;
          const wsDuration = Math.max(1, wsEndMonth - wsStartMonth);
          for (let i = 0; i < deliverables.length; i++) {
            const deliverable = deliverables[i];
            const deliverableName = this.extractDeliverableName(deliverable, i);
            const taskId = `${workstream.id}-D${i + 1}`;
            const deliverableStartMonth = wsStartMonth + Math.floor(i * wsDuration / Math.max(deliverables.length, 1));
            const deliverableEndMonth = Math.min(wsStartMonth + Math.ceil((i + 1) * wsDuration / Math.max(deliverables.length, 1)), wsEndMonth);
            allTasks.push({
              taskId,
              taskName: deliverableName,
              workstreamName: workstream.name,
              workstreamId: workstream.id,
              startMonth: deliverableStartMonth,
              endMonth: deliverableEndMonth
            });
          }
        }
        if (!allTasks.length) {
          console.log("[AssignmentGenerator] No tasks/deliverables found in workstreams");
          return [];
        }
        console.log(`[AssignmentGenerator] Using AI to match ${allTasks.length} tasks to ${allResources.length} resources...`);
        const matches = await this.getAIResourceMatches(allTasks, allResources, programContext);
        const resourceWorkload = {};
        allResources.forEach((r) => resourceWorkload[r.id] = 0);
        for (const task of allTasks) {
          const match = matches.find((m) => m.taskId === task.taskId);
          const resource = match ? allResources.find((r) => r.id === match.resourceId) : this.getFallbackResource(allResources, resourceWorkload);
          if (resource) {
            const durationMonths = Math.max(1, task.endMonth - task.startMonth);
            const estimatedHours = this.estimateHours(null, durationMonths);
            const allocationPercent = this.calculateAllocation(
              resource,
              estimatedHours,
              durationMonths,
              resourceWorkload
            );
            resourceWorkload[resource.id] = (resourceWorkload[resource.id] || 0) + allocationPercent;
            assignments.push({
              epmProgramId: programId,
              taskId: task.taskId,
              taskName: task.taskName,
              resourceId: resource.id,
              resourceName: this.formatResourceName(resource),
              resourceRole: resource.role || "Team Member",
              // Ensure never undefined
              resourceType: resource.type === "external" ? "external_resource" : "internal_team",
              estimatedHours,
              status: "assigned",
              allocationPercent,
              assignedFrom: this.formatDate(task.startMonth),
              assignedTo: this.formatDate(task.endMonth),
              assignmentSource: "ai_generated",
              notes: match?.reasoning || `Auto-assigned to ${task.workstreamName}`
            });
          }
        }
        console.log(`[AssignmentGenerator] Generated ${assignments.length} task assignments`);
        this.logAllocationSummary(assignments, allResources);
        return assignments;
      }
      /**
       * Use AI to semantically match resources to tasks
       * Makes ONE batch call for efficiency
       */
      async getAIResourceMatches(tasks2, resources2, programContext) {
        try {
          const targetPerResource = Math.ceil(tasks2.length / resources2.length);
          const prompt = `You are a project staffing expert assigning team members to tasks.

PROJECT: "${programContext.name}"
${programContext.description ? `CONTEXT: ${programContext.description}` : ""}

AVAILABLE TEAM (${resources2.length} people):
${resources2.map((r) => `\u2022 ${r.id}: ${r.role}${r.skills?.length ? ` \u2014 Skills: ${r.skills.join(", ")}` : ""}`).join("\n")}

TASKS TO ASSIGN (${tasks2.length} total):
${tasks2.map((t) => `\u2022 ${t.taskId}: "${t.taskName}" [${t.workstreamName}]`).join("\n")}

ASSIGNMENT RULES:
1. Match by EXPERTISE: Assign tasks to the person whose role/skills best fit the work
   - "Menu Development" \u2192 Chef/Culinary role
   - "Marketing Campaign" \u2192 Marketing role
   - "POS System Setup" \u2192 IT/Technology role
   - "Staff Training" \u2192 HR/Operations role
   - "Compliance/Licensing" \u2192 Compliance/Legal role
   - "Financial Planning" \u2192 Finance role

2. DISTRIBUTE EVENLY: Each person should get ~${targetPerResource} tasks. Don't overload one person.

3. When in doubt, consider:
   - Who would naturally own this work based on their job title?
   - What department would handle this in a real organization?

Return ONLY valid JSON (no markdown, no explanation):
{
  "matches": [
    {"taskId": "WS001-D1", "resourceId": "INT-001", "confidence": 0.9, "reasoning": "Brief reason"}
  ]
}

IMPORTANT: Return a match for EVERY task. Use exact taskId and resourceId values from above.`;
          const response = await this.llm.generateStructuredResponse(prompt, { matches: [] });
          if (response?.matches && Array.isArray(response.matches)) {
            console.log(`[AssignmentGenerator] AI matched ${response.matches.length} tasks`);
            return response.matches;
          }
          console.log("[AssignmentGenerator] AI returned no matches, using fallback");
          return [];
        } catch (error) {
          console.error("[AssignmentGenerator] AI matching failed, using fallback:", error);
          return [];
        }
      }
      /**
       * Fallback: Get resource with lowest workload (round-robin effect)
       */
      getFallbackResource(resources2, workload) {
        const sorted = [...resources2].sort((a, b) => {
          const workloadA = workload[a.id] || 0;
          const workloadB = workload[b.id] || 0;
          return workloadA - workloadB;
        });
        return sorted[0];
      }
      /**
       * Extract a meaningful name from deliverable data
       */
      extractDeliverableName(deliverable, index2) {
        if (typeof deliverable === "string") {
          const cleaned = deliverable.trim();
          const firstSentence = cleaned.split(/[.;:]/)[0].trim();
          if (firstSentence.length <= 80) return firstSentence;
          const truncated = firstSentence.substring(0, 80);
          const lastSpace = truncated.lastIndexOf(" ");
          return lastSpace > 40 ? truncated.substring(0, lastSpace) + "..." : truncated + "...";
        }
        if (typeof deliverable === "object") {
          return deliverable.name || deliverable.title || deliverable.description?.substring(0, 80) || `Deliverable ${index2 + 1}`;
        }
        return `Deliverable ${index2 + 1}`;
      }
      /**
       * Format resource name for display
       */
      formatResourceName(resource) {
        const role = resource.role || "Team Member";
        return role.replace(/\s+/g, " ").trim();
      }
      /**
       * Convert month number to date string
       */
      formatDate(monthNumber) {
        const startDate = /* @__PURE__ */ new Date();
        startDate.setMonth(startDate.getMonth() + monthNumber);
        return startDate.toISOString().split("T")[0];
      }
      /**
       * Calculate allocation percentage based on workload and FTE
       */
      calculateAllocation(resource, estimatedHours, durationMonths, currentWorkload) {
        const totalAvailableHours = durationMonths * 160 * (resource.fte || resource.allocation || 1);
        const baseAllocation = Math.round(estimatedHours / totalAvailableHours * 100);
        const adjustedAllocation = Math.min(Math.max(baseAllocation, 10), 80);
        return adjustedAllocation;
      }
      /**
       * Estimate hours based on deliverable complexity
       */
      estimateHours(deliverable, durationMonths) {
        if (deliverable && typeof deliverable === "object" && deliverable.effort) {
          const effort = deliverable.effort;
          if (typeof effort === "number") return effort * 8;
          const effortStr = String(effort).toLowerCase();
          const match = effortStr.match(/(\d+)/);
          if (match) {
            const value = parseInt(match[1], 10);
            if (effortStr.includes("day")) return value * 8;
            if (effortStr.includes("week")) return value * 40;
            if (effortStr.includes("month")) return value * 160;
            if (effortStr.includes("hour")) return value;
            return value * 8;
          }
        }
        const baseHours = 30 + durationMonths * 10;
        return Math.min(baseHours, 80);
      }
      /**
       * Log allocation summary for debugging
       */
      logAllocationSummary(assignments, resources2) {
        const summary = {};
        for (const assignment of assignments) {
          if (!summary[assignment.resourceRole]) {
            summary[assignment.resourceRole] = { count: 0, totalAllocation: 0 };
          }
          summary[assignment.resourceRole].count++;
          summary[assignment.resourceRole].totalAllocation += assignment.allocationPercent;
        }
        console.log("[AssignmentGenerator] Allocation Summary:");
        for (const [role, data] of Object.entries(summary)) {
          console.log(`  - ${role}: ${data.count} tasks, avg ${Math.round(data.totalAllocation / data.count)}% allocation`);
        }
      }
    };
  }
});

// server/intelligence/epm/role-inference.ts
function normalizeRole(role) {
  return role.trim().toLowerCase().split(/\s+/).map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
}
function getCacheKey(businessType, workstreamName) {
  return `${businessType}::${workstreamName}`.toLowerCase().replace(/\s+/g, "_");
}
function inferSkillsFromCategory(category) {
  const normalized = category.toLowerCase().replace(/[^a-z_]/g, "");
  return CATEGORY_SKILLS[normalized] || ["general management"];
}
function ensureResourceExists(roleTitle, resourcePlan, category) {
  const normalizedRole = normalizeRole(roleTitle);
  const exists = resourcePlan.internalTeam.some(
    (r) => normalizeRole(r.role) === normalizedRole
  );
  if (!exists) {
    console.log(`[RoleInference] Adding new role to resource plan: ${normalizedRole}`);
    resourcePlan.internalTeam.push({
      role: normalizedRole,
      allocation: 1,
      // 100% allocation
      months: 6,
      // Default 6 months duration
      skills: inferSkillsFromCategory(category),
      justification: `Added by LLM role inference for ${category} workstreams`
    });
  }
}
var roleCache, CATEGORY_SKILLS, RoleInferenceService;
var init_role_inference = __esm({
  "server/intelligence/epm/role-inference.ts"() {
    "use strict";
    init_llm_provider2();
    roleCache = /* @__PURE__ */ new Map();
    CATEGORY_SKILLS = {
      construction: ["fit-out", "build-out", "interior design", "renovation"],
      design: ["interior design", "space planning", "architecture"],
      technology: ["POS systems", "IT infrastructure", "digital integration"],
      tech: ["POS systems", "IT infrastructure", "software implementation"],
      hr: ["recruitment", "training", "onboarding", "staff management"],
      training: ["staff training", "skills development", "certification"],
      marketing: ["launch campaigns", "social media", "brand building", "PR"],
      community: ["community engagement", "local partnerships", "events"],
      compliance: ["regulatory compliance", "food safety", "licensing", "permits"],
      licensing: ["permits", "regulatory approval", "health inspection"],
      operations: ["operational setup", "process design", "supply chain"],
      supply_chain: ["vendor management", "inventory", "logistics"],
      finance: ["financial planning", "budgeting", "cost control"],
      culinary: ["menu development", "food quality", "recipe standardization"]
    };
    RoleInferenceService = class {
      llm = getLLMProvider();
      /**
       * Infer owners for all workstreams in a single batch call
       * Returns role assignments with confidence scores and rationale
       */
      async inferOwners(businessContext, workstreams2, maxRoles = 6) {
        const effectiveMaxRoles = Math.min(workstreams2.length, maxRoles);
        const businessTypeKey = businessContext.businessType || businessContext.industry || "general";
        console.log(`[RoleInference] Starting batch inference for ${workstreams2.length} workstreams`);
        console.log(`[RoleInference] Business context: ${businessTypeKey}, max roles: ${effectiveMaxRoles}`);
        const cachedOwners = [];
        const uncachedWorkstreams = [];
        for (const ws2 of workstreams2) {
          const cacheKey = getCacheKey(businessTypeKey, ws2.name);
          const cached = roleCache.get(cacheKey);
          if (cached) {
            cachedOwners.push({
              ...cached,
              workstreamId: ws2.id
              // Update ID in case of reuse
            });
            console.log(`[RoleInference] Cache hit: "${ws2.name}" \u2192 ${cached.roleTitle}`);
          } else {
            uncachedWorkstreams.push(ws2);
          }
        }
        if (uncachedWorkstreams.length === 0) {
          console.log(`[RoleInference] All ${workstreams2.length} workstreams found in cache`);
          let warnings = [];
          let finalOwners = cachedOwners;
          let validationRan = false;
          if (workstreams2.length >= 3) {
            const validationResult = await this.comprehensiveValidation(
              cachedOwners,
              workstreams2,
              businessContext,
              effectiveMaxRoles
            );
            if (validationResult) {
              validationRan = true;
              warnings = validationResult.warnings;
              if (validationResult.correctedOwners) {
                finalOwners = validationResult.correctedOwners;
              }
            }
          }
          return {
            owners: finalOwners,
            warnings,
            usedCache: true,
            usedFallback: false,
            validationRan
          };
        }
        console.log(`[RoleInference] Cache: ${cachedOwners.length} hits, ${uncachedWorkstreams.length} misses`);
        try {
          const workstreamList = uncachedWorkstreams.map((ws2, i) => {
            const topDeliverables = (ws2.deliverables || []).slice(0, 3).map((d) => typeof d === "string" ? d : d.name || "Deliverable").join(", ");
            return `${i + 1}. ID: ${ws2.id}
   Name: ${ws2.name}
   Description: ${ws2.description || "N/A"}
   Sample tasks: ${topDeliverables || "N/A"}`;
          }).join("\n\n");
          const prompt = `You are a COO staffing expert designing a launch team.

PROGRAM CONTEXT:
- Industry: ${businessContext.industry || "Not specified"}
- Business type: ${businessContext.businessType || "Not specified"}
- Geography: ${businessContext.geography || "Not specified"}
- Initiative: ${businessContext.initiativeType || "market_entry"}
- Program: ${businessContext.programName || "Strategic Program"}
- Team size target: At most ${effectiveMaxRoles} unique roles

WORKSTREAMS TO STAFF:
${workstreamList}

Return ONLY valid JSON (no markdown, no explanation):
{
  "owners": [
    {
      "workstream_id": "WS001",
      "role_title": "Cafe Design & Build Lead",
      "category": "construction",
      "rationale": "Reason referencing context",
      "confidence": 0.9
    }
  ],
  "notes": "Optional consolidation notes"
}

RULES:
1. CRITICAL: Each workstream should have a DISTINCT specialist owner. Do NOT default everything to "Operations Manager" or "Program Manager"
2. Use precise, professional titles appropriate for the business type:
   - Construction/Build-out workstream \u2192 "Construction & Design Lead" or "Cafe Build-out Manager"
   - Technology/Digital/POS workstream \u2192 "Digital Systems Lead" or "Technology Manager"
   - HR/Hiring/Training workstream \u2192 "HR & Training Coordinator" or "Talent Manager"
   - Marketing/Community/Engagement workstream \u2192 "Marketing & Community Manager"
   - Compliance/Licensing/Regulatory workstream \u2192 "Compliance Specialist"
   - Operations/Workflow workstream \u2192 "Operations Manager"
   - Supply Chain/Inventory workstream \u2192 "Supply Chain Manager"
3. Category must be ONE of: construction, design, technology, hr, training, marketing, community, compliance, licensing, operations, supply_chain, finance, culinary
4. Only consolidate roles if workstreams are genuinely similar (e.g., two marketing workstreams can share one Marketing Manager)
5. Match role titles to the actual business type - a cafe should NOT have "Catering Operations Manager"
6. Return an owner for EVERY workstream ID listed above
7. AIM FOR DIVERSITY: If you have 6 workstreams, you should have 4-6 different role titles, not 2-3`;
          const response = await this.llm.generateStructuredResponse(prompt, { owners: [] });
          if (!response?.owners || !Array.isArray(response.owners)) {
            console.warn("[RoleInference] LLM returned invalid structure, using fallback");
            return this.fallbackInference(workstreams2, businessContext);
          }
          const inferredOwners = response.owners.map((o) => ({
            workstreamId: o.workstream_id,
            roleTitle: normalizeRole(o.role_title || "Program Manager"),
            category: o.category || "operations",
            rationale: o.rationale || "AI-assigned based on workstream content",
            confidence: o.confidence || 0.7
          }));
          for (const owner of inferredOwners) {
            const ws2 = uncachedWorkstreams.find((w) => w.id === owner.workstreamId);
            if (ws2) {
              const cacheKey = getCacheKey(businessTypeKey, ws2.name);
              roleCache.set(cacheKey, owner);
            }
          }
          console.log(`[RoleInference] AI inferred ${inferredOwners.length} owners:`);
          for (const owner of inferredOwners) {
            const ws2 = uncachedWorkstreams.find((w) => w.id === owner.workstreamId);
            console.log(`  - ${ws2?.name || owner.workstreamId} \u2192 ${owner.roleTitle} (${owner.category}, conf: ${owner.confidence})`);
          }
          let allOwners = [...cachedOwners, ...inferredOwners];
          const uniqueRoles = new Set(allOwners.map((o) => o.roleTitle));
          console.log(`[RoleInference] Initial unique roles: ${uniqueRoles.size} (target: ${effectiveMaxRoles})`);
          let warnings = [];
          let validationRan = false;
          if (workstreams2.length >= 3) {
            console.log(`[RoleInference] \u{1F50D} Running comprehensive validation...`);
            const validationResult = await this.comprehensiveValidation(
              allOwners,
              workstreams2,
              businessContext,
              effectiveMaxRoles
            );
            if (validationResult) {
              validationRan = true;
              warnings = validationResult.warnings;
              if (validationResult.correctedOwners) {
                allOwners = validationResult.correctedOwners;
                const newUniqueRoles = new Set(allOwners.map((o) => o.roleTitle));
                console.log(`[RoleInference] \u2713 Validation corrected to ${newUniqueRoles.size} unique roles`);
              }
              if (warnings.length > 0) {
                console.log(`[RoleInference] \u26A0\uFE0F Validation warnings (${warnings.length}):`);
                warnings.forEach((w) => console.log(`  - [${w.severity}] ${w.message}`));
              } else {
                console.log(`[RoleInference] \u2713 Validation passed with no warnings`);
              }
            }
          }
          return {
            owners: allOwners,
            notes: response.notes,
            warnings,
            usedCache: cachedOwners.length > 0,
            usedFallback: false,
            validationRan
          };
        } catch (error) {
          console.error("[RoleInference] LLM call failed, using fallback:", error);
          return this.fallbackInference(workstreams2, businessContext);
        }
      }
      /**
       * Fallback inference using simple heuristics (no LLM)
       * Used when LLM call fails
       */
      fallbackInference(workstreams2, businessContext) {
        console.log("[RoleInference] Using fallback heuristic assignment");
        const owners = workstreams2.map((ws2) => {
          const name = ws2.name.toLowerCase();
          const desc21 = (ws2.description || "").toLowerCase();
          const combined = `${name} ${desc21}`;
          let roleTitle = "Program Manager";
          let category = "operations";
          if (combined.includes("construction") || combined.includes("build") || combined.includes("design") || combined.includes("fit-out")) {
            roleTitle = "Construction & Design Lead";
            category = "construction";
          } else if (combined.includes("compliance") || combined.includes("licensing") || combined.includes("permit") || combined.includes("regulatory")) {
            roleTitle = "Compliance & Licensing Specialist";
            category = "compliance";
          } else if (combined.includes("technology") || combined.includes("pos") || combined.includes("system") || combined.includes("digital")) {
            roleTitle = "Technology & Systems Lead";
            category = "technology";
          } else if (combined.includes("talent") || combined.includes("training") || combined.includes("recruitment") || combined.includes("staff") || combined.includes("hr")) {
            roleTitle = "HR & Training Coordinator";
            category = "hr";
          } else if (combined.includes("marketing") || combined.includes("brand") || combined.includes("community") || combined.includes("social")) {
            roleTitle = "Marketing & Community Manager";
            category = "marketing";
          } else if (combined.includes("supply") || combined.includes("inventory") || combined.includes("vendor") || combined.includes("procurement")) {
            roleTitle = "Supply Chain Manager";
            category = "supply_chain";
          } else if (combined.includes("financial") || combined.includes("budget") || combined.includes("cost")) {
            roleTitle = "Financial Controller";
            category = "finance";
          } else if (combined.includes("menu") || combined.includes("culinary") || combined.includes("food") || combined.includes("recipe")) {
            roleTitle = "Culinary Director";
            category = "culinary";
          }
          return {
            workstreamId: ws2.id,
            roleTitle: normalizeRole(roleTitle),
            category,
            rationale: "Fallback assignment based on workstream keywords",
            confidence: 0.5
          };
        });
        return {
          owners,
          notes: "Fallback assignment used due to LLM failure",
          warnings: [{
            type: "mismatch",
            severity: "warning",
            message: "LLM inference failed, using fallback heuristics",
            recommendation: "Review owner assignments manually for accuracy"
          }],
          usedCache: false,
          usedFallback: true,
          validationRan: false
        };
      }
      /**
       * Comprehensive validation pass - checks multiple quality dimensions
       * 1. Are workstreams properly matched to roles?
       * 2. Is the team size realistic for business scale?
       * 3. Are any roles over-consolidated (too many workstreams)?
       * 4. Are any key functions missing (marketing, compliance, HR)?
       */
      async comprehensiveValidation(currentOwners, workstreams2, businessContext, targetMaxRoles) {
        try {
          const assignmentSummary = currentOwners.map((o) => {
            const ws2 = workstreams2.find((w) => w.id === o.workstreamId);
            return `- "${ws2?.name || o.workstreamId}" \u2192 ${o.roleTitle} (category: ${o.category})`;
          }).join("\n");
          const roleCounts = {};
          currentOwners.forEach((o) => {
            roleCounts[o.roleTitle] = (roleCounts[o.roleTitle] || 0) + 1;
          });
          const distribution = Object.entries(roleCounts).map(([role, count2]) => `${role}: ${count2} workstreams`).join(", ");
          const categoriesCovered = [...new Set(currentOwners.map((o) => o.category))];
          const prompt = `You are a COO reviewing staffing assignments for a new ${businessContext.businessType || "business"} launch.

BUSINESS CONTEXT:
- Industry: ${businessContext.industry || "Not specified"}
- Business type: ${businessContext.businessType || "Not specified"}
- Geography: ${businessContext.geography || "Not specified"}
- Initiative: ${businessContext.initiativeType || "market_entry"}
- Total workstreams: ${workstreams2.length}
- Target team size: ${targetMaxRoles} roles max

CURRENT ASSIGNMENTS:
${assignmentSummary}

ROLE DISTRIBUTION: ${distribution}
CATEGORIES COVERED: ${categoriesCovered.join(", ")}

REVIEW THESE QUALITY DIMENSIONS:

1. ROLE-WORKSTREAM MATCH: Does each workstream have the right specialist?
   - Technology/Digital/POS workstream should have Technology Lead, NOT Operations Manager
   - HR/Training workstream should have HR Coordinator, NOT Operations Manager
   - Marketing/Community workstream should have Marketing Manager, NOT Operations Manager

2. TEAM SIZE REALISM: Is ${Object.keys(roleCounts).length} unique roles realistic for a ${businessContext.businessType || "small business"}?
   - Small cafe/restaurant: 4-6 roles is typical
   - Tech startup: 5-8 roles is typical
   - Enterprise: 8-12 roles is typical

3. OVER-CONSOLIDATION: Is any single role assigned to 3+ very different workstreams?
   - OK: Operations Manager owns 2 operational workstreams
   - NOT OK: Operations Manager owns Construction, Marketing, AND Technology workstreams

4. MISSING FUNCTIONS: For this business type, are any critical functions missing?
   - Cafe/Restaurant typically needs: Operations, Construction/Design, Compliance, Marketing, HR/Training
   - Tech typically needs: Engineering, Product, Marketing, Operations, Compliance

Return ONLY valid JSON:
{
  "assessment": {
    "role_match_score": 0.8,
    "team_size_appropriate": true,
    "over_consolidation_detected": false,
    "missing_functions": []
  },
  "corrections": [
    {
      "workstream_id": "WS001",
      "old_role": "Operations Manager",
      "new_role": "Digital Systems Lead",
      "category": "technology",
      "reason": "POS integration is technology work, not general operations"
    }
  ],
  "warnings": [
    {
      "type": "over_consolidation",
      "severity": "warning",
      "message": "Operations Manager is assigned to 4 different workstreams",
      "recommendation": "Consider splitting into specialized roles",
      "workstream_id": null
    }
  ],
  "notes": "Summary of validation findings"
}`;
          const response = await this.llm.generateStructuredResponse(prompt, {
            assessment: {},
            corrections: [],
            warnings: []
          });
          if (!response) {
            console.log("[RoleInference] Validation returned empty response");
            return null;
          }
          const warnings = (response.warnings || []).map((w) => ({
            type: w.type || "mismatch",
            severity: w.severity || "warning",
            message: w.message || "Validation issue detected",
            recommendation: w.recommendation || "Review assignments",
            workstreamId: w.workstream_id || void 0
          }));
          if (response.assessment?.missing_functions?.length > 0) {
            warnings.push({
              type: "missing_function",
              severity: "warning",
              message: `Missing key functions: ${response.assessment.missing_functions.join(", ")}`,
              recommendation: "Consider adding roles for these functions"
            });
          }
          if (response.assessment?.over_consolidation_detected) {
            warnings.push({
              type: "over_consolidation",
              severity: "warning",
              message: "Some roles are overloaded with too many different workstreams",
              recommendation: "Review the corrections below to rebalance"
            });
          }
          if (response.assessment?.team_size_appropriate === false) {
            warnings.push({
              type: "team_size",
              severity: "info",
              message: `Team size may not be optimal for ${businessContext.businessType || "this business type"}`,
              recommendation: "Consider adjusting team structure based on business scale"
            });
          }
          let correctedOwners = null;
          if (response.corrections && Array.isArray(response.corrections) && response.corrections.length > 0) {
            console.log(`[RoleInference] Validation suggested ${response.corrections.length} corrections:`);
            correctedOwners = currentOwners.map((owner) => {
              const correction = response.corrections.find((c) => c.workstream_id === owner.workstreamId);
              if (correction) {
                console.log(`  - ${owner.workstreamId}: "${owner.roleTitle}" \u2192 "${correction.new_role}" (${correction.reason})`);
                return {
                  ...owner,
                  roleTitle: normalizeRole(correction.new_role),
                  category: correction.category || owner.category,
                  rationale: `Validated: ${correction.reason}`,
                  confidence: 0.9
                };
              }
              return owner;
            });
          }
          if (response.notes) {
            console.log(`[RoleInference] Validation notes: ${response.notes}`);
          }
          return { correctedOwners, warnings };
        } catch (error) {
          console.error("[RoleInference] Comprehensive validation failed:", error);
          return null;
        }
      }
      /**
       * Clear the role cache (useful for testing)
       */
      clearCache() {
        roleCache.clear();
        console.log("[RoleInference] Cache cleared");
      }
    };
  }
});

// server/intelligence/epm/benefit-helpers.ts
function summarizeDecision(decision, option) {
  if (decision.title) {
    return decision.title.trim();
  }
  if (option.label) {
    return option.label.trim();
  }
  return `Strategic Initiative ${decision.id}`;
}
function buildBenefitDescription(decision, option) {
  const question = decision.question?.trim() || "";
  const answer = option.description?.trim() || option.label?.trim() || "";
  if (question && answer) {
    return `${answer}. This addresses the strategic question: ${question}`;
  }
  if (answer) {
    return answer;
  }
  if (question) {
    return `Strategic initiative to address: ${question}`;
  }
  return "Strategic initiative aligned with program decisions.";
}
function inferCategory(impactAreas) {
  if (!impactAreas || impactAreas.length === 0) {
    return "Strategic";
  }
  const area = impactAreas[0].toLowerCase();
  if (area.includes("revenue") || area.includes("financial") || area.includes("cost") || area.includes("profit")) {
    return "Financial";
  }
  if (area.includes("efficiency") || area.includes("operations") || area.includes("process")) {
    return "Operational";
  }
  if (area.includes("customer") || area.includes("experience") || area.includes("satisfaction")) {
    return "Customer";
  }
  return "Strategic";
}
function deriveMetric(option, category) {
  if (option.metric) {
    return option.metric;
  }
  const label = (option.label || "").toLowerCase();
  const desc21 = (option.description || "").toLowerCase();
  const text2 = `${label} ${desc21}`;
  if (text2.includes("revenue") || text2.includes("sales")) {
    return "Revenue growth rate (monthly)";
  }
  if (text2.includes("market") || text2.includes("share")) {
    return "Market share percentage (quarterly)";
  }
  if (text2.includes("partnership") || text2.includes("partner")) {
    return "Partnership revenue and contract value (quarterly)";
  }
  if (text2.includes("customer") || text2.includes("satisfaction")) {
    return "Customer satisfaction score (NPS, monthly)";
  }
  if (text2.includes("digital") || text2.includes("online")) {
    return "Digital channel revenue percentage (weekly)";
  }
  if (text2.includes("cost") || text2.includes("efficiency")) {
    return "Cost reduction percentage (monthly)";
  }
  if (text2.includes("expansion") || text2.includes("growth")) {
    return "Expansion readiness score (quarterly)";
  }
  const categoryMetrics = {
    Financial: "Financial performance metrics (monthly)",
    Strategic: "Strategic KPI tracking (quarterly)",
    Operational: "Operational efficiency metrics (monthly)",
    Customer: "Customer satisfaction metrics (monthly)"
  };
  return categoryMetrics[category] || "Performance metrics and KPI tracking (quarterly)";
}
function deriveTarget(option, category) {
  if (option.target) {
    return option.target;
  }
  const desc21 = option.description || "";
  const percentMatch = desc21.match(/(\d+)%/);
  if (percentMatch) {
    return `${percentMatch[1]}% improvement vs baseline`;
  }
  const timeMatch = desc21.match(/(\d+)\s*(months?|weeks?|days?)/i);
  if (timeMatch) {
    return `Complete within ${timeMatch[1]} ${timeMatch[2]}`;
  }
  const categoryTargets = {
    Financial: "+15% revenue growth or -10% cost reduction within 6 months",
    Strategic: "Measurable competitive advantage by Month 6",
    Operational: "+20% operational efficiency within 6 months",
    Customer: "NPS 60+ and 40% repeat customer rate by Month 6"
  };
  return categoryTargets[category] || "Measurable improvement vs baseline within 6 months";
}
function deriveTimeframe(option, programTimeline) {
  if (option.timelineMonths) {
    return `Month ${option.timelineMonths}`;
  }
  if (option.estimated_timeline_months) {
    return `Month ${option.estimated_timeline_months}`;
  }
  const fallback = programTimeline ? Math.min(programTimeline, 6) : 4;
  return `Month ${fallback}`;
}
function pickOwner(decision, workstreams2, resources2) {
  const keywords = [
    ...decision.impactAreas || [],
    decision.title || "",
    decision.question || "",
    ...decision.options[0]?.label ? [decision.options[0].label] : []
  ].map((k) => k.toLowerCase()).filter((k) => k.length > 0);
  for (const keyword of keywords) {
    const ws2 = workstreams2.find(
      (ws3) => ws3.name.toLowerCase().includes(keyword) || (ws3.description || "").toLowerCase().includes(keyword)
    );
    if (ws2?.owner) {
      return ws2.owner;
    }
  }
  for (const keyword of keywords) {
    const resource = resources2.find(
      (r) => r.role.toLowerCase().includes(keyword)
    );
    if (resource?.role) {
      return resource.role;
    }
  }
  const keywordOwnerMap = {
    "marketing": ["Marketing", "Digital", "Brand"],
    "sales": ["Sales", "Marketing", "Business Development"],
    "digital": ["Digital", "Technology", "IT"],
    "operations": ["Operations", "Manager"],
    "finance": ["Finance", "CFO", "Controller"],
    "compliance": ["Compliance", "Legal", "Regulatory"],
    "customer": ["Customer", "Experience", "Service"],
    "technology": ["Technology", "IT", "Tech", "Platform", "Engineer"]
  };
  for (const [area, roleKeywords] of Object.entries(keywordOwnerMap)) {
    if (keywords.some((k) => k.includes(area))) {
      for (const roleKeyword of roleKeywords) {
        const resource = resources2.find(
          (r) => r.role.toLowerCase().includes(roleKeyword.toLowerCase())
        );
        if (resource?.role) {
          return resource.role;
        }
      }
    }
  }
  const ops = resources2.find((r) => r.role.toLowerCase().includes("operations"));
  return ops?.role || resources2[0]?.role || "Program Lead";
}
function matchOwnerToOpportunity(opportunity, workstreams2, resources2) {
  const text2 = `${opportunity.name || ""} ${opportunity.description || ""} ${opportunity.content || ""}`.toLowerCase();
  if (!text2.trim()) {
    return resources2[0]?.role || "Program Lead";
  }
  const ws2 = workstreams2.find(
    (ws3) => text2.includes(ws3.name.toLowerCase()) || ws3.name.toLowerCase().split(" ").some((word) => text2.includes(word))
  );
  if (ws2?.owner) {
    return ws2.owner;
  }
  const resource = resources2.find((r) => {
    const roleWords = r.role.toLowerCase().split(" ");
    return roleWords.some((word) => word.length > 3 && text2.includes(word));
  });
  if (resource?.role) {
    return resource.role;
  }
  return resources2[0]?.role || "Program Lead";
}
function truncate(text2, maxLength = 50) {
  if (text2.length <= maxLength) return text2;
  return text2.substring(0, maxLength - 3) + "...";
}
var init_benefit_helpers = __esm({
  "server/intelligence/epm/benefit-helpers.ts"() {
    "use strict";
  }
});

// server/intelligence/epm/generators.ts
var ExecutiveSummaryGenerator, FinancialPlanGenerator, BenefitsGenerator, RiskGenerator, StageGateGenerator, KPIGenerator, StakeholderGenerator, GovernanceGenerator, QAPlanGenerator, ProcurementGenerator, ExitStrategyGenerator, ProgramNameGenerator;
var init_generators = __esm({
  "server/intelligence/epm/generators.ts"() {
    "use strict";
    init_ai_clients();
    init_role_templates();
    init_benefit_helpers();
    ExecutiveSummaryGenerator = class {
      async generate(insights, programName) {
        const marketInsights = insights.insights.filter((i) => i.type === "other" && i.source.includes("summary"));
        const riskInsights = insights.insights.filter((i) => i.type === "risk");
        const benefitInsights = insights.insights.filter((i) => i.type === "benefit");
        return {
          title: programName,
          marketOpportunity: marketInsights[0]?.content || "Strategic opportunity identified through framework analysis",
          strategicImperatives: insights.insights.filter((i) => i.source.includes("recommendation") || i.source.includes("implication")).slice(0, 5).map((i) => i.content),
          keySuccessFactors: insights.insights.filter((i) => i.type === "workstream").slice(0, 4).map((i) => i.content.split("\n")[0]),
          riskSummary: `${riskInsights.length} risks identified, with ${riskInsights.filter((i) => i.confidence > 0.8).length} high-priority risks requiring immediate mitigation.`,
          investmentRequired: this.estimateInvestmentFromInsights(insights),
          expectedOutcomes: this.summarizeExpectedOutcomes(benefitInsights),
          confidence: 0.9
        };
      }
      estimateInvestmentFromInsights(insights) {
        const costInsights = insights.insights.filter((i) => i.type === "cost");
        if (costInsights.length > 0) {
          return `$${(costInsights.length * 2e5).toLocaleString()} estimated`;
        }
        return insights.marketContext.budgetRange || "$500k - $1.5M";
      }
      summarizeExpectedOutcomes(benefitInsights) {
        if (benefitInsights.length === 0) {
          return "Enhanced strategic positioning, operational efficiency, and competitive advantage";
        }
        return benefitInsights.slice(0, 3).map((i) => i.content).join("; ");
      }
    };
    FinancialPlanGenerator = class {
      async generate(insights, resourcePlan, userContext) {
        const costInsights = insights.insights.filter((i) => i.type === "cost");
        const personnelCost = resourcePlan.totalFTEs * 15e4;
        const externalCost = resourcePlan.externalResources.reduce((sum, r) => sum + r.estimatedCost, 0);
        const overheadCost = (personnelCost + externalCost) * 0.15;
        const totalBudget = userContext?.budgetRange?.max || personnelCost + externalCost + overheadCost;
        const costBreakdown = [
          { category: "Personnel", amount: personnelCost, percentage: personnelCost / totalBudget * 100, description: "Internal team costs" },
          { category: "External Resources", amount: externalCost, percentage: externalCost / totalBudget * 100, description: "Consultants, software, services" },
          { category: "Overhead", amount: overheadCost, percentage: overheadCost / totalBudget * 100, description: "Infrastructure, admin, facilities" }
        ];
        const contingency = totalBudget * 0.1;
        const cashFlow = this.generateCashFlow(totalBudget, 12);
        return {
          totalBudget: totalBudget + contingency,
          costBreakdown,
          cashFlow,
          contingency,
          contingencyPercentage: 10,
          assumptions: [
            `FTE cost: $150k/year`,
            `${resourcePlan.totalFTEs} FTEs for ${12} months`,
            `15% overhead for infrastructure and support`,
            `10% contingency for risks and unknowns`
          ],
          confidence: costInsights.length > 0 ? 0.65 : 0.55
        };
      }
      generateCashFlow(totalBudget, months) {
        const quarters = Math.ceil(months / 3);
        const cashFlow = [];
        let cumulative = 0;
        for (let q = 1; q <= quarters; q++) {
          const percentage = q === 1 ? 0.4 : q === 2 ? 0.3 : q === 3 ? 0.2 : 0.1;
          const amount = -(totalBudget * percentage);
          cumulative += amount;
          cashFlow.push({
            quarter: q,
            amount,
            cumulative
          });
        }
        return cashFlow;
      }
    };
    BenefitsGenerator = class {
      /**
       * Generate benefits from strategic context (decisions + SWOT)
       * This is the PRIMARY method - uses actual user decisions
       */
      generateFromContext(decisions, swotData, workstreams2, resources2, programTimeline) {
        const benefits2 = [];
        console.log(`[BenefitsGenerator] Generating from context: ${decisions?.length || 0} decisions, ${workstreams2?.length || 0} workstreams`);
        const selectedDecisions = decisions?.filter((d) => d.selectedOptionId) || [];
        selectedDecisions.forEach((decision, index2) => {
          if (benefits2.length >= 6) return;
          const option = decision.options?.find((o) => o.id === decision.selectedOptionId);
          if (!option) return;
          const category = inferCategory(decision.impactAreas);
          benefits2.push({
            id: `BEN-${String(index2 + 1).padStart(2, "0")}`,
            name: summarizeDecision(decision, option),
            description: buildBenefitDescription(decision, option),
            category,
            measurement: deriveMetric(option, category),
            target: deriveTarget(option, category),
            realizationMonth: this.parseTimeframeToMonth(deriveTimeframe(option, programTimeline)),
            responsibleParty: pickOwner(decision, workstreams2, resources2),
            confidence: 0.8
          });
        });
        console.log(`[BenefitsGenerator] Generated ${benefits2.length} benefits from decisions`);
        if (benefits2.length < 4) {
          const opportunities = swotData?.opportunities || [];
          const benefitsFromDecisions = benefits2.length;
          opportunities.slice(0, 6 - benefits2.length).forEach((op, idx) => {
            const opText = op.content || op.description || op.name || "";
            const opName = op.name || truncate(opText, 60);
            const analysis = this.analyzeOpportunity(opText || opName);
            const needsEnrichment = !opText || opText.length < 50 || opText === opName;
            const description = needsEnrichment ? this.generateRichDescription(opName, analysis) : opText;
            benefits2.push({
              id: `BEN-SWOT-${String(idx + 1).padStart(2, "0")}`,
              name: analysis.name || opName,
              description,
              category: analysis.category,
              measurement: analysis.measurement,
              target: op.target || analysis.target,
              realizationMonth: programTimeline ? Math.min(programTimeline, 6) : 4,
              responsibleParty: matchOwnerToOpportunity(op, workstreams2, resources2),
              confidence: 0.7
            });
          });
          console.log(`[BenefitsGenerator] Added ${benefits2.length - benefitsFromDecisions} benefits from SWOT opportunities`);
        }
        const totalFinancialValue = benefits2.filter((b) => b.estimatedValue).reduce((sum, b) => sum + (b.estimatedValue || 0), 0);
        return {
          benefits: benefits2.slice(0, 6),
          totalFinancialValue: totalFinancialValue > 0 ? totalFinancialValue : void 0,
          confidence: benefits2.length > 0 ? 0.8 : 0.6
        };
      }
      /**
       * Parse timeframe string to month number
       */
      parseTimeframeToMonth(timeframe) {
        const match = timeframe.match(/Month\s*(\d+)/i);
        return match ? parseInt(match[1], 10) : 4;
      }
      /**
       * Legacy generate method - falls back to insight-based generation
       * Used when strategic context is not available
       */
      async generate(insights, timeline, programContext) {
        const benefitInsights = insights.insights.filter((i) => i.type === "benefit");
        const strengthInsights = insights.insights.filter(
          (i) => i.source?.includes("strength") || i.type === "other" && i.source?.includes("SWOT.strengths")
        );
        const benefits2 = [];
        benefitInsights.forEach((insight, idx) => {
          const analysis = this.analyzeOpportunity(insight.content);
          const estimatedValue = this.estimateBenefitValue(insight, analysis);
          benefits2.push({
            id: `B${String(benefits2.length + 1).padStart(3, "0")}`,
            name: analysis.name,
            category: analysis.category,
            description: insight.content,
            target: analysis.target,
            realizationMonth: this.calculateRealizationMonth(idx, timeline, analysis.priority),
            estimatedValue,
            measurement: analysis.measurement,
            confidence: insight.confidence
          });
        });
        strengthInsights.slice(0, 2).forEach((insight, idx) => {
          if (benefits2.length >= 6) return;
          const analysis = this.analyzeStrength(insight.content);
          benefits2.push({
            id: `B${String(benefits2.length + 1).padStart(3, "0")}`,
            name: `Leverage: ${analysis.name}`,
            category: "Strategic",
            description: insight.content,
            target: analysis.target,
            realizationMonth: timeline.totalMonths - 1,
            estimatedValue: void 0,
            measurement: analysis.measurement,
            confidence: insight.confidence * 0.9
          });
        });
        if (benefits2.length < 3) {
          const defaultBenefits = this.generateContextualDefaults(insights, timeline, 3 - benefits2.length);
          benefits2.push(...defaultBenefits);
        }
        const totalFinancialValue = benefits2.filter((b) => b.estimatedValue).reduce((sum, b) => sum + (b.estimatedValue || 0), 0);
        return {
          benefits: benefits2,
          totalFinancialValue: totalFinancialValue > 0 ? totalFinancialValue : void 0,
          confidence: benefitInsights.length > 0 ? 0.75 : 0.6
        };
      }
      /**
       * Analyze an opportunity to extract specific benefit details
       */
      analyzeOpportunity(content) {
        const lower = content.toLowerCase();
        if (lower.includes("streetwear") || lower.includes("culture") || lower.includes("community")) {
          return {
            name: "Community & Culture Engagement",
            category: "Strategic",
            target: "+25% community engagement; 500+ loyalty members in Year 1",
            measurement: "Community size, event attendance, social engagement (monthly)",
            priority: "high"
          };
        }
        if (lower.includes("digital") || lower.includes("technology") || lower.includes("integration") || lower.includes("online")) {
          return {
            name: "Digital Channel Revenue",
            category: "Financial",
            target: "15% of total revenue from digital channels by Month 6",
            measurement: "E-commerce revenue, app downloads, digital conversion rate (weekly)",
            priority: "high"
          };
        }
        if (lower.includes("exclusive") || lower.includes("launch") || lower.includes("product")) {
          return {
            name: "Exclusive Product Premium",
            category: "Financial",
            target: "+20% margin on exclusive releases; 3+ brand partnerships",
            measurement: "Exclusive SKU margin, brand partnership count, release sell-through rate (monthly)",
            priority: "high"
          };
        }
        if (lower.includes("partnership") || lower.includes("corporate") || lower.includes("sponsor")) {
          return {
            name: "Strategic Partnership Value",
            category: "Strategic",
            target: "2+ corporate partnerships generating $50K+ annual revenue",
            measurement: "Partnership revenue, contract value, renewal rate (quarterly)",
            priority: "medium"
          };
        }
        if (lower.includes("expansion") || lower.includes("regional") || lower.includes("growth") || lower.includes("potential")) {
          return {
            name: "Market Expansion Readiness",
            category: "Strategic",
            target: "Expansion-ready operations by Month 9; 2nd location feasibility complete",
            measurement: "Expansion readiness score, location analysis, capital requirements (quarterly)",
            priority: "medium"
          };
        }
        if (lower.includes("customer") || lower.includes("experience") || lower.includes("service")) {
          return {
            name: "Premium Customer Experience",
            category: "Operational",
            target: "NPS 60+; 40% repeat customer rate by Month 6",
            measurement: "NPS score, repeat purchase rate, customer satisfaction surveys (monthly)",
            priority: "high"
          };
        }
        if (lower.includes("revenue") || lower.includes("sales") || lower.includes("income")) {
          return {
            name: "Revenue Growth",
            category: "Financial",
            target: "+20% YoY revenue growth; break-even by Month 8",
            measurement: "Monthly revenue, growth rate, gross margin (weekly)",
            priority: "high"
          };
        }
        if (lower.includes("brand") || lower.includes("awareness") || lower.includes("recognition")) {
          return {
            name: "Brand Recognition",
            category: "Strategic",
            target: "70% brand awareness in target demographic within 6 months",
            measurement: "Brand awareness surveys, social mentions, media coverage (monthly)",
            priority: "medium"
          };
        }
        return {
          name: this.extractBenefitName(content),
          category: "Strategic",
          target: this.generateContextualTarget(content),
          measurement: "Performance metrics and KPI tracking (quarterly)",
          priority: "medium"
        };
      }
      /**
       * Analyze a strength to create leverage benefit
       */
      analyzeStrength(content) {
        const lower = content.toLowerCase();
        if (lower.includes("location") || lower.includes("prime") || lower.includes("foot traffic")) {
          return {
            name: "Prime Location Advantage",
            target: "+30% walk-in conversion vs market average",
            measurement: "Foot traffic, conversion rate, avg transaction value"
          };
        }
        if (lower.includes("expertise") || lower.includes("knowledge") || lower.includes("team")) {
          return {
            name: "Domain Expertise",
            target: "95% customer satisfaction on product advice",
            measurement: "Customer feedback, upsell rate, return rate"
          };
        }
        return {
          name: this.extractBenefitName(content),
          target: "+15% competitive advantage in key metrics",
          measurement: "Competitive benchmarking (quarterly)"
        };
      }
      /**
       * Generate contextual default benefits when too few are identified
       */
      generateContextualDefaults(insights, timeline, count2) {
        const defaults = [];
        const industry = insights.marketContext?.industry?.toLowerCase() || "";
        const templates2 = [
          {
            name: "Operational Excellence",
            category: "Operational",
            description: "Achieve operational efficiency through optimized processes",
            target: "-15% operational costs; 95% process compliance",
            measurement: "Cost per transaction, process adherence (monthly)"
          },
          {
            name: "Market Positioning",
            category: "Strategic",
            description: "Establish strong market position in target segment",
            target: "Top 3 position in local market segment",
            measurement: "Market share surveys, competitive analysis (quarterly)"
          },
          {
            name: "Customer Acquisition",
            category: "Financial",
            description: "Build sustainable customer acquisition channels",
            target: "1000+ customers in database by Month 6",
            measurement: "Customer count, CAC, LTV (monthly)"
          }
        ];
        for (let i = 0; i < count2 && i < templates2.length; i++) {
          defaults.push({
            id: `B${String(defaults.length + 10).padStart(3, "0")}`,
            ...templates2[i],
            realizationMonth: timeline.totalMonths - (count2 - i),
            estimatedValue: void 0,
            confidence: 0.65
          });
        }
        return defaults;
      }
      extractBenefitName(content) {
        const cleaned = content.replace(/^(opportunity:|benefit:|strength:)/i, "").trim();
        const firstPhrase = cleaned.split(/[.!?,;]/)[0].trim();
        if (firstPhrase.length <= 50) return firstPhrase;
        const truncated = firstPhrase.substring(0, 50);
        const lastSpace = truncated.lastIndexOf(" ");
        return lastSpace > 20 ? truncated.substring(0, lastSpace) : truncated;
      }
      generateContextualTarget(content) {
        const lower = content.toLowerCase();
        if (lower.includes("market") || lower.includes("position")) return "+15% market penetration in Year 1";
        if (lower.includes("efficien") || lower.includes("process")) return "+20% operational efficiency";
        if (lower.includes("quality") || lower.includes("premium")) return "95% quality score; <2% defect rate";
        if (lower.includes("innovat") || lower.includes("new")) return "3+ innovations implemented per year";
        return "Measurable improvement vs baseline within 6 months";
      }
      generateRichDescription(content, analysis) {
        const cleaned = content.trim();
        if (cleaned.length < 50) {
          const expansions = {
            "Financial": `Capitalize on ${cleaned.toLowerCase()} to drive revenue growth and improve financial performance through targeted initiatives`,
            "Strategic": `Leverage ${cleaned.toLowerCase()} to strengthen market position and create sustainable competitive advantage`,
            "Operational": `Optimize ${cleaned.toLowerCase()} to enhance operational efficiency and reduce costs`,
            "Customer Experience": `Enhance ${cleaned.toLowerCase()} to improve customer satisfaction and loyalty`
          };
          return expansions[analysis.category] || `Realize value from ${cleaned.toLowerCase()} through focused strategic execution`;
        }
        return cleaned;
      }
      calculateRealizationMonth(idx, timeline, priority) {
        const baseMonth = priority === "high" ? 3 : priority === "medium" ? 6 : 9;
        return Math.min(baseMonth + idx, timeline.totalMonths);
      }
      categorizeBenefit(content) {
        const lower = content.toLowerCase();
        if (lower.includes("revenue") || lower.includes("cost") || lower.includes("$") || lower.includes("margin")) return "Financial";
        if (lower.includes("risk") || lower.includes("mitigate") || lower.includes("compliance")) return "Risk Mitigation";
        if (lower.includes("efficiency") || lower.includes("process") || lower.includes("operation")) return "Operational";
        return "Strategic";
      }
      estimateBenefitValue(insight, analysis) {
        const match = insight.content.match(/\$([0-9,]+)/);
        if (match) {
          return parseInt(match[1].replace(/,/g, ""));
        }
        return void 0;
      }
      generateMeasurement(content) {
        const lower = content.toLowerCase();
        if (lower.includes("revenue")) return "Revenue tracking (monthly)";
        if (lower.includes("cost")) return "Cost analysis (quarterly)";
        if (lower.includes("customer")) return "Customer surveys (quarterly)";
        if (lower.includes("market")) return "Market analysis (semi-annual)";
        return "Performance metrics (quarterly)";
      }
      /**
       * Use AI to enhance benefits with contextual descriptions and assign owners
       * Makes ONE batch call for efficiency
       */
      async enhanceBenefitsWithAI(benefits2, resources2, programContext) {
        if (!resources2 || resources2.length === 0 || benefits2.length === 0) {
          console.log("[BenefitsGenerator] No resources or benefits, using defaults");
          return benefits2.map((b) => ({ ...b, responsibleParty: "Program Director" }));
        }
        const availableRoles = resources2.map((r) => r.role);
        try {
          const prompt = `You are writing benefit descriptions for a strategic program. Each benefit needs a FULL PARAGRAPH description.

PROGRAM: "${programContext?.name || "Strategic Program"}"
${programContext?.description ? `CONTEXT: ${programContext.description}` : ""}

TEAM MEMBERS (assign owners from this list ONLY):
${availableRoles.map((r, i) => `\u2022 ${r}`).join("\n")}

BENEFITS TO DESCRIBE:
${benefits2.map((b, i) => `${i + 1}. "${b.name}" (Target: ${b.target || "TBD"})`).join("\n")}

EXAMPLE of a GOOD description (this is the quality I need):
"By establishing partnerships with regional tourism boards and eco-tourism operators, the zoo will tap into the growing market of environmentally-conscious travelers. This will drive a projected 25% increase in international visitors within the first year, generating an estimated $500K in additional ticket revenue while positioning the zoo as a leading sustainable attraction in the Gulf region."

YOUR TASK: Write a description like the example above for EACH benefit. Each description must:
- Be 2-3 full sentences (40-80 words)
- Explain HOW the benefit will be achieved
- Include specific outcomes or metrics where possible
- Reference the actual program context

Return ONLY valid JSON:
{
  "enhancements": [
    {
      "benefitIndex": 0,
      "description": "Full paragraph description here (2-3 sentences, 40-80 words)...",
      "owner": "Exact role name from the team list"
    }
  ]
}

RULES:
- DO NOT write short phrases like "Regional Tourism Hub Development" - write FULL PARAGRAPHS
- DO NOT use boilerplate like "This benefit will be realized through..."
- Owners must EXACTLY match a team member name from the list
- Distribute ownership across different team members`;
          const result = await aiClients.callWithFallback({
            systemPrompt: "You are an expert at writing strategic benefit descriptions for enterprise programs.",
            userMessage: prompt,
            maxTokens: 2e3
          });
          const responseText = result?.content || "";
          const jsonMatch = responseText.match(/\{[\s\S]*\}/);
          if (jsonMatch) {
            const parsed = JSON.parse(jsonMatch[0]);
            if (parsed.enhancements && Array.isArray(parsed.enhancements)) {
              console.log(`[BenefitsGenerator] AI enhanced ${parsed.enhancements.length} benefits`);
              return benefits2.map((benefit, idx) => {
                const enhancement = parsed.enhancements.find((e) => e.benefitIndex === idx);
                if (enhancement) {
                  const validOwner = availableRoles.find(
                    (r) => r.toLowerCase() === enhancement.owner?.toLowerCase()
                  ) || availableRoles[idx % availableRoles.length];
                  return {
                    ...benefit,
                    description: enhancement.description || benefit.description,
                    responsibleParty: validOwner
                  };
                }
                return {
                  ...benefit,
                  responsibleParty: availableRoles[idx % availableRoles.length]
                };
              });
            }
          }
          console.log("[BenefitsGenerator] AI returned no valid enhancements, using fallback");
        } catch (error) {
          console.error("[BenefitsGenerator] AI enhancement failed:", error);
        }
        return this.assignBenefitOwners(benefits2, resources2);
      }
      /**
       * Assign responsible parties to benefits based on their category and content
       * Uses role-templates for context-aware owner assignment with round-robin fallback
       * NOTE: This is the fallback method - prefer enhanceBenefitsWithAI for better results
       */
      assignBenefitOwners(benefits2, resources2) {
        if (!resources2 || resources2.length === 0) {
          console.log("[BenefitsGenerator] No resources available, using default owner");
          return benefits2.map((b) => ({ ...b, responsibleParty: "Program Director" }));
        }
        const availableRoles = resources2.map((r) => r.role);
        const usedOwners = /* @__PURE__ */ new Map();
        availableRoles.forEach((role) => usedOwners.set(role, 0));
        return benefits2.map((benefit) => {
          let effectiveCategory = benefit.category || "Strategic";
          const lowerContent = benefit.description.toLowerCase();
          const lowerName = (benefit.name || "").toLowerCase();
          if (lowerContent.includes("revenue") || lowerContent.includes("sales") || lowerName.includes("revenue")) {
            effectiveCategory = "Financial";
          } else if (lowerContent.includes("customer") || lowerContent.includes("experience") || lowerName.includes("customer")) {
            effectiveCategory = "Operational";
          } else if (lowerContent.includes("brand") || lowerContent.includes("marketing") || lowerName.includes("brand")) {
            effectiveCategory = "Strategic";
          }
          const owner = findBenefitOwner(effectiveCategory, availableRoles, usedOwners);
          usedOwners.set(owner, (usedOwners.get(owner) || 0) + 1);
          return {
            ...benefit,
            responsibleParty: owner
          };
        });
      }
    };
    RiskGenerator = class {
      async generate(insights) {
        const riskInsights = insights.insights.filter((i) => i.type === "risk");
        const risks2 = riskInsights.map((insight, idx) => {
          const category = this.categorizeRisk(insight);
          const probability = this.estimateRiskProbability(insight, idx);
          const impact = this.estimateRiskImpact(insight);
          const impactMultiplier = impact === "Critical" ? 4 : impact === "High" ? 3 : impact === "Medium" ? 2 : 1;
          return {
            id: `R${String(idx + 1).padStart(3, "0")}`,
            description: insight.content,
            category,
            probability,
            impact,
            severity: Math.round(probability * impactMultiplier / 10),
            // Normalized severity score
            mitigation: this.generateMitigation(insight, category),
            contingency: `Escalate to governance if probability exceeds ${Math.min(probability + 20, 90)}%`,
            confidence: insight.confidence
          };
        });
        const topRisks = [...risks2].sort((a, b) => b.severity - a.severity).slice(0, 5);
        return {
          risks: risks2,
          topRisks,
          mitigationBudget: risks2.length * 25e3,
          confidence: riskInsights.length > 0 ? 0.8 : 0.65
        };
      }
      categorizeRisk(insight) {
        const lower = insight.content.toLowerCase();
        if (lower.includes("technology") || lower.includes("technical") || lower.includes("system") || lower.includes("integration")) return "Technical";
        if (lower.includes("market") || lower.includes("competitive") || lower.includes("competition") || lower.includes("demand")) return "Market";
        if (lower.includes("resource") || lower.includes("team") || lower.includes("talent") || lower.includes("hiring")) return "Resource";
        if (lower.includes("regulatory") || lower.includes("compliance") || lower.includes("legal") || lower.includes("license")) return "Regulatory";
        if (lower.includes("cost") || lower.includes("budget") || lower.includes("financial") || lower.includes("economic")) return "Financial";
        if (lower.includes("operations") || lower.includes("supply") || lower.includes("inventory") || lower.includes("logistics")) return "Operational";
        return "Strategic";
      }
      /**
       * Estimate risk probability using multiple signals for variation:
       * - Base from confidence (inverted)
       * - Category adjustment (some risks inherently more likely)
       * - Content keywords (explicit indicators)
       * - Index-based variation (prevents all same value)
       */
      estimateRiskProbability(insight, idx) {
        const baseProbability = 25 + Math.round((1 - insight.confidence) * 20);
        const lower = insight.content.toLowerCase();
        let adjustment = 0;
        if (lower.includes("competition") || lower.includes("competitive")) adjustment += 15;
        else if (lower.includes("economic") || lower.includes("currency")) adjustment += 12;
        else if (lower.includes("market") || lower.includes("demand")) adjustment += 10;
        else if (lower.includes("technology") || lower.includes("system")) adjustment += 8;
        else if (lower.includes("cost") || lower.includes("budget")) adjustment += 5;
        else if (lower.includes("regulatory") || lower.includes("compliance")) adjustment += 3;
        else if (lower.includes("talent") || lower.includes("resource")) adjustment += 5;
        if (lower.includes("high") || lower.includes("significant") || lower.includes("major")) adjustment += 10;
        if (lower.includes("limited") || lower.includes("single") || lower.includes("dependency")) adjustment += 8;
        if (lower.includes("changing") || lower.includes("volatile") || lower.includes("uncertain")) adjustment += 6;
        if (lower.includes("intense") || lower.includes("increasing")) adjustment += 5;
        if (lower.includes("manageable") || lower.includes("controllable")) adjustment -= 8;
        if (lower.includes("established") || lower.includes("proven")) adjustment -= 5;
        const indexVariation = idx !== void 0 ? idx % 5 * 3 - 6 : 0;
        return Math.max(20, Math.min(75, baseProbability + adjustment + indexVariation));
      }
      estimateRiskImpact(insight) {
        const lower = insight.content.toLowerCase();
        if (lower.includes("critical") || lower.includes("catastrophic")) return "Critical";
        if (lower.includes("high") || lower.includes("significant")) return "High";
        if (lower.includes("medium") || lower.includes("moderate")) return "Medium";
        return "Low";
      }
      generateMitigation(insight, category) {
        const lower = insight.content.toLowerCase();
        if (lower.includes("competition") || lower.includes("competitor")) {
          return "Develop competitive differentiation strategy and monitor competitor movements weekly";
        }
        if (lower.includes("supply chain") || lower.includes("supplier")) {
          return "Diversify supplier base and maintain 30-day inventory buffer for critical materials";
        }
        if (lower.includes("talent") || lower.includes("hiring") || lower.includes("recruitment")) {
          return "Implement retention bonuses, accelerate hiring pipeline, and cross-train existing staff";
        }
        if (lower.includes("technology") || lower.includes("system") || lower.includes("integration")) {
          return "Conduct technical proof-of-concept, establish rollback procedures, and schedule vendor support";
        }
        if (lower.includes("regulatory") || lower.includes("compliance") || lower.includes("legal")) {
          return "Engage legal counsel, implement compliance monitoring, and establish regulatory liaison";
        }
        if (lower.includes("budget") || lower.includes("cost") || lower.includes("financial")) {
          return "Establish contingency reserve (15% of budget), implement monthly cost reviews, and identify cost reduction levers";
        }
        if (lower.includes("timeline") || lower.includes("delay") || lower.includes("schedule")) {
          return "Build 2-week buffer into critical path, identify fast-track options, and escalate blockers within 48 hours";
        }
        if (lower.includes("customer") || lower.includes("user") || lower.includes("adoption")) {
          return "Conduct user research, implement feedback loops, and develop change management communication plan";
        }
        if (lower.includes("market") || lower.includes("demand") || lower.includes("economic")) {
          return "Monitor market indicators monthly, develop scenario-based contingency plans, and maintain pricing flexibility";
        }
        if (lower.includes("quality") || lower.includes("defect") || lower.includes("performance")) {
          return "Implement quality gates at each phase, establish acceptance criteria, and conduct regular testing";
        }
        if (lower.includes("security") || lower.includes("breach") || lower.includes("data")) {
          return "Conduct security audit, implement access controls, and establish incident response procedures";
        }
        if (lower.includes("stakeholder") || lower.includes("sponsor") || lower.includes("executive")) {
          return "Schedule bi-weekly stakeholder updates, document decisions formally, and maintain RACI clarity";
        }
        if (lower.includes("resource") || lower.includes("capacity") || lower.includes("bandwidth")) {
          return "Prioritize workload, identify backup resources, and establish resource escalation path";
        }
        const categoryMitigations = {
          "Technical": "Conduct technical review, establish fallback architecture, and maintain vendor support agreements",
          "Market": "Monitor market trends quarterly, develop pivot scenarios, and maintain customer feedback channels",
          "Resource": "Cross-train team members, maintain contractor relationships, and document key processes",
          "Regulatory": "Engage compliance experts, monitor regulatory changes, and maintain audit documentation",
          "Strategic": "Review strategy quarterly with leadership, maintain scenario plans, and track leading indicators"
        };
        return categoryMitigations[category] || "Establish monitoring process, define escalation triggers, and review mitigation effectiveness monthly";
      }
      /**
       * Assign owners to risks based on their category and content
       * Uses role-templates for context-aware owner assignment with round-robin fallback
       */
      assignRiskOwners(risks2, resources2) {
        if (!resources2 || resources2.length === 0) {
          console.log("[RiskGenerator] No resources available, using default owner");
          return risks2.map((r) => ({ ...r, owner: "Risk Manager" }));
        }
        const availableRoles = resources2.map((r) => r.role);
        const usedOwners = /* @__PURE__ */ new Map();
        availableRoles.forEach((role) => usedOwners.set(role, 0));
        return risks2.map((risk) => {
          const categoryMap = {
            "technical": "operational",
            "market": "strategic",
            "resource": "operational",
            "regulatory": "compliance",
            "financial": "financial",
            "operational": "operational",
            "strategic": "strategic",
            "reputational": "reputational",
            "execution": "execution"
          };
          const riskCategory = categoryMap[risk.category.toLowerCase()] || "operational";
          const owner = findRiskOwner(riskCategory, availableRoles, usedOwners);
          usedOwners.set(owner, (usedOwners.get(owner) || 0) + 1);
          return {
            ...risk,
            owner
          };
        });
      }
    };
    StageGateGenerator = class {
      async generate(timeline, riskRegister) {
        const gates = timeline.phases.map((phase, idx) => ({
          gate: idx + 1,
          name: `Gate ${idx + 1}: ${phase.name} Complete`,
          month: phase.endMonth,
          goCriteria: [
            `All ${phase.name} deliverables completed`,
            `Phase objectives achieved`,
            `Budget within \xB110% of plan`,
            `No critical risks unmitigated`
          ],
          noGoTriggers: [
            `Critical deliverables >2 weeks late`,
            `Budget overrun >20%`,
            `${riskRegister.topRisks.slice(0, 2).map((r) => `Risk ${r.id} realized`).join(" OR ")}`
          ],
          deliverables: phase.workstreamIds,
          confidence: 0.85
        }));
        return {
          gates,
          confidence: 0.85
        };
      }
    };
    KPIGenerator = class {
      async generate(insights, benefitsRealization) {
        const kpis2 = benefitsRealization.benefits.map((benefit, idx) => {
          let kpiCategory = "Strategic";
          if (benefit.category === "Financial") kpiCategory = "Financial";
          else if (benefit.category === "Operational") kpiCategory = "Operational";
          else if (benefit.category === "Strategic") kpiCategory = "Strategic";
          return {
            id: `KPI${String(idx + 1).padStart(3, "0")}`,
            name: this.generateKPIName(benefit.description),
            category: kpiCategory,
            baseline: "Current state",
            target: benefit.estimatedValue ? `+${benefit.estimatedValue.toLocaleString()}` : this.generateMeasurableTarget(benefit),
            measurement: benefit.measurement,
            frequency: benefit.category === "Financial" ? "Monthly" : "Quarterly",
            linkedBenefitIds: [benefit.id],
            confidence: benefit.confidence
          };
        });
        kpis2.push({
          id: `KPI${String(kpis2.length + 1).padStart(3, "0")}`,
          name: "Program Progress",
          category: "Operational",
          baseline: "0%",
          target: "100%",
          measurement: "Percentage of deliverables completed",
          frequency: "Monthly",
          linkedBenefitIds: [],
          confidence: 0.95
        });
        return {
          kpis: kpis2,
          confidence: 0.75
        };
      }
      generateKPIName(description) {
        const words = description.split(" ").slice(0, 4).join(" ");
        return words.length > 40 ? words.substring(0, 37) + "..." : words;
      }
      generateMeasurableTarget(benefit) {
        const lower = benefit.description.toLowerCase();
        const measurement = benefit.measurement?.toLowerCase() || "";
        if (lower.includes("revenue") || lower.includes("sales")) {
          return "+15% year-over-year";
        }
        if (lower.includes("cost") || lower.includes("expense") || lower.includes("savings")) {
          return "-20% reduction from baseline";
        }
        if (lower.includes("efficiency") || lower.includes("productivity")) {
          return "+25% improvement in throughput";
        }
        if (lower.includes("time") || lower.includes("speed") || lower.includes("faster")) {
          return "-30% reduction in cycle time";
        }
        if (lower.includes("customer") || lower.includes("satisfaction") || lower.includes("nps")) {
          return "+10 points NPS improvement";
        }
        if (lower.includes("quality") || lower.includes("defect") || lower.includes("error")) {
          return "-50% reduction in defect rate";
        }
        if (lower.includes("market") || lower.includes("share")) {
          return "+5% market share gain";
        }
        if (lower.includes("retention") || lower.includes("churn")) {
          return "+10% improvement in retention rate";
        }
        if (lower.includes("conversion") || lower.includes("lead")) {
          return "+20% conversion rate improvement";
        }
        if (lower.includes("engagement") || lower.includes("adoption")) {
          return "+30% increase in active users";
        }
        if (lower.includes("compliance") || lower.includes("audit")) {
          return "100% compliance score";
        }
        if (lower.includes("risk") || lower.includes("incident")) {
          return "-40% reduction in incidents";
        }
        if (benefit.category === "Financial") {
          return "+10% improvement vs baseline";
        }
        if (benefit.category === "Operational") {
          return "+15% operational improvement";
        }
        if (benefit.category === "Customer") {
          return "+20% customer metric improvement";
        }
        return "+15% improvement vs current state";
      }
    };
    StakeholderGenerator = class {
      async generate(insights) {
        const stakeholderInsights = insights.insights.filter((i) => i.type === "stakeholder");
        const stakeholders = stakeholderInsights.map((insight) => ({
          name: insight.content.split(":")[0] || "Stakeholder",
          group: this.categorizeStakeholder(insight.content),
          power: this.assessStakeholderPower(insight),
          interest: this.assessStakeholderInterest(insight),
          engagement: `${this.assessStakeholderPower(insight)} power, ${this.assessStakeholderInterest(insight)} interest - ${this.getEngagementStrategy(insight)}`,
          communicationPlan: this.generateCommunicationPlan(insight)
        }));
        if (stakeholders.length < 3) {
          stakeholders.push(
            { name: "Executive Sponsor", group: "Leadership", power: "High", interest: "High", engagement: "Manage closely", communicationPlan: "Weekly updates" },
            { name: "Program Team", group: "Execution", power: "Medium", interest: "High", engagement: "Keep informed", communicationPlan: "Daily standups" },
            { name: "End Users", group: "Customers", power: "Medium", interest: "High", engagement: "Keep informed", communicationPlan: "Monthly updates" }
          );
        }
        const changeManagement = [
          { phase: "Awareness", months: "Months 0-2", activities: ["Stakeholder identification", "Impact assessment", "Communication planning"] },
          { phase: "Mobilization", months: "Months 2-4", activities: ["Training programs", "Change champions", "Feedback loops"] },
          { phase: "Execution", months: "Months 4-10", activities: ["Ongoing support", "Resistance management", "Progress tracking"] },
          { phase: "Sustainment", months: "Months 10-12+", activities: ["Reinforcement", "Best practices", "Continuous improvement"] }
        ];
        return {
          stakeholders,
          changeManagement,
          impactedGroups: stakeholders.length,
          confidence: stakeholderInsights.length > 0 ? 0.75 : 0.65
        };
      }
      categorizeStakeholder(content) {
        const lower = content.toLowerCase();
        if (lower.includes("customer") || lower.includes("user")) return "Customers";
        if (lower.includes("executive") || lower.includes("leadership")) return "Leadership";
        if (lower.includes("team") || lower.includes("employee")) return "Execution";
        if (lower.includes("partner") || lower.includes("supplier")) return "Partners";
        return "Other";
      }
      assessStakeholderPower(insight) {
        if (insight.confidence > 0.8) return "High";
        if (insight.confidence > 0.6) return "Medium";
        return "Low";
      }
      assessStakeholderInterest(insight) {
        return "High";
      }
      getEngagementStrategy(insight) {
        const power = this.assessStakeholderPower(insight);
        const interest = this.assessStakeholderInterest(insight);
        if (power === "High" && interest === "High") return "Manage closely";
        if (power === "High" && interest !== "High") return "Keep satisfied";
        if (power !== "High" && interest === "High") return "Keep informed";
        return "Monitor";
      }
      generateCommunicationPlan(insight) {
        const strategy = this.getEngagementStrategy(insight);
        if (strategy === "Manage closely") return "Weekly updates, monthly reviews";
        if (strategy === "Keep satisfied") return "Monthly updates";
        if (strategy === "Keep informed") return "Quarterly updates, newsletters";
        return "As needed";
      }
    };
    GovernanceGenerator = class {
      async generate(insights, stakeholderMap) {
        return {
          bodies: [
            {
              name: "Steering Committee",
              level: "Strategic",
              members: ["Executive Sponsor", "Business Owners", "Program Manager"],
              cadence: "Monthly",
              responsibilities: ["Strategic direction", "Budget approval", "Risk escalation"],
              escalationPath: "Board of Directors"
            },
            {
              name: "Program Management Office",
              level: "Tactical",
              members: ["Program Manager", "Workstream Leads", "Change Manager"],
              cadence: "Weekly",
              responsibilities: ["Progress tracking", "Issue resolution", "Resource allocation"],
              escalationPath: "Steering Committee"
            }
          ],
          decisionRights: [
            { decision: "Budget Changes >10%", responsible: "Program Manager", accountable: "Steering Committee", consulted: "Finance", informed: "All Stakeholders" },
            { decision: "Scope Changes", responsible: "Workstream Leads", accountable: "Program Manager", consulted: "Business Owners", informed: "Steering Committee" },
            { decision: "Risk Mitigation", responsible: "Risk Owner", accountable: "Program Manager", consulted: "PMO", informed: "Steering Committee" }
          ],
          meetingCadence: {
            "Daily": "Team standups",
            "Weekly": "PMO sync, workstream reviews",
            "Monthly": "Steering Committee, stakeholder updates"
          },
          confidence: 0.85
        };
      }
    };
    QAPlanGenerator = class {
      async generate(insights) {
        return {
          standards: [
            { area: "Deliverables", standard: "All deliverables reviewed and approved", acceptanceCriteria: ["Peer review completed", "Stakeholder approval", "Quality checklist passed"] },
            { area: "Testing", standard: "Comprehensive testing before deployment", acceptanceCriteria: ["Test plans executed", "Defects resolved", "User acceptance complete"] },
            { area: "Documentation", standard: "Complete and current documentation", acceptanceCriteria: ["User guides", "Technical specs", "Process documentation"] }
          ],
          processes: [
            { phase: "Planning", activities: ["Quality plan development", "Standards definition", "Acceptance criteria"] },
            { phase: "Execution", activities: ["Quality reviews", "Testing", "Defect tracking"] },
            { phase: "Closure", activities: ["Final QA audit", "Lessons learned", "Quality metrics"] }
          ],
          acceptanceCriteria: [
            "All deliverables meet quality standards",
            "Testing complete with <5% defect rate",
            "Stakeholder sign-off received",
            "Documentation complete and approved"
          ],
          confidence: 0.8
        };
      }
    };
    ProcurementGenerator = class {
      async generate(insights, financialPlan) {
        const items = financialPlan.costBreakdown.filter((c) => c.category === "External Resources").map((cost, idx) => ({
          id: `P${String(idx + 1).padStart(3, "0")}`,
          name: cost.description,
          type: "Services",
          estimatedValue: cost.amount,
          timing: "Months 0-6",
          purpose: cost.description,
          approvalRequired: cost.amount > 1e5 ? "Steering Committee" : "Program Manager"
        }));
        return {
          items,
          vendorManagement: [
            "Monthly vendor performance reviews",
            "Contract compliance monitoring",
            "Service level agreement tracking"
          ],
          policies: [
            "All procurement >$50k requires competitive bidding",
            "Vendor selection based on capability and cost",
            "Quarterly vendor portfolio review"
          ],
          totalProcurementValue: items.reduce((sum, i) => sum + i.estimatedValue, 0),
          confidence: 0.75
        };
      }
    };
    ExitStrategyGenerator = class {
      async generate(insights, riskRegister) {
        return {
          failureConditions: riskRegister.topRisks.slice(0, 3).map((risk) => ({
            trigger: risk.description,
            severity: risk.impact === "Low" ? "Medium" : risk.impact,
            responseTime: risk.impact === "Critical" ? "Immediate" : "30 days"
          })),
          rollbackProcedures: [
            {
              name: "Program Pause",
              trigger: "Critical risk realized or budget overrun >30%",
              actions: ["Pause all workstreams", "Stakeholder notification", "Impact assessment", "Remediation plan"],
              estimatedCost: 1e5,
              timeline: "2-4 weeks"
            },
            {
              name: "Graceful Wind-Down",
              trigger: "Strategic objectives no longer valid",
              actions: ["Complete in-flight deliverables", "Knowledge transfer", "Asset disposition", "Team redeployment"],
              estimatedCost: 25e4,
              timeline: "3 months"
            }
          ],
          pivotOptions: [
            { name: "Reduce Scope", description: "Focus on core deliverables only", conditions: ["Budget constraints", "Timeline pressure"] },
            { name: "Phased Approach", description: "Deliver in multiple phases", conditions: ["Resource constraints", "Risk mitigation"] }
          ],
          lessonsLearned: [
            "Conduct post-implementation review",
            "Document successes and challenges",
            "Update organizational playbooks"
          ],
          confidence: 0.75
        };
      }
    };
    ProgramNameGenerator = class {
      async generate(insights, userContext, namingContext) {
        try {
          console.log(`[ProgramNameGenerator] Received namingContext:`, {
            hasNamingContext: !!namingContext,
            journeyTitle: namingContext?.journeyTitle || "NOT SET",
            hasDecisions: !!namingContext?.selectedDecisions,
            hasBmcInsights: !!namingContext?.bmcKeyInsights?.length
          });
          if (namingContext?.journeyTitle && namingContext.journeyTitle.trim().length > 0) {
            console.log(`[ProgramNameGenerator] \u{1F3AF} Using journey title: "${namingContext.journeyTitle}"`);
            return namingContext.journeyTitle.trim();
          }
          const keyInsights = namingContext?.bmcKeyInsights || [];
          const recommendations = namingContext?.bmcRecommendations || [];
          const selectedDecisions = namingContext?.selectedDecisions || {};
          const decisionsData = namingContext?.decisionsData || {};
          const framework = namingContext?.framework || "bmc";
          let contextSummary = "";
          if (keyInsights.length > 0) {
            contextSummary += `
Key Strategic Insights:
${keyInsights.slice(0, 3).join("\n")}`;
          }
          if (recommendations.length > 0) {
            const recs = recommendations.slice(0, 2).map(
              (r) => typeof r === "object" ? r.action : r
            );
            contextSummary += `

Top Recommendations:
${recs.join("\n")}`;
          }
          if (decisionsData?.decisions && selectedDecisions) {
            const selectedOptions = [];
            decisionsData.decisions.forEach((decision) => {
              const selectedOptionId = selectedDecisions[decision.id];
              if (selectedOptionId) {
                const option = decision.options?.find((o) => o.id === selectedOptionId);
                if (option) {
                  selectedOptions.push(`${decision.title}: ${option.label}`);
                }
              }
            });
            if (selectedOptions.length > 0) {
              contextSummary += `

Selected Strategic Decisions:
${selectedOptions.slice(0, 3).join("\n")}`;
            }
          }
          const prompt = `You are an expert program manager creating concise, descriptive program names.

Given the following strategic analysis and decisions, generate a professional program name that captures the essence of this initiative.

${contextSummary}

Framework Used: ${framework.toUpperCase()}

Requirements:
- 8-15 words maximum
- Clear and descriptive
- Professional tone
- Captures the core strategic approach
- Avoid generic terms like "Strategic Initiative"
- Focus on the unique strategic choices made

Examples of good program names:
- "Brooklyn Coffee Shop Community Hub with Diversified Revenue Strategy"
- "Premium Customer Segment Market Entry via Pop-up Testing"
- "Sustainable Pace Technology Integration for Local Market"

Generate ONLY the program name, nothing else.`;
          const result = await aiClients.callWithFallback({
            systemPrompt: "You are a program naming expert. Generate concise, professional program names.",
            userMessage: prompt,
            maxTokens: 100
          });
          const programName = result.content.trim();
          if (programName && programName.length > 0 && programName.length <= 150) {
            return programName;
          }
          return this.generateFallbackProgramName(selectedDecisions, decisionsData, framework);
        } catch (error) {
          console.error("[ProgramNameGenerator] Program name generation failed:", error);
          return this.generateFallbackProgramName(
            namingContext?.selectedDecisions,
            namingContext?.decisionsData,
            namingContext?.framework || "bmc"
          );
        }
      }
      generateFallbackProgramName(selectedDecisions, decisionsData, framework) {
        const parts = [];
        if (decisionsData?.decisions && selectedDecisions) {
          decisionsData.decisions.slice(0, 2).forEach((decision) => {
            const selectedOptionId = selectedDecisions[decision.id];
            if (selectedOptionId) {
              const option = decision.options?.find((o) => o.id === selectedOptionId);
              if (option) {
                parts.push(option.label);
              }
            }
          });
        }
        if (parts.length === 0) {
          return `${framework.toUpperCase()} Strategic Initiative`;
        }
        return parts.slice(0, 3).join(" - ") + " Program";
      }
    };
  }
});

// server/intelligence/epm/index.ts
var init_epm = __esm({
  "server/intelligence/epm/index.ts"() {
    "use strict";
    init_context_builder();
    init_validator2();
    init_timeline_calculator();
    init_workstream_generator();
    init_resource_allocator();
    init_assignment_generator();
    init_role_inference();
    init_generators();
  }
});

// server/intelligence/epm-synthesizer.ts
var EPMSynthesizer;
var init_epm_synthesizer = __esm({
  "server/intelligence/epm-synthesizer.ts"() {
    "use strict";
    init_epm_integration();
    init_epm();
    init_epm();
    EPMSynthesizer = class {
      llm;
      workstreamGenerator;
      timelineCalculator;
      resourceAllocator;
      validator;
      executiveSummaryGenerator;
      financialPlanGenerator;
      benefitsGenerator;
      riskGenerator;
      stageGateGenerator;
      kpiGenerator;
      stakeholderGenerator;
      governanceGenerator;
      qaPlanGenerator;
      procurementGenerator;
      exitStrategyGenerator;
      programNameGenerator;
      assignmentGenerator;
      roleInferenceService;
      constructor(llm2) {
        this.llm = llm2;
        this.workstreamGenerator = new WorkstreamGenerator(this.llm);
        this.timelineCalculator = new TimelineCalculator();
        this.resourceAllocator = new ResourceAllocator();
        this.validator = new EPMValidator();
        this.executiveSummaryGenerator = new ExecutiveSummaryGenerator();
        this.financialPlanGenerator = new FinancialPlanGenerator();
        this.benefitsGenerator = new BenefitsGenerator();
        this.riskGenerator = new RiskGenerator();
        this.stageGateGenerator = new StageGateGenerator();
        this.kpiGenerator = new KPIGenerator();
        this.stakeholderGenerator = new StakeholderGenerator();
        this.governanceGenerator = new GovernanceGenerator();
        this.qaPlanGenerator = new QAPlanGenerator();
        this.procurementGenerator = new ProcurementGenerator();
        this.exitStrategyGenerator = new ExitStrategyGenerator();
        this.programNameGenerator = new ProgramNameGenerator();
        this.assignmentGenerator = new AssignmentGenerator();
        this.roleInferenceService = new RoleInferenceService();
      }
      /**
       * Generate task assignments from an EPM program
       * Maps resources to deliverables across workstreams
       */
      async generateAssignments(epmProgram, programId) {
        return this.assignmentGenerator.generate(epmProgram, programId);
      }
      /**
       * Main entry point: Synthesize complete EPM program from strategic insights
       * 
       * This method orchestrates all components to produce a complete, validated
       * EPM program with all 14 required components.
       */
      async synthesize(insights, userContext, namingContext, options) {
        const startTime = Date.now();
        const onProgress = options?.onProgress;
        console.log("\n" + "=".repeat(80));
        console.log("[EPM Synthesis] \u{1F680} STARTING EPM PROGRAM SYNTHESIS");
        console.log("=".repeat(80));
        console.log("[EPM Synthesis] Framework type:", insights.frameworkType);
        console.log("[EPM Synthesis] Insights count:", insights.insights.length);
        console.log("[EPM Synthesis] Session ID:", userContext?.sessionId || "N/A");
        onProgress?.({
          type: "step-start",
          step: "init",
          description: "Initializing EPM synthesis",
          elapsedSeconds: 0
        });
        try {
          const program = await this.buildWithIntelligentPlanning(
            insights,
            userContext,
            namingContext,
            onProgress,
            startTime
          );
          const elapsedSeconds = Math.round((Date.now() - startTime) / 1e3);
          console.log(`[EPM Synthesis] \u2705 Complete in ${elapsedSeconds}s`);
          onProgress?.({
            type: "step-complete",
            step: "synthesis",
            description: "EPM synthesis finished, preparing to save...",
            elapsedSeconds
          });
          return program;
        } catch (error) {
          console.error("[EPM Synthesis] \u274C Synthesis failed:", error);
          const elapsedSeconds = Math.round((Date.now() - startTime) / 1e3);
          onProgress?.({
            type: "error",
            description: "EPM synthesis failed",
            error: error instanceof Error ? error.message : String(error),
            elapsedSeconds
          });
          throw error;
        }
      }
      /**
       * Build EPM using intelligent planning (primary path)
       */
      async buildWithIntelligentPlanning(insights, userContext, namingContext, onProgress, startTime) {
        const processStartTime = startTime || Date.now();
        onProgress?.({
          type: "step-start",
          step: "workstreams",
          description: "Generating intelligent workstreams",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const workstreams2 = await this.workstreamGenerator.generate(
          insights,
          userContext,
          onProgress,
          processStartTime
        );
        console.log(`[EPM Synthesis] \u2713 Generated ${workstreams2.length} workstreams`);
        onProgress?.({
          type: "step-start",
          step: "planning-context",
          description: "Building planning context",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const planningContext = await ContextBuilder.fromJourneyInsights(
          insights,
          insights.frameworkType || "strategy_workspace",
          userContext?.sessionId
        );
        console.log(`[EPM Synthesis] \u2713 Planning context: Scale=${planningContext.business.scale}, Timeline=${planningContext.execution.timeline.min}-${planningContext.execution.timeline.max}mo`);
        onProgress?.({
          type: "step-start",
          step: "intelligent-planning",
          description: "Applying intelligent timeline planning",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const epmProgramInput = { workstreams: workstreams2 };
        const planningResult = await replaceTimelineGeneration(
          epmProgramInput,
          planningContext
        );
        const strategicContext = this.extractStrategicContext(insights, namingContext);
        console.log(`[EPM Synthesis] \u2713 Strategic context: ${strategicContext.decisions.length} decisions, SWOT available: ${!!strategicContext.swotData}`);
        if (planningResult.success && planningResult.confidence >= 0.6) {
          console.log("[EPM Synthesis] \u2713 Intelligent planning successful");
          console.log(`[EPM Synthesis]   Confidence: ${(planningResult.confidence * 100).toFixed(1)}%`);
          const scheduledWorkstreams = planningResult.program?.workstreams || workstreams2;
          return await this.buildFullProgram(
            insights,
            scheduledWorkstreams,
            planningContext,
            userContext,
            namingContext,
            strategicContext,
            onProgress,
            processStartTime
          );
        } else {
          console.warn("[EPM Synthesis] \u26A0\uFE0F Intelligent planning unsuccessful");
          console.log("[EPM Synthesis] Planning result details:");
          console.log("  - Success:", planningResult.success);
          console.log("  - Confidence:", planningResult.confidence);
          console.log("  - Warnings count:", planningResult.warnings?.length || 0);
          console.log("  - Adjustments count:", planningResult.adjustments?.length || 0);
          if (planningResult.adjustments && planningResult.adjustments.length > 0) {
            console.log("[EPM Synthesis] Adjustments needed:");
            planningResult.adjustments.forEach((adj, i) => {
              console.log(`    ${i + 1}. ${adj}`);
            });
          }
          console.log("[EPM Synthesis] \u{1F4E6} Using WBS Builder workstreams as-is (skipping timeline optimization)");
          console.log(`[EPM Synthesis]   Workstreams preserved: ${workstreams2.length}`);
          const timedWorkstreams = this.assignDefaultTimings(workstreams2, planningContext);
          timedWorkstreams.forEach((ws2, i) => {
            console.log(`[EPM Synthesis]     ${i + 1}. ${ws2.name} (M${ws2.startMonth}-M${ws2.endMonth}, ${ws2.deliverables?.length || 0} deliverables)`);
          });
          return await this.buildFullProgram(
            insights,
            timedWorkstreams,
            // Use WBS Builder workstreams with default timings
            planningContext,
            userContext,
            namingContext,
            strategicContext,
            onProgress,
            processStartTime
          );
        }
      }
      /**
       * Extract strategic context (decisions + SWOT) for benefits generation
       * This pulls ACTUAL user decisions and SWOT analysis data
       *
       * DUAL-PATH SUPPORT:
       * 1. Legacy path: namingContext.decisionsData / selectedDecisions (from version table)
       * 2. Journey Builder path: namingContext.decisionsData (from frameworkInsights)
       * 3. SWOT: Check namingContext.journeyBuilderSwot first, then insights
       */
      extractStrategicContext(insights, namingContext) {
        const decisionsData = namingContext?.decisionsData?.decisions || [];
        const selectedDecisions = namingContext?.selectedDecisions || {};
        const decisions = decisionsData.map((d) => ({
          ...d,
          selectedOptionId: selectedDecisions[d.id] || d.selectedOptionId
        }));
        let opportunities = [];
        let strengths = [];
        const journeyBuilderSwot = namingContext?.journeyBuilderSwot;
        if (journeyBuilderSwot) {
          console.log("[EPM Synthesis] Using Journey Builder SWOT from frameworkInsights");
          const jbOpportunities = journeyBuilderSwot?.opportunities || journeyBuilderSwot?.output?.opportunities || journeyBuilderSwot?.data?.output?.opportunities || [];
          opportunities = jbOpportunities.map((op) => ({
            name: typeof op === "string" ? op.substring(0, 60) : op.name || op.title || op.content?.substring(0, 60),
            description: typeof op === "string" ? op : op.description || op.content || op.name || "",
            content: typeof op === "string" ? op : op.content || op.description || op.name || ""
          }));
          const jbStrengths = journeyBuilderSwot?.strengths || journeyBuilderSwot?.output?.strengths || journeyBuilderSwot?.data?.output?.strengths || [];
          strengths = jbStrengths.map((s) => ({
            content: typeof s === "string" ? s : s.content || s.description || s.name || ""
          }));
        }
        if (opportunities.length === 0) {
          const swotInsights = insights.insights.filter(
            (i) => i.source?.includes("SWOT") || i.source?.includes("swot") || i.type === "benefit" && i.source?.includes("opportunity")
          );
          opportunities = swotInsights.filter((i) => i.source?.includes("opportunity") || i.source?.includes("Opportunities")).map((i) => ({
            name: i.content.split("\n")[0]?.substring(0, 60),
            description: i.content,
            content: i.content
          }));
          strengths = swotInsights.filter((i) => i.source?.includes("strength") || i.source?.includes("Strengths")).map((i) => ({ content: i.content }));
        }
        if (opportunities.length === 0) {
          opportunities = insights.marketContext?.swot?.opportunities || [];
        }
        const swotData = { opportunities, strengths };
        console.log(`[EPM Synthesis] Extracted strategic context:`);
        console.log(`  - Decisions with selections: ${decisions.filter((d) => d.selectedOptionId).length}`);
        console.log(`  - SWOT opportunities: ${swotData.opportunities.length}`);
        console.log(`  - SWOT strengths: ${swotData.strengths.length}`);
        console.log(`  - Source: ${journeyBuilderSwot ? "Journey Builder (frameworkInsights)" : "Legacy (insights/marketContext)"}`);
        return { decisions, swotData };
      }
      /**
       * Assign default timings to workstreams when intelligent planning fails
       * Uses business scale and workstream count to create COMPACT durations (not enterprise-sized)
       */
      assignDefaultTimings(workstreams2, planningContext) {
        const scale = planningContext.business.scale || "mid_market";
        const baseDurationMonths = scale === "smb" ? 1 : scale === "mid_market" ? 2 : 3;
        const overlapFactor = 0.5;
        const byId = new Map(workstreams2.map((ws2) => [ws2.id, ws2]));
        const inDegree = /* @__PURE__ */ new Map();
        const dependents = /* @__PURE__ */ new Map();
        const validDepsById = /* @__PURE__ */ new Map();
        for (const ws2 of workstreams2) {
          inDegree.set(ws2.id, 0);
          dependents.set(ws2.id, []);
          validDepsById.set(ws2.id, []);
        }
        for (const ws2 of workstreams2) {
          const validDeps = (ws2.dependencies || []).filter((depId) => byId.has(depId));
          validDepsById.set(ws2.id, validDeps);
          for (const depId of validDeps) {
            inDegree.set(ws2.id, (inDegree.get(ws2.id) || 0) + 1);
            dependents.get(depId)?.push(ws2.id);
          }
        }
        const queue = workstreams2.filter((ws2) => (inDegree.get(ws2.id) || 0) === 0).map((ws2) => ws2.id);
        const topo = [];
        while (queue.length > 0) {
          const id = queue.shift();
          topo.push(id);
          for (const dependentId of dependents.get(id) || []) {
            const nextDegree = (inDegree.get(dependentId) || 0) - 1;
            inDegree.set(dependentId, nextDegree);
            if (nextDegree === 0) queue.push(dependentId);
          }
        }
        const orderedIds = topo.length === workstreams2.length ? topo : workstreams2.map((ws2) => ws2.id);
        const endMonthById = /* @__PURE__ */ new Map();
        const timedById = /* @__PURE__ */ new Map();
        let independentCursor = 0;
        for (const id of orderedIds) {
          const ws2 = byId.get(id);
          const deps = validDepsById.get(id) || [];
          const complexityLift = Math.floor((ws2.deliverables?.length || 0) / 4);
          const durationMonths = Math.max(1, baseDurationMonths + complexityLift);
          let startMonth;
          if (deps.length > 0) {
            const depEndMonths = deps.map((depId) => endMonthById.get(depId)).filter((month) => month !== void 0);
            const maxDepEnd = depEndMonths.length > 0 ? Math.max(...depEndMonths) : 0;
            startMonth = maxDepEnd + 1;
          } else {
            startMonth = Math.floor(independentCursor * baseDurationMonths * overlapFactor);
            independentCursor += 1;
          }
          const endMonth = startMonth + durationMonths - 1;
          console.log(`[EPM Synthesis]   ${ws2.name}: M${startMonth}-M${endMonth} (${durationMonths}mo)`);
          const timed = {
            ...ws2,
            startMonth,
            endMonth,
            deliverables: (ws2.deliverables || []).map((d) => ({
              ...d,
              dueMonth: endMonth
              // Deliverables due at end of workstream
            }))
          };
          timedById.set(id, timed);
          endMonthById.set(id, endMonth);
        }
        const timedWorkstreams = workstreams2.map((ws2) => timedById.get(ws2.id) || ws2);
        const maxEndMonth = timedWorkstreams.length > 0 ? Math.max(...timedWorkstreams.map((ws2) => ws2.endMonth)) : 0;
        console.log(
          `[EPM Synthesis] \u{1F4C5} Assigned dependency-aware default timings: Scale=${scale}, workstreams=${workstreams2.length}, total=${maxEndMonth + 1}mo`
        );
        return timedWorkstreams;
      }
      /**
       * Build full EPM program with all 14 components
       */
      async buildFullProgram(insights, workstreams2, planningContext, userContext, namingContext, strategicContext, onProgress, startTime) {
        const processStartTime = startTime || Date.now();
        onProgress?.({
          type: "step-start",
          step: "program-name",
          description: "Generating program name",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const programName = await this.programNameGenerator.generate(insights, userContext, namingContext);
        console.log(`[EPM Synthesis] Program name: "${programName}"`);
        onProgress?.({
          type: "step-start",
          step: "timeline",
          description: "Calculating timeline and phases",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const timeline = await this.timelineCalculator.calculate(insights, workstreams2, userContext);
        console.log(`[EPM Synthesis] \u2713 Timeline: ${timeline.totalMonths} months, ${timeline.phases.length} phases`);
        onProgress?.({
          type: "step-start",
          step: "resources",
          description: "Generating resource plan",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const initiativeType = planningContext.business.initiativeType;
        const strategyContext = ContextBuilder.toStrategyContext(
          planningContext,
          userContext?.sessionId || "unknown",
          "strategy_workspace"
        );
        console.log(`[EPM Synthesis] \u2713 Strategy context: ${strategyContext.businessType.category}/${strategyContext.businessType.subcategory || "default"}`);
        const resourcePlan = await this.resourceAllocator.allocate(
          insights,
          workstreams2,
          userContext,
          initiativeType,
          strategyContext
          // Pass strategy context for context-aware role selection
        );
        console.log(`[EPM Synthesis] \u2713 Resources: ${resourcePlan.totalFTEs} FTEs, ${resourcePlan.internalTeam.length} roles`);
        const ownerInferenceContext = {
          industry: planningContext.business.industry || "general",
          businessType: strategyContext?.businessType?.subcategory || strategyContext?.businessType?.category || "general_business",
          geography: "unspecified",
          // TODO: Extract from strategic understanding
          initiativeType: planningContext.business.initiativeType || "market_entry",
          programName
        };
        const roleValidationWarnings = await this.assignWorkstreamOwners(workstreams2, resourcePlan, ownerInferenceContext);
        console.log(`[EPM Synthesis] \u2713 Workstream owners assigned via LLM inference`);
        onProgress?.({
          type: "step-start",
          step: "components",
          description: "Generating EPM components",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const [
          executiveSummary,
          riskRegisterRaw,
          stakeholderMap,
          qaPlan
        ] = await Promise.all([
          this.executiveSummaryGenerator.generate(insights, programName),
          this.riskGenerator.generate(insights),
          this.stakeholderGenerator.generate(insights),
          this.qaPlanGenerator.generate(insights)
        ]);
        const risksWithOwners = this.riskGenerator.assignRiskOwners(
          riskRegisterRaw.risks,
          resourcePlan.internalTeam
        );
        const riskRegister = {
          ...riskRegisterRaw,
          risks: risksWithOwners,
          topRisks: risksWithOwners.slice().sort((a, b) => b.severity - a.severity).slice(0, 5)
        };
        console.log("[EPM Synthesis] \u2713 Assigned risk owners (buildV2Program):", risksWithOwners.map((r) => ({ id: r.id, owner: r.owner })));
        const stageGates2 = await this.stageGateGenerator.generate(timeline, riskRegister);
        onProgress?.({
          type: "step-start",
          step: "validation",
          description: "Validating EPM data",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        const businessContext = insights.marketContext?.industry || "";
        const validationResult = this.validator.validate(workstreams2, timeline, stageGates2, businessContext);
        if (validationResult.errors.length > 0) {
          console.log(`[EPM Synthesis] \u26A0\uFE0F Validation found ${validationResult.errors.length} errors, auto-corrected`);
          validationResult.corrections.forEach((c) => console.log(`    - ${c}`));
        }
        if (validationResult.warnings.length > 0) {
          console.log(`[EPM Synthesis] \u26A0\uFE0F Validation warnings: ${validationResult.warnings.length}`);
          validationResult.warnings.forEach((w) => console.log(`    - ${w}`));
        }
        const planningGrid = this.validator.analyzePlanningGrid(workstreams2, timeline);
        if (planningGrid.conflicts.length > 0) {
          console.log(`[EPM Synthesis] \u26A0\uFE0F Planning grid conflicts: ${planningGrid.conflicts.length}`);
        }
        onProgress?.({
          type: "step-start",
          step: "financial",
          description: "Generating financial and benefit plans",
          elapsedSeconds: Math.round((Date.now() - processStartTime) / 1e3)
        });
        let benefitsRealization;
        const hasStrategicDecisions = strategicContext?.decisions?.some((d) => d.selectedOptionId);
        if (hasStrategicDecisions) {
          console.log("[EPM Synthesis] \u{1F3AF} Using generateFromContext (decisions + SWOT) for benefits");
          benefitsRealization = this.benefitsGenerator.generateFromContext(
            strategicContext.decisions,
            strategicContext.swotData,
            workstreams2,
            resourcePlan.internalTeam,
            timeline.totalMonths
          );
          console.log("[EPM Synthesis] \u2713 Generated benefits from strategic context:", benefitsRealization.benefits.map((b) => ({
            name: b.name,
            owner: b.responsibleParty,
            category: b.category
          })));
        } else {
          console.log("[EPM Synthesis] \u26A0\uFE0F No strategic decisions found, falling back to insight-based generation");
          const benefitsRealizationRaw = await this.benefitsGenerator.generate(insights, timeline);
          const benefitsWithOwners = await this.benefitsGenerator.enhanceBenefitsWithAI(
            benefitsRealizationRaw.benefits,
            resourcePlan.internalTeam,
            { name: programName, description: planningContext.business.description }
          );
          benefitsRealization = {
            ...benefitsRealizationRaw,
            benefits: benefitsWithOwners
          };
          console.log("[EPM Synthesis] \u2713 Enhanced benefits with AI (fallback):", benefitsWithOwners.map((b) => ({ name: b.name, owner: b.responsibleParty })));
        }
        const [
          financialPlan,
          governance
        ] = await Promise.all([
          this.financialPlanGenerator.generate(insights, resourcePlan, userContext),
          this.governanceGenerator.generate(insights, stakeholderMap)
        ]);
        const [
          kpis2,
          procurement,
          exitStrategy
        ] = await Promise.all([
          this.kpiGenerator.generate(insights, benefitsRealization),
          this.procurementGenerator.generate(insights, financialPlan),
          this.exitStrategyGenerator.generate(insights, riskRegister)
        ]);
        const validationReport = this.buildValidationReport(
          workstreams2,
          timeline,
          stageGates2,
          validationResult,
          planningGrid,
          roleValidationWarnings
        );
        const confidences = [
          executiveSummary.confidence,
          resourcePlan.confidence,
          financialPlan.confidence,
          benefitsRealization.confidence,
          riskRegister.confidence,
          stageGates2.confidence,
          kpis2.confidence,
          stakeholderMap.confidence,
          governance.confidence,
          qaPlan.confidence,
          procurement.confidence,
          exitStrategy.confidence
        ];
        const overallConfidence = this.calculateOverallConfidence(confidences);
        const program = {
          id: `EPM-${Date.now()}`,
          generatedAt: /* @__PURE__ */ new Date(),
          sourceFramework: insights.frameworkType,
          sourceInsightsCount: insights.insights.length,
          overallConfidence,
          validationReport,
          executiveSummary,
          workstreams: workstreams2,
          timeline,
          resourcePlan,
          financialPlan,
          benefitsRealization,
          riskRegister,
          stageGates: stageGates2,
          kpis: kpis2,
          stakeholderMap,
          governance,
          qaPlan,
          procurement,
          exitStrategy,
          extractionRationale: this.generateExtractionRationale(insights, userContext)
        };
        console.log("[EPM Synthesis] \u2713 Program built successfully");
        console.log(`[EPM Synthesis]   Overall confidence: ${(overallConfidence * 100).toFixed(1)}%`);
        return program;
      }
      /**
       * Fallback: Build EPM using old system (legacy path)
       */
      async buildWithOldSystem(insights, userContext, namingContext) {
        console.log("[EPM Synthesis] Using legacy synthesis path");
        const programName = await this.programNameGenerator.generate(insights, userContext, namingContext);
        const workstreamInsights = insights.insights.filter((i) => i.type === "workstream");
        const workstreams2 = workstreamInsights.map((insight, index2) => {
          const deliverables = this.workstreamGenerator.generateDeliverables(insight, index2);
          return {
            id: `WS${String(index2 + 1).padStart(3, "0")}`,
            name: insight.content.split("\n")[0] || `Workstream ${index2 + 1}`,
            description: insight.content,
            deliverables,
            startMonth: Math.floor(index2 / 2) + 1,
            endMonth: Math.min(Math.floor(index2 / 2) + 1 + deliverables.length, 12),
            dependencies: index2 > 0 ? [`WS${String(index2).padStart(3, "0")}`] : [],
            confidence: insight.confidence
          };
        });
        if (workstreams2.length < 3) {
          workstreams2.push(...this.workstreamGenerator.generateDefaultWorkstreams(3 - workstreams2.length));
        }
        const timeline = await this.timelineCalculator.calculate(insights, workstreams2, userContext);
        const resourcePlan = await this.resourceAllocator.allocate(insights, workstreams2, userContext);
        const [
          executiveSummary,
          riskRegisterRaw2,
          stakeholderMap,
          qaPlan
        ] = await Promise.all([
          this.executiveSummaryGenerator.generate(insights, programName),
          this.riskGenerator.generate(insights),
          this.stakeholderGenerator.generate(insights),
          this.qaPlanGenerator.generate(insights)
        ]);
        const risksWithOwners2 = this.riskGenerator.assignRiskOwners(
          riskRegisterRaw2.risks,
          resourcePlan.internalTeam
        );
        const riskRegister = {
          ...riskRegisterRaw2,
          risks: risksWithOwners2,
          topRisks: risksWithOwners2.slice().sort((a, b) => b.severity - a.severity).slice(0, 5)
        };
        console.log("[EPM Synthesis] \u2713 Assigned risk owners (legacy):", risksWithOwners2.map((r) => ({ id: r.id, owner: r.owner })));
        const stageGates2 = await this.stageGateGenerator.generate(timeline, riskRegister);
        const businessContext = insights.marketContext?.industry || "";
        const validationResult = this.validator.validate(workstreams2, timeline, stageGates2, businessContext);
        const planningGrid = this.validator.analyzePlanningGrid(workstreams2, timeline);
        if (validationResult.warnings.length > 0) {
          console.log(`[EPM Synthesis] \u26A0\uFE0F Validation warnings: ${validationResult.warnings.length}`);
          validationResult.warnings.forEach((w) => console.log(`    - ${w}`));
        }
        const [
          financialPlan,
          benefitsRealizationRaw2,
          governance
        ] = await Promise.all([
          this.financialPlanGenerator.generate(insights, resourcePlan, userContext),
          this.benefitsGenerator.generate(insights, timeline),
          this.governanceGenerator.generate(insights, stakeholderMap)
        ]);
        const benefitsWithOwners2 = await this.benefitsGenerator.enhanceBenefitsWithAI(
          benefitsRealizationRaw2.benefits,
          resourcePlan.internalTeam,
          { name: programName }
        );
        const benefitsRealization = {
          ...benefitsRealizationRaw2,
          benefits: benefitsWithOwners2
        };
        console.log("[EPM Synthesis] \u2713 Enhanced benefits with AI (legacy):", benefitsWithOwners2.map((b) => ({ name: b.name, owner: b.responsibleParty })));
        const [
          kpis2,
          procurement,
          exitStrategy
        ] = await Promise.all([
          this.kpiGenerator.generate(insights, benefitsRealization),
          this.procurementGenerator.generate(insights, financialPlan),
          this.exitStrategyGenerator.generate(insights, riskRegister)
        ]);
        const validationReport = this.buildValidationReport(
          workstreams2,
          timeline,
          stageGates2,
          validationResult,
          planningGrid
        );
        const confidences = [
          executiveSummary.confidence,
          resourcePlan.confidence,
          financialPlan.confidence,
          benefitsRealization.confidence,
          riskRegister.confidence,
          stageGates2.confidence,
          kpis2.confidence,
          stakeholderMap.confidence,
          governance.confidence,
          qaPlan.confidence,
          procurement.confidence,
          exitStrategy.confidence
        ];
        const overallConfidence = this.calculateOverallConfidence(confidences);
        return {
          id: `EPM-${Date.now()}`,
          generatedAt: /* @__PURE__ */ new Date(),
          sourceFramework: insights.frameworkType,
          sourceInsightsCount: insights.insights.length,
          overallConfidence,
          validationReport,
          executiveSummary,
          workstreams: workstreams2,
          timeline,
          resourcePlan,
          financialPlan,
          benefitsRealization,
          riskRegister,
          stageGates: stageGates2,
          kpis: kpis2,
          stakeholderMap,
          governance,
          qaPlan,
          procurement,
          exitStrategy,
          extractionRationale: this.generateExtractionRationale(insights, userContext)
        };
      }
      /**
       * Build validation report from validation results
       */
      buildValidationReport(workstreams2, timeline, stageGates2, validationResult, planningGrid, roleValidationWarnings = []) {
        const allWarnings = [
          ...validationResult.errors,
          ...planningGrid.conflicts,
          ...roleValidationWarnings
        ];
        return {
          isComplete: validationResult.errors.length === 0,
          missingComponents: [],
          warnings: allWarnings,
          corrections: validationResult.corrections,
          completenessScore: 1 - validationResult.errors.length * 0.05,
          planningGrid: {
            conflicts: planningGrid.conflicts,
            maxUtilization: planningGrid.maxUtilization,
            totalTasks: planningGrid.totalTasks
          },
          roleValidation: roleValidationWarnings.length > 0 ? {
            warnings: roleValidationWarnings,
            checked: true
          } : void 0
        };
      }
      /**
       * Assign owners to workstreams using LLM-based role inference
       * Makes a single batch AI call to determine appropriate roles for all workstreams
       * Falls back to heuristics if LLM call fails
       */
      async assignWorkstreamOwners(workstreams2, resourcePlan, businessContext) {
        if (!resourcePlan.internalTeam || resourcePlan.internalTeam.length === 0) {
          workstreams2.forEach((ws2) => {
            ws2.owner = "Program Manager";
          });
          return ["[Role Validation] No internal team defined - using default Program Manager for all workstreams"];
        }
        const defaultOwner = resourcePlan.internalTeam.find(
          (r) => r.role.toLowerCase().includes("program") || r.role.toLowerCase().includes("director") || r.role.toLowerCase().includes("manager")
        )?.role || resourcePlan.internalTeam[0]?.role || "Program Manager";
        const maxRoles = Math.min(workstreams2.length, 6);
        console.log(`[EPM Synthesis] \u{1F916} Invoking LLM for workstream owner inference...`);
        const inferenceResult = await this.roleInferenceService.inferOwners(
          businessContext || {},
          workstreams2,
          maxRoles
        );
        console.log(`[EPM Synthesis] Role inference result: cache=${inferenceResult.usedCache}, fallback=${inferenceResult.usedFallback}, validated=${inferenceResult.validationRan}`);
        if (inferenceResult.notes) {
          console.log(`[EPM Synthesis] Notes: ${inferenceResult.notes}`);
        }
        if (inferenceResult.warnings && inferenceResult.warnings.length > 0) {
          console.log(`[EPM Synthesis] \u26A0\uFE0F Validation warnings (${inferenceResult.warnings.length}):`);
          inferenceResult.warnings.forEach((w) => {
            console.log(`  - [${w.severity.toUpperCase()}] ${w.message}`);
            console.log(`    Recommendation: ${w.recommendation}`);
          });
        }
        const ownerMap = /* @__PURE__ */ new Map();
        for (const owner of inferenceResult.owners) {
          ownerMap.set(owner.workstreamId, {
            roleTitle: owner.roleTitle,
            category: owner.category,
            rationale: owner.rationale
          });
        }
        for (const ws2 of workstreams2) {
          const inferred = ownerMap.get(ws2.id);
          if (inferred) {
            ws2.owner = normalizeRole(inferred.roleTitle);
            ws2.metadata = {
              ...ws2.metadata,
              ownerCategory: inferred.category,
              ownerRationale: inferred.rationale
            };
            ensureResourceExists(inferred.roleTitle, resourcePlan, inferred.category);
            console.log(`[EPM Synthesis]   ${ws2.name} \u2192 ${ws2.owner} (${inferred.category})`);
          } else {
            ws2.owner = defaultOwner;
            console.log(`[EPM Synthesis]   ${ws2.name} \u2192 ${ws2.owner} (default fallback)`);
          }
        }
        const uniqueRoles = new Set(workstreams2.map((ws2) => ws2.owner));
        console.log(`[EPM Synthesis] \u2713 Assigned ${uniqueRoles.size} unique owner roles across ${workstreams2.length} workstreams`);
        return inferenceResult.warnings.map((w) => `[Role Validation] ${w.message} - ${w.recommendation}`);
      }
      /**
       * Calculate overall confidence from component confidences
       */
      calculateOverallConfidence(confidences) {
        const avg = confidences.reduce((sum, c) => sum + c, 0) / confidences.length;
        const variance = confidences.reduce((sum, c) => sum + Math.pow(c - avg, 2), 0) / confidences.length;
        return Math.max(0.5, avg - variance * 0.1);
      }
      /**
       * Generate extraction rationale for audit trail
       */
      generateExtractionRationale(insights, userContext) {
        const framework = insights.frameworkType.toUpperCase();
        const insightCount = insights.insights.length;
        return `
EPM Program generated from ${framework} framework analysis with ${insightCount} strategic insights.

EXTRACTION APPROACH:
- ${insights.insights.filter((i) => i.type === "workstream").length} workstreams extracted from framework activities/recommendations
- ${insights.insights.filter((i) => i.type === "risk").length} risks identified from framework analysis and contradictions
- ${insights.insights.filter((i) => i.type === "benefit").length} benefits mapped from strategic opportunities
- ${insights.insights.filter((i) => i.type === "stakeholder").length} stakeholders identified from framework segments
- Timeline inferred based on ${insights.marketContext?.urgency || "standard"} urgency
- Resource and financial plans estimated using industry benchmarks
- All 14 EPM components synthesized using documented ${framework}\u2192EPM mappings

USER CONTEXT:
${userContext ? `
- Timeline urgency: ${insights.marketContext?.urgency || "standard"}
- Budget range: ${userContext.budgetRange ? `$${userContext.budgetRange.min.toLocaleString()} - $${userContext.budgetRange.max.toLocaleString()}` : "Not specified"}
- Risk tolerance: ${userContext.riskTolerance || "Not specified"}
` : "No additional user context provided"}

CONFIDENCE ASSESSMENT:
Average confidence across components: ${Math.round((insights.overallConfidence || 0.75) * 100)}%
Confidence varies by component based on directness of extraction vs. AI inference.
`.trim();
      }
    };
  }
});

// server/services/sse-progress-manager.ts
var SSEProgressManager, sseProgressManager;
var init_sse_progress_manager = __esm({
  "server/services/sse-progress-manager.ts"() {
    "use strict";
    SSEProgressManager = class {
      streams = /* @__PURE__ */ new Map();
      cleanupInterval = null;
      constructor() {
        this.startCleanup();
      }
      startCleanup() {
        this.cleanupInterval = setInterval(() => {
          const now = Date.now();
          const staleThreshold = 30 * 60 * 1e3;
          const entries = Array.from(this.streams.entries());
          for (let i = 0; i < entries.length; i++) {
            const [id, stream] = entries[i];
            if (now - stream.createdAt.getTime() > staleThreshold) {
              console.log(`[SSEProgressManager] Cleaning up stale stream: ${id}`);
              this.unregister(id);
            }
          }
        }, 5 * 60 * 1e3);
      }
      register(progressId, res) {
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        this.streams.set(progressId, {
          res,
          lastEventId: 0,
          createdAt: /* @__PURE__ */ new Date()
        });
        res.on("close", () => {
          this.streams.delete(progressId);
        });
        console.log(`[SSEProgressManager] Registered stream: ${progressId}`);
      }
      unregister(progressId) {
        const stream = this.streams.get(progressId);
        if (stream) {
          try {
            stream.res.end();
          } catch {
          }
          this.streams.delete(progressId);
        }
      }
      send(progressId, event) {
        const stream = this.streams.get(progressId);
        if (!stream) {
          return false;
        }
        try {
          stream.lastEventId++;
          const eventData = JSON.stringify({
            ...event,
            timestamp: event.timestamp || (/* @__PURE__ */ new Date()).toISOString()
          });
          stream.res.write(`id: ${stream.lastEventId}
`);
          stream.res.write(`event: ${event.type}
`);
          stream.res.write(`data: ${eventData}

`);
          return true;
        } catch (error) {
          console.error(`[SSEProgressManager] Error sending event to ${progressId}:`, error);
          this.unregister(progressId);
          return false;
        }
      }
      sendProgress(progressId, step, progress, message) {
        return this.send(progressId, {
          type: "progress",
          data: { step, progress, message }
        });
      }
      sendStepStart(progressId, step, description) {
        return this.send(progressId, {
          type: "step-start",
          data: { step, description }
        });
      }
      sendStepComplete(progressId, step, result) {
        return this.send(progressId, {
          type: "step-complete",
          data: { step, result }
        });
      }
      sendError(progressId, error, details) {
        return this.send(progressId, {
          type: "error",
          data: { error, details }
        });
      }
      sendComplete(progressId, result) {
        const sent = this.send(progressId, {
          type: "complete",
          data: { result }
        });
        setTimeout(() => {
          this.unregister(progressId);
        }, 1e3);
        return sent;
      }
      hasStream(progressId) {
        return this.streams.has(progressId);
      }
      getActiveStreams() {
        return Array.from(this.streams.keys());
      }
      destroy() {
        if (this.cleanupInterval) {
          clearInterval(this.cleanupInterval);
        }
        const keys = Array.from(this.streams.keys());
        for (let i = 0; i < keys.length; i++) {
          this.unregister(keys[i]);
        }
      }
    };
    sseProgressManager = new SSEProgressManager();
  }
});

// server/repositories/base-repository.ts
import { eq as eq13, inArray as inArray3 } from "drizzle-orm";
var BaseRepository;
var init_base_repository = __esm({
  "server/repositories/base-repository.ts"() {
    "use strict";
    init_db();
    BaseRepository = class {
      db = db;
      async findById(id) {
        const results = await this.db.select().from(this.table).where(eq13(this.idColumn, id)).limit(1);
        return results[0] || null;
      }
      async findAll(options = {}) {
        const { limit = 100, offset = 0 } = options;
        return this.db.select().from(this.table).limit(limit).offset(offset);
      }
      async findByIds(ids) {
        if (!ids.length) return [];
        return this.db.select().from(this.table).where(inArray3(this.idColumn, ids));
      }
      async create(data) {
        const results = await this.db.insert(this.table).values(data).returning();
        return results[0];
      }
      async update(id, data) {
        const results = await this.db.update(this.table).set(data).where(eq13(this.idColumn, id)).returning();
        return results[0] || null;
      }
      async delete(id) {
        const results = await this.db.delete(this.table).where(eq13(this.idColumn, id)).returning();
        return results.length > 0;
      }
      async exists(id) {
        const result = await this.findById(id);
        return result !== null;
      }
      async count(where) {
        const results = where ? await this.db.select().from(this.table).where(where) : await this.db.select().from(this.table);
        return results.length;
      }
    };
  }
});

// server/repositories/epm-repository.ts
import { eq as eq14, and as and11, desc as desc8 } from "drizzle-orm";
var EPMRepository;
var init_epm_repository = __esm({
  "server/repositories/epm-repository.ts"() {
    "use strict";
    init_base_repository();
    init_schema();
    EPMRepository = class extends BaseRepository {
      table = epmPrograms;
      idColumn = epmPrograms.id;
      async findByStrategyVersionId(strategyVersionId) {
        const results = await this.db.select().from(this.table).where(eq14(epmPrograms.strategyVersionId, strategyVersionId)).limit(1);
        return results[0] || null;
      }
      async findByUserId(userId, options = {}) {
        const conditions = options.includeArchived ? eq14(epmPrograms.userId, userId) : and11(eq14(epmPrograms.userId, userId), eq14(epmPrograms.archived, false));
        return this.db.select().from(this.table).where(conditions).orderBy(desc8(epmPrograms.createdAt));
      }
      async updateStatus(id, status) {
        const updateData = {
          status,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (status === "finalized") {
          updateData.finalizedAt = /* @__PURE__ */ new Date();
        }
        return this.update(id, updateData);
      }
      async archive(id) {
        return this.update(id, {
          archived: true,
          status: "archived",
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      async createTaskAssignment(data) {
        const results = await this.db.insert(taskAssignments).values(data).returning();
        return results[0];
      }
      async createTaskAssignments(data) {
        if (!data.length) return [];
        return this.db.insert(taskAssignments).values(data).returning();
      }
      async findTaskAssignmentsByProgramId(programId) {
        return this.db.select().from(taskAssignments).where(eq14(taskAssignments.epmProgramId, programId));
      }
      async deleteTaskAssignmentsByProgramId(programId) {
        const results = await this.db.delete(taskAssignments).where(eq14(taskAssignments.epmProgramId, programId)).returning();
        return results.length;
      }
    };
  }
});

// server/repositories/journey-repository.ts
import { eq as eq15, desc as desc9, max } from "drizzle-orm";
var JourneyRepository;
var init_journey_repository = __esm({
  "server/repositories/journey-repository.ts"() {
    "use strict";
    init_base_repository();
    init_schema();
    JourneyRepository = class extends BaseRepository {
      table = journeySessions;
      idColumn = journeySessions.id;
      async findByUnderstandingId(understandingId) {
        return this.db.select().from(this.table).where(eq15(journeySessions.understandingId, understandingId)).orderBy(desc9(journeySessions.versionNumber));
      }
      async findLatestByUnderstandingId(understandingId) {
        const results = await this.db.select().from(this.table).where(eq15(journeySessions.understandingId, understandingId)).orderBy(desc9(journeySessions.versionNumber)).limit(1);
        return results[0] || null;
      }
      async findByUserId(userId) {
        return this.db.select().from(this.table).where(eq15(journeySessions.userId, userId)).orderBy(desc9(journeySessions.createdAt));
      }
      async updateStatus(id, status) {
        const updateData = {
          status,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (status === "completed") {
          updateData.completedAt = /* @__PURE__ */ new Date();
        }
        return this.update(id, updateData);
      }
      async updateProgress(id, currentFrameworkIndex, completedFrameworks) {
        return this.update(id, {
          currentFrameworkIndex,
          completedFrameworks,
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      async getNextVersionNumber(understandingId) {
        const result = await this.db.select({ maxVersion: max(journeySessions.versionNumber) }).from(this.table).where(eq15(journeySessions.understandingId, understandingId));
        return (result[0]?.maxVersion || 0) + 1;
      }
      async findUnderstandingById(id) {
        const results = await this.db.select().from(strategicUnderstanding).where(eq15(strategicUnderstanding.id, id)).limit(1);
        return results[0] || null;
      }
      async findUnderstandingBySessionId(sessionId) {
        const results = await this.db.select().from(strategicUnderstanding).where(eq15(strategicUnderstanding.sessionId, sessionId)).limit(1);
        return results[0] || null;
      }
      async createUnderstanding(data) {
        const results = await this.db.insert(strategicUnderstanding).values(data).returning();
        return results[0];
      }
      async updateUnderstanding(id, data) {
        const results = await this.db.update(strategicUnderstanding).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq15(strategicUnderstanding.id, id)).returning();
        return results[0] || null;
      }
    };
  }
});

// server/repositories/strategy-repository.ts
import { eq as eq16, and as and13, desc as desc10, max as max2 } from "drizzle-orm";
var StrategyRepository;
var init_strategy_repository = __esm({
  "server/repositories/strategy-repository.ts"() {
    "use strict";
    init_base_repository();
    init_schema();
    StrategyRepository = class extends BaseRepository {
      table = strategyVersions;
      idColumn = strategyVersions.id;
      async findByUserId(userId, options = {}) {
        const conditions = options.includeArchived ? eq16(strategyVersions.userId, userId) : and13(eq16(strategyVersions.userId, userId), eq16(strategyVersions.archived, false));
        return this.db.select().from(this.table).where(conditions).orderBy(desc10(strategyVersions.createdAt));
      }
      async findBySessionId(sessionId) {
        return this.db.select().from(this.table).where(eq16(strategyVersions.sessionId, sessionId)).orderBy(desc10(strategyVersions.versionNumber));
      }
      async findLatestBySessionId(sessionId) {
        const results = await this.db.select().from(this.table).where(eq16(strategyVersions.sessionId, sessionId)).orderBy(desc10(strategyVersions.versionNumber)).limit(1);
        return results[0] || null;
      }
      async getNextVersionNumber(sessionId) {
        const result = await this.db.select({ maxVersion: max2(strategyVersions.versionNumber) }).from(this.table).where(eq16(strategyVersions.sessionId, sessionId));
        return (result[0]?.maxVersion || 0) + 1;
      }
      async updateStatus(id, status) {
        const updateData = {
          status,
          updatedAt: /* @__PURE__ */ new Date()
        };
        if (status === "finalized") {
          updateData.finalizedAt = /* @__PURE__ */ new Date();
        }
        return this.update(id, updateData);
      }
      async archive(id) {
        return this.update(id, {
          archived: true,
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      async linkToProgram(id, programId) {
        return this.update(id, {
          convertedProgramId: programId,
          updatedAt: /* @__PURE__ */ new Date()
        });
      }
      async findDecisionByVersionId(versionId) {
        const results = await this.db.select().from(strategyDecisions).where(eq16(strategyDecisions.strategyVersionId, versionId)).limit(1);
        return results[0] || null;
      }
      async findDecisionsByUserId(userId) {
        return this.db.select().from(strategyDecisions).where(eq16(strategyDecisions.userId, userId)).orderBy(desc10(strategyDecisions.createdAt));
      }
      async createDecision(data) {
        const results = await this.db.insert(strategyDecisions).values(data).returning();
        return results[0];
      }
      async updateDecision(id, data) {
        const results = await this.db.update(strategyDecisions).set({ ...data, updatedAt: /* @__PURE__ */ new Date() }).where(eq16(strategyDecisions.id, id)).returning();
        return results[0] || null;
      }
    };
  }
});

// server/repositories/index.ts
var init_repositories = __esm({
  "server/repositories/index.ts"() {
    "use strict";
    init_base_repository();
    init_epm_repository();
    init_journey_repository();
    init_strategy_repository();
  }
});

// server/services/container.ts
function createLLMProvider() {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    console.warn("[Container] No OPENAI_API_KEY - WBS Builder will use fallback mode");
    return null;
  }
  return createOpenAIProvider({ apiKey, model: "gpt-5" });
}
function registerServices() {
  container.register(ServiceKeys.EXPORT_ORCHESTRATOR, () => {
    return { generateFullPassExport };
  });
  container.register(ServiceKeys.MARKDOWN_EXPORTER, () => {
    return new MarkdownExporter();
  });
  container.register(ServiceKeys.HTML_EXPORTER, () => {
    return new HtmlExporter();
  });
  container.register(ServiceKeys.PDF_EXPORTER, () => {
    return new PdfExporter();
  });
  container.register(ServiceKeys.DOCX_EXPORTER, () => {
    return new DocxExporter();
  });
  container.register(ServiceKeys.CSV_EXPORTER, () => {
    return new CsvExporter();
  });
  container.register(ServiceKeys.EPM_SYNTHESIZER, () => {
    const llm2 = createLLMProvider();
    return new EPMSynthesizer(llm2);
  });
  container.register(ServiceKeys.CONTEXT_BUILDER, () => {
    return ContextBuilder;
  });
  container.register(ServiceKeys.WORKSTREAM_GENERATOR, () => {
    const llm2 = createLLMProvider();
    return new WorkstreamGenerator(llm2);
  });
  container.register(ServiceKeys.TIMELINE_CALCULATOR, () => {
    return new TimelineCalculator();
  });
  container.register(ServiceKeys.RESOURCE_ALLOCATOR, () => {
    return new ResourceAllocator();
  });
  container.register(ServiceKeys.EPM_VALIDATOR, () => {
    return new EPMValidator();
  });
  container.register(ServiceKeys.SSE_PROGRESS_MANAGER, () => {
    return sseProgressManager;
  });
  container.register(ServiceKeys.EPM_REPOSITORY, () => {
    return new EPMRepository();
  });
  container.register(ServiceKeys.JOURNEY_REPOSITORY, () => {
    return new JourneyRepository();
  });
  container.register(ServiceKeys.STRATEGY_REPOSITORY, () => {
    return new StrategyRepository();
  });
  console.log("[Container] \u2713 Services and repositories registered");
}
function getService(key) {
  return container.resolve(key);
}
var ServiceContainer, container;
var init_container = __esm({
  "server/services/container.ts"() {
    "use strict";
    init_interfaces();
    init_llm_provider();
    init_export();
    init_markdown_exporter();
    init_html_exporter();
    init_pdf_exporter();
    init_docx_exporter();
    init_csv_exporter();
    init_epm_synthesizer();
    init_context_builder();
    init_workstream_generator();
    init_timeline_calculator();
    init_resource_allocator();
    init_validator2();
    init_sse_progress_manager();
    init_repositories();
    ServiceContainer = class {
      services = /* @__PURE__ */ new Map();
      factories = /* @__PURE__ */ new Map();
      register(name, factory) {
        this.factories.set(name, factory);
      }
      registerInstance(name, instance) {
        this.services.set(name, instance);
      }
      resolve(name) {
        if (this.services.has(name)) {
          return this.services.get(name);
        }
        const factory = this.factories.get(name);
        if (!factory) {
          throw new Error(`Service '${name}' not registered`);
        }
        const instance = factory();
        this.services.set(name, instance);
        return instance;
      }
      has(name) {
        return this.services.has(name) || this.factories.has(name);
      }
      clear() {
        this.services.clear();
      }
    };
    container = new ServiceContainer();
  }
});

// server/modules/manifests/bmc-analyzer.ts
var bmcAnalyzerManifest;
var init_bmc_analyzer = __esm({
  "server/modules/manifests/bmc-analyzer.ts"() {
    "use strict";
    bmcAnalyzerManifest = {
      id: "bmc-analyzer",
      name: "Business Model Canvas Analyzer",
      version: "1.0.0",
      description: "Analyzes business model using the 9-block BMC framework with research-backed insights, cross-block consistency validation, and contradiction detection.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "analysis",
      icon: "layout-grid",
      status: "implemented",
      inputs: [
        {
          id: "strategic_context",
          name: "strategicContext",
          type: "StrategicContext",
          required: true,
          description: "The accumulated strategic context including user input and previous framework results"
        },
        {
          id: "design_constraints",
          name: "designConstraints",
          type: "BMCDesignConstraints",
          required: false,
          description: "Optional constraints from Five Whys analysis to guide BMC block design"
        }
      ],
      outputs: [
        {
          id: "bmc_results",
          name: "bmcResults",
          type: "BMCResults",
          required: true,
          description: "Complete 9-block BMC analysis with scores, research, and recommendations"
        },
        {
          id: "contradictions",
          name: "contradictions",
          type: "Contradiction[]",
          required: false,
          description: "Detected contradictions between BMC blocks"
        },
        {
          id: "strategy_insights",
          name: "strategyInsights",
          type: "StrategyInsights",
          required: true,
          description: "Extracted EPM-mappable insights from BMC analysis"
        }
      ],
      requires: [],
      serviceClass: "BMCAnalyzer",
      uiComponent: "BMCResearchPage",
      tags: ["strategic-analysis", "business-model", "bmc"],
      estimatedDuration: 8,
      isActive: true
    };
  }
});

// server/modules/manifests/porters-analyzer.ts
var portersAnalyzerManifest;
var init_porters_analyzer2 = __esm({
  "server/modules/manifests/porters-analyzer.ts"() {
    "use strict";
    portersAnalyzerManifest = {
      id: "porters-analyzer",
      name: "Porter's Five Forces Analyzer",
      version: "1.0.0",
      description: "Analyzes competitive dynamics using Porter's Five Forces framework to identify threats, opportunities, and strategic positioning requirements.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "analysis",
      icon: "shield",
      status: "implemented",
      inputs: [
        {
          id: "strategic_context",
          name: "strategicContext",
          type: "StrategicContext",
          required: true,
          description: "The accumulated strategic context including user input and market information"
        },
        {
          id: "industry_context",
          name: "industryContext",
          type: "IndustryContext",
          required: false,
          description: "Optional industry-specific context to enhance competitive analysis"
        }
      ],
      outputs: [
        {
          id: "porters_results",
          name: "portersResults",
          type: "PortersResults",
          required: true,
          description: "Complete Five Forces analysis with scores, drivers, and strategic implications"
        },
        {
          id: "competitive_pressures",
          name: "competitivePressures",
          type: "CompetitivePressure[]",
          required: true,
          description: "Identified competitive pressures requiring strategic response"
        },
        {
          id: "strategy_insights",
          name: "strategyInsights",
          type: "StrategyInsights",
          required: true,
          description: "Extracted EPM-mappable insights from competitive analysis"
        }
      ],
      requires: [],
      serviceClass: "PortersAnalyzer",
      uiComponent: "PortersAnalysisPage",
      tags: ["strategic-analysis", "competitive-analysis", "porters"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/pestle-analyzer.ts
var pestleAnalyzerManifest;
var init_pestle_analyzer2 = __esm({
  "server/modules/manifests/pestle-analyzer.ts"() {
    "use strict";
    pestleAnalyzerManifest = {
      id: "pestle-analyzer",
      name: "PESTLE Trend Analyzer",
      version: "1.0.0",
      description: "Analyzes macro-environmental trends across Political, Economic, Social, Technological, Legal, and Environmental dimensions with evidence-first research.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "analysis",
      icon: "globe",
      status: "implemented",
      inputs: [
        {
          id: "strategic_context",
          name: "strategicContext",
          type: "StrategicContext",
          required: true,
          description: "The accumulated strategic context including business description and industry"
        },
        {
          id: "geographic_scope",
          name: "geographicScope",
          type: "GeographicScope",
          required: false,
          description: "Optional geographic scope to focus trend analysis on specific regions"
        }
      ],
      outputs: [
        {
          id: "pestle_results",
          name: "pestleResults",
          type: "PESTLEResults",
          required: true,
          description: "Complete PESTLE analysis with factors, trends, and impact assessments"
        },
        {
          id: "external_forces",
          name: "externalForces",
          type: "ExternalForce[]",
          required: true,
          description: "Identified external forces impacting strategic options"
        },
        {
          id: "strategy_insights",
          name: "strategyInsights",
          type: "StrategyInsights",
          required: true,
          description: "Extracted EPM-mappable insights from environmental analysis"
        }
      ],
      requires: [],
      serviceClass: "PESTLEAnalyzer",
      uiComponent: "PESTLEAnalysisPage",
      tags: ["strategic-analysis", "macro-environment", "pestle", "trends"],
      estimatedDuration: 6,
      isActive: true
    };
  }
});

// server/modules/manifests/five-whys-analyzer.ts
var fiveWhysAnalyzerManifest;
var init_five_whys_analyzer = __esm({
  "server/modules/manifests/five-whys-analyzer.ts"() {
    "use strict";
    fiveWhysAnalyzerManifest = {
      id: "five-whys-analyzer",
      name: "Five Whys Root Cause Analyzer",
      version: "1.0.0",
      description: "Interactive root cause analysis using the Five Whys technique with AI-coaching to uncover strategic problems and generate design constraints for downstream frameworks.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "analysis",
      icon: "help-circle",
      status: "implemented",
      inputs: [
        {
          id: "strategic_context",
          name: "strategicContext",
          type: "StrategicContext",
          required: true,
          description: "The strategic context including the initial problem statement"
        },
        {
          id: "interactive_mode",
          name: "interactiveMode",
          type: "boolean",
          required: false,
          description: "Whether to run in interactive mode with user input at each level"
        }
      ],
      outputs: [
        {
          id: "five_whys_analysis",
          name: "fiveWhysAnalysis",
          type: "FiveWhysAnalysis",
          required: true,
          description: "Complete Five Whys tree with questions, answers, and root cause"
        },
        {
          id: "root_causes",
          name: "rootCauses",
          type: "string[]",
          required: true,
          description: "Identified root causes from the analysis"
        },
        {
          id: "design_constraints",
          name: "designConstraints",
          type: "BMCDesignConstraints",
          required: true,
          description: "Design constraints to pass to BMC analyzer for guided analysis"
        },
        {
          id: "strategic_implications",
          name: "strategicImplications",
          type: "string[]",
          required: true,
          description: "Strategic implications derived from root cause analysis"
        }
      ],
      requires: [],
      serviceClass: "StrategyAnalyzer",
      uiComponent: "FiveWhysTreePage",
      tags: ["strategic-analysis", "root-cause", "five-whys", "interactive"],
      estimatedDuration: 10,
      isActive: true
    };
  }
});

// server/modules/manifests/epm-generator.ts
var epmGeneratorManifest;
var init_epm_generator = __esm({
  "server/modules/manifests/epm-generator.ts"() {
    "use strict";
    epmGeneratorManifest = {
      id: "epm-generator",
      name: "EPM Program Generator",
      version: "1.0.0",
      description: "Synthesizes strategic framework results into executable Enterprise Program Management structures including workstreams, tasks, resources, risks, and timelines.",
      type: "generator",
      moduleType: "generator",
      category: "execution",
      icon: "calendar",
      status: "implemented",
      inputs: [
        {
          id: "strategic_context",
          name: "strategicContext",
          type: "StrategicContext",
          required: true,
          description: "Complete strategic context with all framework results"
        },
        {
          id: "strategy_insights",
          name: "strategyInsights",
          type: "StrategyInsights[]",
          required: true,
          description: "Aggregated insights from all completed frameworks"
        },
        {
          id: "strategic_decisions",
          name: "strategicDecisions",
          type: "StrategicDecision[]",
          required: true,
          description: "User-prioritized strategic decisions"
        }
      ],
      outputs: [
        {
          id: "epm_program",
          name: "epmProgram",
          type: "EPMProgram",
          required: true,
          description: "Complete EPM program structure ready for execution"
        },
        {
          id: "workstreams",
          name: "workstreams",
          type: "Workstream[]",
          required: true,
          description: "Generated workstreams with tasks and dependencies"
        },
        {
          id: "timeline",
          name: "timeline",
          type: "ProgramTimeline",
          required: true,
          description: "Optimized program timeline with milestones"
        },
        {
          id: "resource_plan",
          name: "resourcePlan",
          type: "ResourcePlan",
          required: true,
          description: "Resource allocation plan across workstreams"
        }
      ],
      requires: ["five-whys-analyzer", "bmc-analyzer"],
      serviceClass: "EPMSynthesizer",
      uiComponent: "EPMProgramView",
      tags: ["generation", "epm", "program-management", "execution"],
      estimatedDuration: 3,
      isActive: true
    };
  }
});

// server/modules/manifests/input-processor.ts
var inputProcessorManifest;
var init_input_processor = __esm({
  "server/modules/manifests/input-processor.ts"() {
    "use strict";
    inputProcessorManifest = {
      id: "input-processor",
      name: "Strategic Input Processor",
      version: "1.0.0",
      description: "Processes user strategic input, performs entity extraction, geographic disambiguation, and creates the initial strategic understanding context for downstream frameworks.",
      type: "processor",
      moduleType: "internal",
      category: "input",
      icon: "edit",
      status: "implemented",
      inputs: [
        {
          id: "user_input",
          name: "userInput",
          type: "string",
          required: true,
          description: "Raw strategic input from user describing their business challenge or opportunity"
        },
        {
          id: "clarifications",
          name: "clarifications",
          type: "Clarification[]",
          required: false,
          description: "Optional clarifications gathered from user for ambiguous input"
        }
      ],
      outputs: [
        {
          id: "strategic_understanding",
          name: "strategicUnderstanding",
          type: "StrategicUnderstanding",
          required: true,
          description: "Structured understanding of the strategic context"
        },
        {
          id: "entities",
          name: "entities",
          type: "Entity[]",
          required: true,
          description: "Extracted entities (companies, markets, products, locations)"
        },
        {
          id: "initial_context",
          name: "initialContext",
          type: "StrategicContext",
          required: true,
          description: "Initial strategic context to pass to first framework"
        }
      ],
      requires: [],
      serviceClass: "StrategicUnderstandingService",
      uiComponent: "StrategicInputPage",
      tags: ["input", "processing", "entity-extraction", "disambiguation"],
      estimatedDuration: 2,
      isActive: true
    };
  }
});

// server/modules/manifests/swot-analyzer.ts
var swotAnalyzerManifest;
var init_swot_analyzer2 = __esm({
  "server/modules/manifests/swot-analyzer.ts"() {
    "use strict";
    swotAnalyzerManifest = {
      id: "swot-analyzer",
      name: "SWOT Analyzer",
      version: "1.0.0",
      description: "Analyzes internal strengths and weaknesses alongside external opportunities and threats to provide a comprehensive strategic position assessment.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "analysis",
      icon: "compass",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context from BMC, challenge description, or other strategic input"
        },
        {
          id: "external_factors",
          name: "externalFactors",
          type: "pestle_output",
          required: false,
          description: "Optional PESTLE analysis results to inform external opportunities and threats"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "swotAnalysis",
          type: "swot_output",
          required: true,
          description: "Complete SWOT analysis with strengths, weaknesses, opportunities, and threats"
        }
      ],
      requires: [],
      serviceClass: "SWOTAnalyzer",
      uiComponent: "SWOTAnalysisPage",
      tags: ["strategic-analysis", "swot", "internal-external"],
      estimatedDuration: 4,
      isActive: true
    };
  }
});

// server/modules/manifests/segment-discovery-analyzer.ts
var segmentDiscoveryAnalyzerManifest;
var init_segment_discovery_analyzer = __esm({
  "server/modules/manifests/segment-discovery-analyzer.ts"() {
    "use strict";
    segmentDiscoveryAnalyzerManifest = {
      id: "segment-discovery-analyzer",
      name: "Customer Segment Discovery",
      version: "1.0.0",
      description: "Identifies and analyzes customer segments to find beachhead and backup segments for market entry and expansion strategies.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "customer",
      icon: "users",
      status: "implemented",
      inputs: [
        {
          id: "offering",
          name: "offering",
          type: "string",
          required: true,
          description: "Description of the product or service offering being analyzed"
        },
        {
          id: "classification",
          name: "classification",
          type: "marketing_context",
          required: true,
          description: "Business classification including B2B/B2C, stage, and market context"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "segmentDiscovery",
          type: "segment_discovery_output",
          required: true,
          description: "Complete segment analysis with beachhead and backup segments"
        }
      ],
      requires: [],
      serviceClass: "SegmentDiscoveryAnalyzer",
      uiComponent: "SegmentDiscoveryPage",
      tags: ["customer-analysis", "segmentation", "market-entry"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/competitive-positioning-analyzer.ts
var competitivePositioningAnalyzerManifest;
var init_competitive_positioning_analyzer2 = __esm({
  "server/modules/manifests/competitive-positioning-analyzer.ts"() {
    "use strict";
    competitivePositioningAnalyzerManifest = {
      id: "competitive-positioning-analyzer",
      name: "Competitive Positioning Analyzer",
      version: "1.0.0",
      description: "Analyzes competitive positioning to identify differentiation opportunities and strategic positioning options in the market.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "strategy",
      icon: "crosshair",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including current market position and competitors"
        },
        {
          id: "competitive_forces",
          name: "competitiveForces",
          type: "porters_output",
          required: false,
          description: "Optional Porter's Five Forces analysis for competitive context"
        },
        {
          id: "customer_segments",
          name: "customerSegments",
          type: "segment_discovery_output",
          required: false,
          description: "Optional customer segment data for positioning alignment"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "positioningAnalysis",
          type: "competitive_positioning_output",
          required: true,
          description: "Complete competitive positioning analysis with differentiation recommendations"
        }
      ],
      requires: [],
      serviceClass: "CompetitivePositioningAnalyzer",
      uiComponent: "CompetitivePositioningPage",
      tags: ["strategic-analysis", "positioning", "differentiation", "competition"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/ansoff-analyzer.ts
var ansoffAnalyzerManifest;
var init_ansoff_analyzer2 = __esm({
  "server/modules/manifests/ansoff-analyzer.ts"() {
    "use strict";
    ansoffAnalyzerManifest = {
      id: "ansoff-analyzer",
      name: "Ansoff Growth Matrix Analyzer",
      version: "1.0.0",
      description: "Analyzes growth opportunities using the Ansoff Matrix framework: market penetration, market development, product development, and diversification strategies.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "strategy",
      icon: "grid",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including current products, markets, and growth objectives"
        },
        {
          id: "swot_analysis",
          name: "swotAnalysis",
          type: "swot_output",
          required: false,
          description: "Optional SWOT analysis to inform growth strategy recommendations"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "ansoffAnalysis",
          type: "ansoff_output",
          required: true,
          description: "Complete Ansoff Matrix analysis with growth strategy recommendations"
        }
      ],
      requires: [],
      serviceClass: "AnsoffAnalyzer",
      uiComponent: "AnsoffMatrixPage",
      tags: ["strategic-analysis", "growth-strategy", "ansoff"],
      estimatedDuration: 4,
      isActive: true
    };
  }
});

// server/modules/manifests/blue-ocean-analyzer.ts
var blueOceanAnalyzerManifest;
var init_blue_ocean_analyzer2 = __esm({
  "server/modules/manifests/blue-ocean-analyzer.ts"() {
    "use strict";
    blueOceanAnalyzerManifest = {
      id: "blue-ocean-analyzer",
      name: "Blue Ocean Strategy Analyzer",
      version: "1.0.0",
      description: "Applies Blue Ocean Strategy framework to identify uncontested market spaces and create new demand through value innovation.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "strategy",
      icon: "waves",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Current business context and competitive landscape"
        },
        {
          id: "industry_analysis",
          name: "industryAnalysis",
          type: "porters_output",
          required: false,
          description: "Optional Porter's Five Forces analysis to understand current red ocean"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "blueOceanAnalysis",
          type: "blue_ocean_output",
          required: true,
          description: "Blue Ocean strategy canvas with eliminate-reduce-raise-create framework"
        }
      ],
      requires: [],
      serviceClass: "BlueOceanAnalyzer",
      uiComponent: "BlueOceanPage",
      tags: ["strategic-analysis", "market-creation", "blue-ocean", "differentiation"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/ocean-strategy-analyzer.ts
var oceanStrategyAnalyzerManifest;
var init_ocean_strategy_analyzer2 = __esm({
  "server/modules/manifests/ocean-strategy-analyzer.ts"() {
    "use strict";
    oceanStrategyAnalyzerManifest = {
      id: "ocean-strategy-analyzer",
      name: "Ocean Strategy Analyzer",
      version: "1.0.0",
      description: "Analyzes the competitive landscape to determine whether to compete in red ocean (existing market) or create blue ocean (new market space) strategies.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "strategy",
      icon: "navigation",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including current market position and strategic objectives"
        },
        {
          id: "industry_analysis",
          name: "industryAnalysis",
          type: "porters_output",
          required: false,
          description: "Optional Porter's analysis to understand current competitive intensity"
        },
        {
          id: "swot_analysis",
          name: "swotAnalysis",
          type: "swot_output",
          required: false,
          description: "Optional SWOT analysis to inform ocean strategy selection"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "oceanStrategyAnalysis",
          type: "ocean_strategy_output",
          required: true,
          description: "Complete ocean strategy analysis with red/blue ocean recommendations"
        }
      ],
      requires: [],
      serviceClass: "OceanStrategyAnalyzer",
      uiComponent: "OceanStrategyPage",
      tags: ["strategic-analysis", "ocean-strategy", "market-creation", "competition"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/bcg-matrix-analyzer.ts
var bcgMatrixAnalyzerManifest;
var init_bcg_matrix_analyzer2 = __esm({
  "server/modules/manifests/bcg-matrix-analyzer.ts"() {
    "use strict";
    bcgMatrixAnalyzerManifest = {
      id: "bcg-matrix-analyzer",
      name: "BCG Growth-Share Matrix Analyzer",
      version: "1.0.0",
      description: "Analyzes product/business unit portfolio using the BCG Matrix framework to classify as Stars, Cash Cows, Question Marks, or Dogs for optimal resource allocation.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "strategy",
      icon: "pie-chart",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including product portfolio and market positions"
        },
        {
          id: "market_data",
          name: "marketData",
          type: "market_analysis",
          required: false,
          description: "Optional market growth and share data for more accurate classification"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "bcgAnalysis",
          type: "bcg_matrix_output",
          required: true,
          description: "Complete BCG Matrix with portfolio classification and investment recommendations"
        }
      ],
      requires: [],
      serviceClass: "BCGMatrixAnalyzer",
      uiComponent: "BCGMatrixPage",
      tags: ["strategic-analysis", "portfolio", "bcg-matrix", "resource-allocation"],
      estimatedDuration: 4,
      isActive: true
    };
  }
});

// server/modules/manifests/value-chain-analyzer.ts
var valueChainAnalyzerManifest;
var init_value_chain_analyzer2 = __esm({
  "server/modules/manifests/value-chain-analyzer.ts"() {
    "use strict";
    valueChainAnalyzerManifest = {
      id: "value-chain-analyzer",
      name: "Value Chain Analyzer",
      version: "1.0.0",
      description: "Analyzes primary and support activities in the value chain to identify sources of competitive advantage and optimization opportunities.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "analysis",
      icon: "link",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including operations, processes, and activities"
        },
        {
          id: "customer_context",
          name: "customerContext",
          type: "segment_discovery_output",
          required: false,
          description: "Optional customer segment data to align value chain with customer needs"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "valueChainAnalysis",
          type: "value_chain_output",
          required: true,
          description: "Complete value chain analysis with activity mapping and optimization recommendations"
        }
      ],
      requires: [],
      serviceClass: "ValueChainAnalyzer",
      uiComponent: "ValueChainPage",
      tags: ["strategic-analysis", "value-chain", "operations", "competitive-advantage"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/vrio-analyzer.ts
var vrioAnalyzerManifest;
var init_vrio_analyzer2 = __esm({
  "server/modules/manifests/vrio-analyzer.ts"() {
    "use strict";
    vrioAnalyzerManifest = {
      id: "vrio-analyzer",
      name: "VRIO Framework Analyzer",
      version: "1.0.0",
      description: "Evaluates resources and capabilities using the VRIO framework (Valuable, Rare, Inimitable, Organized) to identify sources of sustainable competitive advantage.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "analysis",
      icon: "gem",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including resources, capabilities, and core competencies"
        },
        {
          id: "swot_analysis",
          name: "swotAnalysis",
          type: "swot_output",
          required: false,
          description: "Optional SWOT analysis to inform resource evaluation"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "vrioAnalysis",
          type: "vrio_output",
          required: true,
          description: "Complete VRIO analysis with resource classification and strategic implications"
        }
      ],
      requires: [],
      serviceClass: "VRIOAnalyzer",
      uiComponent: "VRIOPage",
      tags: ["strategic-analysis", "vrio", "resources", "competitive-advantage"],
      estimatedDuration: 4,
      isActive: true
    };
  }
});

// server/modules/manifests/scenario-planning-analyzer.ts
var scenarioPlanningAnalyzerManifest;
var init_scenario_planning_analyzer2 = __esm({
  "server/modules/manifests/scenario-planning-analyzer.ts"() {
    "use strict";
    scenarioPlanningAnalyzerManifest = {
      id: "scenario-planning-analyzer",
      name: "Scenario Planning Analyzer",
      version: "1.0.0",
      description: "Develops multiple future scenarios based on key uncertainties and macro-environmental factors to prepare strategic responses and build organizational resilience.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "strategy",
      icon: "git-branch",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including strategic objectives and key uncertainties"
        },
        {
          id: "macro_factors",
          name: "macroFactors",
          type: "pestle_output",
          required: false,
          description: "Optional PESTLE analysis to inform scenario development"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "scenarioAnalysis",
          type: "scenario_planning_output",
          required: true,
          description: "Complete scenario analysis with multiple future scenarios and strategic implications"
        }
      ],
      requires: [],
      serviceClass: "ScenarioPlanningAnalyzer",
      uiComponent: "ScenarioPlanningPage",
      tags: ["strategic-analysis", "scenario-planning", "futures", "uncertainty"],
      estimatedDuration: 6,
      isActive: true
    };
  }
});

// server/modules/manifests/jobs-to-be-done-analyzer.ts
var jobsToBeDoneAnalyzerManifest;
var init_jobs_to_be_done_analyzer = __esm({
  "server/modules/manifests/jobs-to-be-done-analyzer.ts"() {
    "use strict";
    jobsToBeDoneAnalyzerManifest = {
      id: "jobs-to-be-done-analyzer",
      name: "Jobs-to-be-Done Analyzer",
      version: "1.0.0",
      description: "Identifies and analyzes customer jobs, pains, and gains using the Jobs-to-be-Done framework to uncover innovation opportunities and improve product-market fit.",
      type: "analyzer",
      moduleType: "ai_analyzer",
      category: "customer",
      icon: "target",
      status: "implemented",
      inputs: [
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: true,
          description: "Business context including product/service and target market"
        },
        {
          id: "target_segments",
          name: "targetSegments",
          type: "segment_discovery_output",
          required: false,
          description: "Optional customer segment data to focus job analysis"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "jtbdAnalysis",
          type: "jobs_to_be_done_output",
          required: true,
          description: "Complete JTBD analysis with functional, emotional, and social jobs"
        }
      ],
      requires: [],
      serviceClass: "JobsToBeDoneAnalyzer",
      uiComponent: "JobsToBeDonePage",
      tags: ["customer-analysis", "jtbd", "innovation", "product-development"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/okr-generator.ts
var okrGeneratorManifest;
var init_okr_generator2 = __esm({
  "server/modules/manifests/okr-generator.ts"() {
    "use strict";
    okrGeneratorManifest = {
      id: "okr-generator",
      name: "OKR Generator",
      version: "1.0.0",
      description: "Generates Objectives and Key Results (OKRs) from strategic analysis outputs, creating measurable goals aligned with strategic priorities.",
      type: "generator",
      moduleType: "generator",
      category: "execution",
      icon: "flag",
      status: "implemented",
      inputs: [
        {
          id: "strategic_analysis",
          name: "strategicAnalysis",
          type: "any",
          required: true,
          description: "Strategic analysis output from SWOT, Ansoff, or other strategy frameworks"
        },
        {
          id: "business_context",
          name: "businessContext",
          type: "any",
          required: false,
          description: "Optional additional business context for OKR generation"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "okrs",
          type: "okr_output",
          required: true,
          description: "Complete set of Objectives and Key Results aligned with strategic priorities"
        }
      ],
      requires: [],
      serviceClass: "OKRGenerator",
      uiComponent: "OKRGeneratorPage",
      tags: ["execution", "okr", "goals", "measurement"],
      estimatedDuration: 3,
      isActive: true
    };
  }
});

// server/modules/manifests/strategic-decisions.ts
var strategicDecisionsManifest;
var init_strategic_decisions = __esm({
  "server/modules/manifests/strategic-decisions.ts"() {
    "use strict";
    strategicDecisionsManifest = {
      id: "strategic-decisions",
      name: "Strategic Decisions",
      version: "1.0.0",
      description: "Pauses journey execution for user to input strategic decisions, priorities, and key choices. Captures executive decisions that drive downstream analysis and EPM program generation.",
      type: "user-input",
      moduleType: "user_input",
      category: "input",
      icon: "lightbulb",
      status: "implemented",
      inputs: [
        {
          id: "strategic_context",
          name: "strategicContext",
          type: "StrategicContext",
          required: true,
          description: "Strategic context from prior analysis to inform decision-making"
        },
        {
          id: "understanding_id",
          name: "understandingId",
          type: "string",
          required: true,
          description: "The strategic understanding ID for this session"
        }
      ],
      outputs: [
        {
          id: "decisions",
          name: "decisions",
          type: "StrategicDecision[]",
          required: true,
          description: "Array of strategic decisions made by the user"
        },
        {
          id: "priorities",
          name: "priorities",
          type: "Priority[]",
          required: false,
          description: "Prioritized list of focus areas"
        }
      ],
      requires: [],
      serviceClass: null,
      uiComponent: "DecisionPage",
      tags: ["input", "decisions", "user-input", "priorities"],
      estimatedDuration: 7,
      isActive: true
    };
  }
});

// server/modules/manifests/strategic-understanding.ts
var strategicUnderstandingManifest;
var init_strategic_understanding = __esm({
  "server/modules/manifests/strategic-understanding.ts"() {
    "use strict";
    strategicUnderstandingManifest = {
      id: "strategic-understanding",
      name: "Strategic Understanding",
      version: "1.0.0",
      description: "Build strategic context and foundational knowledge graph through guided user input",
      type: "user-input",
      moduleType: "user_input",
      category: "input",
      icon: "lightbulb",
      status: "implemented",
      inputs: [
        {
          id: "user_description",
          name: "userDescription",
          type: "string",
          required: true,
          description: "Raw business description from user"
        }
      ],
      outputs: [
        {
          id: "output",
          name: "strategicContext",
          type: "strategic_context",
          required: true,
          description: "Processed strategic understanding with entities and classification"
        }
      ],
      requires: [],
      serviceClass: null,
      uiComponent: "InputPage",
      tags: ["foundation", "input", "knowledge-graph"],
      estimatedDuration: 5,
      isActive: true
    };
  }
});

// server/modules/manifests/index.ts
var allManifests;
var init_manifests = __esm({
  "server/modules/manifests/index.ts"() {
    "use strict";
    init_bmc_analyzer();
    init_porters_analyzer2();
    init_pestle_analyzer2();
    init_five_whys_analyzer();
    init_epm_generator();
    init_input_processor();
    init_swot_analyzer2();
    init_segment_discovery_analyzer();
    init_competitive_positioning_analyzer2();
    init_ansoff_analyzer2();
    init_blue_ocean_analyzer2();
    init_ocean_strategy_analyzer2();
    init_bcg_matrix_analyzer2();
    init_value_chain_analyzer2();
    init_vrio_analyzer2();
    init_scenario_planning_analyzer2();
    init_jobs_to_be_done_analyzer();
    init_okr_generator2();
    init_strategic_decisions();
    init_strategic_understanding();
    init_bmc_analyzer();
    init_porters_analyzer2();
    init_pestle_analyzer2();
    init_five_whys_analyzer();
    init_epm_generator();
    init_input_processor();
    init_swot_analyzer2();
    init_segment_discovery_analyzer();
    init_competitive_positioning_analyzer2();
    init_ansoff_analyzer2();
    init_blue_ocean_analyzer2();
    init_ocean_strategy_analyzer2();
    init_bcg_matrix_analyzer2();
    init_value_chain_analyzer2();
    init_vrio_analyzer2();
    init_scenario_planning_analyzer2();
    init_jobs_to_be_done_analyzer();
    init_okr_generator2();
    init_strategic_decisions();
    init_strategic_understanding();
    allManifests = [
      inputProcessorManifest,
      strategicUnderstandingManifest,
      fiveWhysAnalyzerManifest,
      bmcAnalyzerManifest,
      portersAnalyzerManifest,
      pestleAnalyzerManifest,
      swotAnalyzerManifest,
      segmentDiscoveryAnalyzerManifest,
      competitivePositioningAnalyzerManifest,
      ansoffAnalyzerManifest,
      blueOceanAnalyzerManifest,
      oceanStrategyAnalyzerManifest,
      bcgMatrixAnalyzerManifest,
      valueChainAnalyzerManifest,
      vrioAnalyzerManifest,
      scenarioPlanningAnalyzerManifest,
      jobsToBeDoneAnalyzerManifest,
      okrGeneratorManifest,
      epmGeneratorManifest,
      strategicDecisionsManifest
    ];
  }
});

// server/replitAuth.ts
var replitAuth_exports = {};
__export(replitAuth_exports, {
  finishAuthSetup: () => finishAuthSetup,
  getSession: () => getSession,
  isAdmin: () => isAdmin,
  isAuthenticated: () => isAuthenticated,
  isEditor: () => isEditor,
  refreshTokenProactively: () => refreshTokenProactively,
  setupAuth: () => setupAuth,
  setupAuthMiddleware: () => setupAuthMiddleware
});
import * as client from "openid-client";
import { Strategy } from "openid-client/passport";
import passport from "passport";
import session2 from "express-session";
import memoize from "memoizee";
import connectPg2 from "connect-pg-simple";
function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1e3;
  const pgStore = connectPg2(session2);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions"
  });
  return session2({
    secret: process.env.SESSION_SECRET,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true,
      maxAge: sessionTtl
    }
  });
}
function updateUserSession(user, tokens) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  if (tokens.refresh_token) {
    user.refresh_token = tokens.refresh_token;
  }
  user.expires_at = user.claims?.exp;
}
async function refreshTokenProactively(req, thresholdSeconds = 300) {
  const user = req.user;
  if (!req.isAuthenticated() || !user?.expires_at) {
    console.log("[ProactiveRefresh] User not authenticated or no expiry info");
    return false;
  }
  const now = Math.floor(Date.now() / 1e3);
  const expiresIn = user.expires_at - now;
  if (expiresIn > thresholdSeconds) {
    console.log(`[ProactiveRefresh] Token valid for ${expiresIn}s, no refresh needed`);
    return true;
  }
  console.log(`[ProactiveRefresh] Token expires in ${expiresIn}s, refreshing proactively...`);
  const refreshToken = user.refresh_token;
  if (!refreshToken) {
    console.error("[ProactiveRefresh] No refresh token available");
    return false;
  }
  try {
    const config = await getOidcConfig();
    const tokenResponse = await client.refreshTokenGrant(config, refreshToken);
    updateUserSession(user, tokenResponse);
    await new Promise((resolve, reject) => {
      req.session.save((err) => {
        if (err) {
          console.error("[ProactiveRefresh] Failed to save session:", err);
          reject(err);
        } else {
          resolve();
        }
      });
    });
    const newExpiresIn = user.expires_at - Math.floor(Date.now() / 1e3);
    console.log(`[ProactiveRefresh] \u2713 Token refreshed and session saved, valid for ${newExpiresIn}s`);
    return true;
  } catch (error) {
    console.error("[ProactiveRefresh] \u2717 Token refresh failed:", error);
    return false;
  }
}
async function upsertUser(claims) {
  await storage.upsertUser({
    id: claims["sub"],
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"]
  });
}
function setupAuthMiddleware(app2) {
  app2.set("trust proxy", 1);
  app2.use(getSession());
  app2.use(passport.initialize());
  app2.use(passport.session());
  passport.serializeUser((user, cb) => cb(null, user));
  passport.deserializeUser((user, cb) => cb(null, user));
}
async function finishAuthSetup(app2) {
  const config = await getOidcConfig();
  const verify = async (tokens, verified) => {
    const user = {};
    updateUserSession(user, tokens);
    await upsertUser(tokens.claims());
    verified(null, user);
  };
  for (const domain of process.env.REPLIT_DOMAINS.split(",")) {
    const strategy = new Strategy(
      {
        name: `replitauth:${domain}`,
        config,
        scope: "openid email profile offline_access",
        callbackURL: `https://${domain}/api/callback`
      },
      verify
    );
    passport.use(strategy);
  }
  const getStrategyName = (hostname) => {
    const domains = process.env.REPLIT_DOMAINS.split(",");
    const matchedDomain = domains.find((d) => d === hostname);
    return `replitauth:${matchedDomain || domains[0]}`;
  };
  app2.get("/api/login", (req, res, next) => {
    if (!authReadiness.isReady()) {
      return res.status(503).header("Retry-After", "2").json({
        message: "Authentication system initializing, please retry in 2 seconds"
      });
    }
    passport.authenticate(getStrategyName(req.hostname), {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"]
    })(req, res, next);
  });
  app2.get("/api/callback", (req, res, next) => {
    if (!authReadiness.isReady()) {
      return res.status(503).header("Retry-After", "2").json({
        message: "Authentication system initializing, please retry in 2 seconds"
      });
    }
    passport.authenticate(getStrategyName(req.hostname), {
      successReturnToOrRedirect: "/",
      failureRedirect: "/api/login"
    })(req, res, next);
  });
  app2.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: process.env.REPL_ID,
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`
        }).href
      );
    });
  });
  authReadiness.setReady();
}
async function setupAuth(app2) {
  setupAuthMiddleware(app2);
  await finishAuthSetup(app2);
}
var getOidcConfig, isAuthenticated, isAdmin, isEditor;
var init_replitAuth = __esm({
  "server/replitAuth.ts"() {
    "use strict";
    init_storage();
    init_auth_readiness();
    if (!process.env.REPLIT_DOMAINS) {
      throw new Error("Environment variable REPLIT_DOMAINS not provided");
    }
    getOidcConfig = memoize(
      async () => {
        return await client.discovery(
          new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
          process.env.REPL_ID
        );
      },
      { maxAge: 3600 * 1e3 }
    );
    isAuthenticated = async (req, res, next) => {
      const user = req.user;
      if (!req.isAuthenticated() || !user?.expires_at) {
        const isExplicitDevMode = process.env.DEV_AUTH_BYPASS === "true" && process.env.NODE_ENV === "development";
        const remoteAddress = req.socket.remoteAddress || "";
        const isLoopback = remoteAddress === "127.0.0.1" || remoteAddress === "::1" || remoteAddress === "::ffff:127.0.0.1" || remoteAddress.startsWith("172.") || // Docker bridge
        remoteAddress.startsWith("192.168.65.");
        const shouldBypass = isExplicitDevMode && isLoopback;
        if (shouldBypass) {
          console.warn("\u26A0\uFE0F  [Auth] DEV AUTH BYPASS ACTIVE - Synthetic user injected");
          console.warn("\u26A0\uFE0F  [Auth] Remote address:", remoteAddress, "| DEV_AUTH_BYPASS:", process.env.DEV_AUTH_BYPASS);
          const syntheticUser = {
            claims: {
              sub: "dev-user-123",
              email: "dev@example.com",
              first_name: "Dev",
              last_name: "User",
              exp: Math.floor(Date.now() / 1e3) + 86400
              // 24 hours from now
            },
            access_token: "dev-token",
            refresh_token: "dev-refresh-token",
            expires_at: Math.floor(Date.now() / 1e3) + 86400
          };
          req.user = syntheticUser;
          try {
            await upsertUser(syntheticUser.claims);
          } catch (error) {
            console.error("[Auth] Failed to upsert dev user:", error);
          }
          return next();
        }
        if (isExplicitDevMode && !isLoopback) {
          console.error("\u{1F6A8} [Auth] SECURITY ALERT: DEV_AUTH_BYPASS=true but request from:", remoteAddress);
          console.error("\u{1F6A8} [Auth] Auth bypass BLOCKED - Only loopback connections allowed!");
          console.error("\u{1F6A8} [Auth] Set DEV_AUTH_BYPASS=false in production deployments!");
        }
        return res.status(401).json({ message: "Unauthorized" });
      }
      const now = Math.floor(Date.now() / 1e3);
      if (now <= user.expires_at) {
        return next();
      }
      const refreshToken = user.refresh_token;
      if (!refreshToken) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
      try {
        const config = await getOidcConfig();
        const tokenResponse = await client.refreshTokenGrant(config, refreshToken);
        updateUserSession(user, tokenResponse);
        req.session.save((err) => {
          if (err) {
            console.error("[Auth] Failed to save refreshed session:", err);
          }
        });
        return next();
      } catch (error) {
        res.status(401).json({ message: "Unauthorized" });
        return;
      }
    };
    isAdmin = (req, res, next) => {
      if (!req.user || req.user.role !== "Admin") {
        return res.status(403).json({ error: "Admin access required" });
      }
      next();
    };
    isEditor = (req, res, next) => {
      if (!req.user || !["Admin", "Editor"].includes(req.user.role)) {
        return res.status(403).json({ error: "Editor access required" });
      }
      next();
    };
  }
});

// server/assessment-service.ts
var AssessmentService, assessmentService;
var init_assessment_service = __esm({
  "server/assessment-service.ts"() {
    "use strict";
    AssessmentService = class {
      // Industry benchmarks and thresholds
      BENCHMARKS = {
        program: {
          minDurationDays: 90,
          maxDurationDays: 1095,
          typicalDurationDays: 365,
          minTasksPerMonth: 2,
          maxTasksPerMonth: 20,
          minBudgetPerTask: 1e3,
          roiThreshold: 1.5,
          minStageGates: 4,
          maxStageGates: 7
        },
        task: {
          minDurationDays: 1,
          maxDurationDays: 90,
          typicalDurationDays: 14,
          maxDependencies: 5,
          warningDependencies: 3
        },
        risk: {
          highPriorityMitigationRequired: true,
          maxOpenHighRisks: 5,
          mitigationTimeframeDays: 30
        },
        kpi: {
          minMeasurementsForTrend: 3,
          measurementFrequencyDays: 30
        },
        benefit: {
          minROI: 1.2,
          realizationTimeframeMonths: 12
        },
        resource: {
          maxAllocationPercent: 100,
          warningAllocationPercent: 90
        }
      };
      async assessProgram(program, relatedData) {
        const concerns = [];
        if (program.startDate && program.endDate) {
          const durationDays = this.calculateDaysBetween(program.startDate, program.endDate);
          if (durationDays < this.BENCHMARKS.program.minDurationDays) {
            concerns.push({
              category: "timeline",
              severity: "high",
              message: `Program duration of ${durationDays} days is unusually short. Typical programs run 90-1095 days.`,
              recommendation: `Consider extending the timeline to at least ${this.BENCHMARKS.program.minDurationDays} days or evaluate if this should be a project instead of a program.`
            });
          } else if (durationDays > this.BENCHMARKS.program.maxDurationDays) {
            concerns.push({
              category: "timeline",
              severity: "medium",
              message: `Program duration of ${durationDays} days is very long. Programs over 3 years often face scope creep.`,
              recommendation: `Consider breaking into phases or multiple programs with intermediate milestones.`
            });
          }
        }
        if (relatedData?.tasks && program.startDate && program.endDate) {
          const durationMonths = this.calculateDaysBetween(program.startDate, program.endDate) / 30;
          const tasksPerMonth = relatedData.tasks.length / durationMonths;
          if (tasksPerMonth < this.BENCHMARKS.program.minTasksPerMonth) {
            concerns.push({
              category: "scope",
              severity: "medium",
              message: `With ${relatedData.tasks.length} tasks over ${Math.round(durationMonths)} months (${tasksPerMonth.toFixed(1)} tasks/month), the program may lack detailed planning.`,
              recommendation: `Add more granular tasks to ensure work is properly broken down and trackable.`
            });
          } else if (tasksPerMonth > this.BENCHMARKS.program.maxTasksPerMonth) {
            concerns.push({
              category: "scope",
              severity: "medium",
              message: `With ${relatedData.tasks.length} tasks over ${Math.round(durationMonths)} months (${tasksPerMonth.toFixed(1)} tasks/month), the program may be over-planned.`,
              recommendation: `Consider consolidating smaller tasks or delegating detailed planning to workstreams.`
            });
          }
        }
        if (relatedData?.stageGates) {
          if (relatedData.stageGates.length < this.BENCHMARKS.program.minStageGates) {
            concerns.push({
              category: "quality",
              severity: "high",
              message: `Program has only ${relatedData.stageGates.length} stage gates. Proper governance requires at least ${this.BENCHMARKS.program.minStageGates} gates (G0-G4).`,
              recommendation: `Add standard stage gates: G0 (Ideation), G1 (Planning), G2 (Execution), G3 (Validation), G4 (Closure).`
            });
          }
        }
        if (relatedData?.fundingSources && relatedData?.benefits) {
          let totalFunding = 0;
          let hasFundingError = false;
          for (const f of relatedData.fundingSources) {
            const amount = parseFloat(f.allocatedAmount || "0");
            if (isNaN(amount)) {
              hasFundingError = true;
              concerns.push({
                category: "budget",
                severity: "critical",
                message: `Funding source "${f.name || "unnamed"}" has invalid amount: "${f.allocatedAmount}". Must be numeric.`,
                recommendation: `Correct funding amount to be a valid number.`
              });
            } else {
              totalFunding += amount;
            }
          }
          let totalBenefits = 0;
          let hasBenefitError = false;
          for (const b of relatedData.benefits) {
            const value = parseFloat(b.targetValue || "0");
            if (isNaN(value)) {
              hasBenefitError = true;
              concerns.push({
                category: "budget",
                severity: "high",
                message: `Benefit "${b.name || "unnamed"}" has invalid target value: "${b.targetValue}". Must be numeric.`,
                recommendation: `Correct benefit target value to be a valid number.`
              });
            } else {
              totalBenefits += value;
            }
          }
          if (!hasFundingError && totalFunding === 0) {
            concerns.push({
              category: "budget",
              severity: "critical",
              message: `Program has no funding sources defined. Cannot calculate ROI or financial viability.`,
              recommendation: `Define at least one funding source with allocated budget to establish program capital.`
            });
          } else if (!hasFundingError && !hasBenefitError && totalBenefits > 0) {
            const roi = totalBenefits / totalFunding;
            if (roi < this.BENCHMARKS.program.roiThreshold) {
              concerns.push({
                category: "budget",
                severity: roi < 1 ? "critical" : "high",
                message: `Program ROI of ${roi.toFixed(2)}x is ${roi < 1 ? "negative" : "below recommended threshold of " + this.BENCHMARKS.program.roiThreshold + "x"}.`,
                recommendation: roi < 1 ? "Re-evaluate program viability. Consider reducing costs or increasing benefit targets." : "Review benefit calculations and look for additional value opportunities to improve ROI.",
                data: { totalFunding, totalBenefits, roi }
              });
            }
          }
        }
        if (relatedData?.risks) {
          const highRisks = relatedData.risks.filter((r) => r.priority === "High" || r.priority === "Critical");
          const openHighRisks = highRisks.filter((r) => r.status === "Open");
          if (openHighRisks.length > this.BENCHMARKS.risk.maxOpenHighRisks) {
            concerns.push({
              category: "risk",
              severity: "critical",
              message: `Program has ${openHighRisks.length} open high/critical risks. This exceeds safe threshold of ${this.BENCHMARKS.risk.maxOpenHighRisks}.`,
              recommendation: `Prioritize risk mitigation. Address critical risks immediately before proceeding.`
            });
          }
        }
        return {
          isRealistic: concerns.filter((c) => c.severity === "critical").length === 0,
          concerns,
          benchmarks: {
            typical: {
              duration: `${this.BENCHMARKS.program.typicalDurationDays} days (12 months)`,
              tasksPerMonth: `${this.BENCHMARKS.program.minTasksPerMonth}-${this.BENCHMARKS.program.maxTasksPerMonth}`,
              stageGates: `${this.BENCHMARKS.program.minStageGates}-${this.BENCHMARKS.program.maxStageGates}`,
              roi: `${this.BENCHMARKS.program.roiThreshold}x or higher`
            },
            current: {
              duration: program.startDate && program.endDate ? `${this.calculateDaysBetween(program.startDate, program.endDate)} days` : "Not specified",
              tasks: relatedData?.tasks?.length || 0,
              stageGates: relatedData?.stageGates?.length || 0,
              openHighRisks: relatedData?.risks?.filter(
                (r) => (r.priority === "High" || r.priority === "Critical") && r.status === "Open"
              ).length || 0
            },
            deviation: concerns.length === 0 ? "Within normal parameters" : `${concerns.length} concern(s) identified`
          }
        };
      }
      async assessTask(task, program) {
        const concerns = [];
        if (task.startDate && task.endDate) {
          const durationDays = this.calculateDaysBetween(task.startDate, task.endDate);
          if (durationDays === 0) {
            concerns.push({
              category: "timeline",
              severity: "medium",
              message: `Task has zero duration (start and end on the same day). Tasks should span at least 1 day.`,
              recommendation: `Extend task duration to at least 1 day or combine with other tasks.`
            });
          } else if (durationDays < this.BENCHMARKS.task.minDurationDays) {
            concerns.push({
              category: "timeline",
              severity: "low",
              message: `Task duration of ${durationDays} days is very short. Consider consolidating micro-tasks.`,
              recommendation: `Combine with related tasks or extend duration to at least 1 day.`
            });
          } else if (durationDays > this.BENCHMARKS.task.maxDurationDays) {
            concerns.push({
              category: "timeline",
              severity: "medium",
              message: `Task duration of ${durationDays} days is very long. Tasks over 90 days risk becoming stale.`,
              recommendation: `Break into smaller, more manageable subtasks with intermediate deliverables.`
            });
          }
        }
        if (program && task.startDate && task.endDate) {
          if (new Date(task.startDate) < new Date(program.startDate)) {
            concerns.push({
              category: "timeline",
              severity: "critical",
              message: `Task starts before program start date.`,
              recommendation: `Adjust task start date to be within program timeline.`
            });
          }
          if (new Date(task.endDate) > new Date(program.endDate)) {
            concerns.push({
              category: "timeline",
              severity: "critical",
              message: `Task ends after program end date.`,
              recommendation: `Adjust task end date to be within program timeline or extend program duration.`
            });
          }
        }
        if (task.startDate && task.endDate && task.progress !== void 0) {
          const totalDays = Math.max(1, this.calculateDaysBetween(task.startDate, task.endDate));
          const now = /* @__PURE__ */ new Date();
          const taskStart = new Date(task.startDate);
          if (now >= taskStart) {
            const elapsed = Math.max(0, this.calculateDaysBetween(task.startDate, now));
            const expectedProgress = Math.min(100, Math.max(0, elapsed / totalDays * 100));
            const progressGap = task.progress - expectedProgress;
            if (progressGap < -20) {
              concerns.push({
                category: "timeline",
                severity: "high",
                message: `Task is ${Math.abs(progressGap).toFixed(0)}% behind schedule (expected ${expectedProgress.toFixed(0)}%, actual ${task.progress}%).`,
                recommendation: `Investigate delays and allocate additional resources or adjust timeline.`,
                data: { expectedProgress: expectedProgress.toFixed(0), actualProgress: task.progress, gap: progressGap.toFixed(0) }
              });
            }
          }
        }
        return {
          isRealistic: concerns.filter((c) => c.severity === "critical").length === 0,
          concerns,
          benchmarks: {
            typical: {
              duration: `${this.BENCHMARKS.task.typicalDurationDays} days`,
              maxDuration: `${this.BENCHMARKS.task.maxDurationDays} days`
            },
            current: {
              duration: task.startDate && task.endDate ? `${this.calculateDaysBetween(task.startDate, task.endDate)} days` : "Not specified",
              progress: `${task.progress || 0}%`,
              status: task.status || "Unknown"
            },
            deviation: concerns.length === 0 ? "Within normal parameters" : `${concerns.length} concern(s) identified`
          }
        };
      }
      async assessRisk(risk, mitigations) {
        const concerns = [];
        if ((risk.priority === "High" || risk.priority === "Critical") && risk.status === "Open") {
          if (!mitigations || mitigations.length === 0) {
            concerns.push({
              category: "risk",
              severity: "critical",
              message: `High/Critical risk has no mitigation actions defined.`,
              recommendation: `Define at least one mitigation action with owner and target date.`
            });
          } else {
            const completedMitigations = mitigations.filter((m) => m.status === "Completed");
            if (completedMitigations.length === 0) {
              concerns.push({
                category: "risk",
                severity: "high",
                message: `High/Critical risk has ${mitigations.length} mitigation(s) but none are completed.`,
                recommendation: `Accelerate mitigation actions. High/Critical risks should be addressed within ${this.BENCHMARKS.risk.mitigationTimeframeDays} days.`
              });
            }
          }
        }
        if (risk.createdAt && risk.status === "Open") {
          const ageInDays = this.calculateDaysBetween(risk.createdAt, /* @__PURE__ */ new Date());
          if (ageInDays > 90 && (risk.priority === "High" || risk.priority === "Critical")) {
            concerns.push({
              category: "risk",
              severity: "high",
              message: `High/Critical risk has been open for ${ageInDays} days without resolution.`,
              recommendation: `Escalate to program leadership. Persistent high risks threaten program success.`
            });
          }
        }
        return {
          isRealistic: concerns.filter((c) => c.severity === "critical").length === 0,
          concerns,
          benchmarks: {
            typical: {
              mitigationTimeframe: `${this.BENCHMARKS.risk.mitigationTimeframeDays} days for high/critical`,
              requiredMitigations: "At least 1 for high/critical risks"
            },
            current: {
              priority: risk.priority || "Unknown",
              status: risk.status || "Unknown",
              mitigations: mitigations?.length || 0,
              completedMitigations: mitigations?.filter((m) => m.status === "Completed").length || 0
            },
            deviation: concerns.length === 0 ? "Risk properly managed" : `${concerns.length} concern(s) identified`
          }
        };
      }
      async assessBenefit(benefit, program) {
        const concerns = [];
        if (benefit.targetValue && program) {
          const targetValue = parseFloat(benefit.targetValue);
          if (targetValue <= 0) {
            concerns.push({
              category: "budget",
              severity: "critical",
              message: `Benefit target value must be positive to justify investment.`,
              recommendation: `Define a measurable, positive target value for this benefit.`
            });
          }
        }
        if (benefit.targetDate && program?.endDate) {
          const realizationDate = new Date(benefit.targetDate);
          const programEnd = new Date(program.endDate);
          const monthsAfterProgram = (realizationDate.getTime() - programEnd.getTime()) / (1e3 * 60 * 60 * 24 * 30);
          if (monthsAfterProgram > this.BENCHMARKS.benefit.realizationTimeframeMonths) {
            concerns.push({
              category: "timeline",
              severity: "medium",
              message: `Benefit realization is ${Math.round(monthsAfterProgram)} months after program completion. Long delays reduce confidence in benefit delivery.`,
              recommendation: `Review benefit timeline. Consider if this is truly achievable or if interim benefits should be defined.`
            });
          }
        }
        return {
          isRealistic: concerns.filter((c) => c.severity === "critical").length === 0,
          concerns,
          benchmarks: {
            typical: {
              targetValue: "Positive, measurable value",
              realizationTimeframe: `Within ${this.BENCHMARKS.benefit.realizationTimeframeMonths} months of program completion`
            },
            current: {
              targetValue: benefit.targetValue || "Not specified",
              status: benefit.status || "Unknown",
              category: benefit.category || "Unknown"
            },
            deviation: concerns.length === 0 ? "Benefit properly defined" : `${concerns.length} concern(s) identified`
          }
        };
      }
      async assessKpi(kpi, measurements) {
        const concerns = [];
        if (measurements && measurements.length >= 2) {
          const sortedMeasurements = [...measurements].sort(
            (a, b) => new Date(a.measurementDate).getTime() - new Date(b.measurementDate).getTime()
          );
          const intervals = [];
          let hasInvalidDate = false;
          for (let i = 1; i < sortedMeasurements.length; i++) {
            const date1 = new Date(sortedMeasurements[i - 1].measurementDate);
            const date2 = new Date(sortedMeasurements[i].measurementDate);
            if (isNaN(date1.getTime()) || isNaN(date2.getTime())) {
              hasInvalidDate = true;
              concerns.push({
                category: "quality",
                severity: "critical",
                message: `KPI measurements contain invalid dates. Cannot calculate measurement frequency.`,
                recommendation: `Ensure all measurement dates are valid ISO dates.`
              });
              break;
            }
            const daysBetween = this.calculateDaysBetween(date1, date2);
            intervals.push(daysBetween);
          }
          if (!hasInvalidDate && intervals.length > 0) {
            const avgInterval = intervals.reduce((sum, days) => sum + days, 0) / intervals.length;
            if (isNaN(avgInterval)) {
              concerns.push({
                category: "quality",
                severity: "critical",
                message: `Cannot calculate measurement frequency. Check measurement dates.`,
                recommendation: `Verify all measurement dates are valid and properly formatted.`
              });
            } else if (avgInterval > this.BENCHMARKS.kpi.measurementFrequencyDays * 2) {
              concerns.push({
                category: "quality",
                severity: "medium",
                message: `KPI measurements are averaged ${Math.round(avgInterval)} days apart. This is too infrequent for effective tracking.`,
                recommendation: `Increase measurement frequency to at least every ${this.BENCHMARKS.kpi.measurementFrequencyDays} days for meaningful trends.`
              });
            }
          }
        } else if (!measurements || measurements.length < this.BENCHMARKS.kpi.minMeasurementsForTrend) {
          concerns.push({
            category: "quality",
            severity: "high",
            message: `KPI has ${measurements?.length || 0} measurements. Need at least ${this.BENCHMARKS.kpi.minMeasurementsForTrend} to establish a trend.`,
            recommendation: `Record ${this.BENCHMARKS.kpi.minMeasurementsForTrend} measurements to establish a baseline and track progress.`
          });
        }
        if (kpi.targetValue !== void 0 && kpi.actualValue !== void 0) {
          const target = parseFloat(kpi.targetValue);
          const actual = parseFloat(kpi.actualValue);
          if (isNaN(target) || isNaN(actual)) {
            concerns.push({
              category: "quality",
              severity: "medium",
              message: `KPI target or actual value is not numeric. Cannot assess performance.`,
              recommendation: `Ensure target and actual values are numeric for quantitative tracking.`
            });
          } else {
            const achievement = actual / target * 100;
            if (achievement < 50) {
              concerns.push({
                category: "quality",
                severity: "critical",
                message: `KPI achievement is ${achievement.toFixed(0)}% of target. Significantly underperforming.`,
                recommendation: `Investigate root causes. Consider if target is realistic or if corrective actions are needed.`,
                data: { target, actual, achievement: achievement.toFixed(0) }
              });
            } else if (achievement < 80) {
              concerns.push({
                category: "quality",
                severity: "high",
                message: `KPI achievement is ${achievement.toFixed(0)}% of target. Below expected performance.`,
                recommendation: `Review progress and implement improvement actions to reach target.`,
                data: { target, actual, achievement: achievement.toFixed(0) }
              });
            }
          }
        }
        if (measurements && measurements.length > 0) {
          const latestMeasurement = measurements.reduce(
            (latest, m) => new Date(m.measurementDate) > new Date(latest.measurementDate) ? m : latest,
            measurements[0]
          );
          const daysSinceLastMeasurement = this.calculateDaysBetween(latestMeasurement.measurementDate, /* @__PURE__ */ new Date());
          if (daysSinceLastMeasurement > this.BENCHMARKS.kpi.measurementFrequencyDays * 2) {
            concerns.push({
              category: "quality",
              severity: "medium",
              message: `KPI has not been measured in ${daysSinceLastMeasurement} days. Data is stale.`,
              recommendation: `Record a new measurement to keep KPI tracking current.`
            });
          }
        }
        return {
          isRealistic: concerns.filter((c) => c.severity === "critical").length === 0,
          concerns,
          benchmarks: {
            typical: {
              measurementFrequency: `Every ${this.BENCHMARKS.kpi.measurementFrequencyDays} days`,
              minMeasurements: this.BENCHMARKS.kpi.minMeasurementsForTrend,
              targetAchievement: "80% or higher"
            },
            current: {
              measurements: measurements?.length || 0,
              latestValue: kpi.actualValue || "Not recorded",
              targetValue: kpi.targetValue || "Not set"
            },
            deviation: concerns.length === 0 ? "KPI tracking is healthy" : `${concerns.length} concern(s) identified`
          }
        };
      }
      async assessResource(resource) {
        const concerns = [];
        if (resource.allocation !== void 0) {
          const allocation = parseFloat(resource.allocation);
          if (allocation > this.BENCHMARKS.resource.maxAllocationPercent) {
            concerns.push({
              category: "resources",
              severity: "critical",
              message: `Resource allocation of ${allocation}% exceeds 100%. This is not sustainable.`,
              recommendation: `Reduce allocation to 100% or split work across multiple resources.`
            });
          } else if (allocation >= this.BENCHMARKS.resource.warningAllocationPercent) {
            concerns.push({
              category: "resources",
              severity: "medium",
              message: `Resource allocation of ${allocation}% is very high. Risk of burnout and quality issues.`,
              recommendation: `Consider reducing allocation to allow buffer for unexpected work or allocate additional resources.`
            });
          }
        }
        return {
          isRealistic: concerns.filter((c) => c.severity === "critical").length === 0,
          concerns,
          benchmarks: {
            typical: {
              maxAllocation: `${this.BENCHMARKS.resource.maxAllocationPercent}%`,
              sustainableAllocation: `${this.BENCHMARKS.resource.warningAllocationPercent}% or below`
            },
            current: {
              allocation: `${resource.allocation || 0}%`,
              role: resource.role || "Unknown"
            },
            deviation: concerns.length === 0 ? "Allocation is reasonable" : `${concerns.length} concern(s) identified`
          }
        };
      }
      calculateDaysBetween(start, end) {
        const startDate = typeof start === "string" ? new Date(start) : start;
        const endDate = typeof end === "string" ? new Date(end) : end;
        return Math.round((endDate.getTime() - startDate.getTime()) / (1e3 * 60 * 60 * 24));
      }
    };
    assessmentService = new AssessmentService();
  }
});

// server/executive-agent.ts
var ExecutiveAgent, executiveAgent;
var init_executive_agent = __esm({
  "server/executive-agent.ts"() {
    "use strict";
    init_storage();
    init_ontology_service();
    ExecutiveAgent = class {
      activeSessionId = null;
      /**
       * Start a new work session with explicit goal and success criteria
       */
      async startSession(criteria) {
        console.log("[ExecutiveAgent] Starting new session:", criteria.goal);
        const session3 = await storage.createSessionContext({
          goal: criteria.goal,
          successCriteria: criteria.successCriteria,
          currentPhase: criteria.currentPhase || "Planning",
          decisionsLog: []
        });
        this.activeSessionId = session3.id;
        console.log("[ExecutiveAgent] Session created:", session3.id);
        console.log("[ExecutiveAgent] Success criteria:", criteria.successCriteria);
        return session3;
      }
      /**
       * Get the currently active session for this ExecutiveAgent instance
       */
      async getActiveSession() {
        if (!this.activeSessionId) {
          return void 0;
        }
        return await storage.getSessionContextById(this.activeSessionId);
      }
      /**
       * Update current phase of work
       */
      async updatePhase(phase) {
        if (!this.activeSessionId) {
          console.warn("[ExecutiveAgent] No active session to update phase");
          return;
        }
        await storage.updateSessionContext(this.activeSessionId, { currentPhase: phase });
        console.log("[ExecutiveAgent] Phase updated:", phase);
      }
      /**
       * Query ontology for relevant validation rules before making a decision
       */
      async queryOntologyForDecision(entity, context) {
        console.log("[ExecutiveAgent] Querying ontology for:", entity, "context:", context);
        const rules = await ontologyService.getValidationRules({
          entity,
          enabled: true
        });
        const completeness = await ontologyService.getCompletenessChecks({
          entity,
          enabled: true
        });
        const recommendations = [];
        for (const rule of rules) {
          if (rule.severity === "error" || rule.severity === "critical") {
            recommendations.push(`${rule.rule}: ${rule.validation}`);
          }
        }
        for (const check of completeness) {
          if (check.importance === "critical" || check.importance === "required") {
            recommendations.push(`Completeness: ${check.description}`);
          }
        }
        console.log("[ExecutiveAgent] Found", rules.length, "rules and", recommendations.length, "recommendations");
        return { rules, recommendations };
      }
      /**
       * Log a decision with rationale to the active session
       */
      async logDecision(decision) {
        if (!this.activeSessionId) {
          console.warn("[ExecutiveAgent] No active session to log decision");
          return;
        }
        console.log("[ExecutiveAgent] Logging decision:", decision.decision);
        await storage.addDecisionToContext(this.activeSessionId, {
          decision: decision.decision,
          rationale: decision.rationale,
          ontologyRulesChecked: decision.ontologyRulesChecked,
          alternatives: decision.alternatives,
          confidence: decision.confidence
        });
      }
      /**
       * Mark a success criterion as complete
       */
      async completeCriterion(criterionIndex) {
        const session3 = await this.getActiveSession();
        if (!session3 || !this.activeSessionId) {
          console.warn("[ExecutiveAgent] No active session to complete criterion");
          return;
        }
        const updatedCriteria = [...session3.successCriteria];
        if (criterionIndex >= 0 && criterionIndex < updatedCriteria.length) {
          const criterion = updatedCriteria[criterionIndex];
          if (!criterion.startsWith("\u2713 ")) {
            updatedCriteria[criterionIndex] = `\u2713 ${criterion}`;
            await storage.updateSessionContext(this.activeSessionId, { successCriteria: updatedCriteria });
            console.log("[ExecutiveAgent] Completed criterion:", criterion);
          }
        }
      }
      /**
       * Check if all success criteria are met before task completion
       */
      async validateCompletion() {
        const session3 = await this.getActiveSession();
        if (!session3 || !this.activeSessionId) {
          console.warn("[ExecutiveAgent] No active session for validation - treating as incomplete");
          return {
            allCriteriaMet: false,
            // No session = cannot validate
            totalCriteria: 0,
            completedCriteria: 0,
            remainingCriteria: ["No active session"]
          };
        }
        const completed = session3.successCriteria.filter((c) => c.startsWith("\u2713 "));
        const remaining = session3.successCriteria.filter((c) => !c.startsWith("\u2713 "));
        const result = {
          allCriteriaMet: remaining.length === 0,
          totalCriteria: session3.successCriteria.length,
          completedCriteria: completed.length,
          remainingCriteria: remaining
        };
        console.log("[ExecutiveAgent] Validation result:", result);
        return result;
      }
      /**
       * Query ontology to validate output quality before completion
       */
      async validateOutputQuality(entity, outputData) {
        console.log("[ExecutiveAgent] Validating output quality for:", entity);
        const validation = await ontologyService.validateEntityData(entity, outputData);
        const issues = validation.errors.map((e) => e.message);
        const warnings = validation.warnings.map((w) => w.message);
        console.log("[ExecutiveAgent] Validation:", {
          isValid: validation.isValid,
          issues: issues.length,
          warnings: warnings.length
        });
        return {
          isValid: validation.isValid,
          issues,
          warnings
        };
      }
      /**
       * End the current session
       */
      async endSession() {
        if (!this.activeSessionId) {
          console.warn("[ExecutiveAgent] No active session to end");
          return;
        }
        const sessionId = this.activeSessionId;
        await storage.deactivateSessionContext(sessionId);
        this.activeSessionId = null;
        console.log("[ExecutiveAgent] Session ended:", sessionId);
      }
      /**
       * Get session summary for reporting
       */
      async getSessionSummary() {
        const session3 = await this.getActiveSession();
        if (!session3) {
          return "No active session";
        }
        const completed = session3.successCriteria.filter((c) => c.startsWith("\u2713 ")).length;
        const total = session3.successCriteria.length;
        const percentage = total > 0 ? Math.round(completed / total * 100) : 0;
        const decisionsLog = session3.decisionsLog || [];
        return `
Session: ${session3.goal}
Progress: ${completed}/${total} criteria (${percentage}%)
Phase: ${session3.currentPhase || "Unknown"}
Decisions logged: ${decisionsLog.length}
Created: ${session3.createdAt ? new Date(session3.createdAt).toLocaleString() : "Unknown"}
    `.trim();
      }
    };
    executiveAgent = new ExecutiveAgent();
  }
});

// server/orchestrator.ts
var Orchestrator;
var init_orchestrator2 = __esm({
  "server/orchestrator.ts"() {
    "use strict";
    init_ai_clients();
    init_executive_agent();
    init_ontology_service();
    Orchestrator = class {
      storage;
      executiveAgent;
      constructor(storage2) {
        this.storage = storage2;
        this.executiveAgent = new ExecutiveAgent();
      }
      async processTask(task) {
        const session3 = await this.executiveAgent.startSession({
          goal: `Orchestrate AI task: ${task.taskDescription}`,
          successCriteria: [
            "Select appropriate AI provider",
            ...task.requirements.map((r) => `Builder satisfies: ${r}`),
            ...task.requirements.map((r) => `QA verifies: ${r}`),
            "QA verdict is PASS"
          ],
          currentPhase: "Provider Selection"
        });
        try {
          const availableProviders = aiClients.getAvailableProviders();
          if (availableProviders.length === 0) {
            throw new Error("No AI providers available. Please configure at least one API key (OPENAI_API_KEY, ANTHROPIC_API_KEY, or GEMINI_API_KEY).");
          }
          const provider = aiClients.selectProvider(task.preferredProvider);
          await this.executiveAgent.logDecision({
            decision: `Selected AI provider: ${provider}`,
            rationale: `Provider ${provider} is available (from ${availableProviders.join(", ")}) and ${task.preferredProvider ? "matches user preference" : "selected by default priority"}`,
            alternatives: task.preferredProvider ? [`Use ${task.preferredProvider}`] : ["Use OpenAI", "Use Anthropic", "Use Gemini"],
            confidence: "high",
            ontologyRulesChecked: []
          });
          await this.executiveAgent.completeCriterion(0);
          let ontologyContext = "";
          if (task.entity) {
            await this.executiveAgent.updatePhase("Ontology Query");
            const validationRules = await ontologyService.getValidationRules({ entity: task.entity });
            const completeness = await ontologyService.getCompletenessChecks({ entity: task.entity });
            ontologyContext = `

ONTOLOGY CONTEXT for ${task.entity}:
`;
            ontologyContext += `Validation Rules: ${JSON.stringify(validationRules, null, 2)}
`;
            ontologyContext += `Completeness Criteria: ${JSON.stringify(completeness, null, 2)}`;
          }
          let iteration = 0;
          let builderResponse = null;
          let qaReview = null;
          while (iteration <= task.maxRetries) {
            iteration++;
            await this.executiveAgent.updatePhase(`Iteration ${iteration}: Builder`);
            builderResponse = await this.runBuilder(
              provider,
              task,
              ontologyContext,
              qaReview
              // Pass previous QA feedback for retry
            );
            const currentSession = await this.executiveAgent.getActiveSession();
            if (currentSession) {
              for (let i = 0; i < builderResponse.requirements.length; i++) {
                const req = builderResponse.requirements[i];
                if (req.satisfied) {
                  const criterionIndex = currentSession.successCriteria.findIndex(
                    (c) => c.includes(`Builder satisfies: ${req.requirement}`)
                  );
                  if (criterionIndex !== -1) {
                    await this.executiveAgent.completeCriterion(criterionIndex);
                  }
                }
              }
            }
            await this.executiveAgent.updatePhase(`Iteration ${iteration}: QA Review`);
            qaReview = await this.runQA(
              provider,
              task.requirements,
              builderResponse
            );
            const sessionAfterQA = await this.executiveAgent.getActiveSession();
            if (sessionAfterQA) {
              for (let i = 0; i < qaReview.requirementsVerification.length; i++) {
                const verification = qaReview.requirementsVerification[i];
                if (verification.satisfied) {
                  const criterionIndex = sessionAfterQA.successCriteria.findIndex(
                    (c) => c.includes(`QA verifies: ${verification.requirement}`)
                  );
                  if (criterionIndex !== -1) {
                    await this.executiveAgent.completeCriterion(criterionIndex);
                  }
                }
              }
            }
            if (qaReview.verdict === "PASS") {
              const passSession = await this.executiveAgent.getActiveSession();
              if (passSession) {
                const passCriterionIndex = passSession.successCriteria.findIndex(
                  (c) => c.includes("QA verdict is PASS")
                );
                if (passCriterionIndex !== -1) {
                  await this.executiveAgent.completeCriterion(passCriterionIndex);
                }
              }
              await this.executiveAgent.logDecision({
                decision: `QA approved code on iteration ${iteration}`,
                rationale: `All requirements verified with ${qaReview.confidence}% confidence`,
                alternatives: [`Retry up to ${task.maxRetries} times`],
                confidence: qaReview.confidence >= 80 ? "high" : qaReview.confidence >= 50 ? "medium" : "low",
                ontologyRulesChecked: []
              });
              break;
            }
            if (iteration > task.maxRetries) {
              await this.executiveAgent.logDecision({
                decision: `QA rejected code after ${iteration} iterations - max retries exceeded`,
                rationale: `Critical blockers: ${qaReview.criticalBlockers.join(", ")}`,
                alternatives: [`Continue retrying`],
                confidence: "high",
                ontologyRulesChecked: []
              });
              break;
            }
            await this.executiveAgent.logDecision({
              decision: `QA rejected code on iteration ${iteration} - retrying`,
              rationale: `Issues found: ${qaReview.issues.length} (${qaReview.criticalBlockers.length} critical). Retrying with QA feedback.`,
              alternatives: [`Accept code anyway`, `Stop and report failure`],
              confidence: "medium",
              ontologyRulesChecked: []
            });
          }
          const response = {
            taskId: session3.id,
            builderResponse,
            qaReview,
            verdict: qaReview.verdict,
            iterations: iteration,
            finalCode: qaReview.verdict === "PASS" ? builderResponse.artifacts : void 0,
            provider,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
          const validation = await this.executiveAgent.validateCompletion();
          if (validation.allCriteriaMet) {
            await this.executiveAgent.endSession();
          }
          return response;
        } catch (error) {
          await this.executiveAgent.logDecision({
            decision: `Orchestration failed with error`,
            rationale: error instanceof Error ? error.message : String(error),
            alternatives: [],
            confidence: "high",
            ontologyRulesChecked: []
          });
          return {
            taskId: session3.id,
            builderResponse: {
              approach: "",
              artifacts: [],
              confidence: 0,
              requirements: task.requirements.map((r) => ({
                requirement: r,
                satisfied: false,
                notes: "Error occurred before builder execution"
              })),
              unmetRequirements: task.requirements,
              decisions: []
            },
            qaReview: {
              verdict: "FAIL",
              confidence: 100,
              requirementsVerification: task.requirements.map((r) => ({
                requirement: r,
                satisfied: false,
                notes: "Error occurred"
              })),
              issues: [{
                category: "gap",
                severity: "critical",
                description: error instanceof Error ? error.message : String(error),
                recommendation: "Fix the error and try again"
              }],
              criticalBlockers: ["System error occurred"],
              recommendations: [],
              summary: "Orchestration failed due to system error"
            },
            verdict: "FAIL",
            iterations: 0,
            provider: task.preferredProvider || "openai",
            error: error instanceof Error ? error.message : String(error),
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          };
        }
      }
      async runBuilder(provider, task, ontologyContext, previousQA) {
        const systemPrompt = `You are a code generation specialist. Your task is to:
1. Analyze requirements thoroughly
2. Generate clean, production-ready code
3. Provide clear explanations
4. Track requirement fulfillment

${ontologyContext}

Return your response as JSON matching this schema:
{
  "approach": "string - your implementation strategy",
  "artifacts": [{
    "filePath": "string",
    "content": "string - actual code",
    "description": "string"
  }],
  "confidence": number (0-100),
  "requirements": [{
    "requirement": "string",
    "satisfied": boolean,
    "notes": "string"
  }],
  "unmetRequirements": ["string"],
  "decisions": [{
    "decision": "string",
    "rationale": "string",
    "alternatives": ["string"],
    "confidence": number (0-100)
  }]
}`;
        let userMessage = `TASK: ${task.taskDescription}

REQUIREMENTS:
`;
        task.requirements.forEach((req, i) => {
          userMessage += `${i + 1}. ${req}
`;
        });
        if (task.constraints && task.constraints.length > 0) {
          userMessage += `
CONSTRAINTS:
`;
          task.constraints.forEach((constraint, i) => {
            userMessage += `${i + 1}. ${constraint}
`;
          });
        }
        if (previousQA) {
          userMessage += `

PREVIOUS QA FEEDBACK (iteration failed, fix these issues):
`;
          userMessage += `Verdict: ${previousQA.verdict}
`;
          userMessage += `Critical Blockers:
${previousQA.criticalBlockers.map((b) => `- ${b}`).join("\n")}
`;
          userMessage += `Issues:
${previousQA.issues.map((i) => `- [${i.severity}] ${i.description}: ${i.recommendation}`).join("\n")}`;
        }
        userMessage += `

Generate the code now. Return valid JSON only.`;
        const response = await aiClients.call(provider, {
          systemPrompt,
          userMessage,
          maxTokens: 8192
        });
        const builderResponse = JSON.parse(response.content);
        return builderResponse;
      }
      async runQA(provider, originalRequirements, builderResponse) {
        const systemPrompt = `You are an adversarial code reviewer. Your job is to:
1. DEFAULT TO REJECTION - Assume code is incomplete until proven otherwise
2. Independently verify EVERY requirement with strong evidence
3. Search for gaps, bugs, edge cases, security issues
4. Apply strict criteria: FAIL if ANY requirement unsatisfied OR critical/major issues exist
5. PASS only if ALL requirements verified AND no critical/major issues

Return your response as JSON matching this schema:
{
  "verdict": "PASS" | "FAIL",
  "confidence": number (0-100),
  "requirementsVerification": [{
    "requirement": "string",
    "satisfied": boolean,
    "notes": "string - evidence or reason"
  }],
  "issues": [{
    "category": "gap" | "bug" | "edge-case" | "security" | "quality",
    "severity": "critical" | "major" | "minor",
    "description": "string",
    "location": "string - optional",
    "recommendation": "string"
  }],
  "criticalBlockers": ["string - list of must-fix issues"],
  "recommendations": ["string"],
  "summary": "string - detailed rationale for verdict"
}`;
        const userMessage = `ORIGINAL REQUIREMENTS:
${originalRequirements.map((r, i) => `${i + 1}. ${r}`).join("\n")}

BUILDER'S RESPONSE:
Approach: ${builderResponse.approach}
Confidence: ${builderResponse.confidence}%
Builder's Requirement Assessment: ${JSON.stringify(builderResponse.requirements, null, 2)}

CODE ARTIFACTS:
${builderResponse.artifacts.map((a) => `File: ${a.filePath}
${a.content}
---`).join("\n")}

Review this code with an adversarial mindset. Do NOT trust the builder's self-assessment. Independently verify each requirement. Return valid JSON only.`;
        const response = await aiClients.call(provider, {
          systemPrompt,
          userMessage,
          maxTokens: 8192
        });
        const qaReview = JSON.parse(response.content);
        return qaReview;
      }
    };
  }
});

// server/strategic-consultant-legacy/input-processor.ts
import Anthropic4 from "@anthropic-ai/sdk";
import mammoth from "mammoth";
import * as XLSX2 from "xlsx";
import { readFileSync as readFileSync2 } from "fs";
import { createRequire } from "module";
var require2, pdf, InputProcessor;
var init_input_processor2 = __esm({
  "server/strategic-consultant-legacy/input-processor.ts"() {
    "use strict";
    require2 = createRequire(import.meta.url);
    pdf = require2("pdf-parse");
    InputProcessor = class {
      anthropic;
      constructor() {
        const apiKey = process.env.ANTHROPIC_API_KEY;
        if (!apiKey) {
          throw new Error("ANTHROPIC_API_KEY environment variable is required");
        }
        this.anthropic = new Anthropic4({ apiKey });
      }
      async processText(text2) {
        return {
          type: "text",
          content: text2.trim()
        };
      }
      async processPDF(filePath) {
        const dataBuffer = readFileSync2(filePath);
        const data = await pdf(dataBuffer);
        return {
          type: "pdf",
          content: data.text,
          metadata: {
            pageCount: data.total,
            fileName: filePath.split("/").pop()
          }
        };
      }
      async processDOCX(filePath) {
        const result = await mammoth.extractRawText({ path: filePath });
        return {
          type: "docx",
          content: result.value,
          metadata: {
            fileName: filePath.split("/").pop()
          }
        };
      }
      async processExcel(filePath) {
        const workbook = XLSX2.readFile(filePath);
        const sheets = [];
        let content = "";
        for (const sheetName of workbook.SheetNames) {
          sheets.push(sheetName);
          const worksheet = workbook.Sheets[sheetName];
          const jsonData = XLSX2.utils.sheet_to_json(worksheet, { header: 1 });
          content += `

## Sheet: ${sheetName}
`;
          content += JSON.stringify(jsonData, null, 2);
        }
        return {
          type: "xlsx",
          content: content.trim(),
          metadata: {
            fileName: filePath.split("/").pop(),
            sheets
          }
        };
      }
      async processImage(filePath, mimeType) {
        const imageBuffer = readFileSync2(filePath);
        const base64Image = imageBuffer.toString("base64");
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 4e3,
          messages: [
            {
              role: "user",
              content: [
                {
                  type: "image",
                  source: {
                    type: "base64",
                    media_type: mimeType,
                    data: base64Image
                  }
                },
                {
                  type: "text",
                  text: `Extract all text, data, diagrams, and strategic information from this image. 
              
If this appears to be a:
- Whiteboard/sketch: Describe the strategy, key points, connections, and insights
- Screenshot: Extract all visible text and data
- Chart/graph: Describe the data, trends, and implications
- Presentation slide: Extract title, bullet points, and key messages
- Document photo: OCR all text content

Provide a comprehensive extraction that captures the strategic essence.`
                }
              ]
            }
          ]
        });
        const extractedText = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        return {
          type: "image",
          content: extractedText,
          metadata: {
            fileName: filePath.split("/").pop()
          }
        };
      }
      async processFile(filePath, mimeType) {
        if (mimeType === "application/pdf") {
          return this.processPDF(filePath);
        } else if (mimeType === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
          return this.processDOCX(filePath);
        } else if (mimeType === "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" || mimeType === "application/vnd.ms-excel") {
          return this.processExcel(filePath);
        } else if (mimeType.startsWith("image/")) {
          return this.processImage(filePath, mimeType);
        } else {
          throw new Error(`Unsupported file type: ${mimeType}`);
        }
      }
      async combineInputs(inputs) {
        let combinedContent = "";
        for (const input of inputs) {
          combinedContent += `

=== ${input.type.toUpperCase()} INPUT ===
`;
          if (input.metadata?.fileName) {
            combinedContent += `File: ${input.metadata.fileName}
`;
          }
          if (input.metadata?.pageCount) {
            combinedContent += `Pages: ${input.metadata.pageCount}
`;
          }
          if (input.metadata?.sheets) {
            combinedContent += `Sheets: ${input.metadata.sheets.join(", ")}
`;
          }
          combinedContent += `
${input.content}
`;
        }
        return combinedContent.trim();
      }
    };
  }
});

// server/strategic-consultant-legacy/strategy-analyzer.ts
import Anthropic5 from "@anthropic-ai/sdk";
var StrategyAnalyzer;
var init_strategy_analyzer = __esm({
  "server/strategic-consultant-legacy/strategy-analyzer.ts"() {
    "use strict";
    init_strategy_ontology_service();
    init_grounded_analysis_service();
    init_whys_path();
    StrategyAnalyzer = class {
      anthropic;
      useGrounding;
      constructor(options) {
        const apiKey = process.env.ANTHROPIC_API_KEY;
        if (!apiKey) {
          throw new Error("ANTHROPIC_API_KEY environment variable is required");
        }
        this.anthropic = new Anthropic5({ apiKey });
        this.useGrounding = options?.useGrounding ?? isContextFoundryConfigured();
      }
      /**
       * Analyze Five Whys with optional Context Foundry grounding
       * Note: focalEntity parameter is now deprecated - CF handles entity extraction internally
       */
      async analyzeFiveWhys(input, _focalEntity) {
        let analysisInput = input;
        let groundingContext = null;
        let flaggedAssumptions = [];
        let externalClaimsForWebSearch = [];
        if (this.useGrounding) {
          try {
            const orchestration = await orchestrateAnalysis(input, "five_whys");
            analysisInput = orchestration.groundedPrompt;
            groundingContext = orchestration.cfContext;
            flaggedAssumptions = orchestration.flaggedAssumptions;
            externalClaimsForWebSearch = orchestration.externalClaimsForWebSearch;
            console.log("[StrategyAnalyzer] Five Whys analysis orchestrated with intelligent routing");
          } catch (error) {
            console.warn("[StrategyAnalyzer] Orchestration failed, proceeding without:", error);
          }
        }
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 4e3,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `You are a strategic business consultant performing a 5 Whys root cause analysis.

CRITICAL: Focus on PRACTICAL BUSINESS REASONING, not cultural anthropology or academic analysis.

Each "Why?" should probe these BUSINESS dimensions:
- Market conditions and dynamics
- Competitive positioning and dynamics
- Product capabilities and differentiation
- Customer needs and pain points
- Resource constraints and capabilities

INPUT:
${analysisInput}

Perform a systematic 5 Whys analysis using business-focused causal reasoning. Each answer should address practical business factors, NOT cultural or anthropological theories.

WRONG: "Arabic reflects deep cultural identity and power structures..."
RIGHT: "Arabic language support addresses a market gap where 60% of regional buyers prefer native-language interfaces..."

Return ONLY valid JSON with this exact structure (no markdown, no explanation):

{
  "problem_statement": "The core business problem statement",
  "why_1": {
    "question": "Why question 1 (focused on business/market factors)",
    "answer": "Business-focused answer (market conditions, competitive dynamics, customer needs)"
  },
  "why_2": {
    "question": "Why question 2 (focused on business/market factors)",
    "answer": "Business-focused answer (product capabilities, resource constraints)"
  },
  "why_3": {
    "question": "Why question 3 (focused on business/market factors)",
    "answer": "Business-focused answer (competitive positioning, market dynamics)"
  },
  "why_4": {
    "question": "Why question 4 (focused on business/market factors)",
    "answer": "Business-focused answer (customer needs, market opportunities)"
  },
  "why_5": {
    "question": "Why question 5 (focused on business/market factors)",
    "answer": "Business-focused answer (strategic positioning, market fit)"
  },
  "root_cause": "The fundamental business problem or opportunity identified",
  "strategic_implications": ["business implication 1", "business implication 2", "business implication 3"]
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("Failed to extract JSON from 5 Whys analysis response");
        }
        const result = JSON.parse(jsonMatch[0]);
        return { ...result, groundingContext, flaggedAssumptions, externalClaimsForWebSearch };
      }
      /**
       * Analyze Porter's Five Forces with optional Context Foundry grounding
       * Note: focalEntity parameter is now deprecated - CF handles entity extraction internally
       */
      async analyzePortersFiveForces(input, _focalEntity) {
        let analysisInput = input;
        let groundingContext = null;
        let flaggedAssumptions = [];
        let externalClaimsForWebSearch = [];
        if (this.useGrounding) {
          try {
            const orchestration = await orchestrateAnalysis(input, "porters");
            analysisInput = orchestration.groundedPrompt;
            groundingContext = orchestration.cfContext;
            flaggedAssumptions = orchestration.flaggedAssumptions;
            externalClaimsForWebSearch = orchestration.externalClaimsForWebSearch;
            console.log("[StrategyAnalyzer] Porter's analysis orchestrated with intelligent routing");
          } catch (error) {
            console.warn("[StrategyAnalyzer] Orchestration failed, proceeding without:", error);
          }
        }
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 4e3,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `You are a strategic consultant performing Porter's Five Forces analysis.

INPUT:
${analysisInput}

Analyze the competitive environment using Porter's Five Forces. Return ONLY valid JSON with this exact structure (no markdown, no explanation):

{
  "competitive_rivalry": {
    "level": "low|medium|high",
    "factors": ["factor 1", "factor 2", "factor 3"],
    "strategic_response": "Strategic response to competitive rivalry"
  },
  "supplier_power": {
    "level": "low|medium|high",
    "factors": ["factor 1", "factor 2"],
    "strategic_response": "Strategic response to supplier power"
  },
  "buyer_power": {
    "level": "low|medium|high",
    "factors": ["factor 1", "factor 2"],
    "strategic_response": "Strategic response to buyer power"
  },
  "threat_of_substitution": {
    "level": "low|medium|high",
    "factors": ["factor 1", "factor 2"],
    "strategic_response": "Strategic response to substitution threat"
  },
  "threat_of_new_entry": {
    "level": "low|medium|high",
    "factors": ["factor 1", "factor 2"],
    "strategic_response": "Strategic response to new entry threat"
  },
  "overall_attractiveness": "low|medium|high",
  "key_strategic_priorities": ["priority 1", "priority 2", "priority 3"]
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("Failed to extract JSON from Porter's Five Forces analysis response");
        }
        const result = JSON.parse(jsonMatch[0]);
        return { ...result, groundingContext, flaggedAssumptions, externalClaimsForWebSearch };
      }
      async recommendStrategy(fiveWhys, porters, originalInput) {
        const approaches = strategyOntologyService.getStrategicApproaches();
        const markets = strategyOntologyService.getMarketContexts();
        const approachesDesc = Object.entries(approaches).map(([id, approach]) => `- ${id}: ${approach.label} - Requires: ${approach.requires.join(", ")}`).join("\n");
        const marketsDesc = Object.entries(markets).map(([id, market]) => `- ${id}: ${market.label} - Requirements: ${market.requirements.join(", ")}`).join("\n");
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2e3,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `You are a strategic consultant making final strategic recommendations.

ORIGINAL INPUT:
${originalInput.substring(0, 2e3)}

5 WHYS ANALYSIS:
Root Cause: ${fiveWhys.root_cause}
Strategic Implications: ${fiveWhys.strategic_implications.join(", ")}

PORTER'S FIVE FORCES:
Overall Attractiveness: ${porters.overall_attractiveness}
Key Priorities: ${porters.key_strategic_priorities.join(", ")}

AVAILABLE STRATEGIC APPROACHES:
${approachesDesc}

AVAILABLE MARKETS:
${marketsDesc}

Based on the analysis, recommend:
1. 1-3 strategic approaches that best fit (use IDs: cost_leadership, differentiation_service, or blue_ocean)
2. 1 target market (use IDs: uae or usa)
3. Executive summary (2-3 sentences)

Return ONLY valid JSON (no markdown, no explanation):

{
  "recommended_approaches": ["approach_id_1", "approach_id_2"],
  "recommended_market": "market_id",
  "executive_summary": "2-3 sentence summary of strategic recommendation"
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("Failed to extract JSON from strategy recommendation response");
        }
        return JSON.parse(jsonMatch[0]);
      }
      async performFullAnalysis(input) {
        const [fiveWhys, porters] = await Promise.all([
          this.analyzeFiveWhys(input),
          this.analyzePortersFiveForces(input)
        ]);
        const recommendation = await this.recommendStrategy(fiveWhys, porters, input);
        return {
          five_whys: fiveWhys,
          porters_five_forces: porters,
          recommended_approaches: recommendation.recommended_approaches,
          recommended_market: recommendation.recommended_market,
          executive_summary: recommendation.executive_summary
        };
      }
      async analyzeWithResearch(sessionId, rootCause, whysPath, research, input) {
        const whysPathText = whysPathToText(whysPath);
        const findValidation = (fact) => {
          if (!research.validation) return null;
          const factLower = fact.toLowerCase().replace(/[^\w\s]/g, "").trim();
          return research.validation.find((v) => {
            const vClaimLower = v.claim.toLowerCase().replace(/[^\w\s]/g, "").trim();
            return factLower.includes(vClaimLower) || vClaimLower.includes(factLower);
          });
        };
        const formatFindings = (findings) => findings.map((f) => {
          const validation = findValidation(f.fact);
          let validationNote = "";
          if (validation) {
            if (validation.strength === "WEAK") {
              validationNote = ` [\u26A0\uFE0F WEAK VALIDATION: ${validation.details}]`;
            } else if (validation.strength === "MODERATE") {
              validationNote = ` [\u26A1 MODERATE VALIDATION: ${validation.details}]`;
            }
          }
          return `- ${f.fact}${validationNote} [Citation: ${f.citation}] (Confidence: ${f.confidence})`;
        }).join("\n");
        const validationSummary = research.validation && research.validation.length > 0 ? `
VALIDATION WARNINGS:
${research.validation.filter((v) => v.strength !== "STRONG").map((v) => `- ${v.claim}: ${v.strength} (${v.details})`).join("\n")}` : "";
        const researchSummary = `
MARKET DYNAMICS:
${formatFindings(research.market_dynamics)}

COMPETITIVE LANDSCAPE:
${formatFindings(research.competitive_landscape)}

LANGUAGE/CULTURAL PREFERENCES:
${formatFindings(research.language_preferences)}

BUYER BEHAVIOR:
${formatFindings(research.buyer_behavior)}

REGULATORY FACTORS:
${formatFindings(research.regulatory_factors)}
${validationSummary}

AVAILABLE SOURCES:
${research.sources.map((s) => `- ${s.title} (${s.url}) - Relevance: ${s.relevance_score}`).join("\n")}
`;
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 6e3,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `You are a strategic consultant performing a research-backed Porter's Five Forces analysis.

CRITICAL INSTRUCTIONS:
1. Do NOT make assumptions - only use validated data from the research findings below
2. Cite specific research findings for EVERY statement using the citation URLs
3. If research is inconclusive or missing for any aspect, explicitly state "Insufficient data" and note what additional research is needed
4. Base confidence levels on the quality and quantity of research available
5. All factors and responses must be grounded in the research provided

VALIDATION-AWARE ANALYSIS:
6. Research findings are marked with validation strength: \u26A0\uFE0F WEAK or \u26A1 MODERATE
7. When using WEAK findings, use qualifying language:
   - Instead of: "95% of AI projects are failing"
   - Write: "Some older studies from 2021 suggest high failure rates (95%), though this data is contested and may be outdated"
   - Or: "Contested research indicates potential challenges with AI project success"
8. WEAK validation means: outdated data (>2 years old), single-source claims, or contradicted by other evidence
9. Never state WEAK claims as definitive facts - always qualify them with appropriate caveats
10. Lower confidence scores for analysis based primarily on WEAK validation findings

STRATEGIC CONTEXT:
Root Cause: ${rootCause}

Original Input: ${input.substring(0, 1500)}

Analysis Path (5 Whys):
${whysPathText.map((w, i) => `${i + 1}. ${w}`).join("\n")}

RESEARCH FINDINGS:
${researchSummary}

ANALYSIS REQUIREMENTS:

For each of Porter's Five Forces, provide:
1. Level assessment (low/medium/high) based on research
2. Key factors with specific citations from research findings
3. Strategic response grounded in research insights
4. Confidence level (high/medium/low) based on research quality
5. insufficientData flag if research is lacking

Also generate:
1. Executive summary (3-4 sentences) incorporating root cause and key recommendations
2. Strategic recommendations (4-6 actionable recommendations based on Porter's analysis + research)
3. Each recommendation must include text, rationale, and citations

Return ONLY valid JSON with this exact structure (no markdown, no explanation):

{
  "portersAnalysis": {
    "competitive_rivalry": {
      "level": "low|medium|high",
      "factors": [
        {
          "factor": "Specific factor description",
          "citations": ["https://citation-url-1.com", "https://citation-url-2.com"]
        }
      ],
      "strategic_response": "Research-backed strategic response",
      "confidence": "high|medium|low",
      "insufficientData": false
    },
    "supplier_power": {
      "level": "low|medium|high",
      "factors": [
        {
          "factor": "Specific factor description",
          "citations": ["https://citation-url.com"]
        }
      ],
      "strategic_response": "Research-backed strategic response",
      "confidence": "high|medium|low",
      "insufficientData": false
    },
    "buyer_power": {
      "level": "low|medium|high",
      "factors": [
        {
          "factor": "Specific factor description",
          "citations": ["https://citation-url.com"]
        }
      ],
      "strategic_response": "Research-backed strategic response",
      "confidence": "high|medium|low",
      "insufficientData": false
    },
    "threat_of_substitution": {
      "level": "low|medium|high",
      "factors": [
        {
          "factor": "Specific factor description",
          "citations": ["https://citation-url.com"]
        }
      ],
      "strategic_response": "Research-backed strategic response",
      "confidence": "high|medium|low",
      "insufficientData": false
    },
    "threat_of_new_entry": {
      "level": "low|medium|high",
      "factors": [
        {
          "factor": "Specific factor description",
          "citations": ["https://citation-url.com"]
        }
      ],
      "strategic_response": "Research-backed strategic response",
      "confidence": "high|medium|low",
      "insufficientData": false
    },
    "overall_attractiveness": "low|medium|high"
  },
  "recommendations": [
    {
      "text": "Specific actionable recommendation",
      "rationale": "Why this recommendation is important based on analysis",
      "citations": ["https://citation-url.com"]
    }
  ],
  "executiveSummary": "3-4 sentence executive summary incorporating root cause and key strategic recommendations"
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          throw new Error("Failed to extract JSON from research-backed analysis response");
        }
        const parsed = JSON.parse(jsonMatch[0]);
        const normalizeForce = (force) => ({
          level: force.level,
          factors: (force.factors || []).map((f) => ({
            factor: typeof f === "string" ? f : f.factor,
            citations: Array.isArray(f.citations) ? f.citations : []
          })),
          strategic_response: force.strategic_response,
          confidence: force.confidence || "medium",
          insufficientData: force.insufficientData || false
        });
        const normalizedPorters = {
          competitive_rivalry: normalizeForce(parsed.portersAnalysis.competitive_rivalry),
          supplier_power: normalizeForce(parsed.portersAnalysis.supplier_power),
          buyer_power: normalizeForce(parsed.portersAnalysis.buyer_power),
          threat_of_substitution: normalizeForce(parsed.portersAnalysis.threat_of_substitution),
          threat_of_new_entry: normalizeForce(parsed.portersAnalysis.threat_of_new_entry),
          overall_attractiveness: parsed.portersAnalysis.overall_attractiveness || "medium"
        };
        const normalizedRecommendations = (parsed.recommendations || []).map((r) => ({
          text: r.text,
          rationale: r.rationale,
          citations: Array.isArray(r.citations) ? r.citations : []
        }));
        const confidenceScore = this.calculateOverallConfidence(normalizedPorters, research);
        const confidenceExplanation = this.generateConfidenceExplanation(confidenceScore, normalizedPorters, research, input);
        return {
          executiveSummary: parsed.executiveSummary,
          portersAnalysis: normalizedPorters,
          recommendations: normalizedRecommendations,
          researchBased: true,
          confidenceScore,
          confidenceExplanation,
          citations: research.sources
        };
      }
      calculateOverallConfidence(porters, research) {
        const confidenceMap = { high: 100, medium: 60, low: 30 };
        const forceConfidences = [
          porters.competitive_rivalry.confidence,
          porters.supplier_power.confidence,
          porters.buyer_power.confidence,
          porters.threat_of_substitution.confidence,
          porters.threat_of_new_entry.confidence
        ];
        const avgForceConfidence = forceConfidences.reduce((sum, c) => sum + confidenceMap[c], 0) / forceConfidences.length;
        const totalFindings = research.market_dynamics.length + research.competitive_landscape.length + research.language_preferences.length + research.buyer_behavior.length + research.regulatory_factors.length;
        const highConfidenceFindings = [
          ...research.market_dynamics,
          ...research.competitive_landscape,
          ...research.language_preferences,
          ...research.buyer_behavior,
          ...research.regulatory_factors
        ].filter((f) => f.confidence === "high").length;
        const researchQuality = totalFindings > 0 ? highConfidenceFindings / totalFindings * 100 : 0;
        const insufficientDataPenalty = [
          porters.competitive_rivalry.insufficientData,
          porters.supplier_power.insufficientData,
          porters.buyer_power.insufficientData,
          porters.threat_of_substitution.insufficientData,
          porters.threat_of_new_entry.insufficientData
        ].filter(Boolean).length * 10;
        const baseScore = avgForceConfidence * 0.6 + researchQuality * 0.4;
        const finalScore = Math.max(0, Math.min(100, baseScore - insufficientDataPenalty));
        return Math.round(finalScore);
      }
      generateConfidenceExplanation(score, porters, research, originalInput) {
        const explanationParts = [];
        if (score < 40) {
          explanationParts.push(`Low confidence (${score}%) due to:`);
        } else if (score < 70) {
          explanationParts.push(`Moderate confidence (${score}%) due to:`);
        } else {
          explanationParts.push(`High confidence (${score}%) due to:`);
        }
        const totalFindings = research.market_dynamics.length + research.competitive_landscape.length + research.language_preferences.length + research.buyer_behavior.length + research.regulatory_factors.length;
        const highConfidenceFindings = [
          ...research.market_dynamics,
          ...research.competitive_landscape,
          ...research.language_preferences,
          ...research.buyer_behavior,
          ...research.regulatory_factors
        ].filter((f) => f.confidence === "high").length;
        if (totalFindings < 10) {
          explanationParts.push(`- Limited research data (only ${totalFindings} findings)`);
        }
        if (highConfidenceFindings < totalFindings * 0.5) {
          explanationParts.push(`- Low research quality (only ${highConfidenceFindings}/${totalFindings} high-confidence findings)`);
        }
        const insufficientDataCount = [
          porters.competitive_rivalry.insufficientData,
          porters.supplier_power.insufficientData,
          porters.buyer_power.insufficientData,
          porters.threat_of_substitution.insufficientData,
          porters.threat_of_new_entry.insufficientData
        ].filter(Boolean).length;
        if (insufficientDataCount > 0) {
          explanationParts.push(`- ${insufficientDataCount} of 5 Porter's forces lack sufficient research data`);
        }
        const inputLower = originalInput.toLowerCase();
        const contradictions = [];
        research.language_preferences.forEach((finding) => {
          const factLower = finding.fact.toLowerCase();
          if ((inputLower.includes("arabic") || inputLower.includes("\u0639\u0631\u0628\u064A")) && (factLower.includes("english") && (factLower.includes("dominat") || factLower.includes("prefer") || factLower.includes("primary")))) {
            contradictions.push(`Research shows English dominance, contradicting any Arabic differentiation assumption: "${finding.fact}"`);
          }
          if (inputLower.includes("differentiat") && factLower.includes("not") && factLower.includes("differentiat")) {
            contradictions.push(`Research questions differentiation assumption: "${finding.fact}"`);
          }
        });
        if (contradictions.length > 0) {
          explanationParts.push(`

KEY CONTRADICTIONS TO INPUT:`);
          contradictions.forEach((c) => explanationParts.push(`- ${c}`));
        }
        return explanationParts.join("\n");
      }
      createExecutiveSummary(rootCause, recommendations, research) {
        const topRecommendations = recommendations.slice(0, 3).map((r) => r.text).join("; ");
        const keyInsights = [
          research.market_dynamics[0]?.fact,
          research.competitive_landscape[0]?.fact
        ].filter(Boolean).join(". ");
        return `Based on the root cause of "${rootCause}" and comprehensive market research, the strategic analysis reveals: ${keyInsights}. Key recommendations include: ${topRecommendations}.`;
      }
    };
  }
});

// server/strategic-consultant-legacy/version-manager.ts
var VersionManager;
var init_version_manager = __esm({
  "server/strategic-consultant-legacy/version-manager.ts"() {
    "use strict";
    VersionManager = class {
      constructor(storage2) {
        this.storage = storage2;
      }
      async createVersion(sessionId, analysis, decisions, userId) {
        const existingVersions = await this.storage.getStrategyVersionsBySession(sessionId);
        const versionNumber = existingVersions.length + 1;
        const version = await this.storage.createStrategyVersion({
          sessionId,
          versionNumber,
          analysisData: analysis,
          decisionsData: decisions,
          selectedDecisions: null,
          programStructure: null,
          status: "draft",
          createdBy: userId,
          userId
        });
        return {
          versionNumber: version.versionNumber,
          analysis: version.analysisData,
          decisions: version.decisionsData,
          selectedDecisions: version.selectedDecisions,
          programStructure: version.programStructure,
          status: version.status,
          createdBy: version.createdBy,
          createdAt: version.createdAt || void 0,
          finalizedAt: version.finalizedAt || void 0
        };
      }
      async updateVersion(sessionId, versionNumber, selectedDecisions) {
        const version = await this.storage.getStrategyVersion(sessionId, versionNumber);
        if (!version) {
          throw new Error(`Version ${versionNumber} not found for session ${sessionId}`);
        }
        if (version.status === "finalized") {
          throw new Error("Cannot update finalized version");
        }
        const updated = await this.storage.updateStrategyVersion(version.id, {
          selectedDecisions,
          status: "in_review"
        });
        return {
          versionNumber: updated.versionNumber,
          analysis: updated.analysisData,
          decisions: updated.decisionsData,
          selectedDecisions: updated.selectedDecisions,
          programStructure: updated.programStructure,
          status: updated.status,
          createdBy: updated.createdBy,
          createdAt: updated.createdAt || void 0,
          finalizedAt: updated.finalizedAt || void 0
        };
      }
      async finalizeVersion(sessionId, versionNumber, programStructure) {
        const version = await this.storage.getStrategyVersion(sessionId, versionNumber);
        if (!version) {
          throw new Error(`Version ${versionNumber} not found for session ${sessionId}`);
        }
        if (version.status === "finalized") {
          return {
            versionNumber: version.versionNumber,
            analysis: version.analysisData,
            decisions: version.decisionsData,
            selectedDecisions: version.selectedDecisions,
            programStructure: version.programStructure,
            status: version.status,
            createdBy: version.createdBy,
            createdAt: version.createdAt || void 0,
            finalizedAt: version.finalizedAt || void 0
          };
        }
        if (!version.selectedDecisions || Object.keys(version.selectedDecisions).length === 0) {
          throw new Error("Cannot finalize version without selected decisions");
        }
        const updated = await this.storage.updateStrategyVersion(version.id, {
          programStructure,
          status: "finalized",
          finalizedAt: /* @__PURE__ */ new Date()
        });
        return {
          versionNumber: updated.versionNumber,
          analysis: updated.analysisData,
          decisions: updated.decisionsData,
          selectedDecisions: updated.selectedDecisions,
          programStructure: updated.programStructure,
          status: updated.status,
          createdBy: updated.createdBy,
          createdAt: updated.createdAt || void 0,
          finalizedAt: updated.finalizedAt || void 0
        };
      }
      async compareVersions(sessionId, versionA, versionB) {
        const [vA, vB] = await Promise.all([
          this.storage.getStrategyVersion(sessionId, versionA),
          this.storage.getStrategyVersion(sessionId, versionB)
        ]);
        if (!vA || !vB) {
          throw new Error("One or both versions not found");
        }
        const analysisA = vA.analysisData;
        const analysisB = vB.analysisData;
        const decisionsA = vA.decisionsData;
        const decisionsB = vB.decisionsData;
        const approachChanged = JSON.stringify(analysisA.recommended_approaches) !== JSON.stringify(analysisB.recommended_approaches);
        const marketChanged = analysisA.recommended_market !== analysisB.recommended_market;
        const decisionsChanged = [];
        const decisionIdsA = decisionsA.decisions.map((d) => d.id);
        const decisionIdsB = decisionsB.decisions.map((d) => d.id);
        const allDecisionIds = Array.from(/* @__PURE__ */ new Set([...decisionIdsA, ...decisionIdsB]));
        for (const decisionId of allDecisionIds) {
          const decA = decisionsA.decisions.find((d) => d.id === decisionId);
          const decB = decisionsB.decisions.find((d) => d.id === decisionId);
          if (!decA || !decB || JSON.stringify(decA) !== JSON.stringify(decB)) {
            decisionsChanged.push(decisionId);
          }
        }
        let costDelta = null;
        let timelineDelta = null;
        if (vA.selectedDecisions && vB.selectedDecisions) {
          const selectedA = vA.selectedDecisions;
          const selectedB = vB.selectedDecisions;
          let totalCostMinA = 0, totalCostMaxA = 0, totalTimelineA = 0;
          let totalCostMinB = 0, totalCostMaxB = 0, totalTimelineB = 0;
          for (const decision of decisionsA.decisions) {
            const selectedOptionId = selectedA[decision.id];
            const option = decision.options.find((o) => o.id === selectedOptionId);
            if (option?.estimated_cost) {
              totalCostMinA += option.estimated_cost.min;
              totalCostMaxA += option.estimated_cost.max;
            }
            if (option?.estimated_timeline_months) {
              totalTimelineA = Math.max(totalTimelineA, option.estimated_timeline_months);
            }
          }
          for (const decision of decisionsB.decisions) {
            const selectedOptionId = selectedB[decision.id];
            const option = decision.options.find((o) => o.id === selectedOptionId);
            if (option?.estimated_cost) {
              totalCostMinB += option.estimated_cost.min;
              totalCostMaxB += option.estimated_cost.max;
            }
            if (option?.estimated_timeline_months) {
              totalTimelineB = Math.max(totalTimelineB, option.estimated_timeline_months);
            }
          }
          costDelta = {
            min_delta: totalCostMinB - totalCostMinA,
            max_delta: totalCostMaxB - totalCostMaxA
          };
          timelineDelta = totalTimelineB - totalTimelineA;
        }
        let recommendation = "";
        if (approachChanged || marketChanged) {
          recommendation = "Significant strategic changes detected. Review alignment with business objectives.";
        } else if (decisionsChanged.length > 0) {
          recommendation = "Minor decision changes. Review specific decision points that changed.";
        } else {
          recommendation = "No significant differences between versions.";
        }
        return {
          version_a: versionA,
          version_b: versionB,
          differences: {
            approach_changed: approachChanged,
            market_changed: marketChanged,
            cost_delta: costDelta,
            timeline_delta_months: timelineDelta,
            decisions_changed: decisionsChanged
          },
          recommendation
        };
      }
      async listVersions(sessionId) {
        const versions = await this.storage.getStrategyVersionsBySession(sessionId);
        return versions.map((v) => ({
          versionNumber: v.versionNumber,
          analysis: v.analysisData,
          decisions: v.decisionsData,
          selectedDecisions: v.selectedDecisions,
          programStructure: v.programStructure,
          status: v.status,
          createdBy: v.createdBy,
          createdAt: v.createdAt || void 0,
          finalizedAt: v.finalizedAt || void 0
        }));
      }
      async getLatestVersion(sessionId) {
        const versions = await this.listVersions(sessionId);
        if (versions.length === 0) return null;
        return versions.sort((a, b) => b.versionNumber - a.versionNumber)[0];
      }
      async getFinalizedVersion(sessionId) {
        const versions = await this.listVersions(sessionId);
        const finalized = versions.find((v) => v.status === "finalized");
        return finalized || null;
      }
    };
  }
});

// server/strategic-consultant-legacy/epm-converter.ts
import Anthropic6 from "@anthropic-ai/sdk";
var EPMConverter;
var init_epm_converter = __esm({
  "server/strategic-consultant-legacy/epm-converter.ts"() {
    "use strict";
    init_strategy_ontology_service();
    init_ontology_service();
    init_quality_gate_runner();
    EPMConverter = class {
      anthropic;
      constructor() {
        const apiKey = process.env.ANTHROPIC_API_KEY;
        if (!apiKey) {
          throw new Error("ANTHROPIC_API_KEY environment variable is required");
        }
        this.anthropic = new Anthropic6({ apiKey });
      }
      async convertToEPM(analysis, decisions, selectedDecisions) {
        const selectedApproach = this.extractSelectedApproach(analysis, selectedDecisions);
        const selectedMarket = this.normalizeMarket(analysis.recommended_market);
        const workstreams2 = strategyOntologyService.allocateWorkstreams(
          selectedApproach,
          selectedMarket
        );
        const costEstimate = strategyOntologyService.calculateCostEstimate(
          selectedApproach,
          selectedMarket
        );
        const programTitle = await this.generateProgramTitle(analysis, selectedApproach);
        const programDescription = await this.generateProgramDescription(
          analysis,
          selectedApproach,
          selectedMarket
        );
        const enrichedWorkstreams = await this.enrichWorkstreamsWithTasks(
          workstreams2,
          analysis,
          selectedApproach,
          costEstimate
        );
        const objectives = this.extractObjectives(analysis);
        const successCriteria = this.extractSuccessCriteria(analysis);
        const keyRisks = this.extractKeyRisks(analysis);
        const [stageGates2, kpis2, benefits2, risks2, funding, resources2] = await Promise.all([
          this.generateStageGates(analysis, selectedApproach),
          this.generateKPIs(analysis, objectives),
          this.generateBenefits(analysis, costEstimate),
          this.generateRisks(analysis),
          this.generateFundingPlan(costEstimate),
          this.generateResourceRequirements(workstreams2, costEstimate)
        ]);
        const resourcePlan = this.transformResourcesToResourcePlan(resources2);
        console.log("[EPM Converter] Standard path conversion complete - generated resourcePlan with", resourcePlan.summary.totalFte, "total FTEs");
        const benefitsRealization = this.transformBenefitsToBenefitsRealization(benefits2);
        console.log("[EPM Converter] Generated benefitsRealization with", benefitsRealization.summary?.totalBenefits, "benefits");
        const program = {
          title: programTitle,
          description: programDescription,
          objectives,
          strategic_approach: selectedApproach,
          market_context: selectedMarket,
          cost_estimate: {
            total_min: costEstimate?.min || 0,
            total_max: costEstimate?.max || 0,
            currency: "USD"
          },
          timeline: {
            total_months: costEstimate?.timeline_months || 12
          },
          workstreams: enrichedWorkstreams,
          success_criteria: successCriteria,
          key_risks: keyRisks,
          stage_gates: stageGates2,
          kpis: kpis2,
          benefits: benefits2,
          benefitsRealization,
          // Wrapped benefits for export compatibility
          risks: risks2,
          funding,
          resources: resources2,
          resourcePlan
          // FTE-based allocation for export compatibility
        };
        this.runQualityGateValidation(enrichedWorkstreams, stageGates2, costEstimate?.timeline_months || 12);
        return program;
      }
      /**
       * Run quality gate validation on the EPM output
       * Maps EPM structures to validator types and runs quality checks
       */
      runQualityGateValidation(epmWorkstreams, epmStageGates, totalMonths) {
        try {
          const validatorWorkstreams = epmWorkstreams.map((ws2, index2) => ({
            id: ws2.id,
            name: ws2.title,
            description: ws2.description,
            deliverables: ws2.tasks.map((t, taskIndex) => ({
              id: t.id,
              name: t.title,
              description: t.description,
              dueMonth: Math.ceil((index2 + 1) * (totalMonths / epmWorkstreams.length)),
              effort: `${t.estimated_hours} hours`
            })),
            owner: "Program Manager",
            startMonth: index2 * 2,
            // Estimate based on position
            endMonth: Math.min((index2 + 1) * 3, totalMonths),
            dependencies: index2 > 0 ? [epmWorkstreams[index2 - 1].id] : [],
            confidence: ws2.confidence
          }));
          const validatorTimeline = {
            totalMonths,
            phases: [{
              phase: 1,
              name: "Execution",
              startMonth: 0,
              endMonth: totalMonths,
              description: "Program execution phase",
              keyMilestones: epmStageGates.map((g) => g.name),
              workstreamIds: validatorWorkstreams.map((w) => w.id)
            }],
            criticalPath: validatorWorkstreams.map((w) => w.id),
            confidence: 0.85
          };
          const validatorStageGates = {
            gates: epmStageGates.map((g, idx) => ({
              id: `gate-${idx + 1}`,
              name: g.name,
              month: (idx + 1) * Math.floor(totalMonths / (epmStageGates.length + 1)),
              criteria: g.criteria,
              deliverables: g.deliverables,
              approvers: ["Steering Committee"],
              confidence: 0.85
            })),
            confidence: 0.85
          };
          const report = qualityGateRunner.runQualityGate(
            validatorWorkstreams,
            validatorTimeline,
            validatorStageGates,
            "Standard EPM conversion"
          );
          console.log("[EPM Converter] Quality gate report:", {
            passed: report.overallPassed,
            totalIssues: report.totalIssues,
            errors: report.errorCount,
            warnings: report.warningCount,
            corrections: report.corrections.length
          });
        } catch (error) {
          console.error("[EPM Converter] Quality gate validation error:", error);
        }
      }
      normalizeMarket(recommendedMarket) {
        if (!recommendedMarket) {
          return "usa";
        }
        const marketLower = recommendedMarket.toLowerCase();
        if (marketLower.includes("uae") || marketLower.includes("emirates") || marketLower.includes("dubai")) {
          return "uae";
        }
        if (marketLower.includes("usa") || marketLower.includes("united states") || marketLower.includes("america")) {
          return "usa";
        }
        return "usa";
      }
      extractSelectedApproach(analysis, selectedDecisions) {
        for (const [decisionId, optionId] of Object.entries(selectedDecisions)) {
          if (decisionId.includes("approach") || decisionId.includes("strategy")) {
            const option = optionId.toLowerCase();
            if (option.includes("cost") && option.includes("leadership")) {
              return "cost_leadership";
            }
            if (option.includes("differentiation") || option.includes("service")) {
              return "differentiation_service";
            }
            if (option.includes("blue") && option.includes("ocean")) {
              return "blue_ocean";
            }
          }
        }
        return analysis.recommended_approaches[0] || "cost_leadership";
      }
      async generateProgramTitle(analysis, approach) {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 100,
          temperature: 0.5,
          messages: [
            {
              role: "user",
              content: `Generate a concise, professional program title (max 8 words) for this strategic initiative:

ROOT CAUSE: ${analysis.five_whys.root_cause}
APPROACH: ${approach.replace("_", " ")}
EXECUTIVE SUMMARY: ${analysis.executive_summary}

Return ONLY the title, nothing else.`
            }
          ]
        });
        const title = response.content.filter((block) => block.type === "text").map((block) => block.text).join("");
        return title.trim().replace(/['"]/g, "");
      }
      async generateProgramDescription(analysis, approach, market) {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 300,
          temperature: 0.4,
          messages: [
            {
              role: "user",
              content: `Write a 2-3 paragraph program description for:

ROOT CAUSE: ${analysis.five_whys.root_cause}
STRATEGIC APPROACH: ${approach.replace("_", " ")}
MARKET: ${market.toUpperCase()}
EXECUTIVE SUMMARY: ${analysis.executive_summary}

The description should explain:
1. What problem this program solves
2. How the strategic approach addresses it
3. Expected business impact

Return ONLY the description, nothing else.`
            }
          ]
        });
        return response.content.filter((block) => block.type === "text").map((block) => block.text).join("").trim();
      }
      async enrichWorkstreamsWithTasks(workstreams2, analysis, approach, costEstimate) {
        const enrichedWorkstreams = [];
        for (let i = 0; i < workstreams2.length; i++) {
          const ws2 = workstreams2[i];
          const tasks2 = await this.generateTasksForWorkstream(ws2, analysis, approach);
          const confidence = this.calculateWorkstreamConfidence(i, workstreams2.length, ws2.label);
          enrichedWorkstreams.push({
            id: ws2.id,
            title: ws2.label,
            description: `Strategic workstream focused on ${ws2.label.toLowerCase()} to support ${approach.replace("_", " ")} approach`,
            strategic_purpose: `Deliver ${ws2.label.toLowerCase()} capabilities required for strategy execution`,
            cost_allocation: {
              min: Math.round(ws2.cost_allocation * 0.8),
              max: Math.round(ws2.cost_allocation * 1.2)
            },
            timeline_months: costEstimate?.timeline_months || 12,
            required_team: this.estimateTeamSize(ws2),
            tasks: tasks2,
            confidence
          });
        }
        return enrichedWorkstreams;
      }
      async generateTasksForWorkstream(workstream, analysis, approach) {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2e3,
          temperature: 0.4,
          messages: [
            {
              role: "user",
              content: `Generate 4-6 concrete tasks for the "${workstream.label}" workstream.

STRATEGIC CONTEXT:
- Approach: ${approach.replace("_", " ")}
- Root Cause: ${analysis.five_whys.root_cause.substring(0, 200)}

Each task should be:
- Specific and actionable
- Include clear deliverables
- Have realistic hour estimates (20-160 hours)
- Marked with priority (critical/high/medium/low)

Return ONLY valid JSON (no markdown):

{
  "tasks": [
    {
      "id": "task_1",
      "title": "Task Title",
      "description": "Detailed description of what needs to be done",
      "priority": "high",
      "estimated_hours": 80,
      "dependencies": [],
      "deliverables": ["deliverable 1", "deliverable 2"]
    }
  ]
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          return this.createDefaultTasks(workstream);
        }
        try {
          const parsed = JSON.parse(jsonMatch[0]);
          return parsed.tasks || this.createDefaultTasks(workstream);
        } catch {
          return this.createDefaultTasks(workstream);
        }
      }
      createDefaultTasks(workstream) {
        return [
          {
            id: `${workstream.id}_task_1`,
            title: `Initialize ${workstream.label}`,
            description: `Set up foundational elements for ${workstream.label} workstream`,
            priority: "high",
            estimated_hours: 40,
            dependencies: [],
            deliverables: ["Setup complete", "Initial documentation"]
          },
          {
            id: `${workstream.id}_task_2`,
            title: `Implement ${workstream.label} Core`,
            description: `Build core capabilities for ${workstream.label}`,
            priority: "high",
            estimated_hours: 120,
            dependencies: [`${workstream.id}_task_1`],
            deliverables: ["Core implementation", "Test results"]
          },
          {
            id: `${workstream.id}_task_3`,
            title: `Validate ${workstream.label}`,
            description: `Validate and refine ${workstream.label} deliverables`,
            priority: "medium",
            estimated_hours: 60,
            dependencies: [`${workstream.id}_task_2`],
            deliverables: ["Validation report", "Refinement plan"]
          }
        ];
      }
      estimateTeamSize(workstream) {
        const teamSize = workstream.team_size;
        if (teamSize <= 2) {
          return [
            { role: "Senior Specialist", count: 1 },
            { role: "Specialist", count: 1 }
          ];
        } else if (teamSize <= 5) {
          return [
            { role: "Team Lead", count: 1 },
            { role: "Senior Specialist", count: 1 },
            { role: "Specialist", count: teamSize - 2 }
          ];
        } else {
          return [
            { role: "Workstream Manager", count: 1 },
            { role: "Team Lead", count: 1 },
            { role: "Senior Specialist", count: 2 },
            { role: "Specialist", count: teamSize - 4 }
          ];
        }
      }
      /**
       * Calculate workstream confidence based on position and type.
       * Earlier workstreams (foundational) get higher confidence,
       * later workstreams (dependent on earlier work) get lower confidence.
       * Range: 0.60 - 0.90 with variation based on workstream characteristics.
       */
      calculateWorkstreamConfidence(index2, totalCount, label) {
        const positionFactor = totalCount > 1 ? index2 / (totalCount - 1) : 0;
        const baseConfidence = 0.9 - positionFactor * 0.25;
        const labelLower = label.toLowerCase();
        let keywordAdjustment = 0;
        if (labelLower.includes("foundation") || labelLower.includes("core") || labelLower.includes("infrastructure") || labelLower.includes("platform")) {
          keywordAdjustment = 0.05;
        } else if (labelLower.includes("innovation") || labelLower.includes("experimental") || labelLower.includes("pilot") || labelLower.includes("research")) {
          keywordAdjustment = -0.05;
        } else if (labelLower.includes("market") || labelLower.includes("expansion") || labelLower.includes("international")) {
          keywordAdjustment = -0.03;
        }
        const variation = (Math.random() - 0.5) * 0.04;
        const confidence = Math.max(0.6, Math.min(0.9, baseConfidence + keywordAdjustment + variation));
        return Math.round(confidence * 100) / 100;
      }
      extractObjectives(analysis) {
        return analysis.five_whys.strategic_implications.slice(0, 3);
      }
      extractSuccessCriteria(analysis) {
        if (analysis.porters_five_forces?.key_strategic_priorities) {
          return analysis.porters_five_forces.key_strategic_priorities.map(
            (priority) => `Achieve measurable progress in: ${priority}`
          );
        }
        return [
          "Achieve product-market fit within first 6 months",
          "Establish sustainable revenue streams",
          "Build operational infrastructure for scale"
        ];
      }
      extractKeyRisks(analysis) {
        const risks2 = [];
        const forces = analysis.porters_five_forces;
        if (forces?.competitive_rivalry?.level === "high") {
          risks2.push(`High competitive rivalry: ${forces.competitive_rivalry.factors[0]}`);
        }
        if (forces?.threat_of_substitution?.level === "high") {
          risks2.push(`Substitution risk: ${forces.threat_of_substitution.factors[0]}`);
        }
        if (forces?.buyer_power?.level === "high") {
          risks2.push(`Buyer power pressure: ${forces.buyer_power.factors[0]}`);
        }
        return risks2.length > 0 ? risks2 : ["Market dynamics may shift", "Resource constraints", "Execution challenges"];
      }
      async generateStageGates(analysis, approach) {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 2e3,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `Generate 5 stage gates (G0-G4) for this strategic program:

APPROACH: ${approach.replace("_", " ")}
ROOT CAUSE: ${analysis.five_whys.root_cause}

For each gate, provide:
- name: Clear gate name
- criteria: 3-5 specific pass/fail criteria
- deliverables: 3-5 required deliverables

Return ONLY valid JSON:

{
  "stage_gates": [
    {
      "gate": "G0",
      "name": "Program Initiation",
      "criteria": ["criterion 1", "criterion 2"],
      "deliverables": ["deliverable 1", "deliverable 2"]
    }
  ]
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          try {
            const parsed = JSON.parse(jsonMatch[0]);
            return parsed.stage_gates || this.getDefaultStageGates();
          } catch {
            return this.getDefaultStageGates();
          }
        }
        return this.getDefaultStageGates();
      }
      getDefaultStageGates() {
        return [
          { gate: "G0", name: "Program Initiation", criteria: ["Business case approved", "Resources allocated"], deliverables: ["Program charter", "Initial plan"] },
          { gate: "G1", name: "Planning Complete", criteria: ["Detailed plan approved", "Risks identified"], deliverables: ["Program plan", "Risk register"] },
          { gate: "G2", name: "Design Complete", criteria: ["Solution designed", "Architecture approved"], deliverables: ["Design documentation", "Technical specifications"] },
          { gate: "G3", name: "Implementation Complete", criteria: ["All features delivered", "Testing passed"], deliverables: ["Implemented solution", "Test reports"] },
          { gate: "G4", name: "Program Closure", criteria: ["Benefits realized", "Lessons captured"], deliverables: ["Final report", "Lessons learned"] }
        ];
      }
      async generateKPIs(analysis, objectives) {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1500,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `Generate 5-7 KPIs aligned with these strategic objectives:

OBJECTIVES:
${objectives.map((o, i) => `${i + 1}. ${o}`).join("\n")}

ROOT CAUSE: ${analysis.five_whys.root_cause}

Each KPI should have:
- name: Concise KPI name
- description: What it measures
- target: Specific measurable target
- measurement_frequency: How often measured
- owner: Who owns this KPI

Return ONLY valid JSON:

{
  "kpis": [
    {
      "name": "Revenue Growth",
      "description": "Year-over-year revenue increase",
      "target": "25% increase",
      "measurement_frequency": "Monthly",
      "owner": "CFO"
    }
  ]
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          try {
            const parsed = JSON.parse(jsonMatch[0]);
            return parsed.kpis || this.getDefaultKPIs();
          } catch {
            return this.getDefaultKPIs();
          }
        }
        return this.getDefaultKPIs();
      }
      getDefaultKPIs() {
        return [
          { name: "Program ROI", description: "Return on investment", target: ">200%", measurement_frequency: "Quarterly", owner: "Program Manager" },
          { name: "Budget Variance", description: "Actual vs planned spend", target: "<5%", measurement_frequency: "Monthly", owner: "Finance Lead" },
          { name: "Milestone Achievement", description: "On-time delivery rate", target: ">90%", measurement_frequency: "Monthly", owner: "Program Manager" }
        ];
      }
      async generateBenefits(analysis, costEstimate) {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1500,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `Generate 4-6 quantified benefits for this program:

ROOT CAUSE: ${analysis.five_whys.root_cause}
EXECUTIVE SUMMARY: ${analysis.executive_summary}
PROGRAM INVESTMENT: $${costEstimate?.min?.toLocaleString() || "2M"} - $${costEstimate?.max?.toLocaleString() || "4M"}

Benefits should be:
- Name: Short benefit title (2-5 words)
- Category: Financial, Operational, Strategic, Customer, or Risk
- Description: Clear benefit statement
- Quantified value: Specific dollar or % value
- Measurable target: Specific measurable goal with baseline and target
- Realization timeline: When benefit will be realized

Return ONLY valid JSON:

{
  "benefits": [
    {
      "name": "Revenue Growth",
      "category": "Financial",
      "description": "Revenue increase from new market expansion",
      "quantified_value": "$5M annual recurring revenue",
      "measurable_target": "Increase annual revenue from $10M to $15M by Q4",
      "realization_timeline": "Month 12-18"
    }
  ]
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          try {
            const parsed = JSON.parse(jsonMatch[0]);
            const rawBenefits = parsed.benefits || [];
            return this.transformBenefits(rawBenefits);
          } catch {
            return this.getDefaultBenefits();
          }
        }
        return this.getDefaultBenefits();
      }
      getDefaultBenefits() {
        return [
          {
            name: "Revenue Growth",
            category: "Financial",
            description: "Revenue growth from strategic initiatives",
            quantified_value: "+20% annual revenue",
            measurable_target: "Increase annual revenue from baseline to +20% by end of program",
            realization_timeline: "Month 12"
          },
          {
            name: "Cost Optimization",
            category: "Operational",
            description: "Operational efficiency improvement",
            quantified_value: "15% cost reduction",
            measurable_target: "Reduce operational costs by 15% from current baseline",
            realization_timeline: "Month 6"
          },
          {
            name: "Market Position",
            category: "Strategic",
            description: "Enhanced competitive market position",
            quantified_value: "Top 3 market position",
            measurable_target: "Achieve top 3 market position in target segment by month 18",
            realization_timeline: "Month 18"
          }
        ];
      }
      /**
       * Transform raw benefits to ensure all have name and measurable_target fields.
       * Uses keyword-based target generation when targets are missing.
       */
      transformBenefits(rawBenefits) {
        return rawBenefits.map((benefit, index2) => {
          const description = benefit.description || "";
          const category = benefit.category || "Strategic";
          const name = benefit.name || this.generateBenefitName(description, category, index2);
          const measurableTarget = benefit.measurable_target || this.generateMeasurableTarget(description, category, benefit.quantified_value);
          const quantifiedValue = benefit.quantified_value || this.generateQuantifiedValue(description, category);
          return {
            name,
            category,
            description,
            quantified_value: quantifiedValue,
            measurable_target: measurableTarget,
            realization_timeline: benefit.realization_timeline || "Month 12"
          };
        });
      }
      /**
       * Generate a benefit name from description
       */
      generateBenefitName(description, category, index2) {
        const descLower = description.toLowerCase();
        if (descLower.includes("revenue")) return "Revenue Growth";
        if (descLower.includes("cost") || descLower.includes("efficiency")) return "Cost Optimization";
        if (descLower.includes("customer") || descLower.includes("satisfaction")) return "Customer Experience";
        if (descLower.includes("market") || descLower.includes("share")) return "Market Position";
        if (descLower.includes("risk")) return "Risk Reduction";
        if (descLower.includes("time") || descLower.includes("speed")) return "Time-to-Value";
        if (descLower.includes("quality")) return "Quality Improvement";
        return `${category} Benefit ${index2 + 1}`;
      }
      /**
       * Generate measurable target based on keyword analysis
       */
      generateMeasurableTarget(description, category, quantifiedValue) {
        const descLower = description.toLowerCase();
        if (descLower.includes("revenue")) {
          return `Achieve ${quantifiedValue || "+20%"} revenue increase from baseline by program completion`;
        }
        if (descLower.includes("cost") || descLower.includes("efficiency") || descLower.includes("reduction")) {
          return `Reduce operational costs by ${quantifiedValue || "15%"} from current baseline`;
        }
        if (descLower.includes("customer") || descLower.includes("satisfaction") || descLower.includes("experience")) {
          return `Improve customer satisfaction score from current baseline to ${quantifiedValue || "+15 points NPS"}`;
        }
        if (descLower.includes("market") || descLower.includes("share") || descLower.includes("position")) {
          return `Capture ${quantifiedValue || "10%"} additional market share in target segment`;
        }
        if (descLower.includes("time") || descLower.includes("speed") || descLower.includes("faster")) {
          return `Reduce time-to-market by ${quantifiedValue || "30%"} compared to current process`;
        }
        if (descLower.includes("risk")) {
          return `Reduce identified risk exposure by ${quantifiedValue || "40%"} through mitigation measures`;
        }
        if (descLower.includes("quality")) {
          return `Improve quality metrics by ${quantifiedValue || "25%"} from baseline`;
        }
        const categoryTargets = {
          "Financial": `Achieve ${quantifiedValue || "20%"} improvement in financial metrics by program end`,
          "Operational": `Improve operational efficiency by ${quantifiedValue || "25%"} from baseline`,
          "Strategic": `Achieve strategic milestone with ${quantifiedValue || "measurable"} impact`,
          "Customer": `Improve customer metrics by ${quantifiedValue || "15%"} from baseline`,
          "Risk": `Reduce risk exposure by ${quantifiedValue || "30%"} through program initiatives`
        };
        return categoryTargets[category] || `Achieve ${quantifiedValue || "target"} improvement by program completion`;
      }
      /**
       * Generate quantified value based on keyword analysis
       */
      generateQuantifiedValue(description, category) {
        const descLower = description.toLowerCase();
        if (descLower.includes("revenue")) return "+20% annual revenue";
        if (descLower.includes("cost")) return "15% cost reduction";
        if (descLower.includes("customer")) return "+15 points NPS";
        if (descLower.includes("market")) return "10% market share gain";
        if (descLower.includes("time")) return "30% faster delivery";
        if (descLower.includes("risk")) return "40% risk reduction";
        if (descLower.includes("quality")) return "25% quality improvement";
        const categoryDefaults = {
          "Financial": "20% financial improvement",
          "Operational": "25% efficiency gain",
          "Strategic": "Strategic milestone achievement",
          "Customer": "15% customer satisfaction increase",
          "Risk": "30% risk mitigation"
        };
        return categoryDefaults[category] || "Measurable improvement";
      }
      async generateRisks(analysis) {
        const response = await this.anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1500,
          temperature: 0.3,
          messages: [
            {
              role: "user",
              content: `Generate 5-7 program risks with mitigation strategies:

PORTER'S FIVE FORCES:
- Competitive Rivalry: ${analysis.porters_five_forces.competitive_rivalry.level}
- Buyer Power: ${analysis.porters_five_forces.buyer_power.level}
- Supplier Power: ${analysis.porters_five_forces.supplier_power.level}

ROOT CAUSE: ${analysis.five_whys.root_cause}

For each risk:
- description: Clear risk description
- likelihood: low/medium/high
- impact: low/medium/high
- mitigation_strategy: Specific mitigation approach

Return ONLY valid JSON:

{
  "risks": [
    {
      "description": "Market conditions change unexpectedly",
      "likelihood": "medium",
      "impact": "high",
      "mitigation_strategy": "Quarterly market reviews and adaptive planning"
    }
  ]
}`
            }
          ]
        });
        const textContent = response.content.filter((block) => block.type === "text").map((block) => block.text).join("\n");
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          try {
            const parsed = JSON.parse(jsonMatch[0]);
            return parsed.risks || this.getDefaultRisks();
          } catch {
            return this.getDefaultRisks();
          }
        }
        return this.getDefaultRisks();
      }
      getDefaultRisks() {
        return [
          { description: "Resource availability", likelihood: "medium", impact: "high", mitigation_strategy: "Maintain backup resource pool" },
          { description: "Technical complexity", likelihood: "medium", impact: "medium", mitigation_strategy: "Phased implementation approach" },
          { description: "Market dynamics shift", likelihood: "low", impact: "high", mitigation_strategy: "Regular market monitoring" }
        ];
      }
      async generateFundingPlan(costEstimate) {
        const totalCost = costEstimate?.max || 2e6;
        const timeline = costEstimate?.timeline_months || 12;
        return {
          sources: [
            { source: "Operating Budget", amount: Math.floor(totalCost * 0.6) },
            { source: "Capital Investment", amount: Math.floor(totalCost * 0.4) }
          ],
          timeline: [
            { phase: "Initiation", amount: Math.floor(totalCost * 0.2), timing: "Month 1" },
            { phase: "Execution", amount: Math.floor(totalCost * 0.6), timing: `Months 2-${Math.floor(timeline * 0.8)}` },
            { phase: "Closure", amount: Math.floor(totalCost * 0.2), timing: `Month ${timeline}` }
          ]
        };
      }
      async generateResourceRequirements(workstreams2, costEstimate) {
        const resources2 = [
          {
            role: "Program Manager",
            count: 1,
            skillset: ["Program management", "Stakeholder engagement", "Risk management"],
            duration_months: costEstimate?.timeline_months || 12
          }
        ];
        const totalTeamSize = workstreams2.reduce((sum, ws2) => sum + ws2.team_size, 0);
        if (totalTeamSize > 10) {
          resources2.push({
            role: "Workstream Leads",
            count: workstreams2.length,
            skillset: ["Domain expertise", "Team leadership", "Delivery management"],
            duration_months: costEstimate?.timeline_months || 12
          });
        }
        resources2.push({
          role: "Specialists",
          count: Math.max(totalTeamSize - workstreams2.length - 1, 5),
          skillset: ["Technical delivery", "Subject matter expertise"],
          duration_months: costEstimate?.timeline_months || 12
        });
        return resources2;
      }
      /**
       * Transform headcount-based resources to resourcePlan format for export compatibility.
       * Uses normalization rule per implementation orders:
       * - count <= 10: treat as headcount, keep as-is (1 headcount = 1.0 FTE)
       * - count > 10: treat as percentage from LLM, convert to decimal (75  0.75)
       * This ensures exports show proper decimal FTEs (1.0, 2.0, 0.75) instead of raw percentages.
       */
      transformResourcesToResourcePlan(resources2) {
        const fixes = [];
        let totalFte = 0;
        let totalHeadcount = 0;
        const internalTeam = resources2.map((resource) => {
          const rawValue = resource.count;
          let fteValue;
          let isHeadcount = false;
          if (rawValue > 10) {
            fteValue = Math.round(rawValue / 100 * 100) / 100;
            fixes.push(`${resource.role}: ${rawValue}% \u2192 ${fteValue} FTE`);
          } else {
            fteValue = rawValue;
            isHeadcount = true;
          }
          totalFte += fteValue;
          if (isHeadcount) {
            totalHeadcount += rawValue;
          }
          return {
            role: resource.role,
            fte: fteValue,
            responsibilities: resource.skillset.join(", "),
            durationMonths: resource.duration_months
          };
        });
        if (fixes.length > 0) {
          console.log(`[EPM Converter] FTE normalization fixes: ${fixes.join("; ")}`);
        } else {
          console.log("[EPM Converter] FTE normalization: no fixes needed, all values valid");
        }
        return {
          internalTeam,
          externalResources: [],
          // Standard path doesn't generate external resources
          summary: {
            totalFte,
            totalHeadcount
          }
        };
      }
      /**
       * Transform benefits array to benefitsRealization structure for export compatibility.
       * The export system expects benefitsRealization.benefits, not just benefits array.
       */
      transformBenefitsToBenefitsRealization(benefits2) {
        const categories = Array.from(new Set(benefits2.map((b) => b.category)));
        return {
          benefits: benefits2.map((b) => ({
            ...b,
            // Ensure fields are available for CSV export with correct names
            metric: b.quantified_value,
            target: b.measurable_target,
            timeframe: b.realization_timeline
          })),
          summary: {
            totalBenefits: benefits2.length,
            categories
          }
        };
      }
      async validateEPMStructure(program) {
        const issues = [];
        const warnings = [];
        if (!program.title || program.title.length < 5) {
          issues.push("Program title must be at least 5 characters");
        }
        if (!program.description || program.description.length < 50) {
          issues.push("Program description must be at least 50 characters");
        }
        if (program.objectives.length === 0) {
          issues.push("Program must have at least one objective");
        }
        if (program.workstreams.length === 0) {
          issues.push("Program must have at least one workstream");
        }
        for (const ws2 of program.workstreams) {
          if (ws2.tasks.length === 0) {
            warnings.push(`Workstream "${ws2.title}" has no tasks`);
          }
          if (ws2.cost_allocation.min <= 0 || ws2.cost_allocation.max <= 0) {
            warnings.push(`Workstream "${ws2.title}" has invalid cost allocation`);
          }
        }
        if (program.cost_estimate.total_min > program.cost_estimate.total_max) {
          issues.push("Min cost cannot exceed max cost");
        }
        return {
          valid: issues.length === 0,
          issues,
          warnings
        };
      }
      async validateAgainstOntology(program) {
        const programData = {
          title: program.title,
          description: program.description,
          objectives: program.objectives,
          budget: program.cost_estimate.total_max,
          timelineDays: program.timeline.total_months * 30,
          status: "planning",
          successCriteria: program.success_criteria,
          workstreams: program.workstreams,
          stage_gates: program.stage_gates,
          kpis: program.kpis,
          benefits: program.benefits,
          risks: program.risks,
          funding: program.funding,
          resources: program.resources
        };
        const [validation, baseCompleteness] = await Promise.all([
          ontologyService.validateEntityData("Program", programData),
          ontologyService.checkCompleteness("Program", programData)
        ]);
        const criticalChecks = {
          passed: 0,
          total: 4,
          fields: [
            { check: program.workstreams.length > 0, description: "Programs must have defined work (tasks or workstreams)" },
            { check: program.stage_gates.length >= 5, description: "Programs must have all standard stage gates (G0-G4)" },
            { check: program.benefits.length > 0, description: "Programs must define expected benefits" },
            { check: program.funding.sources.length > 0, description: "Programs must have identified funding sources" }
          ]
        };
        const importantChecks = {
          passed: 0,
          total: 3,
          fields: [
            { check: program.kpis.length >= 3 && program.kpis.length <= 7, description: "Programs should have 3-7 KPIs to measure success" },
            { check: program.risks.length > 0, description: "Programs should conduct risk assessment" },
            { check: program.resources.length > 0, description: "Programs should have allocated resources" }
          ]
        };
        criticalChecks.passed = criticalChecks.fields.filter((f) => f.check).length;
        importantChecks.passed = importantChecks.fields.filter((f) => f.check).length;
        const totalScore = criticalChecks.passed * 3 + importantChecks.passed * 2;
        const maxScore = criticalChecks.total * 3 + importantChecks.total * 2;
        const missingFields = [
          ...criticalChecks.fields.filter((f) => !f.check).map((f) => ({ importance: "critical", description: f.description })),
          ...importantChecks.fields.filter((f) => !f.check).map((f) => ({ importance: "important", description: f.description }))
        ];
        const completeness = {
          score: totalScore,
          maxScore,
          critical: {
            passed: criticalChecks.passed,
            total: criticalChecks.total
          },
          important: {
            passed: importantChecks.passed,
            total: importantChecks.total
          },
          niceToHave: {
            passed: 0,
            total: 0
          },
          missingFields
        };
        const recommendations = [];
        const completenessPercentage = maxScore > 0 ? Math.round(totalScore / maxScore * 100) : 0;
        if (completenessPercentage < 100) {
          recommendations.push(`Consider adding more detail to improve completeness (currently ${completenessPercentage}%)`);
        }
        if (missingFields.length > 0) {
          const critical = missingFields.filter((f) => f.importance === "critical");
          if (critical.length > 0) {
            recommendations.push(`Add critical fields: ${critical.map((f) => f.description.split(" ")[3] || "").join(", ")}`);
          }
        }
        if (validation.warnings && validation.warnings.length > 0) {
          validation.warnings.forEach((w) => {
            recommendations.push(`Warning: ${w.message}`);
          });
        }
        return {
          valid: validation.isValid && criticalChecks.passed === criticalChecks.total,
          validation,
          completeness,
          recommendations
        };
      }
    };
  }
});

// server/strategic-consultant-legacy/epm-integrator.ts
var EPMIntegrator, epmIntegrator;
var init_epm_integrator = __esm({
  "server/strategic-consultant-legacy/epm-integrator.ts"() {
    "use strict";
    init_storage();
    EPMIntegrator = class {
      /**
       * Integrates a Strategic Consultant EPM program into the main EPM suite database.
       * Creates actual database records for programs, workstreams, tasks, stage gates, KPIs, benefits, risks, and resources.
       */
      async integrateToEPMSuite(epmProgram, userId, sessionId, versionId) {
        console.log(`[EPMIntegrator] Starting integration for session ${sessionId}`);
        const summary = {
          programId: "",
          workstreamsCreated: 0,
          tasksCreated: 0,
          stageGatesCreated: 0,
          kpisCreated: 0,
          benefitsCreated: 0,
          risksCreated: 0,
          fundingSourcesCreated: 0,
          resourcesCreated: 0
        };
        try {
          const program = await this.createProgram(epmProgram, userId);
          summary.programId = program.id;
          console.log(`[EPMIntegrator] Created program: ${program.id}`);
          await storage.updateStrategyVersion(versionId, {
            convertedProgramId: program.id
          });
          console.log(`[EPMIntegrator] Marked version ${versionId} with program ID for idempotency`);
          const workstreamMap = await this.createWorkstreamsAndTasks(
            epmProgram,
            program.id
          );
          summary.workstreamsCreated = workstreamMap.size;
          summary.tasksCreated = Array.from(workstreamMap.values()).reduce((total, tasks2) => total + tasks2.length, 0);
          console.log(`[EPMIntegrator] Created ${summary.workstreamsCreated} workstreams with ${summary.tasksCreated} tasks`);
          summary.stageGatesCreated = await this.createStageGates(
            epmProgram,
            program.id
          );
          console.log(`[EPMIntegrator] Created ${summary.stageGatesCreated} stage gates`);
          summary.kpisCreated = await this.createKPIs(
            epmProgram,
            program.id
          );
          console.log(`[EPMIntegrator] Created ${summary.kpisCreated} KPIs`);
          summary.benefitsCreated = await this.createBenefits(
            epmProgram,
            program.id
          );
          console.log(`[EPMIntegrator] Created ${summary.benefitsCreated} benefits`);
          summary.risksCreated = await this.createRisks(
            epmProgram,
            program.id
          );
          console.log(`[EPMIntegrator] Created ${summary.risksCreated} risks`);
          summary.fundingSourcesCreated = await this.createFundingSources(
            epmProgram,
            program.id
          );
          console.log(`[EPMIntegrator] Created ${summary.fundingSourcesCreated} funding sources`);
          summary.resourcesCreated = await this.createResources(
            epmProgram,
            program.id,
            userId
          );
          console.log(`[EPMIntegrator] Created ${summary.resourcesCreated} resources`);
          console.log(`[EPMIntegrator] Integration complete for program ${program.id}`);
          return { programId: program.id, summary };
        } catch (error) {
          console.error("[EPMIntegrator] Integration failed:", error);
          throw error;
        }
      }
      async createProgram(epmProgram, userId) {
        const startDate = /* @__PURE__ */ new Date();
        const endDate = /* @__PURE__ */ new Date();
        endDate.setMonth(endDate.getMonth() + epmProgram.timeline.total_months);
        const programData = {
          name: epmProgram.title,
          description: epmProgram.description,
          status: "Planning",
          startDate,
          endDate,
          ownerId: userId
        };
        return await storage.createProgram(programData);
      }
      async createWorkstreamsAndTasks(epmProgram, programId) {
        const workstreamMap = /* @__PURE__ */ new Map();
        for (const ws2 of epmProgram.workstreams) {
          const workstreamData = {
            programId,
            name: ws2.title,
            description: ws2.description
          };
          const workstream = await storage.createWorkstream(workstreamData);
          const taskIds = [];
          for (const task of ws2.tasks) {
            const taskData = {
              workstreamId: workstream.id,
              name: task.title,
              description: task.description,
              status: "Not Started",
              priority: this.normalizePriority(task.priority),
              progress: 0
            };
            const createdTask = await storage.createTask(taskData);
            taskIds.push(createdTask.id);
          }
          workstreamMap.set(workstream.id, taskIds);
        }
        return workstreamMap;
      }
      async createStageGates(epmProgram, programId) {
        let count2 = 0;
        for (const sg of epmProgram.stage_gates) {
          const stageGateData = {
            programId,
            code: sg.gate,
            name: sg.name,
            description: sg.criteria.join(", "),
            successCriteria: sg.deliverables.join("; ")
          };
          await storage.createStageGate(stageGateData);
          count2++;
        }
        return count2;
      }
      async createKPIs(epmProgram, programId) {
        let count2 = 0;
        for (const kpi of epmProgram.kpis) {
          const kpiData = {
            programId,
            name: kpi.name,
            description: kpi.description,
            targetValue: this.extractNumericTarget(kpi.target),
            currentValue: "0",
            unit: this.extractUnit(kpi.target),
            frequency: kpi.measurement_frequency
          };
          await storage.createKpi(kpiData);
          count2++;
        }
        return count2;
      }
      async createBenefits(epmProgram, programId) {
        let count2 = 0;
        for (const benefit of epmProgram.benefits) {
          const benefitData = {
            programId,
            name: benefit.category,
            description: benefit.description,
            category: benefit.category,
            targetValue: benefit.quantified_value ? this.extractNumericValue(benefit.quantified_value) : "0",
            realizedValue: "0",
            unit: benefit.quantified_value ? this.extractUnit(benefit.quantified_value) : "$",
            status: "Not Started",
            realizationDate: this.parseRealizationDate(benefit.realization_timeline)
          };
          await storage.createBenefit(benefitData);
          count2++;
        }
        return count2;
      }
      async createRisks(epmProgram, programId) {
        let count2 = 0;
        for (let i = 0; i < epmProgram.risks.length; i++) {
          const risk = epmProgram.risks[i];
          const riskData = {
            programId,
            riskId: `R-${String(i + 1).padStart(3, "0")}`,
            description: risk.description,
            category: "Strategic",
            likelihood: this.normalizeLikelihood(risk.likelihood),
            impact: this.normalizeImpact(risk.impact),
            priority: this.calculateRiskPriority(risk.likelihood, risk.impact),
            mitigationPlan: risk.mitigation_strategy,
            status: "Open"
          };
          await storage.createRisk(riskData);
          count2++;
        }
        return count2;
      }
      async createFundingSources(epmProgram, programId) {
        let count2 = 0;
        for (const source of epmProgram.funding.sources) {
          const fundingData = {
            programId,
            sourceName: source.source,
            allocatedAmount: source.amount,
            // Keep as number
            dateReceived: /* @__PURE__ */ new Date()
          };
          await storage.createFundingSource(fundingData);
          count2++;
        }
        return count2;
      }
      async createResources(epmProgram, programId, userId) {
        let count2 = 0;
        for (const resource of epmProgram.resources) {
          for (let i = 0; i < resource.count; i++) {
            const resourceData = {
              programId,
              name: `${resource.role} ${i + 1}`,
              role: resource.role,
              department: resource.skillset.join(", "),
              email: null,
              userId: null
            };
            await storage.createResource(resourceData);
            count2++;
          }
        }
        return count2;
      }
      normalizePriority(priority) {
        const map = {
          "critical": "High",
          "high": "High",
          "medium": "Medium",
          "low": "Low"
        };
        return map[priority.toLowerCase()] || "Medium";
      }
      normalizeLikelihood(likelihood) {
        const map = {
          "low": "Unlikely",
          "medium": "Possible",
          "high": "Likely"
        };
        return map[likelihood.toLowerCase()] || "Possible";
      }
      normalizeImpact(impact) {
        const map = {
          "low": "Low",
          "medium": "Medium",
          "high": "High"
        };
        return map[impact.toLowerCase()] || "Medium";
      }
      calculateRiskPriority(likelihood, impact) {
        if (likelihood === "high" && impact === "high") return "Critical";
        if (likelihood === "high" || impact === "high") return "High";
        if (likelihood === "medium" && impact === "medium") return "Medium";
        return "Low";
      }
      extractNumericTarget(target) {
        const match = target.match(/[\d.]+/);
        return match ? match[0] : "0";
      }
      extractNumericValue(value) {
        const match = value.match(/[\d.]+/);
        return match ? match[0] : "0";
      }
      extractUnit(target) {
        if (target.includes("%")) return "%";
        if (target.includes("$") || target.includes("M") || target.includes("USD")) return "$";
        if (target.includes("hours")) return "hours";
        if (target.includes("days")) return "days";
        return "count";
      }
      parseRealizationDate(timeline) {
        const match = timeline.match(/\d+/);
        const months = match ? parseInt(match[0]) : 12;
        const date2 = /* @__PURE__ */ new Date();
        date2.setMonth(date2.getMonth() + months);
        return date2;
      }
    };
    epmIntegrator = new EPMIntegrator();
  }
});

// server/strategic-consultant-v2/epm-adapter.ts
import { randomUUID as randomUUID2 } from "crypto";
function createLLMProvider2() {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) {
    console.warn("[EPM-Adapter] No OPENAI_API_KEY - using default mode");
    return null;
  }
  return createOpenAIProvider({ apiKey, model: "gpt-4o" });
}
var EPMAdapter, epmAdapter;
var init_epm_adapter = __esm({
  "server/strategic-consultant-v2/epm-adapter.ts"() {
    "use strict";
    init_epm_synthesizer();
    init_llm_provider();
    EPMAdapter = class {
      synthesizer;
      constructor() {
        this.synthesizer = new EPMSynthesizer(createLLMProvider2());
      }
      /**
       * Convert legacy Strategic Consultant data to EPM program using V2 engine
       */
      async convertToEPM(input, options) {
        console.log("[EPM-Adapter] Converting legacy input to V2 format");
        console.log("[EPM-Adapter] Session:", input.sessionId);
        console.log("[EPM-Adapter] Selected decisions:", Object.keys(input.selectedDecisions || {}).length);
        const insights = this.transformToInsights(input);
        const userContext = {
          sessionId: input.sessionId,
          userId: input.userId
        };
        const namingContext = this.extractNamingContext(input);
        console.log("[EPM-Adapter] Calling EPMSynthesizer with transformed insights");
        const program = await this.synthesizer.synthesize(
          insights,
          userContext,
          namingContext,
          { onProgress: options?.onProgress }
        );
        console.log("[EPM-Adapter] EPM program generated successfully");
        return program;
      }
      /**
       * Transform legacy analysis/decisions format to StrategyInsights
       * Produces a fully compliant StrategyInsights object per the intelligence/types.ts schema
       */
      transformToInsights(input) {
        const insights = [];
        if (input.analysisData?.five_whys) {
          insights.push({
            type: "other",
            source: "five_whys.rootCause",
            content: this.extractFiveWhysContent(input.analysisData.five_whys),
            confidence: 0.8,
            reasoning: "Root cause analysis from Five Whys framework"
          });
        }
        if (input.analysisData?.swot) {
          insights.push(...this.extractSWOTInsights(input.analysisData.swot));
        }
        if (input.analysisData?.porters) {
          insights.push(...this.extractPortersInsights(input.analysisData.porters));
        }
        if (input.analysisData?.pestle) {
          insights.push(...this.extractPESTLEInsights(input.analysisData.pestle));
        }
        if (input.decisionsData?.decisions) {
          const selectedDecisionIds = Object.keys(input.selectedDecisions || {});
          const filteredDecisions = input.decisionsData.decisions.filter(
            (d) => selectedDecisionIds.includes(d.id)
          );
          for (const decision of filteredDecisions) {
            insights.push({
              type: "workstream",
              source: "user.selectedDecision",
              content: decision.recommendation || decision.title || decision.description,
              confidence: 0.95,
              reasoning: "User-selected strategic decision to implement",
              metadata: {
                decisionId: decision.id,
                priority: input.selectedDecisions[decision.id]
              }
            });
          }
        }
        const frameworkType = this.detectFrameworkType(input.analysisData);
        const industry = input.analysisData?.detectedIndustry || input.analysisData?.industry || "general";
        return {
          frameworkType,
          frameworkRunId: input.sessionId || randomUUID2(),
          insights,
          references: [],
          marketContext: {
            industry,
            urgency: this.detectUrgency(input.analysisData),
            riskTolerance: "Moderate"
          },
          overallConfidence: this.calculateOverallConfidence(insights),
          initiativeType: input.analysisData?.initiativeType || input.analysisData?.type || "strategic"
        };
      }
      detectUrgency(analysisData) {
        if (analysisData?.urgency) return analysisData.urgency;
        if (analysisData?.timeline === "immediate") return "ASAP";
        if (analysisData?.timeline === "long-term") return "Exploratory";
        return "Strategic";
      }
      calculateOverallConfidence(insights) {
        if (insights.length === 0) return 0.5;
        const sum = insights.reduce((acc, i) => acc + i.confidence, 0);
        return Math.round(sum / insights.length * 100) / 100;
      }
      extractFiveWhysContent(fiveWhys) {
        if (!fiveWhys) return "";
        const parts = [];
        if (fiveWhys.problem) parts.push(`Problem: ${fiveWhys.problem}`);
        if (fiveWhys.rootCause) parts.push(`Root Cause: ${fiveWhys.rootCause}`);
        if (fiveWhys.whys) {
          fiveWhys.whys.forEach((why, i) => {
            parts.push(`Why ${i + 1}: ${why.question} - ${why.answer}`);
          });
        }
        return parts.join("\n");
      }
      extractSWOTInsights(swot) {
        const insights = [];
        if (swot.strengths) {
          for (const strength of swot.strengths) {
            insights.push({
              type: "resource",
              source: "swot.strengths",
              content: typeof strength === "string" ? strength : strength.description,
              confidence: 0.75,
              reasoning: "Internal strength identified via SWOT analysis"
            });
          }
        }
        if (swot.weaknesses) {
          for (const weakness of swot.weaknesses) {
            insights.push({
              type: "risk",
              source: "swot.weaknesses",
              content: typeof weakness === "string" ? weakness : weakness.description,
              confidence: 0.7,
              reasoning: "Internal weakness requiring mitigation via SWOT analysis"
            });
          }
        }
        if (swot.opportunities) {
          for (const opportunity of swot.opportunities) {
            insights.push({
              type: "benefit",
              source: "swot.opportunities",
              content: typeof opportunity === "string" ? opportunity : opportunity.description,
              confidence: 0.8,
              reasoning: "External opportunity identified via SWOT analysis"
            });
          }
        }
        if (swot.threats) {
          for (const threat of swot.threats) {
            insights.push({
              type: "risk",
              source: "swot.threats",
              content: typeof threat === "string" ? threat : threat.description,
              confidence: 0.75,
              reasoning: "External threat requiring mitigation via SWOT analysis"
            });
          }
        }
        return insights;
      }
      extractPortersInsights(porters) {
        const insights = [];
        const forceMapping = {
          competitiveRivalry: { type: "risk", reasoning: "Competitive intensity from Porter's Five Forces" },
          threatOfNewEntrants: { type: "risk", reasoning: "New entrant threat from Porter's Five Forces" },
          bargainingPowerOfSuppliers: { type: "stakeholder", reasoning: "Supplier dynamics from Porter's Five Forces" },
          bargainingPowerOfBuyers: { type: "stakeholder", reasoning: "Customer dynamics from Porter's Five Forces" },
          threatOfSubstitutes: { type: "risk", reasoning: "Substitute threat from Porter's Five Forces" }
        };
        for (const [force, meta] of Object.entries(forceMapping)) {
          if (porters[force]) {
            insights.push({
              type: meta.type,
              source: `porters.${force}`,
              content: typeof porters[force] === "string" ? porters[force] : porters[force].analysis || JSON.stringify(porters[force]),
              confidence: 0.7,
              reasoning: meta.reasoning
            });
          }
        }
        return insights;
      }
      extractPESTLEInsights(pestle) {
        const insights = [];
        const factorMapping = {
          political: { type: "risk", reasoning: "Political factor from PESTLE analysis" },
          economic: { type: "cost", reasoning: "Economic factor from PESTLE analysis" },
          social: { type: "stakeholder", reasoning: "Social/demographic factor from PESTLE analysis" },
          technological: { type: "resource", reasoning: "Technology factor from PESTLE analysis" },
          legal: { type: "risk", reasoning: "Legal/regulatory factor from PESTLE analysis" },
          environmental: { type: "risk", reasoning: "Environmental factor from PESTLE analysis" }
        };
        for (const [factor, meta] of Object.entries(factorMapping)) {
          if (pestle[factor]) {
            const content = Array.isArray(pestle[factor]) ? pestle[factor].join("; ") : typeof pestle[factor] === "string" ? pestle[factor] : JSON.stringify(pestle[factor]);
            insights.push({
              type: meta.type,
              source: `pestle.${factor}`,
              content,
              confidence: 0.7,
              reasoning: meta.reasoning
            });
          }
        }
        return insights;
      }
      detectFrameworkType(analysisData) {
        if (analysisData?.bmc) return "bmc";
        if (analysisData?.porters) return "porters";
        if (analysisData?.pestle) return "pestle";
        if (analysisData?.swot) return "swot";
        if (analysisData?.five_whys) return "swot";
        return "swot";
      }
      extractNamingContext(input) {
        return {
          userInput: input.analysisData?.originalInput || input.analysisData?.userInput || "",
          industry: input.analysisData?.detectedIndustry || input.analysisData?.industry,
          businessType: input.analysisData?.businessType || input.analysisData?.type,
          companyName: input.analysisData?.companyName
        };
      }
    };
    epmAdapter = new EPMAdapter();
  }
});

// server/strategic-consultant-legacy/framework-selector.ts
import { eq as eq17 } from "drizzle-orm";
import { z as z7 } from "zod";
var FrameworkSelector;
var init_framework_selector = __esm({
  "server/strategic-consultant-legacy/framework-selector.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_ai_clients();
    FrameworkSelector = class {
      bmcKeywords = [
        "business model",
        "revenue",
        "ARR",
        "MRR",
        "customer",
        "customers",
        "client",
        "clients",
        "value proposition",
        "value propositions",
        "pivot",
        "pivoting",
        "pivoted",
        "new venture",
        "startup",
        "startups",
        "early stage",
        "monetize",
        "monetization",
        "monetizing",
        "customer segment",
        "customer segments",
        "revenue stream",
        "revenue streams",
        "revenue target",
        "revenue goal",
        "key resource",
        "key resources",
        "cost structure",
        "costs",
        "channel",
        "channels",
        "distribution",
        "partnership",
        "partnerships",
        "partner",
        "partners",
        "launch",
        "launching",
        "expanding",
        "go-to-market",
        "GTM",
        "product-market fit",
        "PMF",
        "scaling",
        "scale",
        "growth",
        "pricing model",
        "pricing strategy",
        "business design",
        "localization",
        "market entry",
        "market expansion",
        "investment",
        "invest",
        "investing",
        "target market",
        "positioning strategy"
      ];
      portersKeywords = [
        "competitive",
        "competition",
        "compete",
        "competing",
        "competitor",
        "competitors",
        "market force",
        "market forces",
        "industry analysis",
        "industry structure",
        "rivalry",
        "competitive rivalry",
        "threat of entry",
        "new entrant",
        "new entrants",
        "barriers to entry",
        "substitute",
        "substitutes",
        "substitution",
        "supplier power",
        "bargaining power of suppliers",
        "buyer power",
        "bargaining power of buyers",
        "competitive advantage",
        "differentiation",
        "market position",
        "positioning",
        "industry dynamics",
        "competitive landscape",
        "market share",
        "strategic positioning"
      ];
      constructor() {
      }
      async selectFramework(sessionId, userId, input) {
        const signals = this.detectSignals(input);
        const analysis = await this.analyzeWithClaude(input, signals);
        if (!sessionId.startsWith("test-")) {
          await db.insert(frameworkSelections).values({
            sessionId,
            userId,
            selectedFramework: analysis.selectedFramework,
            confidence: analysis.confidence.toFixed(2),
            signals,
            reasoning: analysis.reasoning,
            userOverride: false,
            alternativeFramework: analysis.alternativeFramework || null
          });
        }
        return analysis;
      }
      detectSignals(input) {
        const lowerInput = input.toLowerCase();
        const normalizedInput = lowerInput.replace(/[^\w\s]/g, " ").replace(/\s+/g, " ");
        const bmcMatches = this.bmcKeywords.filter((keyword) => {
          const normalizedKeyword = keyword.toLowerCase();
          const wordBoundaryPattern = new RegExp(`\\b${normalizedKeyword.replace(/\s+/g, "\\s+")}\\b`, "i");
          return wordBoundaryPattern.test(normalizedInput) || normalizedInput.includes(normalizedKeyword);
        });
        const portersMatches = this.portersKeywords.filter((keyword) => {
          const normalizedKeyword = keyword.toLowerCase();
          const wordBoundaryPattern = new RegExp(`\\b${normalizedKeyword.replace(/\s+/g, "\\s+")}\\b`, "i");
          return wordBoundaryPattern.test(normalizedInput) || normalizedInput.includes(normalizedKeyword);
        });
        const businessStage = this.detectBusinessStage(lowerInput);
        const queryType = this.detectQueryType(lowerInput);
        return {
          bmcKeywords: bmcMatches,
          portersKeywords: portersMatches,
          businessStage,
          queryType
        };
      }
      detectBusinessStage(input) {
        if (/\b(startup|new venture|launch|founding|early stage)\b/i.test(input)) {
          return "early_stage";
        }
        if (/\b(pivot|transform|change direction|rethink|redesign)\b/i.test(input)) {
          return "pivoting";
        }
        if (/\b(scale|expand|growth|mature|established)\b/i.test(input)) {
          return "scaling";
        }
        return "unknown";
      }
      detectQueryType(input) {
        if (/\b(how to|strategy for|approach to|plan for)\b/i.test(input)) {
          return "strategic_planning";
        }
        if (/\b(analyze|assessment|evaluation|review)\b/i.test(input)) {
          return "analysis";
        }
        if (/\b(compete|competitive|vs|versus|against)\b/i.test(input)) {
          return "competitive";
        }
        return "general";
      }
      async analyzeWithClaude(input, signals) {
        const systemPrompt = `You are a strategic framework selection expert. Return ONLY valid JSON (no markdown, no explanation).`;
        const userMessage = `Analyze the user's input and select the most appropriate framework.

FRAMEWORKS:
1. Business Model Canvas (BMC): Best for designing/redesigning business models, understanding revenue/customers/value
2. Porter's Five Forces: Best for competitive analysis, industry dynamics, market positioning

USER INPUT:
${input.substring(0, 1500)}

DETECTED SIGNALS:
- BMC keywords found: ${signals.bmcKeywords.join(", ") || "none"}
- Porter's keywords found: ${signals.portersKeywords.join(", ") || "none"}
- Business stage: ${signals.businessStage}
- Query type: ${signals.queryType}

SELECTION CRITERIA:
- Choose BMC if: Input focuses on business model design, revenue models, customer segments, value propositions, market entry/expansion strategy, investment decisions, or go-to-market planning
- Choose Porter's if: Input focuses on competitive dynamics, market forces, competitor analysis, industry structure analysis, or competitive positioning
- If both apply, prioritize BMC when discussing revenue targets, customer acquisition, value delivery, or investment strategy
- If both apply, prioritize Porter's when discussing competitive threats, industry barriers, or supplier/buyer power

Return ONLY valid JSON (no markdown, no explanation):

{
  "selectedFramework": "business_model_canvas|porters_five_forces",
  "confidence": 0.85,
  "reasoning": "Clear 2-3 sentence explanation of why this framework was selected based on input focus",
  "alternativeFramework": "business_model_canvas|porters_five_forces|null"
}

Confidence scale:
- 0.9-1.0: Very clear single framework focus
- 0.7-0.89: Clear primary framework with some secondary signals
- 0.5-0.69: Mixed signals but one framework is more appropriate
- <0.5: Unclear, may need user choice`;
        const response = await aiClients.callWithFallback({
          systemPrompt,
          userMessage,
          maxTokens: 1500
        }, "anthropic");
        const textContent = response.content;
        const ClaudeResponseSchema = z7.object({
          selectedFramework: z7.enum(["business_model_canvas", "porters_five_forces"]),
          confidence: z7.number().min(0).max(1),
          reasoning: z7.string().min(10),
          alternativeFramework: z7.enum(["business_model_canvas", "porters_five_forces", "null"]).optional().nullable()
        });
        const jsonMatch = textContent.match(/\{[\s\S]*\}/);
        if (!jsonMatch) {
          console.error("FrameworkSelector: Failed to extract JSON from Claude response");
          return this.defaultSelection(signals);
        }
        try {
          const parsed = JSON.parse(jsonMatch[0]);
          const validated = ClaudeResponseSchema.parse(parsed);
          return {
            selectedFramework: validated.selectedFramework,
            confidence: validated.confidence,
            signals,
            reasoning: validated.reasoning,
            alternativeFramework: validated.alternativeFramework === "null" || !validated.alternativeFramework ? void 0 : validated.alternativeFramework
          };
        } catch (error) {
          if (error instanceof z7.ZodError) {
            console.error("FrameworkSelector: Schema validation failed", error.errors);
          } else {
            console.error("FrameworkSelector: Error parsing Claude response", error);
          }
          return this.defaultSelection(signals);
        }
      }
      defaultSelection(signals) {
        const bmcScore = signals.bmcKeywords.length;
        const portersScore = signals.portersKeywords.length;
        if (bmcScore > portersScore) {
          return {
            selectedFramework: "business_model_canvas",
            confidence: 0.6,
            signals,
            reasoning: "Selected Business Model Canvas based on keyword matching (Business model, revenue, customers). Confidence is moderate due to automatic detection.",
            alternativeFramework: portersScore > 0 ? "porters_five_forces" : void 0
          };
        } else if (portersScore > bmcScore) {
          return {
            selectedFramework: "porters_five_forces",
            confidence: 0.6,
            signals,
            reasoning: "Selected Porter's Five Forces based on keyword matching (Competitive analysis, market forces). Confidence is moderate due to automatic detection.",
            alternativeFramework: bmcScore > 0 ? "business_model_canvas" : void 0
          };
        }
        return {
          selectedFramework: "porters_five_forces",
          confidence: 0.5,
          signals,
          reasoning: "Defaulting to Porter's Five Forces as no clear framework signals were detected. Low confidence - user may want to choose manually."
        };
      }
      async updateUserOverride(selectionId, overriddenFramework) {
        await db.update(frameworkSelections).set({
          selectedFramework: overriddenFramework,
          userOverride: true
        }).where(eq17(frameworkSelections.id, selectionId));
      }
    };
  }
});

// server/strategic-consultant-legacy/initiative-classifier.ts
var CLASSIFICATION_SYSTEM_PROMPT, CLASSIFICATION_USER_PROMPT, InitiativeClassifier;
var init_initiative_classifier = __esm({
  "server/strategic-consultant-legacy/initiative-classifier.ts"() {
    "use strict";
    init_ai_clients();
    CLASSIFICATION_SYSTEM_PROMPT = `You are an expert business analyst specializing in initiative classification.

Your task is to analyze strategic inputs and classify the type of initiative being described.

Choose the MOST SPECIFIC classification that fits:

1. **physical_business_launch** - Opening physical locations (stores, restaurants, offices, warehouses)
   Examples: "Open a coffee shop in Brooklyn", "Launch a retail store", "Start a gym"

2. **software_development** - Building software products, apps, platforms, or technical systems
   Examples: "Build a SaaS platform", "Create a mobile app", "Develop an AI tool"

3. **digital_transformation** - Modernizing existing physical business with digital capabilities
   Examples: "Add online ordering to restaurant", "Build e-commerce for retail store", "Digitize manual processes"

4. **market_expansion** - Entering new markets, regions, or customer segments with existing products/services
   Examples: "Expand to European markets", "Target enterprise customers", "Launch in Asia"

5. **product_launch** - Introducing new physical or digital products to existing markets
   Examples: "Launch new product line", "Release upgraded version", "Add new SKU"

6. **service_launch** - Introducing new service offerings
   Examples: "Add consulting services", "Launch subscription service", "Offer training programs"

7. **process_improvement** - Optimizing existing operations, workflows, or efficiency
   Examples: "Improve supply chain", "Streamline HR processes", "Reduce operational costs"

8. **other** - Initiatives that don't clearly fit the above (use sparingly)

IMPORTANT: Always respond with valid JSON in this exact format:
{
  "initiativeType": "physical_business_launch",
  "description": "Launch of a physical retail location",
  "confidence": 0.95,
  "reasoning": "User explicitly mentions opening a physical store in a specific location"
}`;
    CLASSIFICATION_USER_PROMPT = `Analyze this strategic input and classify the initiative type:

USER INPUT:
{userInput}

Provide:
1. The most appropriate classification from the 8 types listed
2. A 1-2 sentence description of what type of initiative this is
3. Confidence score (0.0-1.0) - how certain you are about this classification
4. Brief reasoning for your choice

Respond ONLY with valid JSON.`;
    InitiativeClassifier = class {
      /**
       * Classify a strategic input to determine the type of initiative
       */
      static async classify(userInput, preferredProvider) {
        try {
          console.log(
            "[INITIATIVE-CLASSIFIER] Starting classification for input:",
            userInput.substring(0, 100) + "..."
          );
          const userMessage = CLASSIFICATION_USER_PROMPT.replace("{userInput}", userInput);
          const response = await aiClients.callWithFallback({
            systemPrompt: CLASSIFICATION_SYSTEM_PROMPT,
            userMessage,
            maxTokens: 1024
          }, preferredProvider);
          console.log("[INITIATIVE-CLASSIFIER] Raw AI response:", response.content);
          let parsed;
          try {
            parsed = JSON.parse(response.content);
          } catch (parseError) {
            console.error("[INITIATIVE-CLASSIFIER] JSON parse error:", parseError);
            console.error("[INITIATIVE-CLASSIFIER] Invalid JSON content:", response.content);
            return this.fallbackClassification(userInput);
          }
          if (!parsed || typeof parsed !== "object") {
            console.error("[INITIATIVE-CLASSIFIER] Response is not an object:", parsed);
            return this.fallbackClassification(userInput);
          }
          if (!this.isValidInitiativeType(parsed.initiativeType)) {
            console.warn(`[INITIATIVE-CLASSIFIER] Invalid initiative type returned: ${parsed.initiativeType}, defaulting to 'other'`);
            parsed.initiativeType = "other";
          }
          if (typeof parsed.confidence !== "number" || parsed.confidence < 0 || parsed.confidence > 1) {
            console.warn(`[INITIATIVE-CLASSIFIER] Invalid confidence score: ${parsed.confidence}, defaulting to 0.5`);
            parsed.confidence = 0.5;
          }
          if (!parsed.description || typeof parsed.description !== "string") {
            console.warn("[INITIATIVE-CLASSIFIER] Missing or invalid description, using default");
            parsed.description = "Initiative classification";
          }
          if (!parsed.reasoning || typeof parsed.reasoning !== "string") {
            console.warn("[INITIATIVE-CLASSIFIER] Missing or invalid reasoning, using default");
            parsed.reasoning = "Automatic classification";
          }
          const result = {
            initiativeType: parsed.initiativeType,
            description: parsed.description,
            confidence: parsed.confidence,
            reasoning: parsed.reasoning
          };
          console.log("[INITIATIVE-CLASSIFIER] Classification result:", result);
          return result;
        } catch (error) {
          console.error("[INITIATIVE-CLASSIFIER] Classification failed:", error);
          return this.fallbackClassification(userInput);
        }
      }
      /**
       * Validate if a string is a valid InitiativeType
       */
      static isValidInitiativeType(type) {
        const validTypes = [
          "physical_business_launch",
          "software_development",
          "digital_transformation",
          "market_expansion",
          "product_launch",
          "service_launch",
          "process_improvement",
          "other"
        ];
        return validTypes.includes(type);
      }
      /**
       * Fallback classification using simple keyword matching
       * Used when LLM classification fails
       */
      static fallbackClassification(userInput) {
        console.log("[INITIATIVE-CLASSIFIER] Using fallback keyword-based classification");
        const input = userInput.toLowerCase();
        const physicalKeywords = ["open", "launch", "store", "shop", "restaurant", "cafe", "coffee", "retail", "gym", "office", "location"];
        if (physicalKeywords.some((kw) => input.includes(kw))) {
          return {
            initiativeType: "physical_business_launch",
            description: "Physical business or location launch",
            confidence: 0.6,
            reasoning: "Keyword-based fallback classification (physical business indicators detected)"
          };
        }
        const softwareKeywords = ["app", "software", "platform", "saas", "website", "system", "code", "develop", "build", "api", "mobile"];
        if (softwareKeywords.some((kw) => input.includes(kw))) {
          return {
            initiativeType: "software_development",
            description: "Software or technical product development",
            confidence: 0.6,
            reasoning: "Keyword-based fallback classification (software development indicators detected)"
          };
        }
        const digitalKeywords = ["digital", "online", "e-commerce", "modernize", "automate", "cloud", "transform"];
        if (digitalKeywords.some((kw) => input.includes(kw))) {
          return {
            initiativeType: "digital_transformation",
            description: "Digital transformation or modernization",
            confidence: 0.6,
            reasoning: "Keyword-based fallback classification (digital transformation indicators detected)"
          };
        }
        const expansionKeywords = ["expand", "new market", "international", "region", "geography", "enter", "penetrate"];
        if (expansionKeywords.some((kw) => input.includes(kw))) {
          return {
            initiativeType: "market_expansion",
            description: "Market or geographic expansion",
            confidence: 0.6,
            reasoning: "Keyword-based fallback classification (market expansion indicators detected)"
          };
        }
        return {
          initiativeType: "other",
          description: "General business initiative",
          confidence: 0.3,
          reasoning: "Keyword-based fallback classification (no clear category indicators)"
        };
      }
    };
  }
});

// server/services/ambiguity-detector.ts
var AmbiguityDetectorService, ambiguityDetector;
var init_ambiguity_detector = __esm({
  "server/services/ambiguity-detector.ts"() {
    "use strict";
    init_ai_clients();
    AmbiguityDetectorService = class {
      /**
       * Common ambiguity patterns to watch for
       */
      AMBIGUITY_PATTERNS = {
        technology_usage_vs_teaching: [
          "AI tutoring",
          "AI coaching",
          "AI consulting",
          "AI training",
          "tech education",
          "digital training",
          "software tutoring"
        ],
        b2b_vs_b2c: [
          "consulting",
          "services",
          "platform",
          "marketplace",
          "app"
        ],
        physical_vs_digital: [
          "store",
          "shop",
          "location",
          "platform",
          "service"
        ],
        product_vs_service: [
          "offering",
          "solution",
          "business"
        ],
        local_vs_international: [
          "market",
          "customers",
          "expansion"
        ]
      };
      /**
       * Detect ambiguities in user input
       * @param userInput - The text to analyze
       * @param precomputedQuestions - Optional pre-computed questions (e.g., from geographic disambiguation)
       */
      async detectAmbiguities(userInput, precomputedQuestions = []) {
        console.log("[Ambiguity Detector] Analyzing input for ambiguities...");
        const mergedQuestions = [...precomputedQuestions];
        if (precomputedQuestions.length > 0) {
          console.log(`[Ambiguity Detector] Including ${precomputedQuestions.length} pre-computed question(s)`);
        }
        const prompt = `Analyze this business idea for ambiguities that would affect strategic planning:

"${userInput}"

COMMON AMBIGUITIES TO CHECK:

1. **Technology Role Ambiguity**
   - Does "AI tutoring" mean using AI to tutor students, OR teaching students about AI?
   - Does "tech consulting" mean advising on technology, OR providing tech services?

2. **Customer Type Ambiguity**
   - B2B (selling to businesses) or B2C (selling to consumers)?
   - Who is the actual customer?

3. **Delivery Mode Ambiguity**
   - Physical location (store, office) or digital (app, website, online)?
   - In-person or remote?

4. **Business Model Ambiguity**
   - Product (selling goods) or service (providing services)?
   - One-time purchase or subscription?

5. **Market Scope Ambiguity**
   - Local/regional or national/international?
   - Geographic boundaries unclear?

INSTRUCTIONS:
- Identify CRITICAL ambiguities that would lead to wrong strategic decisions
- For each ambiguity, generate a clear multiple-choice question
- Provide 2-3 specific options (not "other")
- Keep questions simple and direct

Return as JSON:
{
  "hasAmbiguities": true/false,
  "questions": [
    {
      "id": "unique_id",
      "question": "Clear question?",
      "multiSelect": true/false,
      "options": [
        {
          "value": "option_a",
          "label": "Short label",
          "description": "What this means"
        }
      ]
    }
  ],
  "reasoning": "Why these ambiguities matter"
}

NOTE: Set "multiSelect": true if options are NOT mutually exclusive (user can select multiple). Set "multiSelect": false or omit if options are mutually exclusive (user must choose one).

If NO critical ambiguities found, return:
{
  "hasAmbiguities": false,
  "questions": [],
  "reasoning": "Input is clear"
}`;
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a strategic planning expert. Detect ambiguities that would lead to wrong business assumptions. Return ONLY valid JSON.",
            userMessage: prompt,
            maxTokens: 1500
          });
          let cleanedContent = response.content.trim();
          const codeBlockMatch = cleanedContent.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
          if (codeBlockMatch) {
            cleanedContent = codeBlockMatch[1];
          }
          const jsonMatch = cleanedContent.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            throw new Error("No JSON found in AI response");
          }
          const result = JSON.parse(jsonMatch[0]);
          if (result.questions && result.questions.length > 0) {
            mergedQuestions.push(...result.questions);
          }
          const hasAmbiguities = mergedQuestions.length > 0;
          console.log("[Ambiguity Detector] \u2713 Analysis complete:", {
            hasAmbiguities,
            totalQuestions: mergedQuestions.length,
            precomputedQuestions: precomputedQuestions.length,
            aiDetectedQuestions: result.questions?.length || 0
          });
          return {
            hasAmbiguities,
            questions: mergedQuestions,
            reasoning: result.reasoning || "Questions require clarification"
          };
        } catch (error) {
          console.error("[Ambiguity Detector] Error:", error);
          if (mergedQuestions.length > 0) {
            return {
              hasAmbiguities: true,
              questions: mergedQuestions,
              reasoning: "Geographic disambiguation needed"
            };
          }
          return {
            hasAmbiguities: false,
            questions: [],
            reasoning: "Error detecting ambiguities - proceeding with input as-is"
          };
        }
      }
      /**
       * Incorporate clarifications into original input
       */
      buildClarifiedInput(originalInput, clarifications) {
        const clarificationText = Object.entries(clarifications).map(([question, answer]) => `- ${answer}`).join("\n");
        return `${originalInput}

CLARIFICATIONS:
${clarificationText}`;
      }
    };
    ambiguityDetector = new AmbiguityDetectorService();
  }
});

// server/services/location-resolver.ts
var LocationResolverService, locationResolver;
var init_location_resolver = __esm({
  "server/services/location-resolver.ts"() {
    "use strict";
    init_request_throttler();
    LocationResolverService = class {
      NOMINATIM_BASE_URL = "https://nominatim.openstreetmap.org";
      USER_AGENT = "Premisia/1.0 (contact@premisia.app)";
      IMPORTANCE_THRESHOLD = 0.6;
      CIRCUIT_BREAKER_THRESHOLD = 1;
      // Stop after 1 failure - fail fast
      REQUEST_TIMEOUT = 3e3;
      // 3 second timeout - fail fast
      cache;
      throttler;
      consecutiveFailures = 0;
      circuitOpen = false;
      circuitOpenUntil = 0;
      constructor() {
        this.cache = /* @__PURE__ */ new Map();
        this.throttler = new RequestThrottler({
          maxConcurrent: 1,
          delayBetweenBatches: 1e3,
          // 1 second for Nominatim
          maxRetries: 1,
          // Reduced retries - fail fast
          initialRetryDelay: 500
        });
      }
      /**
       * Check if circuit breaker is open (API is blocked/unavailable)
       */
      isCircuitOpen() {
        if (!this.circuitOpen) return false;
        if (Date.now() > this.circuitOpenUntil) {
          this.circuitOpen = false;
          this.consecutiveFailures = 0;
          console.log("[LocationResolver] Circuit breaker reset");
          return false;
        }
        return true;
      }
      /**
       * Record API failure and potentially open circuit breaker
       */
      recordFailure() {
        this.consecutiveFailures++;
        if (this.consecutiveFailures >= this.CIRCUIT_BREAKER_THRESHOLD) {
          this.circuitOpen = true;
          this.circuitOpenUntil = Date.now() + 2 * 60 * 1e3;
          console.log("[LocationResolver] Circuit breaker OPEN - Nominatim API unavailable, skipping geocoding for 2 minutes");
        }
      }
      /**
       * Record API success and reset failure counter
       */
      recordSuccess() {
        this.consecutiveFailures = 0;
      }
      /**
       * Generate n-grams (1-3 words) with span tracking
       * Uses smart filtering to reduce API calls while preserving location detection
       */
      generateNGrams(text2) {
        const ngrams = [];
        const skipWords = /* @__PURE__ */ new Set([
          "we",
          "i",
          "the",
          "a",
          "an",
          "is",
          "are",
          "was",
          "were",
          "be",
          "been",
          "have",
          "has",
          "had",
          "do",
          "does",
          "did",
          "will",
          "would",
          "could",
          "should",
          "may",
          "might",
          "must",
          "can",
          "our",
          "their",
          "its",
          "my",
          "your",
          "his",
          "her",
          "this",
          "that",
          "these",
          "those",
          "it",
          "they",
          "he",
          "she",
          "you",
          "what",
          "which",
          "who",
          "when",
          "where",
          "why",
          "how",
          "all",
          "each",
          "every",
          "both",
          "few",
          "more",
          "most",
          "other",
          "some",
          "such",
          "no",
          "not",
          "only",
          "same",
          "so",
          "than",
          "too",
          "very",
          "just",
          "also",
          "now",
          "here",
          "there",
          "then",
          "once",
          "reduce",
          "increase",
          "improve",
          "built",
          "build",
          "make",
          "help",
          "helps",
          "using",
          "use",
          "find",
          "organize",
          "tool",
          "workers",
          "documents",
          "information",
          "knowledge",
          "system",
          "company",
          "business",
          "product",
          "service",
          "customer",
          "market",
          "strategy"
        ]);
        const capitalizedPattern = /[A-Z][a-zA-Z\u00C0-\u024F]*/g;
        const tokens = [];
        let match;
        while ((match = capitalizedPattern.exec(text2)) !== null) {
          const word = match[0];
          if (!skipWords.has(word.toLowerCase()) && word.length >= 3) {
            tokens.push({
              word,
              index: match.index
            });
          }
        }
        if (tokens.length === 0) {
          console.log(`[LocationResolver] No location candidates found, skipping geocoding`);
          return [];
        }
        const MAX_TOKENS = 10;
        const limitedTokens = tokens.slice(0, MAX_TOKENS);
        if (tokens.length > MAX_TOKENS) {
          console.log(`[LocationResolver] Limited tokens from ${tokens.length} to ${MAX_TOKENS}`);
        }
        for (let i = 0; i < limitedTokens.length; i++) {
          for (let len = 1; len <= 3 && i + len <= limitedTokens.length; len++) {
            const slice = limitedTokens.slice(i, i + len);
            const ngramText = slice.map((t) => t.word).join(" ");
            if (ngramText.length < 3) {
              continue;
            }
            const startIndex = slice[0].index;
            const lastToken = slice[slice.length - 1];
            const endIndex = lastToken.index + lastToken.word.length;
            ngrams.push({
              text: ngramText,
              startIndex,
              endIndex
            });
          }
        }
        const MAX_NGRAMS = 20;
        const limitedNgrams = ngrams.slice(0, MAX_NGRAMS);
        console.log(`[LocationResolver] Generated ${limitedNgrams.length} n-grams from ${limitedTokens.length} candidate words`);
        return limitedNgrams;
      }
      /**
       * Simple title case conversion
       */
      toTitleCase(text2) {
        return text2.toLowerCase().split(" ").map((word) => word.charAt(0).toUpperCase() + word.slice(1)).join(" ");
      }
      /**
       * Geocode a single query (no rate limiting - handled by throttler)
       */
      async geocode(query) {
        if (this.isCircuitOpen()) {
          return [];
        }
        const cacheKey = query.toLowerCase();
        if (this.cache.has(cacheKey)) {
          return this.cache.get(cacheKey);
        }
        try {
          const searchParams = new URLSearchParams({
            q: query,
            format: "json",
            addressdetails: "1",
            limit: "5",
            "accept-language": "en"
          });
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), this.REQUEST_TIMEOUT);
          const response = await fetch(
            `${this.NOMINATIM_BASE_URL}/search?${searchParams}`,
            {
              headers: {
                "User-Agent": this.USER_AGENT
              },
              signal: controller.signal
            }
          );
          clearTimeout(timeoutId);
          if (!response.ok) {
            this.recordFailure();
            if (this.consecutiveFailures <= this.CIRCUIT_BREAKER_THRESHOLD) {
              console.warn(`[LocationResolver] Nominatim API returned ${response.status} for "${query}"`);
            }
            return [];
          }
          const results = await response.json();
          this.recordSuccess();
          const candidates = results.map((result) => {
            const importance = parseFloat(result.importance) || 0;
            return {
              displayName: result.display_name,
              lat: parseFloat(result.lat),
              lon: parseFloat(result.lon),
              countryCode: result.address?.country_code?.toUpperCase() || "XX",
              adminLevels: {
                country: result.address?.country,
                state: result.address?.state,
                county: result.address?.county,
                city: result.address?.city || result.address?.town || result.address?.village
              },
              confidence: this.calculateConfidence(importance),
              importance,
              rawQuery: query
            };
          });
          this.cache.set(cacheKey, candidates);
          return candidates;
        } catch (error) {
          this.recordFailure();
          if (this.consecutiveFailures <= this.CIRCUIT_BREAKER_THRESHOLD) {
            console.warn(`[LocationResolver] Geocode failed for "${query}": ${error.message}`);
          }
          return [];
        }
      }
      /**
       * Calculate confidence score based on Nominatim importance
       */
      calculateConfidence(importance) {
        if (importance > 0.6) return "high";
        if (importance > 0.3) return "medium";
        return "low";
      }
      /**
       * Merge overlapping n-gram hits, keeping the best candidate per span
       */
      mergeOverlapping(hits) {
        if (hits.length === 0) return [];
        const sorted = hits.sort((a, b) => a.ngram.startIndex - b.ngram.startIndex);
        const merged = [];
        let i = 0;
        while (i < sorted.length) {
          let best = sorted[i];
          let j = i + 1;
          while (j < sorted.length && sorted[j].ngram.startIndex < best.ngram.endIndex) {
            if (sorted[j].candidate.importance > best.candidate.importance) {
              best = sorted[j];
            } else if (sorted[j].candidate.importance === best.candidate.importance) {
              if (sorted[j].ngram.text.length > best.ngram.text.length) {
                best = sorted[j];
              }
            }
            j++;
          }
          merged.push(best.candidate);
          i = j;
        }
        const unique2 = /* @__PURE__ */ new Map();
        for (const candidate of merged) {
          const key = candidate.displayName.toLowerCase();
          if (!unique2.has(key) || candidate.importance > unique2.get(key).importance) {
            unique2.set(key, candidate);
          }
        }
        return Array.from(unique2.values());
      }
      /**
       * Main API: Extract and resolve locations using geocoder-first approach
       */
      async extractAndResolveLocations(text2) {
        try {
          if (this.isCircuitOpen()) {
            console.log(`[LocationResolver] Circuit breaker open, skipping location resolution`);
            return [];
          }
          console.log(`[LocationResolver] Starting geocoder-first extraction for text:`, text2.substring(0, 100));
          const ngrams = this.generateNGrams(text2);
          if (ngrams.length === 0) {
            console.log(`[LocationResolver] No valid n-grams generated`);
            return [];
          }
          console.log(`[LocationResolver] Generated ${ngrams.length} n-grams to check`);
          const tasks2 = ngrams.map((ngram) => async () => {
            let candidates = await this.geocode(ngram.text);
            if (candidates.length === 0) {
              const titleCased = this.toTitleCase(ngram.text);
              if (titleCased !== ngram.text) {
                candidates = await this.geocode(titleCased);
              }
            }
            return { ngram, candidates };
          });
          const results = await this.throttler.throttleAll(
            tasks2,
            (taskIndex) => ({ ngram: ngrams[taskIndex], candidates: [] })
          );
          const strongHits = results.flatMap(
            ({ ngram, candidates }) => candidates.filter((c) => c.importance >= this.IMPORTANCE_THRESHOLD).map((c) => ({ ngram, candidate: c }))
          );
          console.log(`[LocationResolver] Found ${strongHits.length} strong hits (importance \u2265 ${this.IMPORTANCE_THRESHOLD})`);
          const locations2 = this.mergeOverlapping(strongHits);
          console.log(`[LocationResolver] Final result: ${locations2.length} locations`);
          return locations2;
        } catch (error) {
          console.error("[LocationResolver] extractAndResolveLocations failed completely, returning empty array:", error.message);
          return [];
        }
      }
      /**
       * Resolve a single place name (legacy compatibility)
       */
      async resolveSingle(placeName) {
        const candidates = await this.geocode(placeName);
        if (candidates.length === 0) {
          return { needsClarification: false };
        }
        if (candidates.length > 1) {
          console.log(`[LocationResolver] Multiple candidates (${candidates.length}) for: ${placeName} - asking for clarification`);
          return {
            needsClarification: true,
            question: this.createGeographicQuestion(placeName, candidates)
          };
        }
        const candidate = candidates[0];
        if (candidate.importance >= 0.85) {
          console.log(`[LocationResolver] Auto-resolved: ${placeName} \u2192 ${candidate.displayName} (importance: ${candidate.importance})`);
          return {
            needsClarification: false,
            autoResolved: candidate
          };
        }
        console.log(`[LocationResolver] Low confidence (${candidate.importance}) for: ${placeName} - asking for clarification`);
        return {
          needsClarification: true,
          question: this.createGeographicQuestion(placeName, [candidate])
        };
      }
      /**
       * Resolve all place names in text (legacy compatibility - now uses extractAndResolveLocations)
       */
      async resolveAll(text2) {
        try {
          const locations2 = await this.extractAndResolveLocations(text2);
          console.log(`[LocationResolver] resolveAll found ${locations2.length} high-confidence locations`);
          if (locations2.length >= 2) {
            const question = {
              id: "geo_multiple_locations",
              question: `We found multiple locations in your input. Which one(s) are relevant?`,
              rawQuery: text2,
              multiSelect: true,
              // Allow selecting multiple
              options: locations2.map((candidate, idx) => ({
                value: `location_${idx}`,
                label: this.formatLocationLabel(candidate),
                description: this.formatLocationDescription(candidate),
                metadata: candidate
              })),
              allowManualEntry: true,
              manualEntryPlaceholder: 'Type the full city + country (e.g., "Madinat al Riyadh, Saudi Arabia")'
            };
            return {
              autoResolved: [],
              questions: [question]
            };
          }
          return {
            autoResolved: locations2,
            questions: []
          };
        } catch (error) {
          console.error("[LocationResolver] resolveAll failed, returning empty result:", error.message);
          return {
            autoResolved: [],
            questions: []
          };
        }
      }
      /**
       * Create a clarification question for ambiguous location
       */
      createGeographicQuestion(placeName, candidates) {
        const topCandidates = candidates.sort((a, b) => b.importance - a.importance).slice(0, 3);
        return {
          id: `geo_${placeName.toLowerCase().replace(/\s+/g, "_")}`,
          question: `Which "${placeName}" do you mean?`,
          rawQuery: placeName,
          multiSelect: false,
          options: topCandidates.map((candidate, idx) => ({
            value: `location_${idx}`,
            label: this.formatLocationLabel(candidate),
            description: this.formatLocationDescription(candidate),
            metadata: candidate
          })),
          allowManualEntry: true,
          manualEntryPlaceholder: 'Type the full city + country (e.g., "Madinat al Riyadh, Saudi Arabia")'
        };
      }
      /**
       * Format location for display label
       */
      formatLocationLabel(candidate) {
        const parts = [];
        if (candidate.adminLevels.city) {
          parts.push(candidate.adminLevels.city);
        }
        if (candidate.adminLevels.state) {
          parts.push(candidate.adminLevels.state);
        }
        if (candidate.adminLevels.country) {
          parts.push(candidate.adminLevels.country);
        }
        return parts.join(", ") || candidate.displayName.split(",").slice(0, 2).join(",");
      }
      /**
       * Format location description with coordinates
       */
      formatLocationDescription(candidate) {
        const parts = [];
        if (candidate.adminLevels.county) {
          parts.push(candidate.adminLevels.county);
        }
        parts.push(`${candidate.countryCode}`);
        parts.push(`(${candidate.lat.toFixed(4)}, ${candidate.lon.toFixed(4)})`);
        return parts.join(" \u2022 ");
      }
      /**
       * Clear cache (for testing or memory management)
       */
      clearCache() {
        this.cache.clear();
      }
    };
    locationResolver = new LocationResolverService();
  }
});

// server/services/five-whys-coach.ts
var FiveWhysCoach, fiveWhysCoach;
var init_five_whys_coach = __esm({
  "server/services/five-whys-coach.ts"() {
    "use strict";
    init_ai_clients();
    FiveWhysCoach = class {
      /**
       * Validate a candidate "Why" statement
       */
      async validateWhy(request) {
        const { level, candidate, previousWhys, rootQuestion } = request;
        const prompt = this.buildValidationPrompt(level, candidate, previousWhys, rootQuestion);
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a strategic thinking coach helping users conduct rigorous Five Whys root cause analysis. Always return valid JSON.",
            userMessage: prompt,
            maxTokens: 2e3
          });
          const evaluation = this.parseValidationResponse(response.content);
          console.log(`[FiveWhysCoach] Validated Why #${level}:`, {
            verdict: evaluation.verdict,
            issueCount: evaluation.issues.length,
            provider: response.provider
          });
          return evaluation;
        } catch (error) {
          console.error("[FiveWhysCoach] Validation error:", error);
          return {
            verdict: "needs_clarification",
            issues: [{
              type: "evidence",
              message: "Unable to fully validate this response. Please review it carefully.",
              severity: "warning"
            }],
            followUpQuestions: ["Does this answer directly address the root cause?"],
            reasoning: "Validation service temporarily unavailable"
          };
        }
      }
      /**
       * Provide interactive coaching to help user improve their answer
       */
      async provideCoaching(request) {
        const { rootQuestion, previousWhys, candidate, userQuestion, conversationHistory = [] } = request;
        const prompt = this.buildCoachingPrompt(
          rootQuestion,
          previousWhys,
          candidate,
          userQuestion,
          conversationHistory
        );
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a supportive strategic thinking coach. Help users improve their Five Whys analysis through conversational guidance. Always return valid JSON.",
            userMessage: prompt,
            maxTokens: 1500
          });
          return this.parseCoachingResponse(response.content);
        } catch (error) {
          console.error("[FiveWhysCoach] Coaching error:", error);
          return {
            guidance: "I'm having trouble connecting right now. Try thinking about: What specific, controllable factor led to this situation? What evidence supports your answer?"
          };
        }
      }
      buildValidationPrompt(level, candidate, previousWhys, rootQuestion) {
        const previousContext = previousWhys.length > 0 ? `

Previous answers in this analysis:
${previousWhys.map((w, i) => `Why #${i + 1}: ${w}`).join("\n")}` : "";
        return `You are a strategic thinking coach helping users conduct a rigorous Five Whys root cause analysis.

**Root Problem:** ${rootQuestion}${previousContext}

**Candidate Answer for Why #${level}:** ${candidate}

Evaluate this candidate answer against these criteria:

1. **Causality**: Does it identify a root CAUSE (not just restate the problem, describe a symptom, or jump to a solution)?
2. **Relevance**: Is it directly connected to ${previousWhys.length > 0 ? "the previous answer" : "the root problem"}?
3. **Specificity**: Is it concrete and specific (not vague like "bad management" or "lack of planning")?
4. **Evidence**: Is it grounded in reality (not pure speculation or wishful thinking)?
5. **Duplication**: Does it repeat what was already said in previous levels?
6. **Contradiction**: Does it contradict earlier answers in the chain?
7. **Circular Logic**: Does it create a circular loop (A causes B causes A)?

**Classification Guidelines:**
- **"acceptable"**: Advances the root cause analysis with a specific, causal, evidence-based answer
- **"needs_clarification"**: Could work but needs more detail, specificity, or evidence
- **"invalid"**: Off-topic, speculative, contradictory, circular, or just restating the problem/symptom

Return your evaluation in this JSON format:
\`\`\`json
{
  "verdict": "acceptable" | "needs_clarification" | "invalid",
  "issues": [
    {
      "type": "causality" | "relevance" | "specificity" | "evidence" | "duplication" | "contradiction" | "circular",
      "message": "Brief explanation of the issue",
      "severity": "critical" | "warning"
    }
  ],
  "followUpQuestions": [
    "Specific question to help user think deeper",
    "Another guiding question"
  ],
  "improvedSuggestion": "A better version of this answer (optional, only if you can suggest one)",
  "reasoning": "Brief explanation of your verdict"
}
\`\`\`

**IMPORTANT GUIDELINES FOR SUGGESTIONS:**
- Base suggestions ONLY on information the user has already provided
- Do NOT assume the user has conducted surveys, collected data, or performed research they haven't mentioned
- Do NOT invent specific numbers, percentages, or statistics unless the user stated them
- Keep suggestions grounded in observable, verifiable business factors
- If you can't make a concrete suggestion without making assumptions, provide follow-up questions instead

Focus on helping the user dig deeper into controllable, organizational root causes - not external factors or symptoms.`;
      }
      buildCoachingPrompt(rootQuestion, previousWhys, candidate, userQuestion, conversationHistory) {
        const previousContext = previousWhys.length > 0 ? `
Previous answers: ${previousWhys.map((w, i) => `Why #${i + 1}: ${w}`).join(" \u2192 ")}` : "";
        const historyContext = conversationHistory.length > 0 ? `

Previous coaching conversation:
${conversationHistory.map((msg) => `${msg.role === "user" ? "User" : "Coach"}: ${msg.content}`).join("\n")}` : "";
        return `You are a strategic thinking coach helping a user refine their Five Whys analysis.

**Root Problem:** ${rootQuestion}${previousContext}

**Their current answer:** ${candidate}

**Their question to you:** ${userQuestion}${historyContext}

Provide helpful, conversational guidance that:
1. Addresses their specific question
2. Helps them think more deeply about root causes
3. Encourages evidence-based, specific thinking
4. Guides them toward controllable organizational factors
5. Keeps them on track (avoid letting them drift to symptoms or external factors)

If you can suggest a better phrasing of their answer, include it.

Return your response in this JSON format:
\`\`\`json
{
  "guidance": "Your conversational coaching response here",
  "suggestedRevision": "An improved version of their answer (optional)"
}
\`\`\`

Be supportive but direct. Keep responses concise (2-4 sentences).`;
      }
      parseValidationResponse(content) {
        try {
          const jsonMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
          const jsonStr = jsonMatch ? jsonMatch[1] : content;
          const parsed = JSON.parse(jsonStr.trim());
          if (!parsed.verdict || !["acceptable", "needs_clarification", "invalid"].includes(parsed.verdict)) {
            throw new Error("Invalid verdict in response");
          }
          return {
            verdict: parsed.verdict,
            issues: Array.isArray(parsed.issues) ? parsed.issues : [],
            followUpQuestions: Array.isArray(parsed.followUpQuestions) ? parsed.followUpQuestions : [],
            improvedSuggestion: parsed.improvedSuggestion || void 0,
            reasoning: parsed.reasoning || "No reasoning provided"
          };
        } catch (error) {
          console.error("[FiveWhysCoach] Failed to parse validation response:", error);
          console.error("[FiveWhysCoach] Response content:", content);
          return {
            verdict: "needs_clarification",
            issues: [{
              type: "evidence",
              message: "Unable to parse validation response. Please review carefully.",
              severity: "warning"
            }],
            followUpQuestions: ["Is this answer specific and actionable?", "What evidence supports this?"],
            reasoning: "Failed to parse AI response"
          };
        }
      }
      parseCoachingResponse(content) {
        try {
          const jsonMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
          const jsonStr = jsonMatch ? jsonMatch[1] : content;
          const parsed = JSON.parse(jsonStr.trim());
          return {
            guidance: parsed.guidance || "Try to be more specific about the root cause.",
            suggestedRevision: parsed.suggestedRevision || void 0
          };
        } catch (error) {
          console.error("[FiveWhysCoach] Failed to parse coaching response:", error);
          if (typeof content === "string" && content.trim().length > 0 && !content.includes("{")) {
            return { guidance: content.trim() };
          }
          return {
            guidance: "Let me help you think this through: What specific factor within your organization's control led to this? What evidence do you have?"
          };
        }
      }
    };
    fiveWhysCoach = new FiveWhysCoach();
  }
});

// server/services/strategic-summary-builder.ts
function truncate2(text2, maxLength) {
  if (!text2) return "";
  return text2.length > maxLength ? text2.substring(0, maxLength) : text2;
}
async function findLatestCompletedSession(understandingId) {
  const latestSession = await db.query.journeySessions.findFirst({
    where: (tbl, { eq: eq37, and: and25 }) => and25(
      eq37(tbl.understandingId, understandingId),
      eq37(tbl.status, "completed")
    ),
    orderBy: (tbl, { desc: desc21 }) => desc21(tbl.completedAt ?? tbl.createdAt)
  });
  return latestSession;
}
async function buildStrategicSummary(understandingId) {
  const startTime = Date.now();
  const understanding = await getStrategicUnderstanding(understandingId);
  if (!understanding) {
    throw new Error("Strategic understanding not found");
  }
  const latestSession = await findLatestCompletedSession(understandingId);
  const summary = {
    summaryVersion: 2,
    strategySnapshot: {
      // Truncate baseline input to 300 chars max (enforcing 300 char limit for all text fields)
      baselineInput: truncate2(understanding.userInput, 300),
      title: understanding.title ? truncate2(understanding.title, 200) : null,
      currentGoal: understanding.initiativeDescription ? truncate2(understanding.initiativeDescription, 300) : null
    },
    latestJourney: null,
    supportingEvidence: [],
    openItems: []
  };
  if (!latestSession) {
    console.log("[StrategicSummary] No completed journey found, using baseline input only");
    return formatSummaryAsMarkdown(summary);
  }
  summary.latestJourney = {
    journeySessionId: latestSession.id,
    journeyType: latestSession.journeyType,
    completedAt: (latestSession.completedAt ?? latestSession.createdAt)?.toISOString() || "",
    frameworks: {},
    keyDecisions: []
  };
  const sessionVersions = await db.query.strategyVersions.findMany({
    where: (versions, { eq: eq37 }) => eq37(versions.sessionId, latestSession.id),
    orderBy: (versions, { desc: desc21 }) => [desc21(versions.createdAt)],
    limit: 1
    // Only the latest version from this session
  });
  if (sessionVersions.length > 0) {
    const version = sessionVersions[0];
    if (version.strategicApproach) {
      summary.latestJourney.keyDecisions.push({
        title: "Strategic Approach",
        approach: truncate2(version.strategicApproach, 150)
      });
    }
    if (version.decisionsData) {
      try {
        const decisions = typeof version.decisionsData === "string" ? JSON.parse(version.decisionsData) : version.decisionsData;
        if (Array.isArray(decisions)) {
          decisions.slice(0, 4).forEach((d) => {
            if (d.title) {
              summary.latestJourney.keyDecisions.push({
                title: truncate2(d.title, 100),
                approach: d.approach ? truncate2(d.approach, 150) : void 0
              });
            }
          });
        }
      } catch (e) {
        console.warn("[StrategicSummary] Failed to parse decisionsData:", e);
      }
    }
  }
  summary.latestJourney.keyDecisions = summary.latestJourney.keyDecisions.slice(0, 5);
  const accumulatedContext = latestSession.accumulatedContext;
  if (accumulatedContext?.fiveWhys) {
    const fiveWhysData = accumulatedContext.fiveWhys;
    summary.latestJourney.frameworks.fiveWhys = {
      rootCause: truncate2(fiveWhysData.rootCause || fiveWhysData.finalRootCause, 200),
      // Limit to 3 path items max (enforcing 3 items guarantee)
      path: (fiveWhysData.selectedPath || []).slice(0, 3).map((p) => truncate2(p, 100))
    };
  }
  if (accumulatedContext?.bmc) {
    const bmcData = accumulatedContext.bmc;
    const keyBlocks = [];
    const blockTypes = [
      "customer_segments",
      "value_propositions",
      "revenue_streams",
      "channels",
      "customer_relationships",
      "key_resources",
      "key_activities",
      "key_partnerships",
      "cost_structure"
    ];
    for (const blockType of blockTypes) {
      if (keyBlocks.length >= 3) break;
      const blockData = bmcData[blockType];
      if (blockData?.insights && Array.isArray(blockData.insights) && blockData.insights.length > 0) {
        keyBlocks.push({
          blockType,
          finding: truncate2(blockData.insights[0], 150)
        });
      }
    }
    if (keyBlocks.length > 0) {
      summary.latestJourney.frameworks.bmc = { keyBlocks };
    }
  }
  const sessionReferences = await db.query.references.findMany({
    where: (refs, { eq: eq37 }) => eq37(refs.sessionId, latestSession.id),
    orderBy: (refs, { desc: desc21 }) => [desc21(refs.confidence)],
    limit: 3
  });
  summary.supportingEvidence = sessionReferences.map((ref) => ({
    title: truncate2(ref.title, 80),
    url: ref.url,
    confidence: ref.confidence ? parseFloat(ref.confidence) : null
  }));
  const entities = await db.query.strategicEntities.findMany({
    where: (entities2, { eq: eq37 }) => eq37(entities2.understandingId, understandingId),
    orderBy: (entities2, { desc: desc21 }) => [desc21(entities2.createdAt)],
    limit: 5
  });
  summary.openItems = entities.filter((e) => e.type === "risk" || e.type === "constraint").slice(0, 5).map((e) => truncate2(e.claim, 120));
  const markdownSummary = formatSummaryAsMarkdown(summary);
  const sizeInBytes = Buffer.byteLength(markdownSummary, "utf8");
  const sizeInKB = (sizeInBytes / 1024).toFixed(2);
  const duration = Date.now() - startTime;
  console.log(`[StrategicSummary] Built summary in ${duration}ms - Size: ${sizeInKB} KB`);
  if (sizeInBytes > 8192) {
    console.warn(`\u26A0\uFE0F  [StrategicSummary] WARNING: Summary size ${sizeInKB} KB exceeds 8KB limit! This may cause token issues.`);
  }
  return markdownSummary;
}
function formatSummaryAsMarkdown(summary) {
  const lines = [];
  lines.push("# Strategic Context Summary\n");
  if (summary.strategySnapshot.title) {
    lines.push(`## ${summary.strategySnapshot.title}
`);
  }
  lines.push("## Executive Summary");
  lines.push(summary.strategySnapshot.baselineInput);
  lines.push("");
  if (summary.strategySnapshot.currentGoal) {
    lines.push("## Current Goal");
    lines.push(summary.strategySnapshot.currentGoal);
    lines.push("");
  }
  if (summary.latestJourney) {
    lines.push("## Latest Analysis");
    lines.push(`**Journey Type:** ${summary.latestJourney.journeyType}`);
    lines.push(`**Completed:** ${summary.latestJourney.completedAt}`);
    lines.push("");
    if (summary.latestJourney.frameworks.fiveWhys) {
      lines.push("### Five Whys Root Cause");
      lines.push(summary.latestJourney.frameworks.fiveWhys.rootCause);
      if (summary.latestJourney.frameworks.fiveWhys.path.length > 0) {
        lines.push("**Path:** " + summary.latestJourney.frameworks.fiveWhys.path.join(" \u2192 "));
      }
      lines.push("");
    }
    if (summary.latestJourney.frameworks.bmc) {
      lines.push("### Business Model Canvas Highlights");
      summary.latestJourney.frameworks.bmc.keyBlocks.forEach((block) => {
        lines.push(`- **${block.blockType}:** ${block.finding}`);
      });
      lines.push("");
    }
    if (summary.latestJourney.keyDecisions.length > 0) {
      lines.push("### Key Decisions");
      summary.latestJourney.keyDecisions.forEach((decision, idx) => {
        lines.push(`${idx + 1}. **${decision.title}**`);
        if (decision.approach) {
          lines.push(`   ${decision.approach}`);
        }
      });
      lines.push("");
    }
  }
  if (summary.supportingEvidence.length > 0) {
    lines.push("## Supporting Evidence");
    summary.supportingEvidence.forEach((ref, idx) => {
      const conf = ref.confidence ? ` (confidence: ${ref.confidence.toFixed(2)})` : "";
      lines.push(`${idx + 1}. ${ref.title}${conf}`);
      if (ref.url) {
        lines.push(`   ${ref.url}`);
      }
    });
    lines.push("");
  }
  if (summary.openItems.length > 0) {
    lines.push("## Outstanding Risks/Questions");
    summary.openItems.forEach((item, idx) => {
      lines.push(`${idx + 1}. ${item}`);
    });
    lines.push("");
  }
  lines.push(`*Summary v${summary.summaryVersion} - Single snapshot from latest completed journey*`);
  return lines.join("\n");
}
var init_strategic_summary_builder = __esm({
  "server/services/strategic-summary-builder.ts"() {
    "use strict";
    init_db();
    init_secure_data_service();
  }
});

// server/services/initial-sanity-check.ts
var initial_sanity_check_exports = {};
__export(initial_sanity_check_exports, {
  InitialSanityChecker: () => InitialSanityChecker,
  initialSanityChecker: () => initialSanityChecker
});
var InitialSanityChecker, initialSanityChecker;
var init_initial_sanity_check = __esm({
  "server/services/initial-sanity-check.ts"() {
    "use strict";
    init_ai_clients();
    InitialSanityChecker = class {
      /**
       * Validate user's initial strategic input for obvious impossibilities and contradictions
       */
      async checkInput(request) {
        const { userInput } = request;
        const prompt = this.buildSanityCheckPrompt(userInput);
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt: "You are a strategic business advisor helping validate business ideas for feasibility. Always return valid JSON.",
            userMessage: prompt,
            maxTokens: 1500
          });
          const result = this.parseResponse(response.content);
          console.log(`[InitialSanityChecker] Validated input:`, {
            isValid: result.isValid,
            issueCount: result.issues.length,
            provider: response.provider
          });
          return result;
        } catch (error) {
          console.error("[InitialSanityChecker] Validation error:", error);
          return {
            isValid: true,
            issues: [],
            reasoning: "Sanity check temporarily unavailable"
          };
        }
      }
      buildSanityCheckPrompt(userInput) {
        return `You are a strategic business advisor conducting an initial sanity check on a business idea.

**User's Business Idea:**
${userInput}

Check this idea for obvious red flags:

1. **Legal/Geographic Impossibilities**: Activities prohibited by law in the specified region (e.g., gambling in Saudi Arabia, cannabis in most countries, etc.)
2. **Logical Contradictions**: Mutually exclusive goals or internally contradictory statements
3. **Unrealistic Claims**: Physically impossible, technologically infeasible, or economically absurd scenarios
4. **Critical Missing Information**: So vague it's impossible to proceed (e.g., "I want to start a business")

**Classification Guidelines:**
- **Valid (isValid: true)**: Idea is feasible, even if challenging or risky. Let them proceed.
- **Invalid (isValid: false)**: ONLY for obvious impossibilities that make analysis pointless

**Important Notes:**
- Be permissive - most ideas should be valid even if ambitious
- Don't flag normal business risks or competition concerns
- Don't require perfect market research upfront
- Focus only on OBVIOUS impossibilities that would waste the user's time

Return your evaluation in this JSON format:
\`\`\`json
{
  "isValid": true | false,
  "issues": [
    {
      "type": "legal_impossibility" | "logical_contradiction" | "unrealistic_claim" | "critical_missing_info",
      "severity": "critical" | "warning",
      "message": "Brief explanation of the issue",
      "suggestion": "How they could reformulate this (optional)"
    }
  ],
  "reasoning": "Brief explanation of your assessment",
  "improvedFormulation": "A better way to frame their idea (optional, only for critical issues)"
}
\`\`\`

Be supportive but honest. Help them succeed by catching obvious problems early.`;
      }
      parseResponse(content) {
        try {
          const jsonMatch = content.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
          const jsonStr = jsonMatch ? jsonMatch[1] : content;
          const parsed = JSON.parse(jsonStr.trim());
          if (typeof parsed.isValid !== "boolean") {
            throw new Error("Invalid isValid in response");
          }
          return {
            isValid: parsed.isValid,
            issues: Array.isArray(parsed.issues) ? parsed.issues : [],
            reasoning: parsed.reasoning || "No reasoning provided",
            improvedFormulation: parsed.improvedFormulation || void 0
          };
        } catch (error) {
          console.error("[InitialSanityChecker] Failed to parse response:", error);
          console.error("[InitialSanityChecker] Response content:", content);
          return {
            isValid: true,
            issues: [],
            reasoning: "Failed to parse sanity check response"
          };
        }
      }
    };
    initialSanityChecker = new InitialSanityChecker();
  }
});

// shared/contracts/bridge.contract.ts
var bridge_contract_exports = {};
__export(bridge_contract_exports, {
  createBridge: () => createBridge,
  getBridge: () => getBridge,
  hasBridge: () => hasBridge2,
  listBridges: () => listBridges,
  registerBridge: () => registerBridge2
});
function registerBridge2(bridge) {
  const key = `${bridge.fromModule}_to_${bridge.toModule}`;
  bridgeRegistry.set(key, bridge);
  console.log(`[Bridge Registry] Registered bridge: ${bridge.id} (${bridge.fromModule} \u2192 ${bridge.toModule})`);
}
function getBridge(fromModule, toModule) {
  const key = `${fromModule}_to_${toModule}`;
  return bridgeRegistry.get(key);
}
function listBridges() {
  return Array.from(bridgeRegistry.values()).map((b) => ({
    id: b.id,
    from: b.fromModule,
    to: b.toModule
  }));
}
function hasBridge2(fromModule, toModule) {
  const key = `${fromModule}_to_${toModule}`;
  return bridgeRegistry.has(key);
}
function createBridge(config) {
  return {
    name: config.name || `${config.fromModule} \u2192 ${config.toModule}`,
    description: config.description || `Transforms ${config.fromModule} output for ${config.toModule}`,
    interpretationRules: config.interpretationRules || [],
    validateSource: config.validateSource || ((from) => {
      const result = config.fromSchema.safeParse(from);
      return {
        valid: result.success,
        errors: result.success ? void 0 : [result.error.message]
      };
    }),
    validateTransformation: config.validateTransformation || (() => ({
      valid: true
    })),
    ...config
  };
}
var bridgeRegistry;
var init_bridge_contract = __esm({
  "shared/contracts/bridge.contract.ts"() {
    "use strict";
    bridgeRegistry = /* @__PURE__ */ new Map();
  }
});

// server/routes/strategic-consultant-legacy.ts
import { Router } from "express";
import multer from "multer";
import { randomUUID as randomUUID3 } from "crypto";
import { unlink } from "fs/promises";
import { eq as eq18, and as and14, inArray as inArray4 } from "drizzle-orm";
var router, upload, inputProcessor, strategyAnalyzer, decisionGenerator, versionManager, epmConverter, epmIntegrator2, whysTreeGenerator, marketResearcher, frameworkSelector, bmcResearcher, journeyOrchestrator3, strategic_consultant_legacy_default;
var init_strategic_consultant_legacy = __esm({
  "server/routes/strategic-consultant-legacy.ts"() {
    "use strict";
    init_input_processor2();
    init_strategy_analyzer();
    init_decision_generator();
    init_version_manager();
    init_epm_converter();
    init_epm_integrator();
    init_epm_adapter();
    init_whys_tree_generator();
    init_market_researcher();
    init_framework_selector();
    init_bmc_researcher();
    init_storage();
    init_replitAuth();
    init_db();
    init_schema();
    init_strategic_understanding_service();
    init_journey_orchestrator();
    init_journey_registry();
    init_initiative_classifier();
    init_config();
    init_ambiguity_detector();
    init_location_resolver();
    init_secure_data_service();
    init_five_whys_coach();
    init_strategic_summary_builder();
    init_reference_service();
    init_journey_summary_service();
    init_kms_encryption();
    init_whys_path();
    router = Router();
    upload = multer({
      dest: "/tmp/uploads/",
      limits: { fileSize: 50 * 1024 * 1024 }
    });
    inputProcessor = new InputProcessor();
    strategyAnalyzer = new StrategyAnalyzer();
    decisionGenerator = new DecisionGenerator();
    versionManager = new VersionManager(storage);
    epmConverter = new EPMConverter();
    epmIntegrator2 = new EPMIntegrator();
    whysTreeGenerator = new WhysTreeGenerator();
    marketResearcher = new MarketResearcher();
    frameworkSelector = new FrameworkSelector();
    bmcResearcher = new BMCResearcher();
    journeyOrchestrator3 = new JourneyOrchestrator();
    router.post("/extract-file", upload.single("file"), async (req, res) => {
      let filePath;
      try {
        const file = req.file;
        if (!file) {
          return res.status(400).json({ error: "File is required" });
        }
        filePath = file.path;
        const fileType = file.mimetype;
        let processedInput;
        if (fileType === "application/pdf") {
          processedInput = await inputProcessor.processPDF(file.path);
        } else if (fileType === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
          processedInput = await inputProcessor.processDOCX(file.path);
        } else if (fileType === "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") {
          processedInput = await inputProcessor.processExcel(file.path);
        } else if (fileType.startsWith("image/")) {
          processedInput = await inputProcessor.processImage(file.path, file.mimetype);
        } else {
          return res.status(400).json({ error: "Unsupported file type" });
        }
        res.json({
          success: true,
          content: processedInput.content,
          metadata: processedInput.metadata,
          fileName: file.originalname
          // Include fileName for enrichment tracking
        });
      } catch (error) {
        console.error("Error in /extract-file:", error);
        res.status(500).json({ error: error.message || "File extraction failed" });
      } finally {
        if (filePath) {
          try {
            await unlink(filePath);
          } catch (unlinkError) {
            console.error("Error cleaning up file:", unlinkError);
          }
        }
      }
    });
    router.post("/analyze", upload.single("file"), async (req, res) => {
      try {
        const { text: text2, sessionId } = req.body;
        const file = req.file;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        if (!text2 && !file) {
          return res.status(400).json({ error: "Either text or file is required" });
        }
        let processedInput;
        if (file) {
          const fileType = file.mimetype;
          if (fileType === "application/pdf") {
            processedInput = await inputProcessor.processPDF(file.path);
          } else if (fileType === "application/vnd.openxmlformats-officedocument.wordprocessingml.document") {
            processedInput = await inputProcessor.processDOCX(file.path);
          } else if (fileType === "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet") {
            processedInput = await inputProcessor.processExcel(file.path);
          } else if (fileType.startsWith("image/")) {
            processedInput = await inputProcessor.processImage(file.path, file.mimetype);
          } else {
            await unlink(file.path);
            return res.status(400).json({ error: "Unsupported file type" });
          }
          await unlink(file.path);
        } else {
          processedInput = await inputProcessor.processText(text2);
        }
        const analysis = await strategyAnalyzer.performFullAnalysis(processedInput.content);
        const decisions = await decisionGenerator.generateDecisions(analysis, processedInput.content);
        const validationResult = await decisionGenerator.validateDecisions(decisions);
        if (!validationResult.valid) {
          return res.status(400).json({
            error: "Generated decisions are invalid",
            issues: validationResult.issues
          });
        }
        const userId = req.user?.claims?.sub || null;
        const version = await versionManager.createVersion(sessionId, analysis, decisions, userId);
        if (file && processedInput) {
          const { backgroundJobService: backgroundJobService2 } = await Promise.resolve().then(() => (init_background_job_service(), background_job_service_exports));
          await backgroundJobService2.createJob({
            userId,
            jobType: "document_enrichment",
            sessionId,
            relatedEntityId: version.versionNumber.toString(),
            relatedEntityType: "strategy_version",
            inputData: {
              processedInput,
              sessionId,
              fileName: file.originalname
            }
          });
          console.log("[Analyze] \u2713 Queued document enrichment job for:", file.originalname);
        }
        res.json({
          success: true,
          analysis,
          decisions,
          version: {
            versionNumber: version.versionNumber,
            status: version.status,
            createdAt: version.createdAt
          },
          metadata: processedInput.metadata,
          inputContent: processedInput.content
        });
      } catch (error) {
        console.error("Error in /analyze:", error);
        res.status(500).json({ error: error.message || "Analysis failed" });
      }
    });
    router.post("/check-sanity", async (req, res) => {
      try {
        const { userInput } = req.body;
        if (!userInput) {
          return res.status(400).json({ error: "userInput is required" });
        }
        const { initialSanityChecker: initialSanityChecker2 } = await Promise.resolve().then(() => (init_initial_sanity_check(), initial_sanity_check_exports));
        const result = await initialSanityChecker2.checkInput({ userInput });
        res.json(result);
      } catch (error) {
        console.error("[Strategic Consultant] Error in sanity check:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router.post("/check-ambiguities", async (req, res) => {
      try {
        const { userInput } = req.body;
        if (!userInput) {
          return res.status(400).json({ error: "userInput is required" });
        }
        const textForLocationCheck = typeof userInput === "string" ? userInput : userInput.text || "";
        const fullInputForAmbiguity = typeof userInput === "string" ? userInput : userInput.fullInput || userInput.text || userInput;
        console.log("[Ambiguity Check] Step 1: Checking for geographic ambiguities...");
        let locationResult = { autoResolved: [], questions: [] };
        try {
          locationResult = await locationResolver.resolveAll(textForLocationCheck);
          for (const location of locationResult.autoResolved) {
            await storage.createLocation({
              rawQuery: location.rawQuery,
              displayName: location.displayName,
              lat: location.lat.toString(),
              lon: location.lon.toString(),
              countryCode: location.countryCode,
              adminLevels: location.adminLevels
            });
            console.log(`[Ambiguity Check] Auto-resolved location: ${location.rawQuery} \u2192 ${location.displayName}`);
          }
        } catch (locationError) {
          console.warn("[Ambiguity Check] Geographic resolution failed (external API unavailable), continuing without location data:", locationError.message);
        }
        console.log("[Ambiguity Check] Step 2: Checking for other ambiguities...");
        const result = await ambiguityDetector.detectAmbiguities(
          fullInputForAmbiguity,
          locationResult.questions
        );
        res.json(result);
      } catch (error) {
        console.error("[Strategic Consultant] Error checking ambiguities:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router.post("/validate-manual-location", async (req, res) => {
      try {
        const { userInput } = req.body;
        if (!userInput || typeof userInput !== "string" || !userInput.trim()) {
          return res.status(400).json({ error: "userInput is required and must be a non-empty string" });
        }
        console.log(`[Manual Location Validation] Validating user input: "${userInput}"`);
        const locations2 = await locationResolver.extractAndResolveLocations(userInput);
        if (locations2.length > 0) {
          console.log(`[Manual Location Validation] Found ${locations2.length} validated location(s)`);
          res.json({
            validated: true,
            suggestions: locations2,
            originalInput: userInput
          });
        } else {
          console.log(`[Manual Location Validation] No locations found, allowing unvalidated entry`);
          res.json({
            validated: false,
            originalInput: userInput
          });
        }
      } catch (error) {
        console.error("[Manual Location Validation] Error:", error);
        res.status(500).json({ error: error.message });
      }
    });
    router.post("/understanding", async (req, res) => {
      try {
        const { input, clarifications, fileMetadata } = req.body;
        if (!input || !input.trim()) {
          return res.status(400).json({ error: "Input text is required" });
        }
        const finalInput = clarifications ? ambiguityDetector.buildClarifiedInput(input.trim(), clarifications) : input.trim();
        const sessionId = `session-${Date.now()}-${Math.random().toString(36).substring(7)}`;
        console.log("[Understanding] Step 1: Classifying initiative type...");
        const classification = await InitiativeClassifier.classify(finalInput);
        console.log("[Understanding] Classification result:", {
          type: classification.initiativeType,
          confidence: classification.confidence,
          description: classification.description
        });
        console.log("[Understanding] Step 2: Starting Strategic Understanding analysis with ontology/knowledge graph...");
        const result = await strategicUnderstandingService.extractUnderstanding({
          sessionId,
          userInput: finalInput,
          companyContext: null
        });
        console.log(`[Understanding] Analysis complete - extracted ${result.entities.length} entities`);
        console.log("[Understanding] \u{1F510} Encrypting and saving initiative classification...");
        await updateStrategicUnderstanding(result.understandingId, {
          initiativeType: classification.initiativeType,
          initiativeDescription: classification.description,
          classificationConfidence: classification.confidence.toString(),
          // Convert to string for decimal type
          userConfirmed: false
          // Not yet confirmed by user
        });
        console.log("[Understanding] \u2713 Initiative classification saved to database with encryption");
        if (fileMetadata?.fileName && fileMetadata?.content) {
          const userId = req.user?.claims?.sub || null;
          const { backgroundJobService: backgroundJobService2 } = await Promise.resolve().then(() => (init_background_job_service(), background_job_service_exports));
          const processedInput = {
            content: fileMetadata.content,
            metadata: fileMetadata.metadata || {}
          };
          await backgroundJobService2.createJob({
            userId,
            jobType: "document_enrichment",
            sessionId,
            relatedEntityId: result.understandingId,
            relatedEntityType: "strategic_understanding",
            inputData: {
              processedInput,
              sessionId,
              understandingId: result.understandingId,
              fileName: fileMetadata.fileName
            }
          });
          console.log("[Understanding] \u2713 Queued document enrichment job for:", fileMetadata.fileName);
        }
        res.json({
          success: true,
          understandingId: result.understandingId,
          sessionId,
          entitiesExtracted: result.entities.length,
          // Include classification in response for immediate use
          classification: {
            initiativeType: classification.initiativeType,
            description: classification.description,
            confidence: classification.confidence,
            reasoning: classification.reasoning,
            userConfirmed: false
          }
        });
      } catch (error) {
        console.error("Error in /understanding:", error);
        res.status(500).json({ error: error.message || "Failed to create understanding" });
      }
    });
    router.get("/understanding/:understandingId", async (req, res) => {
      try {
        const { understandingId } = req.params;
        if (!understandingId) {
          return res.status(400).json({ error: "Understanding ID is required" });
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          return res.status(404).json({ error: "Understanding not found" });
        }
        res.json({
          id: understanding.id,
          sessionId: understanding.sessionId,
          userInput: understanding.userInput,
          initiativeType: understanding.initiativeType,
          initiativeDescription: understanding.initiativeDescription,
          classificationConfidence: understanding.classificationConfidence,
          userConfirmed: understanding.userConfirmed
        });
      } catch (error) {
        console.error("Error in /understanding/:understandingId:", error);
        res.status(500).json({ error: error.message || "Failed to fetch understanding" });
      }
    });
    router.get("/journey-sessions/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        const session3 = await getJourneySession(sessionId);
        if (!session3) {
          return res.status(404).json({ error: "Journey session not found" });
        }
        res.json({
          id: session3.id,
          understandingId: session3.understandingId,
          journeyType: session3.journeyType,
          currentFrameworkIndex: session3.currentFrameworkIndex,
          completedFrameworks: session3.completedFrameworks,
          createdAt: session3.createdAt,
          updatedAt: session3.updatedAt
        });
      } catch (error) {
        console.error("Error in /journey-sessions/:sessionId:", error);
        res.status(500).json({ error: error.message || "Failed to fetch journey session" });
      }
    });
    router.get("/journey-sessions/by-session/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        const session3 = await getJourneySessionByUnderstandingSessionId(sessionId);
        if (!session3) {
          return res.status(404).json({ error: "Journey session not found" });
        }
        let pageSequence = [];
        let frameworks = [];
        if (session3.journeyType) {
          const journeyDef = journeyRegistry.getJourney(session3.journeyType);
          if (journeyDef) {
            pageSequence = journeyDef.pageSequence || [];
            frameworks = journeyDef.frameworks || [];
          }
        }
        res.json({
          id: session3.id,
          understandingId: session3.understandingId,
          journeyType: session3.journeyType,
          currentFrameworkIndex: session3.currentFrameworkIndex,
          completedFrameworks: session3.completedFrameworks,
          createdAt: session3.createdAt,
          updatedAt: session3.updatedAt,
          pageSequence,
          // Added for dynamic navigation
          frameworks
          // Added for dynamic navigation
        });
      } catch (error) {
        console.error("Error in /journey-sessions/by-session/:sessionId:", error);
        res.status(500).json({ error: error.message || "Failed to fetch journey session" });
      }
    });
    router.patch("/classification", async (req, res) => {
      try {
        const { understandingId, initiativeType, userConfirmed } = req.body;
        if (!understandingId || typeof understandingId !== "string") {
          return res.status(400).json({ error: "Valid understanding ID is required" });
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          return res.status(404).json({ error: "Understanding not found" });
        }
        const updateData = {};
        if (initiativeType !== void 0) {
          const validTypes = [
            "physical_business_launch",
            "software_development",
            "digital_transformation",
            "market_expansion",
            "product_launch",
            "service_launch",
            "process_improvement",
            "other"
          ];
          if (typeof initiativeType !== "string" || !validTypes.includes(initiativeType)) {
            return res.status(400).json({
              error: "Invalid initiative type. Must be one of the valid enum values.",
              validTypes,
              received: initiativeType
            });
          }
          updateData.initiativeType = initiativeType;
        }
        if (userConfirmed !== void 0) {
          if (typeof userConfirmed !== "boolean") {
            return res.status(400).json({
              error: "userConfirmed must be a boolean value",
              received: typeof userConfirmed
            });
          }
          updateData.userConfirmed = userConfirmed;
        }
        if (Object.keys(updateData).length === 0) {
          return res.status(400).json({
            error: "No valid fields provided for update. Provide initiativeType and/or userConfirmed."
          });
        }
        console.log("[Classification] \u{1F510} Updating classification with encryption protection...");
        await updateStrategicUnderstanding(understandingId, updateData);
        console.log("[Classification] \u2713 Updated classification for understanding:", understandingId, updateData);
        res.json({
          success: true,
          message: "Classification updated successfully",
          understandingId,
          updates: updateData
        });
      } catch (error) {
        console.error("Error in PATCH /classification:", error);
        res.status(500).json({ error: error.message || "Failed to update classification" });
      }
    });
    router.post("/journeys/execute", async (req, res) => {
      try {
        const { journeyType, understandingId } = req.body;
        if (!journeyType || !understandingId) {
          return res.status(400).json({
            error: "Both journeyType and understandingId are required"
          });
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          return res.status(404).json({ error: "Understanding not found" });
        }
        const journey = journeyRegistry.getJourney(journeyType);
        if (!journey) {
          return res.status(404).json({ error: "Journey not found" });
        }
        if (!journey.available) {
          return res.status(400).json({
            error: "This journey is not yet available",
            journeyName: journey.name
          });
        }
        const userId = req.user?.claims?.sub || null;
        const { journeySessionId, versionNumber } = await journeyOrchestrator3.startJourney(
          understanding.id,
          journeyType,
          userId
        );
        const firstPage = journey.pageSequence?.[1] || "/strategic-consultant/whys-tree/:understandingId";
        console.log(`[JourneyExecute] journeyType=${journeyType}, pageSequence[1]=${firstPage}`);
        const navigationUrl = firstPage.replace(":understandingId", understandingId).replace(":sessionId", understanding.sessionId).replace(":versionNumber", String(versionNumber));
        console.log(`[JourneyExecute] Final navigationUrl=${navigationUrl}`);
        res.json({
          success: true,
          journeySessionId,
          sessionId: understanding.sessionId,
          // Session ID used in navigation URLs
          versionNumber,
          // Version number for this journey session
          journeyType,
          message: "Journey initialized successfully",
          navigationUrl,
          totalSteps: journey.frameworks.length
        });
      } catch (error) {
        console.error("Error in /journeys/execute:", error);
        res.status(500).json({ error: error.message || "Journey execution failed" });
      }
    });
    router.post("/journeys/:sessionId/execute", async (req, res) => {
      try {
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        const journeySession = await getJourneySession(sessionId);
        if (!journeySession) {
          return res.status(404).json({ error: "Journey session not found" });
        }
        console.log(`[Journey API] Triggering execution for session: ${sessionId}`);
        journeyOrchestrator3.executeJourney(sessionId, (progress) => {
          console.log(`[Journey Progress] ${sessionId}: ${progress.status} (${progress.percentComplete}%)`);
        }).then(() => {
          console.log(`[Journey API] \u2713 Journey ${sessionId} completed successfully`);
        }).catch((error) => {
          console.error(`[Journey API] \u2717 Journey ${sessionId} failed:`, error.message);
        });
        res.json({
          success: true,
          message: "Journey execution started",
          sessionId,
          status: "in_progress"
        });
      } catch (error) {
        console.error("Error in /journeys/:sessionId/execute:", error);
        res.status(500).json({ error: error.message || "Journey execution failed" });
      }
    });
    router.get("/journeys/:sessionId/results", async (req, res) => {
      try {
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        const journeySession = await getJourneySession(sessionId);
        if (!journeySession) {
          return res.status(404).json({ error: "Journey session not found" });
        }
        res.json({
          success: true,
          journeyType: journeySession.journeyType,
          status: journeySession.status,
          completedFrameworks: journeySession.completedFrameworks,
          context: journeySession.accumulatedContext,
          // Already decrypted by secure service
          completedAt: journeySession.completedAt,
          metadata: journeySession.metadata
          // Custom journey metadata (frameworks, templateId)
        });
      } catch (error) {
        console.error("Error in /journeys/:sessionId/results:", error);
        res.status(500).json({ error: error.message || "Failed to fetch journey results" });
      }
    });
    router.post("/journeys/summary", async (req, res) => {
      try {
        const { understandingId, journeyType } = req.body;
        if (!understandingId || !journeyType) {
          return res.status(400).json({
            error: "Both understandingId and journeyType are required"
          });
        }
        if (!isJourneyRegistryV2Enabled()) {
          console.log("[Strategic Consultant] Journey Registry V2 disabled, returning empty summary");
          return res.json({ success: true, summary: null });
        }
        const summary = await journeySummaryService.getLatestSummary(understandingId, journeyType);
        if (!summary) {
          return res.json({ success: true, summary: null });
        }
        res.json({
          success: true,
          summary: {
            completedAt: summary.completedAt,
            versionNumber: summary.versionNumber,
            keyInsights: summary.keyInsights.slice(0, 3),
            strategicImplications: summary.strategicImplications.slice(0, 2)
          }
        });
      } catch (error) {
        console.error("Error in /journeys/summary:", error);
        res.status(500).json({ error: error.message || "Failed to fetch journey summary" });
      }
    });
    router.post("/decisions/select", async (req, res) => {
      try {
        const { sessionId, versionNumber, selectedDecisions } = req.body;
        if (!sessionId || !versionNumber || !selectedDecisions) {
          return res.status(400).json({
            error: "sessionId, versionNumber, and selectedDecisions are required"
          });
        }
        const updated = await versionManager.updateVersion(
          sessionId,
          versionNumber,
          selectedDecisions
        );
        console.log(`[Decisions] Saved decisions for session ${sessionId} v${versionNumber}. Frontend will auto-trigger EPM conversion.`);
        res.json({
          success: true,
          version: {
            versionNumber: updated.versionNumber,
            status: updated.status,
            selectedDecisions: updated.selectedDecisions
          }
        });
      } catch (error) {
        console.error("Error in /decisions/select:", error);
        res.status(500).json({ error: error.message || "Failed to update decisions" });
      }
    });
    router.post("/convert-to-epm", async (req, res) => {
      try {
        const { sessionId, versionNumber, useLegacyEngine } = req.body;
        const userId = req.user?.claims?.sub;
        if (!sessionId || !versionNumber) {
          return res.status(400).json({ error: "sessionId and versionNumber are required" });
        }
        const version = await storage.getStrategyVersion(sessionId, versionNumber);
        if (!version) {
          return res.status(404).json({ error: "Version not found" });
        }
        if (!version.selectedDecisions || Object.keys(version.selectedDecisions).length === 0) {
          return res.status(400).json({ error: "Version must have selected decisions" });
        }
        let program;
        let engineUsed;
        const useV2Engine = !useLegacyEngine && process.env.USE_EPM_V2_ENGINE !== "false";
        if (useV2Engine) {
          console.log("[convert-to-epm] Using V2 EPM engine (EPMSynthesizer via Journey Builder)");
          engineUsed = "v2";
          try {
            program = await epmAdapter.convertToEPM({
              analysisData: version.analysisData,
              decisionsData: version.decisionsData,
              selectedDecisions: version.selectedDecisions,
              sessionId,
              versionNumber,
              userId
            });
          } catch (v2Error) {
            console.error("[convert-to-epm] V2 engine failed, falling back to legacy:", v2Error.message);
            console.error("[convert-to-epm] V2 error details:", v2Error.stack);
            engineUsed = "legacy";
            program = await epmConverter.convertToEPM(
              version.analysisData,
              version.decisionsData,
              version.selectedDecisions
            );
            program._v2FallbackReason = v2Error.message;
          }
        } else {
          console.log("[convert-to-epm] Using legacy EPM engine (EPMConverter)");
          engineUsed = "legacy";
          program = await epmConverter.convertToEPM(
            version.analysisData,
            version.decisionsData,
            version.selectedDecisions
          );
        }
        const structureValidation = await epmConverter.validateEPMStructure(program);
        if (!structureValidation.valid) {
          return res.status(400).json({
            error: "Invalid EPM structure",
            issues: structureValidation.issues,
            warnings: structureValidation.warnings
          });
        }
        const ontologyValidation = await epmConverter.validateAgainstOntology(program);
        const finalized = await versionManager.finalizeVersion(sessionId, versionNumber, program);
        res.json({
          success: true,
          program,
          engineUsed,
          validation: {
            structure: structureValidation,
            ontology: ontologyValidation
          },
          version: {
            versionNumber: finalized.versionNumber,
            status: finalized.status,
            finalizedAt: finalized.finalizedAt
          }
        });
      } catch (error) {
        console.error("Error in /convert-to-epm:", error);
        res.status(500).json({ error: error.message || "EPM conversion failed" });
      }
    });
    router.get("/versions/all", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const versions = await storage.getAllStrategyVersionsByUser(userId);
        res.json(versions);
      } catch (error) {
        console.error("Error in /versions/all:", error);
        res.status(500).json({ error: error.message || "Failed to fetch versions" });
      }
    });
    router.get("/versions/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        const versions = await versionManager.listVersions(sessionId);
        res.json({
          success: true,
          versions: versions.map((v) => ({
            versionNumber: v.versionNumber,
            status: v.status,
            createdAt: v.createdAt,
            finalizedAt: v.finalizedAt,
            hasSelectedDecisions: !!v.selectedDecisions,
            hasProgram: !!v.programStructure,
            decisions: v.decisions,
            // Include AI-generated decisions for DecisionSummaryPage
            analysis: v.analysis
            // Include analysis data for frontend access
          }))
        });
      } catch (error) {
        console.error("Error in /versions:", error);
        res.status(500).json({ error: error.message || "Failed to fetch versions" });
      }
    });
    router.get("/versions/:sessionId/:versionNumber", async (req, res) => {
      try {
        const { sessionId, versionNumber } = req.params;
        const version = await storage.getStrategyVersion(sessionId, parseInt(versionNumber));
        if (!version) {
          return res.status(404).json({ error: "Version not found" });
        }
        console.log("[GET /versions] Retrieved version:", {
          hasId: !!version.id,
          id: version.id,
          versionNumber: version.versionNumber,
          sessionId: version.sessionId
        });
        let analysisData = version.analysisData || {};
        const understanding = await db.query.strategicUnderstanding.findFirst({
          where: eq18(strategicUnderstanding.sessionId, sessionId)
        });
        if (understanding) {
          const journeySession = await db.query.journeySessions.findFirst({
            where: eq18(journeySessions.understandingId, understanding.id),
            orderBy: (js, { desc: desc21 }) => [desc21(js.updatedAt)]
          });
          if (journeySession) {
            console.log(`[GET /versions] Found journeySession ${journeySession.id} for understanding ${understanding.id}`);
            const insights = await db.query.frameworkInsights.findMany({
              where: eq18(frameworkInsights.sessionId, journeySession.id),
              orderBy: (fi, { asc }) => [asc(fi.createdAt)]
            });
            if (insights.length > 0) {
              console.log(`[GET /versions] Found ${insights.length} framework insights`);
              const frameworkResults = insights.map((insight) => ({
                framework: insight.frameworkName,
                ...insight.insights || {}
              }));
              analysisData = {
                ...analysisData,
                frameworks: frameworkResults
              };
            }
          }
        }
        res.json({
          success: true,
          version: {
            id: version.id,
            versionNumber: version.versionNumber,
            status: version.status,
            analysis: analysisData,
            decisions: version.decisionsData,
            selectedDecisions: version.selectedDecisions,
            program: version.programStructure,
            createdAt: version.createdAt,
            finalizedAt: version.finalizedAt
          }
        });
      } catch (error) {
        console.error("Error in /versions/:sessionId/:versionNumber:", error);
        res.status(500).json({ error: error.message || "Failed to fetch version" });
      }
    });
    router.patch("/versions/:sessionId/:versionNumber", async (req, res) => {
      try {
        const { sessionId, versionNumber } = req.params;
        const { selectedDecisions } = req.body;
        if (!selectedDecisions) {
          return res.status(400).json({ error: "selectedDecisions is required" });
        }
        const version = await storage.getStrategyVersion(sessionId, parseInt(versionNumber));
        if (!version) {
          return res.status(404).json({ error: "Version not found" });
        }
        await db.update(strategyVersions).set({
          selectedDecisions,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq18(strategyVersions.id, version.id));
        res.json({
          success: true,
          message: "Selected decisions saved"
        });
      } catch (error) {
        console.error("Error in PATCH /versions/:sessionId/:versionNumber:", error);
        res.status(500).json({ error: error.message || "Failed to update version" });
      }
    });
    router.post("/versions/compare", async (req, res) => {
      try {
        const { sessionId, versionA, versionB } = req.body;
        if (!sessionId || !versionA || !versionB) {
          return res.status(400).json({
            error: "sessionId, versionA, and versionB are required"
          });
        }
        const comparison = await versionManager.compareVersions(
          sessionId,
          versionA,
          versionB
        );
        res.json({
          success: true,
          comparison
        });
      } catch (error) {
        console.error("Error in /versions/compare:", error);
        res.status(500).json({ error: error.message || "Version comparison failed" });
      }
    });
    router.post("/integrate/:sessionId/:versionNumber", async (req, res) => {
      try {
        const { sessionId, versionNumber } = req.params;
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const version = await storage.getStrategyVersion(sessionId, parseInt(versionNumber));
        if (!version) {
          return res.status(404).json({ error: "Version not found" });
        }
        if (!version.programStructure) {
          return res.status(400).json({
            error: "No EPM program structure found. Please convert decisions to EPM program first."
          });
        }
        const startedVersion = await storage.tryStartIntegration(version.id);
        if (!startedVersion) {
          return res.status(400).json({
            error: "This version is already integrated or currently being integrated",
            programId: version.convertedProgramId
          });
        }
        try {
          const result = await epmIntegrator2.integrateToEPMSuite(
            version.programStructure,
            userId,
            sessionId,
            version.id
          );
          await storage.updateStrategyVersion(version.id, {
            status: "converted_to_program"
          });
          res.json({
            success: true,
            programId: result.programId,
            summary: result.summary,
            message: "Strategic Consultant program successfully integrated into EPM Suite"
          });
        } catch (error) {
          const currentVersion = await storage.getStrategyVersion(sessionId, parseInt(versionNumber));
          if (currentVersion?.convertedProgramId) {
            await storage.updateStrategyVersion(version.id, {
              status: "converted_to_program"
            });
          } else {
            await storage.updateStrategyVersion(version.id, {
              status: version.status
              // Restore original status
            });
          }
          throw error;
        }
      } catch (error) {
        console.error("Error in /integrate:", error);
        res.status(500).json({ error: error.message || "Integration failed" });
      }
    });
    router.post("/whys-tree/generate", async (req, res) => {
      try {
        const { sessionId, input } = req.body;
        if (!sessionId || !input) {
          return res.status(400).json({ error: "sessionId and input are required" });
        }
        const tree = await whysTreeGenerator.generateTree(input, sessionId);
        res.json({
          tree,
          estimatedTime: "20s"
        });
      } catch (error) {
        console.error("Error in /whys-tree/generate:", error);
        const fallbackTree = {
          rootQuestion: "Why is this strategic initiative important?",
          branches: [
            {
              id: randomUUID3(),
              question: "Why is this strategic initiative important?",
              option: "It aligns with our business goals",
              depth: 1,
              isLeaf: false,
              branches: [],
              supporting_evidence: [],
              counter_arguments: [],
              consideration: "Generated fallback due to AI service unavailability"
            }
          ],
          maxDepth: 5,
          sessionId: req.body.sessionId,
          warning: "AI service unavailable - using fallback tree structure"
        };
        console.warn("[WhysTreeGenerator] Returning fallback tree due to AI failure");
        res.json({
          tree: fallbackTree,
          estimatedTime: "0s",
          warning: "AI service temporarily unavailable. You can skip this step and proceed with your analysis."
        });
      }
    });
    router.post("/whys-tree/expand", async (req, res) => {
      try {
        const {
          sessionId,
          nodeId,
          selectedPath,
          currentDepth,
          parentQuestion,
          input,
          isCustom,
          customOption,
          allSiblings
        } = req.body;
        if (!sessionId || !nodeId || !selectedPath || currentDepth === void 0 || !parentQuestion || !input) {
          return res.status(400).json({
            error: "sessionId, nodeId, selectedPath, currentDepth, parentQuestion, and input are required"
          });
        }
        let expandedBranches;
        let fromCache = false;
        let prefetchStarted = false;
        let prefetchCount = 0;
        if (isCustom && customOption) {
          console.log("[API] Custom branch expansion requested");
          console.log("[API] selectedPath:", selectedPath);
          console.log("[API] customOption:", customOption);
          console.log("[API] isCustom:", isCustom);
          expandedBranches = await whysTreeGenerator.generateCustomBranches(
            customOption,
            selectedPath,
            input,
            sessionId,
            currentDepth
          );
        } else {
          const cached = whysTreeGenerator.getCachedBranches(sessionId, nodeId, currentDepth);
          if (cached) {
            console.log("[API] Cache HIT - returning cached branches");
            expandedBranches = cached;
            fromCache = true;
          } else {
            const result = await whysTreeGenerator.expandBranchWithPrefetch(
              nodeId,
              selectedPath,
              input,
              sessionId,
              currentDepth,
              parentQuestion,
              allSiblings
            );
            expandedBranches = result.expandedBranches;
            if (allSiblings && allSiblings.length > 1 && currentDepth <= 3) {
              prefetchStarted = true;
              prefetchCount = allSiblings.length - 1;
              console.log(`[API] Prefetch initiated for ${prefetchCount} siblings at depth ${currentDepth}`);
            }
          }
        }
        res.json({
          expandedBranches,
          fromCache,
          prefetchStarted,
          prefetchCount
        });
      } catch (error) {
        console.error("Error in /whys-tree/expand:", error);
        res.status(500).json({ error: error.message || "Branch expansion failed" });
      }
    });
    router.post("/whys-tree/finalize", async (req, res) => {
      try {
        const { sessionId, selectedPath, rootCause, versionNumber, input } = req.body;
        if (!sessionId || !selectedPath || !rootCause || !input) {
          return res.status(400).json({
            error: "sessionId, selectedPath, rootCause, and input are required"
          });
        }
        const canonicalPath = normalizeWhysPathSteps(selectedPath || []);
        const whysPathText = whysPathToText(canonicalPath);
        const canonicalTree = buildLinearWhysTree(canonicalPath);
        console.log("[FiveWhys] Finalize received:", {
          sessionId,
          versionNumber,
          selectedPathLength: Array.isArray(selectedPath) ? selectedPath.length : 0,
          normalizedPathLength: canonicalPath.length,
          rootCausePreview: rootCause?.slice(0, 120)
        });
        const insights = await whysTreeGenerator.analyzePathInsights(
          input,
          whysPathText.map((option, index2) => ({
            id: `node-${index2}`,
            question: canonicalPath[index2]?.question || "",
            option,
            depth: index2 + 1,
            isLeaf: false,
            supporting_evidence: [],
            counter_arguments: [],
            consideration: ""
          }))
        );
        const analysisData = {
          five_whys: {
            problem_statement: input,
            why_1: {
              question: canonicalPath[0]?.question || "Why is this happening?",
              answer: canonicalPath[0]?.answer || ""
            },
            why_2: {
              question: canonicalPath[1]?.question || "Why does that occur?",
              answer: canonicalPath[1]?.answer || ""
            },
            why_3: {
              question: canonicalPath[2]?.question || "Why is that the case?",
              answer: canonicalPath[2]?.answer || ""
            },
            why_4: {
              question: canonicalPath[3]?.question || "Why does that matter?",
              answer: canonicalPath[3]?.answer || ""
            },
            why_5: {
              question: canonicalPath[4]?.question || "What's the underlying cause?",
              answer: canonicalPath[4]?.answer || ""
            },
            root_cause: rootCause,
            strategic_implications: insights.strategic_implications,
            // Keep whysPath for backward compatibility
            whysPath: canonicalPath,
            tree: canonicalTree,
            recommendedActions: insights.recommended_actions,
            framework: "five_whys"
          },
          // Add fields expected by downstream pages to prevent crashes
          recommended_approaches: [],
          strategic_options: [],
          risks: [],
          porters_analysis: null
        };
        let version;
        const userId = req.user?.claims?.sub || null;
        let targetVersionNumber = versionNumber;
        const understanding = await db.query.strategicUnderstanding.findFirst({
          where: eq18(strategicUnderstanding.sessionId, sessionId)
        });
        if (understanding?.id) {
          const journeySession = await db.query.journeySessions.findFirst({
            where: eq18(journeySessions.understandingId, understanding.id)
          });
          if (journeySession?.versionNumber) {
            targetVersionNumber = journeySession.versionNumber;
            console.log(`[FiveWhys] Using journey session versionNumber=${targetVersionNumber} (authoritative)`);
          }
        }
        if (!targetVersionNumber) {
          const versions = await storage.getStrategyVersionsBySession(sessionId);
          if (versions.length > 0) {
            const maxVersion = Math.max(...versions.map((v) => v.versionNumber));
            targetVersionNumber = maxVersion;
            console.log(`[FiveWhys] No versionNumber provided, using latest=${targetVersionNumber}`);
          } else {
            targetVersionNumber = 1;
            console.log(`[FiveWhys] No existing versions, using version 1`);
          }
        }
        const existingVersion = await storage.getStrategyVersion(sessionId, targetVersionNumber);
        if (existingVersion) {
          console.log(`[FiveWhys] Updating existing version ${targetVersionNumber} for session ${sessionId}`);
          const existingAnalysisData = existingVersion.analysisData || {};
          await storage.updateStrategyVersion(existingVersion.id, {
            analysisData: {
              ...existingAnalysisData,
              ...analysisData
            }
          });
          version = existingVersion;
        } else {
          console.log(`[FiveWhys] Creating new version ${targetVersionNumber} for session ${sessionId}`);
          const doubleCheck = await storage.getStrategyVersion(sessionId, targetVersionNumber);
          if (doubleCheck) {
            targetVersionNumber++;
            console.warn(`[FiveWhys] Version collision detected, incremented to ${targetVersionNumber}`);
          }
          const initiativeDescription = await storage.getInitiativeDescriptionForSession(sessionId);
          const inputSummary = initiativeDescription || "Strategic Analysis";
          version = await storage.createStrategyVersion({
            sessionId,
            versionNumber: targetVersionNumber,
            analysisData,
            decisionsData: { decisions: [] },
            selectedDecisions: null,
            programStructure: null,
            status: "draft",
            createdBy: userId,
            userId,
            inputSummary
          });
        }
        try {
          if (understanding?.id) {
            const journeySession = await db.query.journeySessions.findFirst({
              where: eq18(journeySessions.understandingId, understanding.id)
            });
            if (journeySession?.id) {
              await db.insert(frameworkInsights).values({
                understandingId: understanding.id,
                sessionId: journeySession.id,
                frameworkName: "five_whys",
                insights: {
                  whysPath: canonicalPath,
                  rootCauses: rootCause ? [rootCause] : [],
                  strategicImplications: insights.strategic_implications || [],
                  tree: canonicalTree
                }
              });
            }
          }
        } catch (insightsError) {
          console.warn("[FiveWhys] Failed to persist frameworkInsights:", insightsError?.message || insightsError);
        }
        try {
          if (understanding?.id) {
            await db.update(journeySessions).set({ status: "completed", completedAt: /* @__PURE__ */ new Date() }).where(eq18(journeySessions.understandingId, understanding.id));
          }
        } catch (statusError) {
          console.warn("[FiveWhys] Failed to update journey status:", statusError?.message || statusError);
        }
        try {
          const writtenVersion = await storage.getStrategyVersion(sessionId, targetVersionNumber);
          const analysisData2 = typeof writtenVersion?.analysisData === "string" ? JSON.parse(writtenVersion?.analysisData) : writtenVersion?.analysisData || {};
          const five = analysisData2?.five_whys || {};
          console.log("[FiveWhys] Finalize write verification:", {
            targetVersionNumber,
            fiveWhysKeys: five ? Object.keys(five) : [],
            whysPathLength: Array.isArray(five?.whysPath) ? five.whysPath.length : 0,
            rootCause: five?.root_cause || null
          });
        } catch (verifyError) {
          console.warn("[FiveWhys] Finalize verification failed:", verifyError?.message || verifyError);
        }
        res.json({
          rootCause,
          fullPath: canonicalPath,
          strategicImplication: insights.strategic_implications.join("; "),
          versionNumber: version.versionNumber
        });
      } catch (error) {
        console.error("Error in /whys-tree/finalize:", error);
        res.status(500).json({ error: error.message || "Whys tree finalization failed" });
      }
    });
    router.post("/whys-tree/validate-root-cause", async (req, res) => {
      try {
        const { rootCauseText } = req.body;
        if (!rootCauseText) {
          return res.status(400).json({ error: "rootCauseText is required" });
        }
        const validation = await whysTreeGenerator.validateRootCause(rootCauseText);
        res.json(validation);
      } catch (error) {
        console.error("Error in /whys-tree/validate-root-cause:", error);
        res.status(500).json({ error: error.message || "Root cause validation failed" });
      }
    });
    router.get("/whys-tree/debug/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        if (!sessionId) return res.status(400).json({ error: "sessionId is required" });
        const understanding = await db.query.strategicUnderstanding.findFirst({
          where: eq18(strategicUnderstanding.sessionId, sessionId)
        });
        const journeySession = understanding?.id ? await db.query.journeySessions.findFirst({
          where: eq18(journeySessions.understandingId, understanding.id)
        }) : null;
        const versions = await storage.getStrategyVersionsBySession(sessionId);
        const versionSummaries = versions.map((v) => {
          const analysisData = typeof v.analysisData === "string" ? JSON.parse(v.analysisData) : v.analysisData || {};
          const five = analysisData?.five_whys || {};
          return {
            versionNumber: v.versionNumber,
            status: v.status,
            fiveWhysKeys: five ? Object.keys(five) : [],
            whysPathLength: Array.isArray(five?.whysPath) ? five.whysPath.length : 0,
            rootCause: five?.root_cause || null
          };
        });
        res.json({
          sessionId,
          understandingId: understanding?.id || null,
          journeySession: journeySession ? {
            id: journeySession.id,
            versionNumber: journeySession.versionNumber,
            status: journeySession.status,
            completedFrameworks: journeySession.completedFrameworks
          } : null,
          versions: versionSummaries
        });
      } catch (error) {
        console.error("[FiveWhys Debug] Error:", error);
        res.status(500).json({ error: error.message || "Debug endpoint failed" });
      }
    });
    router.get("/research/stream/:sessionId", async (req, res) => {
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      const sessionId = req.params.sessionId;
      const rootCause = req.query.rootCause;
      const whysPath = JSON.parse(req.query.whysPath || "[]");
      const whysPathText = whysPathToText(whysPath);
      const input = req.query.input;
      const versionNumber = req.query.versionNumber ? parseInt(req.query.versionNumber) : void 0;
      if (!sessionId || !rootCause || !whysPath || !input) {
        res.write(`data: ${JSON.stringify({ error: "Missing required parameters" })}

`);
        res.end();
        return;
      }
      try {
        const startTime = Date.now();
        res.write(`data: ${JSON.stringify({ type: "progress", message: "Generating research queries...", progress: 10 })}

`);
        const queries = await marketResearcher.generateResearchQueries(rootCause, input, whysPathText);
        res.write(`data: ${JSON.stringify({ type: "progress", message: `Generated ${queries.length} research queries`, progress: 20 })}

`);
        res.write(`data: ${JSON.stringify({ type: "progress", message: "Executing web searches...", progress: 30 })}

`);
        const searchResults = [];
        for (let i = 0; i < queries.length; i++) {
          const query = queries[i];
          res.write(`data: ${JSON.stringify({
            type: "query",
            message: `Searching: ${query.query}`,
            progress: 30 + (i + 1) * (30 / queries.length)
          })}

`);
          const result = await marketResearcher.performSingleWebSearch(query);
          searchResults.push(result);
        }
        res.write(`data: ${JSON.stringify({ type: "progress", message: "Selecting top sources...", progress: 65 })}

`);
        const topSources = marketResearcher.selectTopSourcesPublic(searchResults);
        res.write(`data: ${JSON.stringify({ type: "progress", message: "Fetching article content...", progress: 70 })}

`);
        const sourceContents = await marketResearcher.fetchSourceContentPublic(topSources.slice(0, 3));
        res.write(`data: ${JSON.stringify({ type: "progress", message: "Synthesizing research findings...", progress: 85 })}

`);
        const findings = await marketResearcher.synthesizeFindingsPublic(
          rootCause,
          input,
          whysPath,
          searchResults,
          topSources,
          sourceContents
        );
        res.write(`data: ${JSON.stringify({ type: "progress", message: "Validating research sources...", progress: 88 })}

`);
        const allFindings = [
          ...findings.market_dynamics,
          ...findings.competitive_landscape,
          ...findings.language_preferences,
          ...findings.buyer_behavior,
          ...findings.regulatory_factors
        ];
        const validation = await marketResearcher.validateFindingsPublic(allFindings, findings.sources);
        const findingsWithValidation = {
          ...findings,
          validation
        };
        const endTime = Date.now();
        const timeElapsedMs = endTime - startTime;
        const timeElapsed = `${(timeElapsedMs / 1e3).toFixed(1)}s`;
        res.write(`data: ${JSON.stringify({ type: "progress", message: "Saving research data...", progress: 95 })}

`);
        let targetVersionNumber;
        let version;
        if (versionNumber) {
          targetVersionNumber = versionNumber;
          version = await storage.getStrategyVersion(sessionId, targetVersionNumber);
          if (!version) {
            return res.status(404).json({ error: "Version not found" });
          }
        } else {
          const versions = await storage.getStrategyVersionsBySession(sessionId);
          if (versions.length === 0) {
            return res.status(404).json({ error: "No versions found for this session" });
          }
          version = versions[versions.length - 1];
          targetVersionNumber = version.versionNumber;
        }
        const existingAnalysisData = version.analysisData || {};
        await storage.updateStrategyVersion(version.id, {
          analysisData: {
            ...existingAnalysisData,
            research: findingsWithValidation
          }
        });
        try {
          const understanding = await getStrategicUnderstandingBySession(sessionId);
          if (understanding && req.user?.id) {
            const userId = req.user.id;
            const normalizedReferences = findingsWithValidation.sources.map(
              (source) => referenceService.normalizeReference(
                source,
                userId,
                { component: "research.pestle", claim: source.description || source.title },
                { understandingId: understanding.id, sessionId }
              )
            );
            await referenceService.persistReferences(normalizedReferences, {
              understandingId: understanding.id,
              sessionId
            });
            console.log(`[PESTLE Research] \u2705 Persisted ${normalizedReferences.length} references to knowledge graph`);
          }
        } catch (refError) {
          console.error("[PESTLE Research] \u26A0\uFE0F Failed to persist references:", refError);
        }
        const searchQueriesUsed = findingsWithValidation.sources.map((s) => s.title);
        const sourcesAnalyzed = findingsWithValidation.sources.length;
        res.write(`data: ${JSON.stringify({
          type: "complete",
          data: {
            findings: findingsWithValidation,
            searchQueriesUsed,
            sourcesAnalyzed,
            timeElapsed,
            versionNumber: targetVersionNumber,
            nextUrl: `/strategic-consultant/results/${sessionId}/${targetVersionNumber}`
          },
          progress: 100
        })}

`);
        res.end();
      } catch (error) {
        console.error("Error in /research/stream:", error);
        res.write(`data: ${JSON.stringify({ type: "error", error: error.message || "Research failed" })}

`);
        res.end();
      }
    });
    router.post("/analyze-enhanced", async (req, res) => {
      try {
        const { sessionId, rootCause, whysPath, versionNumber } = req.body;
        if (!sessionId || !rootCause || !whysPath) {
          return res.status(400).json({
            error: "sessionId, rootCause, and whysPath are required"
          });
        }
        let targetVersionNumber;
        let version;
        if (versionNumber) {
          targetVersionNumber = versionNumber;
          version = await storage.getStrategyVersion(sessionId, targetVersionNumber);
          if (!version) {
            return res.status(404).json({ error: "Version not found" });
          }
        } else {
          const versions = await storage.getStrategyVersionsBySession(sessionId);
          if (versions.length === 0) {
            return res.status(404).json({ error: "No versions found for this session" });
          }
          version = versions[versions.length - 1];
          targetVersionNumber = version.versionNumber;
        }
        const existingAnalysisData = version.analysisData || {};
        if (!existingAnalysisData.research) {
          return res.status(400).json({
            error: "No research findings available. Please conduct research first."
          });
        }
        let input = "";
        if (version.inputSummary) {
          input = version.inputSummary;
        }
        const enhancedAnalysis = await strategyAnalyzer.analyzeWithResearch(
          sessionId,
          rootCause,
          whysPath,
          existingAnalysisData.research,
          input
        );
        await storage.updateStrategyVersion(version.id, {
          analysisData: {
            ...existingAnalysisData,
            enhanced_analysis: enhancedAnalysis
          }
        });
        res.json({
          analysis: enhancedAnalysis,
          versionNumber: targetVersionNumber
        });
      } catch (error) {
        console.error("Error in /analyze-enhanced:", error);
        res.status(500).json({ error: error.message || "Enhanced analysis failed" });
      }
    });
    router.post("/decisions/generate-with-research", async (req, res) => {
      try {
        const { sessionId, versionNumber } = req.body;
        if (!sessionId) {
          return res.status(400).json({ error: "sessionId is required" });
        }
        let targetVersionNumber;
        let version;
        if (versionNumber) {
          targetVersionNumber = versionNumber;
          version = await storage.getStrategyVersion(sessionId, targetVersionNumber);
          if (!version) {
            return res.status(404).json({ error: "Version not found" });
          }
        } else {
          const versions = await storage.getStrategyVersionsBySession(sessionId);
          if (versions.length === 0) {
            return res.status(404).json({ error: "No versions found for this session" });
          }
          version = versions[versions.length - 1];
          targetVersionNumber = version.versionNumber;
        }
        const existingAnalysisData = version.analysisData || {};
        if (!existingAnalysisData.research) {
          return res.status(400).json({
            error: "No research findings available. Please conduct research first."
          });
        }
        if (!existingAnalysisData.enhanced_analysis) {
          return res.status(400).json({
            error: "No Porter's analysis available. Please run enhanced analysis first."
          });
        }
        const originalAnalysis = version.analysisData;
        if (!originalAnalysis) {
          return res.status(400).json({ error: "No analysis data found in version" });
        }
        let originalInput = version.inputSummary || "";
        const researchInformedDecisions = await decisionGenerator.generateDecisionsWithResearch(
          originalAnalysis,
          originalInput,
          existingAnalysisData.research,
          existingAnalysisData.enhanced_analysis.portersAnalysis
        );
        const validationResult = await decisionGenerator.validateDecisions(researchInformedDecisions);
        if (!validationResult.valid) {
          return res.status(400).json({
            error: "Generated decisions are invalid",
            issues: validationResult.issues
          });
        }
        await storage.updateStrategyVersion(version.id, {
          decisionsData: researchInformedDecisions
        });
        res.json({
          success: true,
          decisions: researchInformedDecisions,
          versionNumber: targetVersionNumber,
          message: "Decisions successfully updated with research findings"
        });
      } catch (error) {
        console.error("Error in /decisions/generate-with-research:", error);
        res.status(500).json({ error: error.message || "Research-informed decision generation failed" });
      }
    });
    router.post("/select-framework", async (req, res) => {
      try {
        const { input, sessionId } = req.body;
        const userId = req.user?.claims?.sub;
        if (!input) {
          return res.status(400).json({ error: "Input text is required" });
        }
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        if (!userId) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const selection = await frameworkSelector.selectFramework(sessionId, userId, input);
        res.json({
          success: true,
          selection
        });
      } catch (error) {
        console.error("Error in /select-framework:", error);
        res.status(500).json({ error: error.message || "Framework selection failed" });
      }
    });
    router.post("/bmc-research", async (req, res) => {
      console.log("[BMC-RESEARCH] Endpoint called! sessionId:", req.body.sessionId);
      req.socket.setTimeout(6e5);
      try {
        const { input, sessionId, versionNumber } = req.body;
        if (!input) {
          return res.status(400).json({ error: "Input text is required" });
        }
        console.log("[BMC-RESEARCH] Starting SSE stream for session:", sessionId);
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        console.log("[BMC-RESEARCH] SSE headers set, starting to send messages...");
        const progressMessages = [
          // Category 1: Analyzing (0-55s) - 11 messages
          { message: "\u{1F50D} Analyzing your business concept and strategic context...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Extracting key assumptions from your input...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Identifying explicit and implicit strategic claims...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Building knowledge graph of your business model...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Categorizing assumptions by confidence level...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Mapping relationships between strategic elements...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Validating source attribution for all claims...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Preparing comprehensive analysis framework...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Structuring insights for deep research...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Finalizing assumption categorization...", step: 1, totalSteps: 8 },
          { message: "\u{1F50D} Analysis foundation complete, moving to components...", step: 1, totalSteps: 8 },
          // Category 2: Breaking down (55-105s) - 10 messages
          { message: "\u{1F9E9} Breaking down Business Model Canvas components...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Generating queries for Customer Segments...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Creating Value Proposition research queries...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Developing Revenue Streams investigation plan...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Building Channels distribution analysis...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Structuring Customer Relationships queries...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Preparing Key Resources research framework...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Designing Key Activities validation approach...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Creating Key Partnerships research strategy...", step: 2, totalSteps: 8 },
          { message: "\u{1F9E9} Finalizing Cost Structure analysis queries...", step: 2, totalSteps: 8 },
          // Category 3: Searching markets (105-160s) - 11 messages
          { message: "\u{1F310} Searching global markets for industry insights...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Gathering real-world customer segment data...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Researching competitive landscape and alternatives...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Analyzing market size and growth trends...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Discovering customer pain points and needs...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Exploring regional market variations...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Investigating industry-specific challenges...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Collecting case studies and success stories...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Examining market entry barriers and opportunities...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Evaluating competitive positioning opportunities...", step: 3, totalSteps: 8 },
          { message: "\u{1F310} Synthesizing market intelligence findings...", step: 3, totalSteps: 8 },
          // Category 4: Researching pricing (160-210s) - 10 messages
          { message: "\u{1F4B0} Researching pricing models and revenue strategies...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Analyzing competitor pricing structures...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Investigating subscription vs. one-time models...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Examining price sensitivity in target market...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Discovering hidden cost factors and margins...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Evaluating pricing tier effectiveness...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Researching revenue per customer benchmarks...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Analyzing monetization strategy alternatives...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Assessing pricing power and elasticity...", step: 4, totalSteps: 8 },
          { message: "\u{1F4B0} Consolidating revenue model insights...", step: 4, totalSteps: 8 },
          // Category 5: Investigating partnerships (210-265s) - 11 messages
          { message: "\u{1F91D} Investigating partnership and channel strategies...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Researching distribution channel effectiveness...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Analyzing direct vs. partner sales models...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Exploring strategic alliance opportunities...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Investigating customer acquisition channels...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Examining partner program structures...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Researching integration partner ecosystems...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Analyzing relationship management approaches...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Discovering channel conflict and solutions...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Assessing customer success team requirements...", step: 5, totalSteps: 8 },
          { message: "\u{1F91D} Compiling partnership strategy findings...", step: 5, totalSteps: 8 },
          // Category 6: Analyzing costs (265-315s) - 10 messages
          { message: "\u{1F4CA} Analyzing cost structures and resource needs...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Researching key resource requirements...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Investigating critical activities and processes...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Examining operational cost benchmarks...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Analyzing fixed vs. variable cost ratios...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Discovering hidden implementation costs...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Researching resource optimization strategies...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Evaluating economies of scale potential...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Assessing cost efficiency opportunities...", step: 6, totalSteps: 8 },
          { message: "\u{1F4CA} Synthesizing cost structure insights...", step: 6, totalSteps: 8 },
          // Category 7: Detecting contradictions (315-370s) - 11 messages
          { message: "\u{1F3AF} Detecting strategic gaps and contradictions...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Cross-validating assumptions against evidence...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Identifying inconsistencies in business logic...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Discovering conflicting market signals...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Analyzing assumption-reality mismatches...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Validating timeline and budget feasibility...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Examining cross-block consistency issues...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Identifying critical missing components...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Highlighting strategic blind spots...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Prioritizing risk factors and mitigation strategies...", step: 7, totalSteps: 8 },
          { message: "\u{1F3AF} Compiling contradiction analysis results...", step: 7, totalSteps: 8 },
          // Category 8: Finalizing (370-420s) - 10 messages
          { message: "\u2728 Finalizing Business Model Canvas analysis...", step: 8, totalSteps: 8 },
          { message: "\u2728 Synthesizing insights across all components...", step: 8, totalSteps: 8 },
          { message: "\u2728 Performing viability assessment...", step: 8, totalSteps: 8 },
          { message: "\u2728 Calculating overall confidence scores...", step: 8, totalSteps: 8 },
          { message: "\u2728 Generating strategic recommendations...", step: 8, totalSteps: 8 },
          { message: "\u2728 Prioritizing critical action items...", step: 8, totalSteps: 8 },
          { message: "\u2728 Creating executive summary...", step: 8, totalSteps: 8 },
          { message: "\u2728 Persisting insights to knowledge graph...", step: 8, totalSteps: 8 },
          { message: "\u2728 Preparing final deliverables...", step: 8, totalSteps: 8 },
          { message: "\u2728 Analysis complete! Review your strategic insights...", step: 8, totalSteps: 8 }
        ];
        let messageIndex = 0;
        let progressInterval = null;
        progressInterval = setInterval(() => {
          if (messageIndex < progressMessages.length) {
            const msg = progressMessages[messageIndex];
            console.log(`[BMC-RESEARCH] Sending message ${messageIndex}/${progressMessages.length}:`, msg.message);
            res.write(`data: ${JSON.stringify(msg)}

`);
            messageIndex++;
          }
        }, 1400);
        console.log("[BMC-RESEARCH] Sending initial message:", progressMessages[0].message);
        res.write(`data: ${JSON.stringify(progressMessages[0])}

`);
        messageIndex = 1;
        const result = await bmcResearcher.conductBMCResearch(input, sessionId);
        if (progressInterval) {
          clearInterval(progressInterval);
        }
        if (result.references && result.references.length > 0 && sessionId) {
          try {
            const { referenceService: referenceService2 } = await Promise.resolve().then(() => (init_reference_service(), reference_service_exports));
            let understanding;
            let journeySession = await getJourneySession(sessionId);
            if (journeySession && journeySession.understandingId) {
              understanding = await getStrategicUnderstanding(journeySession.understandingId);
            } else {
              understanding = await getStrategicUnderstandingBySession(sessionId);
              journeySession = await getJourneySessionByUnderstandingSessionId(sessionId);
            }
            if (understanding) {
              console.log(`[BMC-RESEARCH] Persisting ${result.references.length} references to knowledge graph...`);
              const userId = journeySession?.userId || req.user?.claims?.sub;
              if (!userId) {
                throw new Error("Cannot persist research references without a user");
              }
              const normalized = result.references.map(
                (ref, idx) => referenceService2.normalizeReference(
                  ref,
                  userId,
                  { component: "bmc_research", claim: ref.description },
                  { understandingId: understanding.id, sessionId }
                )
              );
              await referenceService2.persistReferences(normalized, {
                understandingId: understanding.id,
                sessionId
              });
              console.log(`[BMC-RESEARCH] \u2713 Persisted ${normalized.length} references and updated metadata cache`);
            }
          } catch (error) {
            console.error("[BMC-RESEARCH] Failed to persist references:", error);
          }
        }
        if (sessionId) {
          let journeySession = await getJourneySession(sessionId);
          if (!journeySession) {
            journeySession = await getJourneySessionByUnderstandingSessionId(sessionId);
          }
          const userId = journeySession?.userId || req.user?.claims?.sub;
          if (!userId) {
            throw new Error("Cannot persist version without a user");
          }
          let version;
          const initiativeDescription = await storage.getInitiativeDescriptionForSession(sessionId);
          const inputSummary = initiativeDescription || "Strategic Analysis";
          if (versionNumber) {
            version = await storage.getStrategyVersion(sessionId, versionNumber);
            if (!version) {
              version = await storage.createStrategyVersion({
                sessionId,
                versionNumber,
                status: "draft",
                analysisData: {},
                userId,
                createdBy: userId,
                inputSummary
              });
            }
          } else {
            version = await storage.getStrategyVersion(sessionId, 1);
            if (!version) {
              version = await storage.createStrategyVersion({
                sessionId,
                versionNumber: 1,
                status: "draft",
                analysisData: {},
                userId,
                createdBy: userId,
                inputSummary
              });
            }
          }
          if (version) {
            const existingAnalysisData = version.analysisData || {};
            await storage.updateStrategyVersion(version.id, {
              analysisData: {
                ...existingAnalysisData,
                bmc_research: result
              }
            });
            console.log(`[BMC-RESEARCH] Saved results to version ${version.versionNumber} for session ${sessionId}`);
          }
        }
        const finalMessage = progressMessages[progressMessages.length - 1];
        res.write(`data: ${JSON.stringify(finalMessage)}

`);
        res.write(`data: ${JSON.stringify({ complete: true, result })}

`);
        res.end();
      } catch (error) {
        console.error("Error in /bmc-research:", error);
        res.write(`data: ${JSON.stringify({ error: error.message || "BMC research failed" })}

`);
        res.end();
      }
    });
    router.get("/bmc-research/stream/:sessionId", async (req, res) => {
      console.log("[BMC-RESEARCH-STREAM] GET endpoint called! sessionId:", req.params.sessionId);
      req.socket.setTimeout(6e5);
      let keepaliveInterval = null;
      try {
        const tokenValid = await refreshTokenProactively(req, 600);
        if (!tokenValid) {
          return res.status(401).json({
            error: "Session expired",
            message: "Please log in again to continue"
          });
        }
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        console.log("[BMC-RESEARCH-STREAM] Starting SSE stream for session:", sessionId);
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        console.log("[BMC-RESEARCH-STREAM] SSE headers set, fetching input from strategic understanding...");
        let understanding;
        const journeySession = await getJourneySession(sessionId);
        if (journeySession && journeySession.understandingId) {
          console.log("[BMC-RESEARCH-STREAM] Found journey session, fetching understanding via understandingId:", journeySession.understandingId);
          understanding = await getStrategicUnderstanding(journeySession.understandingId);
        } else {
          console.log("[BMC-RESEARCH-STREAM] No journey session found, trying as base session ID");
          understanding = await getStrategicUnderstandingBySession(sessionId);
        }
        if (!understanding || !understanding.userInput) {
          res.write(`data: ${JSON.stringify({ type: "error", error: "Strategic understanding not found for this session" })}

`);
          res.end();
          return;
        }
        const input = understanding.userInput;
        console.log("[BMC-RESEARCH-STREAM] Input fetched from understanding, length:", input.length);
        const sink = {
          emitContext: (inputPreview) => {
            res.write(`data: ${JSON.stringify({ type: "context", message: `Analyzing: "${inputPreview}..."`, progress: 5 })}

`);
          },
          emitQuery: (query, purpose, queryType) => {
            res.write(`data: ${JSON.stringify({ type: "query", query, purpose, queryType, progress: 30 })}

`);
          },
          emitSynthesis: (block, message) => {
            res.write(`data: ${JSON.stringify({ type: "synthesis", block, message, progress: 70 })}

`);
          },
          emitProgress: (message, progress) => {
            res.write(`data: ${JSON.stringify({ type: "progress", message, progress })}

`);
          },
          emitComplete: (data) => {
            res.write(`data: ${JSON.stringify({ type: "complete", data })}

`);
          },
          emitError: (error) => {
            res.write(`data: ${JSON.stringify({ type: "error", error })}

`);
          }
        };
        console.log("[BMC-RESEARCH-STREAM] Sending initial message");
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F680} Starting BMC research...", progress: 0 })}

`);
        res.write(`data: ${JSON.stringify({ type: "debug", debugInput: input.slice(0, 200) })}

`);
        keepaliveInterval = setInterval(() => {
          try {
            res.write(`: keepalive ${Date.now()}

`);
          } catch (e) {
            if (keepaliveInterval) clearInterval(keepaliveInterval);
          }
        }, 15e3);
        res.on("close", () => {
          if (keepaliveInterval) {
            clearInterval(keepaliveInterval);
            keepaliveInterval = null;
          }
        });
        let result;
        let decisions;
        let researchError = false;
        try {
          console.log("[BMC-RESEARCH-STREAM] Starting BMC research with real-time streaming...");
          result = await bmcResearcher.conductBMCResearch(input, sessionId, sink);
          console.log("[BMC-RESEARCH-STREAM] BMC research completed successfully");
          res.write(`data: ${JSON.stringify({ type: "progress", message: "\u2705 Research complete, processing results...", progress: 100 })}

`);
        } catch (error) {
          console.error("[BMC-RESEARCH-STREAM] Research failed:", error);
          researchError = true;
          throw error;
        }
        let timeoutHandle;
        try {
          console.log("[BMC-RESEARCH-STREAM] Generating strategic decisions from BMC analysis...");
          const decisionPromise = decisionGenerator.generateDecisionsFromBMC(result, input);
          const timeoutPromise = new Promise((_, reject) => {
            timeoutHandle = setTimeout(() => reject(new Error("Decision generation timeout after 60s")), 6e4);
          });
          decisions = await Promise.race([decisionPromise, timeoutPromise]);
          console.log(`[BMC-RESEARCH-STREAM] Generated ${decisions.decisions.length} strategic decisions`);
        } catch (error) {
          console.error("[BMC-RESEARCH-STREAM] Decision generation failed (non-critical):", error);
          decisions = { decisions: [] };
        } finally {
          if (timeoutHandle) {
            clearTimeout(timeoutHandle);
          }
        }
        try {
          if (result.references && result.references.length > 0 && understanding) {
            const { referenceService: referenceService2 } = await Promise.resolve().then(() => (init_reference_service(), reference_service_exports));
            const journeySession2 = await getJourneySessionByUnderstandingSessionId(sessionId);
            const userId = journeySession2?.userId || req.user?.claims?.sub;
            if (!userId) {
              throw new Error("Cannot persist BMC references without a user");
            }
            const normalized = result.references.map(
              (reference) => referenceService2.normalizeReference(
                reference,
                userId,
                {
                  component: `bmc.${reference.topics?.[1] || "general"}`,
                  claim: reference.description || reference.snippet || ""
                },
                { understandingId: understanding.id }
              )
            );
            const persistResult = await referenceService2.persistReferences(normalized, {
              understandingId: understanding.id
            });
            console.log(`[BMC-RESEARCH-STREAM] \u2713 Persisted ${persistResult.created.length} new references, updated ${persistResult.updated.length} existing`);
          }
        } catch (error) {
          console.error("[BMC-RESEARCH-STREAM] Reference persistence failed (non-critical):", error);
        }
        let targetVersionNumber = 1;
        let version = null;
        try {
          const journeySession2 = await getJourneySessionByUnderstandingSessionId(sessionId);
          let userId = journeySession2?.userId || req.user?.claims?.sub;
          if (!userId) {
            console.warn(`[BMC-RESEARCH-STREAM] \u26A0\uFE0F  No authenticated user found for session ${sessionId}, using system fallback`);
            userId = "system";
          }
          const versionNumberFromQuery = req.query.versionNumber ? parseInt(req.query.versionNumber) : void 0;
          if (versionNumberFromQuery) {
            targetVersionNumber = versionNumberFromQuery;
          } else if (journeySession2 && journeySession2.versionNumber) {
            targetVersionNumber = journeySession2.versionNumber;
          } else {
            const versions = await storage.getStrategyVersionsBySession(sessionId);
            if (versions.length > 0) {
              const maxVersion = Math.max(...versions.map((v) => v.versionNumber));
              targetVersionNumber = maxVersion + 1;
              console.log(`[BMC-RESEARCH-STREAM] No versionNumber provided, computed max+1: ${targetVersionNumber}`);
            } else {
              targetVersionNumber = 1;
              console.log(`[BMC-RESEARCH-STREAM] No existing versions, using version 1`);
            }
          }
          const initiativeDescription = await storage.getInitiativeDescriptionForSession(sessionId);
          const inputSummary = initiativeDescription || "Strategic Analysis";
          version = await storage.getStrategyVersion(sessionId, targetVersionNumber);
          if (!version) {
            const doubleCheck = await storage.getStrategyVersion(sessionId, targetVersionNumber);
            if (doubleCheck) {
              targetVersionNumber++;
              console.warn(`[BMC-RESEARCH-STREAM] Version collision detected, incremented to ${targetVersionNumber}`);
            }
            version = await storage.createStrategyVersion({
              sessionId,
              versionNumber: targetVersionNumber,
              status: "draft",
              analysisData: { bmc_research: result },
              decisionsData: decisions,
              userId,
              createdBy: userId,
              inputSummary
            });
            if (!version || !version.id) {
              console.error(`[BMC-RESEARCH-STREAM] VALIDATION FAILED: strategy_versions not created for session=${sessionId}, version=${targetVersionNumber}`);
              throw new Error(`Failed to create strategy version ${targetVersionNumber} for session ${sessionId}`);
            }
            console.log(`[BMC-RESEARCH-STREAM] \u2713 VALIDATION PASSED: strategy_versions row (id=${version.id}, session=${sessionId}, version=${targetVersionNumber}) verified`);
            console.log(`[BMC-RESEARCH-STREAM] Created new version ${targetVersionNumber}`);
          } else {
            const existingAnalysisData = version.analysisData || {};
            await storage.updateStrategyVersion(version.id, {
              analysisData: {
                ...existingAnalysisData,
                bmc_research: result
              },
              decisionsData: decisions
            });
            console.log(`[BMC-RESEARCH-STREAM] Updated existing version ${targetVersionNumber}`);
          }
          console.log(`[BMC-RESEARCH-STREAM] \u2713 Saved BMC results and ${decisions.decisions.length} decisions to version ${version.versionNumber}`);
        } catch (error) {
          console.error("[BMC-RESEARCH-STREAM] \u26A0\uFE0F  CRITICAL: Database save failed - decisions will NOT be persisted!");
          console.error("[BMC-RESEARCH-STREAM] Error details:", error.message || error);
          console.error("[BMC-RESEARCH-STREAM] This means the frontend will show the legacy wizard instead of AI decisions");
        }
        console.log("[BMC-RESEARCH-STREAM] Sending completion event");
        const findings = {
          market_dynamics: [],
          competitive_landscape: [],
          language_preferences: [],
          buyer_behavior: [],
          regulatory_factors: [],
          sources: []
        };
        if (result.blocks && Array.isArray(result.blocks)) {
          result.blocks.forEach((block) => {
            if (block.research && Array.isArray(block.research)) {
              block.research.forEach((item) => {
                if (item.citations && Array.isArray(item.citations)) {
                  item.citations.forEach((citation) => {
                    if (citation.url && citation.title) {
                      findings.sources.push({
                        url: citation.url,
                        title: citation.title,
                        relevance_score: citation.relevance || 0.8
                      });
                    }
                  });
                }
              });
            }
          });
        }
        const finalVersionNumber = version?.versionNumber || targetVersionNumber;
        if (keepaliveInterval) clearInterval(keepaliveInterval);
        res.write(`data: ${JSON.stringify({
          type: "complete",
          data: {
            findings,
            searchQueriesUsed: [],
            versionNumber: finalVersionNumber,
            sourcesAnalyzed: findings.sources.length || 9,
            timeElapsed: "~2 minutes",
            nextUrl: `/strategy-workspace/decisions/${sessionId}/${finalVersionNumber}`,
            // Include full BMC analysis for 9-block canvas display
            bmcAnalysis: result
          }
        })}

`);
        res.end();
        console.log("[BMC-RESEARCH-STREAM] Stream ended successfully, nextUrl: /strategy-workspace/decisions/" + sessionId + "/" + finalVersionNumber);
      } catch (error) {
        if (keepaliveInterval) clearInterval(keepaliveInterval);
        console.error("Error in /bmc-research/stream:", error);
        const errorMessage = error.message || "BMC research failed";
        res.write(`data: ${JSON.stringify({ type: "error", error: errorMessage })}

`);
        res.end();
      }
    });
    router.get("/journey-research/stream/:sessionId", async (req, res) => {
      console.log("[JOURNEY-RESEARCH] Unified endpoint called! sessionId:", req.params.sessionId);
      req.socket.setTimeout(6e5);
      let keepaliveInterval = null;
      try {
        const tokenValid = await refreshTokenProactively(req, 600);
        if (!tokenValid) {
          return res.status(401).json({
            error: "Session expired",
            message: "Please log in again to continue"
          });
        }
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        let journeySession = await getJourneySession(sessionId);
        if (!journeySession) {
          console.log(`[JOURNEY-RESEARCH] Direct lookup failed, trying understanding session lookup for: ${sessionId}`);
          journeySession = await getJourneySessionByUnderstandingSessionId(sessionId);
        }
        if (!journeySession) {
          console.error(`[JOURNEY-RESEARCH] Journey session not found for sessionId: ${sessionId}`);
          res.write(`data: ${JSON.stringify({ type: "error", error: "Journey session not found" })}

`);
          res.end();
          return;
        }
        console.log(`[JOURNEY-RESEARCH] Found journey session: ${journeySession.id}, type: ${journeySession.journeyType}`);
        const journeyType = journeySession.journeyType;
        console.log(`[JOURNEY-RESEARCH] Journey type: ${journeyType}`);
        const journeyDef = journeyRegistry.getJourney(journeyType);
        if (!journeyDef) {
          res.write(`data: ${JSON.stringify({ type: "error", error: `Unknown journey type: ${journeyType}` })}

`);
          res.end();
          return;
        }
        console.log(`[JOURNEY-RESEARCH] Framework sequence: ${journeyDef.frameworks.join(" \u2192 ")}`);
        let understanding;
        if (journeySession.understandingId) {
          understanding = await getStrategicUnderstanding(journeySession.understandingId);
        } else {
          understanding = await getStrategicUnderstandingBySession(sessionId);
        }
        if (!understanding || !understanding.userInput) {
          res.write(`data: ${JSON.stringify({ type: "error", error: "Strategic understanding not found" })}

`);
          res.end();
          return;
        }
        const input = understanding.userInput;
        console.log(`[JOURNEY-RESEARCH] Input length: ${input.length}`);
        res.write(`data: ${JSON.stringify({
          type: "progress",
          message: `\u{1F680} Starting ${journeyDef.name}...`,
          progress: 0,
          journeyType,
          frameworks: journeyDef.frameworks
        })}

`);
        res.write(`data: ${JSON.stringify({ type: "debug", debugInput: input.slice(0, 200) })}

`);
        keepaliveInterval = setInterval(() => {
          try {
            res.write(`: keepalive ${Date.now()}

`);
          } catch (e) {
            if (keepaliveInterval) clearInterval(keepaliveInterval);
          }
        }, 15e3);
        res.on("close", () => {
          if (keepaliveInterval) clearInterval(keepaliveInterval);
        });
        const { frameworkRegistry: fwRegistry } = await Promise.resolve().then(() => (init_framework_executor_registry(), framework_executor_registry_exports));
        const { getBridge: getBridge2 } = await Promise.resolve().then(() => (init_bridge_contract(), bridge_contract_exports));
        const strategicContext = {
          userInput: input,
          understandingId: understanding.id,
          sessionId,
          journeyType,
          previousResults: {},
          bridgeEnhancements: {}
        };
        const frameworkResults = {};
        const totalFrameworks = journeyDef.frameworks.length;
        for (let i = 0; i < totalFrameworks; i++) {
          const frameworkName = journeyDef.frameworks[i];
          const progressPercent = Math.round(i / totalFrameworks * 80) + 10;
          if (["strategic_decisions", "prioritization"].includes(frameworkName)) {
            console.log(`[JOURNEY-RESEARCH] Skipping user input framework: ${frameworkName}`);
            continue;
          }
          res.write(`data: ${JSON.stringify({
            type: "progress",
            message: `\u{1F4CA} Running ${frameworkName.replace(/_/g, " ").toUpperCase()} analysis...`,
            progress: progressPercent,
            currentFramework: frameworkName
          })}

`);
          console.log(`[JOURNEY-RESEARCH] Executing ${frameworkName}...`);
          if (i > 0) {
            const prevFramework = journeyDef.frameworks[i - 1];
            const bridge = getBridge2(prevFramework, frameworkName);
            if (bridge) {
              console.log(`[JOURNEY-RESEARCH] Applying bridge: ${prevFramework} \u2192 ${frameworkName}`);
              try {
                const bridgeContext = {
                  positioning: understanding.strategyMetadata?.positioning || {},
                  allPriorOutputs: frameworkResults,
                  sessionId,
                  journeyType
                };
                const enhancement = await bridge.transform(frameworkResults[prevFramework], bridgeContext);
                strategicContext.bridgeEnhancements[frameworkName] = enhancement;
                console.log(`[JOURNEY-RESEARCH] \u2713 Bridge applied: ${prevFramework} \u2192 ${frameworkName}`);
              } catch (bridgeError) {
                console.warn(`[JOURNEY-RESEARCH] Bridge failed (${prevFramework} \u2192 ${frameworkName}):`, bridgeError.message);
              }
            }
          }
          strategicContext.previousResults = frameworkResults;
          let result;
          try {
            result = await fwRegistry.execute(frameworkName, strategicContext);
            frameworkResults[frameworkName] = result.data;
            console.log(`[JOURNEY-RESEARCH] \u2713 ${frameworkName} complete`);
            res.write(`data: ${JSON.stringify({
              type: "progress",
              message: `\u2713 ${frameworkName.replace(/_/g, " ").toUpperCase()} complete`,
              progress: progressPercent + Math.round(80 / totalFrameworks),
              completedFramework: frameworkName
            })}

`);
            try {
              await db.insert(frameworkInsights).values({
                understandingId: understanding.id,
                sessionId: journeySession.id,
                // Use journey session primary key for FK
                frameworkName,
                frameworkVersion: "1.0",
                insights: result.data,
                telemetry: {
                  duration: result.duration,
                  executedAt: result.executedAt.toISOString(),
                  source: "unified_journey_research"
                }
              }).onConflictDoNothing();
              console.log(`[JOURNEY-RESEARCH] \u2713 Saved ${frameworkName} to frameworkInsights for session ${journeySession.id}`);
            } catch (saveError) {
              console.warn(`[JOURNEY-RESEARCH] Failed to save ${frameworkName} insight:`, saveError.message);
            }
          } catch (error) {
            console.error(`[JOURNEY-RESEARCH] ${frameworkName} failed:`, error.message);
            res.write(`data: ${JSON.stringify({
              type: "progress",
              message: `\u26A0\uFE0F ${frameworkName} had issues, continuing...`,
              progress: progressPercent + Math.round(80 / totalFrameworks)
            })}

`);
            frameworkResults[frameworkName] = { error: error.message };
          }
        }
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F4BE} Generating strategic decisions...", progress: 90 })}

`);
        const generator = new DecisionGenerator();
        let decisions;
        const finalFramework = journeyDef.frameworks[journeyDef.frameworks.length - 1];
        const finalResult = frameworkResults[finalFramework];
        const finalData = finalResult?.output || finalResult?.data || finalResult;
        try {
          if (finalFramework === "swot" && finalData && !finalData.error) {
            decisions = await generator.generateDecisionsFromSWOT(finalData, input);
          } else if (finalFramework === "bmc" && finalData && !finalData.error) {
            decisions = await generator.generateDecisionsFromBMC(finalData, input);
          } else if (finalData && !finalData.error) {
            decisions = await generator.generateDecisions(finalData, input);
          } else {
            decisions = {
              decisions: [{
                id: "review_analysis",
                title: "Review Analysis Results",
                question: "Based on the analysis, what strategic direction should we pursue?",
                options: [
                  { id: "growth", label: "Growth Strategy", description: "Focus on expansion" },
                  { id: "consolidate", label: "Consolidation", description: "Optimize current operations" },
                  { id: "transform", label: "Transformation", description: "Significant change" }
                ]
              }]
            };
          }
          console.log(`[JOURNEY-RESEARCH] \u2713 Generated ${decisions?.decisions?.length || 0} decision points`);
        } catch (decisionError) {
          console.error("[JOURNEY-RESEARCH] Decision generation failed:", decisionError.message);
          decisions = { decisions: [], error: decisionError.message };
        }
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F4BE} Saving results...", progress: 95 })}

`);
        const userId = req.user?.claims?.sub || "system";
        const targetVersionNumber = journeySession.versionNumber || 1;
        const existingVersion = await storage.getStrategyVersion(sessionId, targetVersionNumber);
        const mergeAnalysis = (existingAnalysis, newAnalysis) => {
          const merged = { ...newAnalysis, ...existingAnalysis };
          const existingWhys = existingAnalysis?.five_whys;
          const hasFinalizedWhys = existingWhys?.root_cause || Array.isArray(existingWhys?.whysPath) && existingWhys.whysPath.length >= 4;
          if (hasFinalizedWhys) {
            merged.five_whys = existingWhys;
          } else if (newAnalysis?.five_whys) {
            merged.five_whys = newAnalysis.five_whys;
          }
          return merged;
        };
        if (existingVersion) {
          const existingAnalysis = typeof existingVersion.analysisData === "string" ? JSON.parse(existingVersion.analysisData) : existingVersion.analysisData || {};
          const mergedAnalysis = mergeAnalysis(existingAnalysis, frameworkResults);
          await storage.updateStrategyVersion(existingVersion.id, {
            analysisData: mergedAnalysis,
            decisionsData: decisions,
            versionLabel: existingVersion.versionLabel || `${journeyDef.name} v${targetVersionNumber}`,
            status: "draft"
          });
          const existingWhys = existingAnalysis?.five_whys;
          const mergedWhys = mergedAnalysis?.five_whys;
          console.log("[JOURNEY-RESEARCH] Five Whys merge check:", {
            targetVersionNumber,
            existingWhysKeys: existingWhys ? Object.keys(existingWhys) : [],
            mergedWhysKeys: mergedWhys ? Object.keys(mergedWhys) : [],
            mergedWhysPathLength: Array.isArray(mergedWhys?.whysPath) ? mergedWhys.whysPath.length : 0,
            mergedRootCause: mergedWhys?.root_cause || null
          });
          console.log(`[JOURNEY-RESEARCH] \u2713 Updated strategy version ${targetVersionNumber}`);
        } else {
          await storage.createStrategyVersion({
            sessionId,
            versionNumber: targetVersionNumber,
            versionLabel: `${journeyDef.name} v${targetVersionNumber}`,
            analysisData: frameworkResults,
            decisionsData: decisions,
            status: "draft",
            createdBy: userId,
            userId
          });
          console.log(`[JOURNEY-RESEARCH] \u2713 Created strategy version ${targetVersionNumber}`);
        }
        const decisionPageIndex = journeyDef.pageSequence.findIndex((p) => p.includes("decisions"));
        let nextUrl = `/strategy-workspace/decisions/${sessionId}/${targetVersionNumber}`;
        if (decisionPageIndex > 0) {
          nextUrl = journeyDef.pageSequence[decisionPageIndex].replace(":sessionId", sessionId).replace(":versionNumber", targetVersionNumber.toString());
        }
        if (keepaliveInterval) {
          clearInterval(keepaliveInterval);
          keepaliveInterval = null;
        }
        res.write(`data: ${JSON.stringify({
          type: "complete",
          data: {
            findings: frameworkResults,
            decisions,
            versionNumber: targetVersionNumber,
            nextUrl,
            bmcAnalysis: frameworkResults.bmc,
            sourcesAnalyzed: Object.keys(frameworkResults).length,
            timeElapsed: "completed",
            journeyType
          }
        })}

`);
        console.log(`[JOURNEY-RESEARCH] \u2713 Journey complete for ${sessionId}`);
        res.end();
      } catch (error) {
        if (keepaliveInterval) clearInterval(keepaliveInterval);
        console.error("[JOURNEY-RESEARCH] Error:", error);
        res.write(`data: ${JSON.stringify({ type: "error", error: error.message || "Journey research failed" })}

`);
        res.end();
      }
    });
    router.get("/market-entry-research/stream/:sessionId", async (req, res) => {
      console.log("[MARKET-ENTRY-RESEARCH] GET endpoint called! sessionId:", req.params.sessionId);
      req.socket.setTimeout(6e5);
      let keepaliveInterval = null;
      try {
        const tokenValid = await refreshTokenProactively(req, 600);
        if (!tokenValid) {
          return res.status(401).json({
            error: "Session expired",
            message: "Please log in again to continue"
          });
        }
        const { sessionId } = req.params;
        if (!sessionId) {
          return res.status(400).json({ error: "Session ID is required" });
        }
        console.log("[MARKET-ENTRY-RESEARCH] Starting SSE stream for session:", sessionId);
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        let understanding;
        const journeySession = await getJourneySession(sessionId);
        if (journeySession && journeySession.understandingId) {
          console.log("[MARKET-ENTRY-RESEARCH] Found journey session, fetching understanding via understandingId:", journeySession.understandingId);
          understanding = await getStrategicUnderstanding(journeySession.understandingId);
        } else {
          console.log("[MARKET-ENTRY-RESEARCH] No journey session found, trying as base session ID");
          understanding = await getStrategicUnderstandingBySession(sessionId);
        }
        if (!understanding || !understanding.userInput) {
          res.write(`data: ${JSON.stringify({ type: "error", error: "Strategic understanding not found for this session" })}

`);
          res.end();
          return;
        }
        const input = understanding.userInput;
        console.log("[MARKET-ENTRY-RESEARCH] Input fetched from understanding, length:", input.length);
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F680} Starting Market Entry analysis...", progress: 0 })}

`);
        res.write(`data: ${JSON.stringify({ type: "debug", debugInput: input.slice(0, 200) })}

`);
        keepaliveInterval = setInterval(() => {
          try {
            res.write(`: keepalive ${Date.now()}

`);
          } catch (e) {
            if (keepaliveInterval) clearInterval(keepaliveInterval);
          }
        }, 15e3);
        res.on("close", () => {
          if (keepaliveInterval) clearInterval(keepaliveInterval);
        });
        const { frameworkRegistry: frameworkRegistry3 } = await Promise.resolve().then(() => (init_framework_executor_registry(), framework_executor_registry_exports));
        const strategicContext = {
          userInput: input,
          understandingId: understanding.id,
          sessionId
        };
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F4CA} Running PESTLE analysis (macro-environmental factors)...", progress: 10 })}

`);
        console.log("[MARKET-ENTRY-RESEARCH] Executing PESTLE analysis...");
        let pestleResult;
        try {
          pestleResult = await frameworkRegistry3.execute("pestle", strategicContext);
          console.log("[MARKET-ENTRY-RESEARCH] \u2713 PESTLE analysis complete");
          res.write(`data: ${JSON.stringify({ type: "progress", message: "\u2713 PESTLE analysis complete", progress: 30 })}

`);
        } catch (error) {
          console.error("[MARKET-ENTRY-RESEARCH] PESTLE analysis failed:", error.message);
          res.write(`data: ${JSON.stringify({ type: "progress", message: "\u26A0\uFE0F PESTLE analysis had issues, continuing...", progress: 30 })}

`);
          pestleResult = { error: error.message };
        }
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F3E2} Running Porter's Five Forces analysis (competitive forces)...", progress: 35 })}

`);
        console.log("[MARKET-ENTRY-RESEARCH] Executing Porter's analysis...");
        let portersResult;
        try {
          portersResult = await frameworkRegistry3.execute("porters", strategicContext);
          console.log("[MARKET-ENTRY-RESEARCH] \u2713 Porter's analysis complete");
          res.write(`data: ${JSON.stringify({ type: "progress", message: "\u2713 Porter's Five Forces complete", progress: 55 })}

`);
        } catch (error) {
          console.error("[MARKET-ENTRY-RESEARCH] Porter's analysis failed:", error.message);
          res.write(`data: ${JSON.stringify({ type: "progress", message: "\u26A0\uFE0F Porter's analysis had issues, continuing...", progress: 55 })}

`);
          portersResult = { error: error.message };
        }
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F4CB} Running SWOT analysis (synthesizing insights)...", progress: 60 })}

`);
        console.log("[MARKET-ENTRY-RESEARCH] Executing SWOT analysis...");
        const swotContext = {
          ...strategicContext,
          previousResults: {
            pestle: pestleResult,
            porters: portersResult
          }
        };
        let swotResult;
        try {
          swotResult = await frameworkRegistry3.execute("swot", swotContext);
          console.log("[MARKET-ENTRY-RESEARCH] \u2713 SWOT analysis complete");
          res.write(`data: ${JSON.stringify({ type: "progress", message: "\u2713 SWOT analysis complete", progress: 80 })}

`);
        } catch (error) {
          console.error("[MARKET-ENTRY-RESEARCH] SWOT analysis failed:", error.message);
          res.write(`data: ${JSON.stringify({ type: "progress", message: "\u26A0\uFE0F SWOT analysis had issues", progress: 80 })}

`);
          swotResult = { error: error.message };
        }
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F4BE} Generating strategic decisions...", progress: 85 })}

`);
        const generator = new DecisionGenerator();
        let decisions;
        try {
          const swotDataForDecisions = swotResult?.data?.output || swotResult?.output || swotResult?.data || swotResult;
          const hasValidSwot = swotDataForDecisions && !swotDataForDecisions.error && Array.isArray(swotDataForDecisions.strengths) && Array.isArray(swotDataForDecisions.weaknesses);
          console.log("[MARKET-ENTRY-RESEARCH] SWOT data for decisions:", {
            hasData: !!swotDataForDecisions,
            isError: swotDataForDecisions?.error,
            hasStrengths: Array.isArray(swotDataForDecisions?.strengths),
            hasWeaknesses: Array.isArray(swotDataForDecisions?.weaknesses),
            valid: hasValidSwot
          });
          if (!hasValidSwot) {
            console.warn("[MARKET-ENTRY-RESEARCH] Invalid SWOT data, using placeholder decisions");
            decisions = { decisions: [], decision_flow: "SWOT data unavailable", estimated_completion_time_minutes: 30 };
          } else {
            decisions = await generator.generateDecisionsFromSWOT(
              swotDataForDecisions,
              input
            );
          }
          console.log(`[MARKET-ENTRY-RESEARCH] Generated ${decisions?.decisions?.length || 0} decisions`);
        } catch (error) {
          console.error("[MARKET-ENTRY-RESEARCH] Decision generation failed:", error.message);
          decisions = { decisions: [], decision_flow: {}, estimated_completion_time_minutes: 30 };
        }
        res.write(`data: ${JSON.stringify({ type: "progress", message: "\u{1F4BE} Saving analysis results...", progress: 90 })}

`);
        const userId = req.user?.claims?.sub || "system";
        let targetVersionNumber = journeySession?.versionNumber || 1;
        let version;
        try {
          const versions = await storage.getStrategyVersionsBySession(sessionId);
          if (versions.length === 0) {
            version = await storage.createStrategyVersion({
              sessionId,
              versionNumber: targetVersionNumber,
              status: "draft",
              analysisData: {
                pestle: pestleResult,
                porters: portersResult,
                swot: swotResult,
                market_entry_research: true
              },
              decisionsData: decisions,
              userId,
              createdBy: userId,
              inputSummary: input.slice(0, 200)
            });
            console.log(`[MARKET-ENTRY-RESEARCH] Created new version ${targetVersionNumber}`);
          } else {
            version = versions[versions.length - 1];
            targetVersionNumber = version.versionNumber;
            const existingAnalysisData = version.analysisData || {};
            await storage.updateStrategyVersion(version.id, {
              analysisData: {
                ...existingAnalysisData,
                pestle: pestleResult,
                porters: portersResult,
                swot: swotResult,
                market_entry_research: true
              },
              decisionsData: decisions
            });
            console.log(`[MARKET-ENTRY-RESEARCH] Updated existing version ${targetVersionNumber}`);
          }
        } catch (error) {
          console.error("[MARKET-ENTRY-RESEARCH] Database save failed:", error.message);
        }
        const findings = {
          market_dynamics: [],
          competitive_landscape: [],
          language_preferences: [],
          buyer_behavior: [],
          regulatory_factors: [],
          sources: []
        };
        const pestleData = pestleResult?.data || pestleResult;
        const portersData = portersResult?.data || portersResult;
        const swotData = swotResult?.data || swotResult;
        if (pestleData && !pestleData.errors) {
          if (pestleData?.political?.trends) {
            findings.regulatory_factors = pestleData.political.trends.map((t) => ({
              fact: t.description || t,
              citation: "PESTLE Analysis",
              confidence: "high"
            }));
          }
          if (pestleData?.economic?.trends) {
            findings.market_dynamics = [...findings.market_dynamics, ...pestleData.economic.trends.map((t) => ({
              fact: t.description || t,
              citation: "PESTLE Analysis",
              confidence: "high"
            }))];
          }
        }
        if (portersData && !portersData.errors) {
          const forces = ["new_entrants", "supplier_power", "buyer_power", "substitutes", "rivalry"];
          forces.forEach((force) => {
            if (portersData?.[force]) {
              findings.competitive_landscape.push({
                fact: `${force.replace("_", " ")}: ${portersData[force]?.summary || portersData[force]?.description || ""}`,
                citation: "Porter's Five Forces Analysis",
                confidence: "high"
              });
            }
          });
        }
        if (swotData && !swotData.errors) {
          if (swotData?.opportunities) {
            findings.buyer_behavior = swotData.opportunities.slice(0, 3).map((o) => ({
              fact: o.description || o,
              citation: "SWOT Analysis",
              confidence: "high"
            }));
          }
        }
        const finalVersionNumber = version?.versionNumber || targetVersionNumber;
        if (keepaliveInterval) clearInterval(keepaliveInterval);
        const nextUrl = `/strategic-consultant/market-entry-results/${sessionId}/${finalVersionNumber}`;
        res.write(`data: ${JSON.stringify({
          type: "complete",
          data: {
            findings,
            searchQueriesUsed: [],
            versionNumber: finalVersionNumber,
            sourcesAnalyzed: 3,
            timeElapsed: "~2 minutes",
            nextUrl,
            // Include framework analysis results
            marketEntryAnalysis: {
              pestle: pestleResult,
              porters: portersResult,
              swot: swotResult
            }
          }
        })}

`);
        res.end();
        console.log("[MARKET-ENTRY-RESEARCH] Stream ended successfully, nextUrl:", nextUrl);
      } catch (error) {
        if (keepaliveInterval) clearInterval(keepaliveInterval);
        console.error("Error in /market-entry-research/stream:", error);
        res.write(`data: ${JSON.stringify({ type: "error", error: error.message || "Market Entry research failed" })}

`);
        res.end();
      }
    });
    router.get("/understanding/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        const result = await getStrategicUnderstandingBySession(sessionId);
        if (!result) {
          return res.status(404).json({
            success: false,
            error: "Strategic understanding not found for this session"
          });
        }
        res.json({
          success: true,
          understandingId: result.id
        });
      } catch (error) {
        console.error("Error fetching understanding ID:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Failed to fetch understanding ID"
        });
      }
    });
    router.post("/five-whys/validate", async (req, res) => {
      try {
        const { level, candidate, previousWhys, rootQuestion, sessionContext: sessionContext3 } = req.body;
        if (!candidate || !rootQuestion || level === void 0) {
          return res.status(400).json({
            error: "level, candidate, and rootQuestion are required"
          });
        }
        const evaluation = await fiveWhysCoach.validateWhy({
          level: parseInt(level),
          candidate,
          previousWhys: previousWhys || [],
          rootQuestion,
          sessionContext: sessionContext3
        });
        res.json({
          success: true,
          evaluation
        });
      } catch (error) {
        console.error("Error in /five-whys/validate:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Validation failed"
        });
      }
    });
    router.post("/five-whys/coach", async (req, res) => {
      try {
        const {
          sessionId,
          rootQuestion,
          previousWhys,
          candidate,
          userQuestion,
          conversationHistory
        } = req.body;
        if (!sessionId || !rootQuestion || !candidate || !userQuestion) {
          return res.status(400).json({
            error: "sessionId, rootQuestion, candidate, and userQuestion are required"
          });
        }
        const coaching = await fiveWhysCoach.provideCoaching({
          sessionId,
          rootQuestion,
          previousWhys: previousWhys || [],
          candidate,
          userQuestion,
          conversationHistory: conversationHistory || []
        });
        res.json({
          success: true,
          coaching
        });
      } catch (error) {
        console.error("Error in /five-whys/coach:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Coaching failed"
        });
      }
    });
    router.post("/journeys/execute-background", async (req, res) => {
      try {
        const { understandingId, journeyType, frameworks } = req.body;
        const userId = req.user?.claims?.sub || null;
        if (!understandingId) {
          return res.status(400).json({ error: "understandingId is required" });
        }
        if (!journeyType && (!frameworks || frameworks.length === 0)) {
          return res.status(400).json({
            error: "Either journeyType or frameworks must be provided"
          });
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          return res.status(404).json({ error: "Strategy not found" });
        }
        const existingSessions = await db.query.journeySessions.findMany({
          where: (sessions2, { eq: eq37 }) => eq37(sessions2.understandingId, understandingId)
        });
        let targetUnderstandingId = understandingId;
        let isFollowOn = false;
        if (existingSessions.length > 0) {
          try {
            const strategicSummary = await buildStrategicSummary(understandingId);
            const summaryResult = await strategicUnderstandingService.extractUnderstanding({
              sessionId: understanding.sessionId || "",
              userInput: strategicSummary,
              companyContext: null
            });
            await updateStrategicUnderstanding(summaryResult.understandingId, {
              initiativeType: understanding.initiativeType || "strategic_analysis",
              initiativeDescription: `Follow-on analysis derived from ${understanding.id} (v${existingSessions.length + 1})`,
              userConfirmed: true
            });
            targetUnderstandingId = summaryResult.understandingId;
            isFollowOn = true;
            console.log(`Follow-on journey detected. Created new understanding ${targetUnderstandingId} from summary of ${understandingId}`);
          } catch (summaryError) {
            console.warn("Failed to build strategic summary, using original understanding:", summaryError.message);
          }
        }
        const { journeySessionId, versionNumber } = await journeyOrchestrator3.startJourney(
          targetUnderstandingId,
          journeyType,
          userId
        );
        const { backgroundJobService: backgroundJobService2 } = await Promise.resolve().then(() => (init_background_job_service(), background_job_service_exports));
        const jobId = await backgroundJobService2.createJob({
          userId,
          jobType: journeyType ? "strategic_understanding" : "web_research",
          inputData: {
            sessionId: journeySessionId,
            // CRITICAL: Worker needs session ID
            understandingId: targetUnderstandingId,
            versionNumber,
            // Include version number for background worker
            journeyType,
            frameworks,
            mode: "background",
            isFollowOn,
            baseUnderstandingId: isFollowOn ? understandingId : void 0
          },
          relatedEntityId: targetUnderstandingId,
          relatedEntityType: "strategic_understanding"
        });
        console.log(`[execute-background] Journey session ${journeySessionId} (v${versionNumber}) queued for background execution by worker`);
        res.json({
          success: true,
          jobId,
          journeySessionId,
          versionNumber,
          // Return version number to client
          understandingId: targetUnderstandingId,
          isFollowOn,
          message: journeyType ? `Journey "${journeyType}" queued for background execution${isFollowOn ? " (follow-on analysis with strategic summary)" : ""}` : `${frameworks.length} framework(s) queued for background execution${isFollowOn ? " (follow-on analysis with strategic summary)" : ""}`,
          estimatedDuration: "10-15 minutes"
        });
      } catch (error) {
        console.error("Error in /journeys/execute-background:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Background execution failed"
        });
      }
    });
    router.post("/journeys/run-now", async (req, res) => {
      try {
        const { understandingId, journeyType } = req.body;
        const userId = req.user?.claims?.sub || null;
        if (!understandingId) {
          return res.status(400).json({ error: "understandingId is required" });
        }
        if (!journeyType) {
          return res.status(400).json({
            error: "journeyType is required for interactive execution"
          });
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          return res.status(404).json({ error: "Strategy not found" });
        }
        const journey = journeyRegistry.getJourney(journeyType);
        if (!journey) {
          return res.status(404).json({ error: "Journey not found" });
        }
        if (!journey.available) {
          return res.status(400).json({
            error: "This journey is not yet available",
            journeyName: journey.name
          });
        }
        const existingSessions = await db.query.journeySessions.findMany({
          where: (sessions2, { eq: eq37 }) => eq37(sessions2.understandingId, understandingId)
        });
        if (existingSessions.length > 0) {
          try {
            const strategicSummary = await buildStrategicSummary(understandingId);
            await updateStrategicUnderstanding(understandingId, {
              userInput: strategicSummary,
              initiativeDescription: strategicSummary
              // Show the actual summary, not a technical message
            });
            console.log(`[Run Now] Follow-on journey detected. Updated understanding ${understandingId} with strategic summary`);
          } catch (summaryError) {
            console.warn("[Run Now] Failed to build strategic summary, using existing input:", summaryError.message);
          }
        }
        const { journeySessionId, versionNumber } = await journeyOrchestrator3.startJourney(
          understandingId,
          journeyType,
          userId
        );
        const firstPageUrl = journey.pageSequence?.[1]?.replace(":understandingId", understandingId).replace(":sessionId", journeySessionId);
        console.log(`[Run Now] Journey session ${journeySessionId} created (v${versionNumber}), redirecting to wizard`);
        res.json({
          success: true,
          journeySessionId,
          versionNumber,
          // Version number for this journey session
          understandingId,
          message: `Journey "${journeyType}" started${existingSessions.length > 0 ? " using strategic summary from previous analysis" : ""}`,
          navigationUrl: firstPageUrl || `/strategic-consultant/whys-tree/${journeySessionId}`
        });
      } catch (error) {
        console.error("Error in /journeys/run-now:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Journey execution failed"
        });
      }
    });
    router.get("/journey-registry", async (req, res) => {
      try {
        const allJourneys = journeyRegistry.getAllJourneys();
        res.json({
          success: true,
          journeys: allJourneys,
          count: allJourneys.length
        });
      } catch (error) {
        console.error("Error in /journey-registry:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Failed to fetch journey registry"
        });
      }
    });
    router.post("/journeys/check-readiness", async (req, res) => {
      try {
        const { understandingId, journeyType, frameworks } = req.body;
        if (!understandingId) {
          return res.status(400).json({
            error: "understandingId is required"
          });
        }
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          return res.status(404).json({ error: "Strategy not found" });
        }
        const [entities, referencesData] = await Promise.all([
          db.query.strategicEntities.findMany({
            where: (entities2, { eq: eq37 }) => eq37(entities2.understandingId, understandingId)
          }),
          db.query.references.findMany({
            where: (refs, { eq: eq37 }) => eq37(refs.understandingId, understandingId)
          })
        ]);
        const entityCount = entities.length;
        const referenceCount = referencesData.length;
        const hasUserInput = !!understanding.userInput;
        let minReferences;
        let minEntities;
        if (isJourneyRegistryV2Enabled()) {
          const journey = journeyRegistry.getJourney(journeyType);
          if (!journey) {
            return res.status(400).json({ error: "Invalid journey type" });
          }
          ({ minReferences, minEntities } = journey.defaultReadiness);
          console.log("[Strategic Consultant] Using registry thresholds:", { minReferences, minEntities });
        } else {
          const readinessConfig = {
            business_model_innovation: { minReferences: 0, minEntities: 0 },
            business_model_canvas: { minReferences: 0, minEntities: 0 }
          };
          const config = readinessConfig[journeyType] ?? { minReferences: 3, minEntities: 5 };
          minReferences = config.minReferences;
          minEntities = config.minEntities;
          console.log("[Strategic Consultant] Using legacy thresholds:", { minReferences, minEntities });
        }
        const isReady = hasUserInput && referenceCount >= minReferences && entityCount >= minEntities;
        const missingRequirements = [];
        if (!hasUserInput) {
          missingRequirements.push("Original strategic input is missing");
        }
        if (referenceCount < minReferences) {
          missingRequirements.push(`Need ${minReferences - referenceCount} more reference(s)`);
        }
        if (entityCount < minEntities) {
          missingRequirements.push(`Need ${minEntities - entityCount} more strategic entit${entityCount === 1 ? "y" : "ies"}`);
        }
        res.json({
          success: true,
          ready: isReady,
          canRunInBackground: isReady,
          context: {
            entityCount,
            referenceCount,
            hasUserInput
          },
          missingRequirements,
          recommendation: isReady ? "Sufficient context available for background execution" : "Interactive journey recommended to gather more context"
        });
      } catch (error) {
        console.error("Error in /journeys/check-readiness:", error);
        res.status(500).json({
          success: false,
          error: error.message || "Readiness check failed"
        });
      }
    });
    router.get("/config/features", (req, res) => {
      res.json({
        journeyRegistryV2: isJourneyRegistryV2Enabled(),
        knowledgeGraph: isKnowledgeGraphEnabled()
      });
    });
    router.get("/bmc-knowledge/:programId", async (req, res) => {
      try {
        const { programId } = req.params;
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({ error: "Unauthorized" });
        }
        const [program] = await db.select().from(epmPrograms).where(and14(
          eq18(epmPrograms.id, programId),
          eq18(epmPrograms.userId, userId)
        )).limit(1);
        if (!program) {
          return res.status(404).json({ error: "EPM program not found" });
        }
        const [strategyVersion] = await db.select().from(strategyVersions).where(eq18(strategyVersions.id, program.strategyVersionId)).limit(1);
        if (!strategyVersion || !strategyVersion.sessionId) {
          return res.json({
            userAssumptions: [],
            researchFindings: [],
            contradictions: [],
            criticalGaps: []
          });
        }
        const understanding = await getStrategicUnderstandingBySession(strategyVersion.sessionId);
        if (!understanding || !understanding.id) {
          return res.json({
            userAssumptions: [],
            researchFindings: [],
            contradictions: [],
            criticalGaps: []
          });
        }
        const allEntities = await strategicUnderstandingService.getEntitiesByUnderstanding(understanding.id);
        const userAssumptions = allEntities.filter((e) => e.discoveredBy === "user_input");
        const researchFindings = allEntities.filter((e) => e.discoveredBy === "bmc_agent");
        const entityIds = allEntities.map((e) => e.id);
        const contradictionRelationships = entityIds.length > 0 ? await db.select().from(strategicRelationships).where(and14(
          eq18(strategicRelationships.relationshipType, "contradicts"),
          inArray4(strategicRelationships.fromEntityId, entityIds),
          inArray4(strategicRelationships.toEntityId, entityIds)
        )).orderBy(strategicRelationships.discoveredAt) : [];
        const contradictions = await Promise.all(
          contradictionRelationships.map(async (rel) => {
            const fromEntity = allEntities.find((e) => e.id === rel.fromEntityId);
            const toEntity = allEntities.find((e) => e.id === rel.toEntityId);
            const isFromUser = fromEntity?.discoveredBy === "user_input";
            let decryptedEvidence = rel.evidence || "";
            if (decryptedEvidence) {
              try {
                decryptedEvidence = await decryptKMS(decryptedEvidence) || decryptedEvidence;
              } catch (e) {
                console.warn("Evidence decryption failed, using as-is:", e);
              }
            }
            return {
              userClaim: isFromUser ? fromEntity : toEntity,
              researchClaim: isFromUser ? toEntity : fromEntity,
              evidence: decryptedEvidence
            };
          })
        );
        const validContradictions = contradictions.filter((c) => c.userClaim && c.researchClaim);
        const bmcAnalysisRecords = await db.select().from(bmcAnalyses).where(eq18(bmcAnalyses.strategyVersionId, program.strategyVersionId)).limit(1);
        const criticalGaps = bmcAnalysisRecords[0]?.criticalGaps || [];
        res.json({
          userAssumptions,
          researchFindings,
          contradictions: validContradictions,
          criticalGaps
        });
      } catch (error) {
        console.error("Error in /bmc-knowledge/:programId:", error);
        res.status(500).json({
          error: error.message || "Failed to retrieve BMC knowledge data"
        });
      }
    });
    router.get("/context-foundry/status", async (req, res) => {
      try {
        const { validateContextFoundryConnection: validateContextFoundryConnection2, isContextFoundryConfigured: isContextFoundryConfigured2 } = await Promise.resolve().then(() => (init_grounded_analysis_service(), grounded_analysis_service_exports));
        const status = await validateContextFoundryConnection2();
        res.json({
          configured: status.configured,
          connected: status.connected,
          error: status.error,
          message: status.connected ? "Context Foundry is connected and ready for grounded analysis" : status.configured ? "Context Foundry is configured but connection failed" : "Context Foundry API key not configured"
        });
      } catch (error) {
        res.status(500).json({
          configured: false,
          connected: false,
          error: error.message
        });
      }
    });
    router.get("/health", (req, res) => {
      res.json({
        success: true,
        message: "Strategic Consultant API is healthy",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    });
    router.get("/framework-insights/:sessionId/:frameworkName", async (req, res) => {
      try {
        const { sessionId, frameworkName } = req.params;
        console.log(`[Framework Insights] Fetching ${frameworkName} insights for session ${sessionId}`);
        const session3 = await db.query.journeySessions.findFirst({
          where: eq18(journeySessions.id, sessionId)
        });
        if (!session3) {
          return res.status(404).json({ error: "Journey session not found" });
        }
        const insight = await db.query.frameworkInsights.findFirst({
          where: and14(
            eq18(frameworkInsights.sessionId, sessionId),
            eq18(frameworkInsights.frameworkName, frameworkName)
          )
        });
        if (!insight) {
          console.log(`[Framework Insights] No insight found for ${frameworkName} in session ${sessionId}`);
          return res.status(404).json({
            error: "Framework insight not found",
            message: `The ${frameworkName} analysis hasn't been completed yet for this session`
          });
        }
        console.log(`[Framework Insights] \u2713 Found ${frameworkName} insight for session ${sessionId}`);
        const metadata = session3.metadata;
        let nextStepRedirectUrl = metadata?.nextStepRedirectUrl || null;
        if (!nextStepRedirectUrl) {
          const frameworks = metadata?.frameworks || [];
          const normalizeFrameworkName2 = (name) => name.toLowerCase().replace(/_/g, "-");
          const normalizedFrameworkName = normalizeFrameworkName2(frameworkName);
          const currentIndex = frameworks.findIndex((f) => normalizeFrameworkName2(f) === normalizedFrameworkName);
          if (currentIndex >= 0 && currentIndex < frameworks.length - 1) {
            const nextFramework = frameworks[currentIndex + 1];
            const normalizedNext = normalizeFrameworkName2(nextFramework);
            if (normalizedNext === "strategic-decisions") {
              const versions = await db.query.strategyVersions.findMany({
                where: eq18(strategyVersions.sessionId, session3.understandingId || ""),
                orderBy: (sv, { desc: desc21 }) => [desc21(sv.versionNumber)],
                limit: 1
              });
              if (versions.length > 0) {
                nextStepRedirectUrl = `/strategic-consultant/decisions/${session3.understandingId}/${versions[0].versionNumber}`;
              }
            }
          }
        }
        res.json({
          success: true,
          insight: {
            id: insight.id,
            sessionId: insight.sessionId,
            frameworkName: insight.frameworkName,
            frameworkVersion: insight.frameworkVersion,
            insights: insight.insights,
            telemetry: insight.telemetry,
            createdAt: insight.createdAt
          },
          session: {
            id: session3.id,
            journeyType: session3.journeyType,
            status: session3.status,
            currentFrameworkIndex: session3.currentFrameworkIndex,
            completedFrameworks: session3.completedFrameworks,
            understandingId: session3.understandingId,
            metadata: session3.metadata
          },
          nextStepRedirectUrl
        });
      } catch (error) {
        console.error("[Framework Insights] Error fetching framework insights:", error);
        res.status(500).json({ error: error.message || "Failed to fetch framework insights" });
      }
    });
    router.get("/framework-insights/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        console.log(`[Framework Insights] Fetching all insights for session ${sessionId}`);
        const insights = await db.query.frameworkInsights.findMany({
          where: eq18(frameworkInsights.sessionId, sessionId),
          orderBy: (fi, { asc }) => [asc(fi.createdAt)]
        });
        res.json({
          success: true,
          insights: insights.map((i) => ({
            id: i.id,
            frameworkName: i.frameworkName,
            frameworkVersion: i.frameworkVersion,
            insights: i.insights,
            telemetry: i.telemetry,
            createdAt: i.createdAt
          }))
        });
      } catch (error) {
        console.error("[Framework Insights] Error fetching all insights:", error);
        res.status(500).json({ error: error.message || "Failed to fetch framework insights" });
      }
    });
    router.post("/frameworks/pestle/execute/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        console.log("[PESTLE Execute] Starting for session:", sessionId);
        const journeySession = await getJourneySession(sessionId);
        let understanding;
        if (journeySession?.understandingId) {
          understanding = await getStrategicUnderstanding(journeySession.understandingId);
        } else {
          understanding = await getStrategicUnderstandingBySession(sessionId);
        }
        if (!understanding?.userInput) {
          return res.status(404).json({ error: "Strategic understanding not found" });
        }
        const { frameworkRegistry: frameworkRegistry3 } = await Promise.resolve().then(() => (init_framework_executor_registry(), framework_executor_registry_exports));
        const strategicContext = {
          userInput: understanding.userInput,
          understandingId: understanding.id,
          sessionId,
          insights: {}
        };
        const pestleResult = await frameworkRegistry3.execute("pestle", strategicContext);
        console.log("[PESTLE Execute] \u2713 Analysis complete");
        const userId = req.user?.claims?.sub || "system";
        let versions = await storage.getStrategyVersionsBySession(sessionId);
        let version;
        const versionNumber = journeySession?.versionNumber || 1;
        if (versions.length === 0) {
          version = await storage.createStrategyVersion({
            sessionId,
            versionNumber,
            status: "draft",
            analysisData: { pestle: pestleResult },
            userId,
            createdBy: userId,
            inputSummary: understanding.userInput.slice(0, 200)
          });
        } else {
          version = versions[versions.length - 1];
          const existingData = version.analysisData || {};
          await storage.updateStrategyVersion(version.id, {
            analysisData: { ...existingData, pestle: pestleResult }
          });
        }
        res.json({
          success: true,
          framework: "pestle",
          data: pestleResult,
          versionNumber: version?.versionNumber || versionNumber
        });
      } catch (error) {
        console.error("[PESTLE Execute] Error:", error);
        res.status(500).json({ error: error.message || "PESTLE analysis failed" });
      }
    });
    router.post("/frameworks/porters/execute/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        console.log("[Porters Execute] Starting for session:", sessionId);
        const journeySession = await getJourneySession(sessionId);
        let understanding;
        if (journeySession?.understandingId) {
          understanding = await getStrategicUnderstanding(journeySession.understandingId);
        } else {
          understanding = await getStrategicUnderstandingBySession(sessionId);
        }
        if (!understanding?.userInput) {
          return res.status(404).json({ error: "Strategic understanding not found" });
        }
        const versions = await storage.getStrategyVersionsBySession(sessionId);
        const existingData = versions.length > 0 ? versions[versions.length - 1].analysisData || {} : {};
        const { frameworkRegistry: frameworkRegistry3 } = await Promise.resolve().then(() => (init_framework_executor_registry(), framework_executor_registry_exports));
        const strategicContext = {
          userInput: understanding.userInput,
          understandingId: understanding.id,
          sessionId,
          insights: {},
          previousResults: { pestle: existingData.pestle }
        };
        const portersResult = await frameworkRegistry3.execute("porters", strategicContext);
        console.log("[Porters Execute] \u2713 Analysis complete");
        const userId = req.user?.claims?.sub || "system";
        const versionNumber = journeySession?.versionNumber || 1;
        let version;
        if (versions.length === 0) {
          version = await storage.createStrategyVersion({
            sessionId,
            versionNumber,
            status: "draft",
            analysisData: { ...existingData, porters: portersResult },
            userId,
            createdBy: userId,
            inputSummary: understanding.userInput.slice(0, 200)
          });
        } else {
          version = versions[versions.length - 1];
          await storage.updateStrategyVersion(version.id, {
            analysisData: { ...existingData, porters: portersResult }
          });
        }
        res.json({
          success: true,
          framework: "porters",
          data: portersResult,
          versionNumber: version?.versionNumber || versionNumber
        });
      } catch (error) {
        console.error("[Porters Execute] Error:", error);
        res.status(500).json({ error: error.message || "Porter's analysis failed" });
      }
    });
    router.post("/frameworks/swot/execute/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        console.log("[SWOT Execute] Starting for session:", sessionId);
        const journeySession = await getJourneySession(sessionId);
        let understanding;
        if (journeySession?.understandingId) {
          understanding = await getStrategicUnderstanding(journeySession.understandingId);
        } else {
          understanding = await getStrategicUnderstandingBySession(sessionId);
        }
        if (!understanding?.userInput) {
          return res.status(404).json({ error: "Strategic understanding not found" });
        }
        const versions = await storage.getStrategyVersionsBySession(sessionId);
        const existingData = versions.length > 0 ? versions[versions.length - 1].analysisData || {} : {};
        const { frameworkRegistry: frameworkRegistry3 } = await Promise.resolve().then(() => (init_framework_executor_registry(), framework_executor_registry_exports));
        const strategicContext = {
          userInput: understanding.userInput,
          understandingId: understanding.id,
          sessionId,
          insights: existingData,
          // Pass previous results for context
          previousResults: {
            pestle: existingData.pestle,
            porters: existingData.porters
          }
        };
        const swotResult = await frameworkRegistry3.execute("swot", strategicContext);
        console.log("[SWOT Execute] \u2713 Analysis complete");
        const generator = new DecisionGenerator();
        let decisions;
        try {
          const swotData = swotResult?.data?.output || swotResult?.output || swotResult?.data || swotResult;
          const hasValidSwot = swotData && !swotData.error && Array.isArray(swotData.strengths) && Array.isArray(swotData.weaknesses);
          console.log("[SWOT Execute] SWOT data for decisions:", {
            hasData: !!swotData,
            isError: swotData?.error,
            hasStrengths: Array.isArray(swotData?.strengths),
            hasWeaknesses: Array.isArray(swotData?.weaknesses),
            valid: hasValidSwot
          });
          if (!hasValidSwot) {
            console.warn("[SWOT Execute] Invalid SWOT data, using placeholder decisions");
            decisions = { decisions: [], decision_flow: "SWOT data unavailable", estimated_completion_time_minutes: 30 };
          } else {
            decisions = await generator.generateDecisionsFromSWOT(swotData, understanding.userInput);
          }
          console.log(`[SWOT Execute] Generated ${decisions?.decisions?.length || 0} decisions`);
        } catch (decisionError) {
          console.error("[SWOT Execute] Decision generation failed:", decisionError.message);
          decisions = { decisions: [], decision_flow: {}, estimated_completion_time_minutes: 30 };
        }
        const userId = req.user?.claims?.sub || "system";
        const versionNumber = journeySession?.versionNumber || 1;
        let version;
        if (versions.length === 0) {
          version = await storage.createStrategyVersion({
            sessionId,
            versionNumber,
            status: "draft",
            analysisData: { ...existingData, swot: swotResult },
            decisionsData: decisions,
            userId,
            createdBy: userId,
            inputSummary: understanding.userInput.slice(0, 200)
          });
        } else {
          version = versions[versions.length - 1];
          await storage.updateStrategyVersion(version.id, {
            analysisData: { ...existingData, swot: swotResult },
            decisionsData: decisions
          });
        }
        res.json({
          success: true,
          framework: "swot",
          data: swotResult,
          decisions,
          versionNumber: version?.versionNumber || versionNumber
        });
      } catch (error) {
        console.error("[SWOT Execute] Error:", error);
        res.status(500).json({ error: error.message || "SWOT analysis failed" });
      }
    });
    router.get("/frameworks/:framework/:sessionId", async (req, res) => {
      try {
        const { framework, sessionId } = req.params;
        console.log(`[Framework Get] Fetching ${framework} for session:`, sessionId);
        const versions = await storage.getStrategyVersionsBySession(sessionId);
        if (versions.length === 0) {
          return res.status(404).json({ error: "No analysis data found for this session" });
        }
        const version = versions[versions.length - 1];
        const analysisData = version.analysisData || {};
        const frameworkData = analysisData[framework];
        if (!frameworkData) {
          return res.status(404).json({ error: `${framework} analysis not found` });
        }
        res.json({
          success: true,
          framework,
          data: frameworkData,
          versionNumber: version.versionNumber
        });
      } catch (error) {
        console.error("[Framework Get] Error:", error);
        res.status(500).json({ error: error.message || "Failed to fetch framework data" });
      }
    });
    strategic_consultant_legacy_default = router;
  }
});

// server/strategic-consultant-v2/context-gatherer.ts
var ContextGatherer, contextGatherer;
var init_context_gatherer = __esm({
  "server/strategic-consultant-v2/context-gatherer.ts"() {
    "use strict";
    init_secure_data_service();
    ContextGatherer = class {
      async askClarifications(userInput) {
        const questions = [];
        const lowerInput = userInput.toLowerCase();
        if (!lowerInput.includes("budget") && !lowerInput.includes("$") && !lowerInput.includes("cost")) {
          questions.push({
            id: "budget_range",
            question: "What is your approximate budget range for this initiative?",
            type: "select",
            options: [
              "Under $50,000",
              "$50,000 - $250,000",
              "$250,000 - $1,000,000",
              "$1,000,000 - $5,000,000",
              "Over $5,000,000"
            ],
            required: false
          });
        }
        if (!lowerInput.includes("month") && !lowerInput.includes("year") && !lowerInput.includes("week") && !lowerInput.includes("timeline")) {
          questions.push({
            id: "timeline",
            question: "What is your target timeline for completion?",
            type: "select",
            options: [
              "1-3 months",
              "3-6 months",
              "6-12 months",
              "12-24 months",
              "Over 24 months"
            ],
            required: false
          });
        }
        return questions;
      }
      async runAnalysis(userInput, clarifications) {
        console.log("[ContextGatherer] Running initial analysis...");
        const industry = this.detectIndustry(userInput);
        const businessType = this.detectBusinessType(userInput);
        console.log(`[ContextGatherer] Detected industry: ${industry}, type: ${businessType}`);
        return {
          detectedIndustry: industry,
          detectedBusinessType: businessType,
          keyInsights: [],
          opportunities: [],
          threats: [],
          strategicChallenge: this.extractChallenge(userInput)
        };
      }
      async saveContext(sessionId, context, userId) {
        console.log(`[ContextGatherer] Saving context for session: ${sessionId}`);
        const initiativeType = this.mapToInitiativeType(context.userInput, context.analysis.detectedIndustry);
        const existing = await getStrategicUnderstanding(sessionId);
        if (existing) {
          await updateStrategicUnderstanding(sessionId, {
            userInput: context.userInput,
            initiativeType,
            initiativeDescription: `${context.analysis.detectedBusinessType}: ${context.analysis.strategicChallenge}`
          });
          return sessionId;
        } else {
          console.log(`[ContextGatherer] Creating new Strategic Understanding record`);
          const saved = await saveStrategicUnderstanding({
            sessionId,
            userInput: context.userInput,
            initiativeType,
            initiativeDescription: `${context.analysis.detectedBusinessType}: ${context.analysis.strategicChallenge}`,
            title: context.analysis.strategicChallenge.substring(0, 100),
            companyContext: {
              industry: context.analysis.detectedIndustry,
              businessType: context.analysis.detectedBusinessType,
              v2Analysis: context.analysis,
              clarifications: context.clarifications
            }
          });
          return saved.sessionId;
        }
      }
      mapToInitiativeType(userInput, detectedIndustry) {
        const lowerInput = userInput.toLowerCase();
        if (lowerInput.includes("store") || lowerInput.includes("shop") || lowerInput.includes("restaurant") || lowerInput.includes("cafe") || lowerInput.includes("open") || lowerInput.includes("launch") && (lowerInput.includes("physical") || lowerInput.includes("location"))) {
          return "physical_business_launch";
        }
        if (lowerInput.includes("app") || lowerInput.includes("software") || lowerInput.includes("saas") || lowerInput.includes("platform") || lowerInput.includes("build")) {
          return "software_development";
        }
        if (lowerInput.includes("digital") || lowerInput.includes("transform") || lowerInput.includes("modernize") || lowerInput.includes("automate")) {
          return "digital_transformation";
        }
        if (lowerInput.includes("expand") || lowerInput.includes("new market") || lowerInput.includes("geographic") || lowerInput.includes("international")) {
          return "market_expansion";
        }
        if (lowerInput.includes("product") || lowerInput.includes("launch") || lowerInput.includes("new line")) {
          return "product_launch";
        }
        return "physical_business_launch";
      }
      detectIndustry(userInput) {
        const lowerInput = userInput.toLowerCase();
        const industryPatterns = {
          "retail": ["store", "shop", "retail", "ecommerce", "e-commerce", "merchandise", "sneaker", "fashion", "clothing"],
          "food_service": ["restaurant", "cafe", "food", "dining", "kitchen", "catering", "bakery", "bistro"],
          "technology": ["software", "app", "tech", "saas", "platform", "digital", "IT", "cloud"],
          "healthcare": ["health", "medical", "clinic", "hospital", "pharma", "wellness"],
          "finance": ["bank", "financial", "fintech", "investment", "insurance"],
          "manufacturing": ["factory", "manufacturing", "production", "assembly"],
          "professional_services": ["consulting", "agency", "legal", "accounting", "advisory"],
          "hospitality": ["hotel", "resort", "tourism", "travel", "hospitality"],
          "education": ["school", "university", "education", "training", "learning"],
          "real_estate": ["property", "real estate", "development", "construction"]
        };
        for (const [industry, keywords] of Object.entries(industryPatterns)) {
          if (keywords.some((keyword) => lowerInput.includes(keyword))) {
            return industry;
          }
        }
        return "general";
      }
      detectBusinessType(userInput) {
        const lowerInput = userInput.toLowerCase();
        if (lowerInput.includes("startup") || lowerInput.includes("new business") || lowerInput.includes("launch")) {
          return "startup";
        }
        if (lowerInput.includes("expand") || lowerInput.includes("growth") || lowerInput.includes("scale")) {
          return "expansion";
        }
        if (lowerInput.includes("transform") || lowerInput.includes("modernize") || lowerInput.includes("digital")) {
          return "transformation";
        }
        if (lowerInput.includes("improve") || lowerInput.includes("optimize") || lowerInput.includes("efficiency")) {
          return "optimization";
        }
        return "initiative";
      }
      extractChallenge(userInput) {
        const sentences = userInput.split(/[.!?]+/).filter((s) => s.trim().length > 0);
        if (sentences.length > 0) {
          return sentences[0].trim();
        }
        return userInput.substring(0, 200);
      }
    };
    contextGatherer = new ContextGatherer();
  }
});

// server/journey/templates/standard-epm.ts
var standardEPMTemplate;
var init_standard_epm = __esm({
  "server/journey/templates/standard-epm.ts"() {
    "use strict";
    standardEPMTemplate = {
      id: "standard-epm",
      name: "Standard EPM Journey",
      description: "Full strategic analysis to EPM program generation",
      analysisFrameworks: ["five_whys", "swot"],
      epmModules: [
        { moduleId: "executive-summary", required: true },
        { moduleId: "workstreams", required: true },
        { moduleId: "timeline", required: true },
        { moduleId: "resource-plan", required: true },
        { moduleId: "financial-plan", required: true },
        { moduleId: "risk-register", required: true },
        { moduleId: "benefits-realization", required: true },
        { moduleId: "kpis", required: true },
        { moduleId: "stage-gates", required: true },
        { moduleId: "stakeholder-map", required: true },
        { moduleId: "governance", required: true },
        { moduleId: "qa-plan", required: true },
        { moduleId: "procurement", required: true },
        { moduleId: "exit-strategy", required: true }
      ],
      defaultTimeline: { min: 6, max: 18 },
      defaultBudget: { min: 1e5, max: 2e6 }
    };
  }
});

// server/journey/templates/bmc-journey.ts
var bmcJourneyTemplate;
var init_bmc_journey = __esm({
  "server/journey/templates/bmc-journey.ts"() {
    "use strict";
    bmcJourneyTemplate = {
      id: "bmc-journey",
      name: "Business Model Canvas Journey",
      description: "BMC-focused analysis leading to strategic execution plan",
      analysisFrameworks: ["bmc", "swot"],
      epmModules: [
        { moduleId: "executive-summary", required: true },
        { moduleId: "workstreams", required: true },
        { moduleId: "value-proposition", required: true },
        { moduleId: "customer-segments", required: true },
        { moduleId: "channels", required: true },
        { moduleId: "revenue-streams", required: true },
        { moduleId: "timeline", required: true },
        { moduleId: "resource-plan", required: true },
        { moduleId: "financial-plan", required: true },
        { moduleId: "risk-register", required: true },
        { moduleId: "kpis", required: true }
      ],
      defaultTimeline: { min: 3, max: 12 }
    };
  }
});

// server/journey/templates/digital-transformation.ts
var digitalTransformationTemplate;
var init_digital_transformation = __esm({
  "server/journey/templates/digital-transformation.ts"() {
    "use strict";
    digitalTransformationTemplate = {
      id: "digital-transformation",
      name: "Digital Transformation Journey",
      description: "Strategic analysis for digital modernization initiatives",
      analysisFrameworks: ["five_whys", "swot", "value_chain"],
      epmModules: [
        { moduleId: "executive-summary", required: true },
        { moduleId: "workstreams", required: true },
        { moduleId: "technology-roadmap", required: true },
        { moduleId: "change-management", required: true },
        { moduleId: "timeline", required: true },
        { moduleId: "resource-plan", required: true },
        { moduleId: "financial-plan", required: true },
        { moduleId: "risk-register", required: true },
        { moduleId: "benefits-realization", required: true },
        { moduleId: "kpis", required: true },
        { moduleId: "stage-gates", required: true },
        { moduleId: "stakeholder-map", required: true },
        { moduleId: "governance", required: true }
      ],
      industryHints: ["technology", "software", "IT", "digital", "automation", "cloud"],
      defaultTimeline: { min: 12, max: 36 },
      defaultBudget: { min: 5e5, max: 1e7 }
    };
  }
});

// server/journey/templates/product-launch.ts
var productLaunchTemplate;
var init_product_launch = __esm({
  "server/journey/templates/product-launch.ts"() {
    "use strict";
    productLaunchTemplate = {
      id: "product-launch",
      name: "Product Launch Journey",
      description: "Strategic analysis for new product or service launches",
      analysisFrameworks: ["swot", "segment_discovery", "competitive_positioning"],
      epmModules: [
        { moduleId: "executive-summary", required: true },
        { moduleId: "workstreams", required: true },
        { moduleId: "market-analysis", required: true },
        { moduleId: "go-to-market", required: true },
        { moduleId: "timeline", required: true },
        { moduleId: "resource-plan", required: true },
        { moduleId: "financial-plan", required: true },
        { moduleId: "risk-register", required: true },
        { moduleId: "benefits-realization", required: true },
        { moduleId: "kpis", required: true },
        { moduleId: "stage-gates", required: true }
      ],
      industryHints: ["product", "launch", "new", "MVP", "release", "market entry"],
      defaultTimeline: { min: 3, max: 12 },
      defaultBudget: { min: 5e4, max: 1e6 }
    };
  }
});

// server/journey/templates/market-expansion.ts
var marketExpansionTemplate;
var init_market_expansion = __esm({
  "server/journey/templates/market-expansion.ts"() {
    "use strict";
    marketExpansionTemplate = {
      id: "market-expansion",
      name: "Market Expansion Journey",
      description: "Strategic analysis for market or geographic expansion",
      analysisFrameworks: ["pestle", "porters", "swot"],
      epmModules: [
        { moduleId: "executive-summary", required: true },
        { moduleId: "workstreams", required: true },
        { moduleId: "market-analysis", required: true },
        { moduleId: "competitive-landscape", required: true },
        { moduleId: "entry-strategy", required: true },
        { moduleId: "timeline", required: true },
        { moduleId: "resource-plan", required: true },
        { moduleId: "financial-plan", required: true },
        { moduleId: "risk-register", required: true },
        { moduleId: "benefits-realization", required: true },
        { moduleId: "kpis", required: true },
        { moduleId: "stage-gates", required: true },
        { moduleId: "stakeholder-map", required: true }
      ],
      industryHints: ["expansion", "international", "market entry", "geographic", "new market", "region"],
      defaultTimeline: { min: 6, max: 24 },
      defaultBudget: { min: 2e5, max: 5e6 }
    };
  }
});

// server/journey/templates/index.ts
var templates, templateRegistry;
var init_templates = __esm({
  "server/journey/templates/index.ts"() {
    "use strict";
    init_standard_epm();
    init_bmc_journey();
    init_digital_transformation();
    init_product_launch();
    init_market_expansion();
    templates = /* @__PURE__ */ new Map([
      [standardEPMTemplate.id, standardEPMTemplate],
      [bmcJourneyTemplate.id, bmcJourneyTemplate],
      [digitalTransformationTemplate.id, digitalTransformationTemplate],
      [productLaunchTemplate.id, productLaunchTemplate],
      [marketExpansionTemplate.id, marketExpansionTemplate]
    ]);
    templateRegistry = {
      get(templateId) {
        const template = templates.get(templateId);
        if (!template) {
          console.log(`[TemplateRegistry] Template ${templateId} not found, returning default`);
          return standardEPMTemplate;
        }
        return template;
      },
      list() {
        return Array.from(templates.values());
      },
      has(templateId) {
        return templates.has(templateId);
      },
      getDefault() {
        return standardEPMTemplate;
      },
      getByIndustryHint(keyword) {
        const lowerKeyword = keyword.toLowerCase();
        const templateList = Array.from(templates.values());
        for (const template of templateList) {
          if (template.industryHints?.some(
            (hint) => lowerKeyword.includes(hint.toLowerCase()) || hint.toLowerCase().includes(lowerKeyword)
          )) {
            return template;
          }
        }
        return null;
      }
    };
  }
});

// server/strategic-consultant-v2/journey-selector.ts
var JourneySelector, journeySelector;
var init_journey_selector = __esm({
  "server/strategic-consultant-v2/journey-selector.ts"() {
    "use strict";
    init_templates();
    JourneySelector = class {
      selectBestTemplate(context) {
        console.log("[JourneySelector] Selecting best template for context...");
        const userInput = context.userInput.toLowerCase();
        if (this.matchesBMC(userInput)) {
          console.log("[JourneySelector] Selected: BMC Journey");
          return templateRegistry.get("bmc-journey");
        }
        if (this.matchesDigitalTransformation(userInput)) {
          console.log("[JourneySelector] Selected: Digital Transformation");
          return templateRegistry.get("digital-transformation");
        }
        if (this.matchesProductLaunch(userInput)) {
          console.log("[JourneySelector] Selected: Product Launch");
          return templateRegistry.get("product-launch");
        }
        if (this.matchesMarketExpansion(userInput)) {
          console.log("[JourneySelector] Selected: Market Expansion");
          return templateRegistry.get("market-expansion");
        }
        const industryMatch = templateRegistry.getByIndustryHint(userInput);
        if (industryMatch) {
          console.log(`[JourneySelector] Selected by industry: ${industryMatch.name}`);
          return industryMatch;
        }
        console.log("[JourneySelector] Selected: Standard EPM (default)");
        return templateRegistry.getDefault();
      }
      matchesBMC(input) {
        const keywords = [
          "business model",
          "revenue stream",
          "value proposition",
          "customer segment",
          "bmc",
          "business canvas",
          "revenue model",
          "monetization"
        ];
        return keywords.some((kw) => input.includes(kw));
      }
      matchesDigitalTransformation(input) {
        const keywords = [
          "digital transformation",
          "modernize",
          "automate",
          "cloud migration",
          "digital strategy",
          "technology upgrade",
          "system integration",
          "software implementation"
        ];
        return keywords.some((kw) => input.includes(kw));
      }
      matchesProductLaunch(input) {
        const keywords = [
          "product launch",
          "new product",
          "launch strategy",
          "go to market",
          "go-to-market",
          "gtm",
          "mvp",
          "minimum viable",
          "release strategy"
        ];
        return keywords.some((kw) => input.includes(kw));
      }
      matchesMarketExpansion(input) {
        const keywords = [
          "market expansion",
          "geographic expansion",
          "new market",
          "international",
          "enter market",
          "market entry",
          "expansion strategy",
          "new region",
          "new country"
        ];
        return keywords.some((kw) => input.includes(kw));
      }
    };
    journeySelector = new JourneySelector();
  }
});

// server/strategic-consultant-v2/index.ts
var StrategicConsultantV2, strategicConsultantV2;
var init_strategic_consultant_v2 = __esm({
  "server/strategic-consultant-v2/index.ts"() {
    "use strict";
    init_context_gatherer();
    init_journey_selector();
    init_templates();
    init_journey_orchestrator();
    StrategicConsultantV2 = class {
      contextGatherer;
      journeySelector;
      constructor() {
        this.contextGatherer = new ContextGatherer();
        this.journeySelector = new JourneySelector();
      }
      async gatherContext(userInput, sessionId, userId) {
        console.log("[SC-V2] Phase 1: Gathering strategic context...");
        const clarifications = await this.contextGatherer.askClarifications(userInput);
        const analysis = await this.contextGatherer.runAnalysis(userInput, {});
        const understandingId = await this.contextGatherer.saveContext(sessionId, {
          userInput,
          clarifications: {},
          analysis
        }, userId);
        return {
          sessionId: understandingId,
          userInput,
          clarifications: {},
          analysis,
          industry: analysis.detectedIndustry,
          businessType: analysis.detectedBusinessType
        };
      }
      async executeJourney(context, userId, templateId) {
        console.log("[SC-V2] Phase 2: Executing journey...");
        const template = templateId ? templateRegistry.get(templateId) : this.journeySelector.selectBestTemplate(context);
        console.log(`[SC-V2] Using template: ${template.name}`);
        console.log(`[SC-V2] Industry detected: ${context.industry}`);
        console.log(`[SC-V2] Analysis frameworks: ${template.analysisFrameworks.join(", ")}`);
        try {
          const journeyType = this.mapTemplateToJourneyType(template);
          const orchestrator = new JourneyOrchestrator();
          console.log(`[SC-V2] Starting journey type: ${journeyType}`);
          const journeySession = await orchestrator.startJourney(
            context.sessionId,
            journeyType,
            userId
          );
          return {
            success: true,
            sessionId: context.sessionId,
            templateUsed: template.id,
            epmProgramId: journeySession.journeySessionId
          };
        } catch (error) {
          console.error("[SC-V2] Journey execution failed:", error);
          return {
            success: false,
            sessionId: context.sessionId,
            templateUsed: template.id,
            error: error instanceof Error ? error.message : "Unknown error"
          };
        }
      }
      async run(userInput, sessionId, userId, templateId) {
        console.log("[SC-V2] Starting full flow...");
        console.log(`[SC-V2] Session: ${sessionId}`);
        console.log(`[SC-V2] Input: ${userInput.substring(0, 100)}...`);
        const context = await this.gatherContext(userInput, sessionId, userId);
        return this.executeJourney(context, userId, templateId);
      }
      mapTemplateToJourneyType(template) {
        const templateToJourneyMap = {
          "standard-epm": "business_model_innovation",
          "bmc-journey": "business_model_innovation",
          "digital-transformation": "digital_transformation",
          "product-launch": "product_launch",
          "market-expansion": "market_entry"
        };
        return templateToJourneyMap[template.id] || "business_model_innovation";
      }
      listTemplates() {
        return templateRegistry.list();
      }
    };
    strategicConsultantV2 = new StrategicConsultantV2();
  }
});

// server/routes/strategic-consultant-v2.ts
import { Router as Router2 } from "express";
import { randomUUID as randomUUID4 } from "crypto";
var router2, strategic_consultant_v2_default;
var init_strategic_consultant_v22 = __esm({
  "server/routes/strategic-consultant-v2.ts"() {
    "use strict";
    init_strategic_consultant_v2();
    init_templates();
    router2 = Router2();
    router2.get("/health", (req, res) => {
      res.json({
        success: true,
        message: "Strategic Consultant V2 API is healthy",
        version: "2.0.0",
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      });
    });
    router2.get("/templates", (req, res) => {
      try {
        const templates2 = templateRegistry.list();
        res.json({
          success: true,
          templates: templates2.map((t) => ({
            id: t.id,
            name: t.name,
            description: t.description,
            analysisFrameworks: t.analysisFrameworks,
            moduleCount: t.epmModules.length,
            defaultTimeline: t.defaultTimeline,
            defaultBudget: t.defaultBudget
          }))
        });
      } catch (error) {
        console.error("[SC-V2 Routes] Error listing templates:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router2.post("/start", async (req, res) => {
      try {
        const { userInput, sessionId } = req.body;
        const userId = req.user?.claims?.sub || "system";
        if (!userInput) {
          res.status(400).json({
            success: false,
            error: "userInput is required"
          });
          return;
        }
        const actualSessionId = sessionId || randomUUID4();
        console.log(`[SC-V2 Routes] Starting context gathering for session: ${actualSessionId}`);
        const context = await strategicConsultantV2.gatherContext(userInput, actualSessionId, userId);
        res.json({
          success: true,
          sessionId: context.sessionId,
          context: {
            industry: context.industry,
            businessType: context.businessType,
            analysis: context.analysis
          }
        });
      } catch (error) {
        console.error("[SC-V2 Routes] Error in /start:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router2.post("/execute", async (req, res) => {
      try {
        const { sessionId, templateId, context } = req.body;
        const userId = req.user?.claims?.sub || "system";
        if (!sessionId) {
          res.status(400).json({
            success: false,
            error: "sessionId is required"
          });
          return;
        }
        console.log(`[SC-V2 Routes] Executing journey for session: ${sessionId}`);
        const result = await strategicConsultantV2.executeJourney(
          context || { sessionId, userInput: "" },
          userId,
          templateId
        );
        res.json(result);
      } catch (error) {
        console.error("[SC-V2 Routes] Error in /execute:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router2.post("/run", async (req, res) => {
      try {
        const { userInput, sessionId, templateId } = req.body;
        const userId = req.user?.claims?.sub || "system";
        if (!userInput) {
          res.status(400).json({
            success: false,
            error: "userInput is required"
          });
          return;
        }
        const actualSessionId = sessionId || randomUUID4();
        console.log(`[SC-V2 Routes] Full flow for session: ${actualSessionId}`);
        console.log(`[SC-V2 Routes] Input: ${userInput.substring(0, 100)}...`);
        const result = await strategicConsultantV2.run(userInput, actualSessionId, userId, templateId);
        res.json(result);
      } catch (error) {
        console.error("[SC-V2 Routes] Error in /run:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    router2.get("/template/:templateId", (req, res) => {
      try {
        const { templateId } = req.params;
        if (!templateRegistry.has(templateId)) {
          res.status(404).json({
            success: false,
            error: `Template ${templateId} not found`
          });
          return;
        }
        const template = templateRegistry.get(templateId);
        res.json({
          success: true,
          template
        });
      } catch (error) {
        console.error("[SC-V2 Routes] Error getting template:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    });
    strategic_consultant_v2_default = router2;
  }
});

// server/routes/document-enrichment.ts
import { Router as Router3 } from "express";
var router3, document_enrichment_default;
var init_document_enrichment = __esm({
  "server/routes/document-enrichment.ts"() {
    "use strict";
    init_background_job_service();
    init_replitAuth();
    router3 = Router3();
    router3.get("/notifications", isAuthenticated, async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({ error: "Unauthorized" });
        }
        const allJobs = await backgroundJobService.getRecentJobs(userId, 50);
        const enrichmentJobs = allJobs.filter(
          (job) => job.jobType === "document_enrichment" && job.status === "completed" && job.resultData && !job.resultData.ignored
        );
        const notifications = enrichmentJobs.map((job) => {
          const resultData = job.resultData;
          return {
            id: job.id,
            understandingId: resultData.understandingId,
            entityCount: resultData.entityCount || 0,
            fileName: resultData.fileName || "document",
            completedAt: job.completedAt || job.updatedAt
          };
        });
        res.json({ jobs: notifications });
      } catch (error) {
        console.error("[Document Enrichment] Error fetching notifications:", error);
        res.status(500).json({ error: error.message || "Failed to fetch notifications" });
      }
    });
    document_enrichment_default = router3;
  }
});

// server/domain-extraction-service.ts
import { eq as eq19 } from "drizzle-orm";
var DomainExtractionService, domainExtractionService;
var init_domain_extraction_service = __esm({
  "server/domain-extraction-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_secure_data_service();
    DomainExtractionService = class {
      /**
       * Extract domain context from strategic understanding
       */
      async extractDomain(understandingId) {
        const understandingData = await getStrategicUnderstanding(understandingId);
        if (!understandingData) {
          throw new Error(`Strategic understanding ${understandingId} not found`);
        }
        const entities = await db.select().from(strategicEntities).where(eq19(strategicEntities.understandingId, understandingId));
        const domain = {
          industry: void 0,
          geography: void 0,
          language: "en",
          regulatory: [],
          context: [],
          assumptions: []
        };
        if (understandingData.companyContext) {
          const context = understandingData.companyContext;
          if (context.industry) domain.industry = context.industry;
          if (context.geography) domain.geography = context.geography;
          if (context.language) domain.language = context.language;
          if (context.regulatory && Array.isArray(context.regulatory)) {
            domain.regulatory = context.regulatory;
          }
        }
        for (const entity of entities) {
          if (entity.type === "explicit_assumption" || entity.type === "implicit_implication") {
            domain.assumptions.push(entity.claim);
          }
          if (entity.metadata) {
            const entityMeta = entity.metadata;
            if (entityMeta.industry && !domain.industry) {
              domain.industry = entityMeta.industry;
            }
            if (entityMeta.geography && !domain.geography) {
              domain.geography = entityMeta.geography;
            }
            if (domain.language === "en") {
              let lang = entityMeta.language || entityMeta.originalLanguage || entityMeta.sourceMetadata?.language || entityMeta.source?.metadata?.language;
              if (!lang && entityMeta.evidence && !Array.isArray(entityMeta.evidence)) {
                lang = entityMeta.evidence.originalLanguage || entityMeta.evidence.source?.metadata?.language;
              }
              if (!lang && Array.isArray(entityMeta.evidence)) {
                for (const ev of entityMeta.evidence) {
                  if (ev.originalLanguage || ev.source?.metadata?.language) {
                    lang = ev.originalLanguage || ev.source?.metadata?.language;
                    break;
                  }
                }
              }
              if (!lang && Array.isArray(entityMeta.sources)) {
                for (const src of entityMeta.sources) {
                  if (src.metadata?.language || src.originalLanguage) {
                    lang = src.metadata?.language || src.originalLanguage;
                    break;
                  }
                }
              }
              if (lang && lang !== "unknown") {
                domain.language = lang;
              }
            }
            if (entityMeta.regulatory && domain.regulatory) {
              if (Array.isArray(entityMeta.regulatory)) {
                domain.regulatory.push(...entityMeta.regulatory);
              } else {
                domain.regulatory.push(entityMeta.regulatory);
              }
            }
            if (entityMeta.context) {
              if (Array.isArray(entityMeta.context)) {
                domain.context.push(...entityMeta.context);
              } else {
                domain.context.push(entityMeta.context);
              }
            }
          }
          if (entity.source) {
            domain.context.push(entity.source);
          }
        }
        domain.regulatory = [...Array.from(new Set(domain.regulatory))];
        domain.context = [...Array.from(new Set(domain.context))];
        domain.assumptions = [...Array.from(new Set(domain.assumptions))];
        if (!domain.industry) {
          domain.industry = this.inferIndustry(entities);
        }
        if (!domain.geography) {
          domain.geography = this.inferGeography(entities);
        }
        return domain;
      }
      /**
       * Infer industry from entity claims
       */
      inferIndustry(entities) {
        const industryKeywords = {
          "technology": ["software", "ai", "machine learning", "saas", "cloud", "digital", "tech", "platform"],
          "finance": ["banking", "financial", "investment", "fintech", "trading", "insurance", "lending"],
          "healthcare": ["health", "medical", "pharmaceutical", "hospital", "patient", "clinical", "biotech"],
          "retail": ["retail", "ecommerce", "shopping", "consumer", "store", "marketplace"],
          "manufacturing": ["manufacturing", "production", "factory", "assembly", "industrial", "supply chain"],
          "energy": ["energy", "oil", "gas", "renewable", "solar", "wind", "power", "utilities"]
        };
        const claimsText = entities.map((e) => e.claim?.toLowerCase() || "").join(" ");
        for (const [industry, keywords] of Object.entries(industryKeywords)) {
          for (const keyword of keywords) {
            if (claimsText.includes(keyword)) {
              return industry;
            }
          }
        }
        return void 0;
      }
      /**
       * Infer geography from entity claims
       */
      inferGeography(entities) {
        const geographyKeywords = {
          "US": ["united states", "america", "us ", "american", "usa"],
          "GB": ["united kingdom", "uk", "britain", "british", "england", "scotland"],
          "DE": ["germany", "german", "deutschland"],
          "FR": ["france", "french", "fran\xE7ais"],
          "CN": ["china", "chinese"],
          "IN": ["india", "indian"],
          "JP": ["japan", "japanese"],
          "global": ["global", "worldwide", "international"]
        };
        const claimsText = entities.map((e) => e.claim?.toLowerCase() || "").join(" ");
        for (const [geography, keywords] of Object.entries(geographyKeywords)) {
          for (const keyword of keywords) {
            if (claimsText.includes(keyword)) {
              return geography;
            }
          }
        }
        return void 0;
      }
      /**
       * Get domain summary as text for LLM prompts
       */
      getDomainSummary(domain) {
        const parts = [];
        if (domain.industry) {
          parts.push(`Industry: ${domain.industry}`);
        }
        if (domain.geography) {
          parts.push(`Geography: ${domain.geography}`);
        }
        if (domain.language && domain.language !== "en") {
          parts.push(`Language: ${domain.language}`);
        }
        if (domain.regulatory && domain.regulatory.length > 0) {
          parts.push(`Regulatory Context: ${domain.regulatory.join(", ")}`);
        }
        if (domain.assumptions.length > 0) {
          parts.push(`Key Assumptions: ${domain.assumptions.slice(0, 5).join("; ")}`);
        }
        return parts.join("\n");
      }
    };
    domainExtractionService = new DomainExtractionService();
  }
});

// server/pestle-claims-service.ts
var PESTLEClaimsService, pestleClaimsService;
var init_pestle_claims_service = __esm({
  "server/pestle-claims-service.ts"() {
    "use strict";
    init_ai_clients();
    PESTLEClaimsService = class {
      /**
       * Generate PESTLE claims based on domain context
       * Returns claims and provider used for telemetry
       */
      async generateClaims(domain) {
        const userMessage = this.buildPESTLEPrompt(domain);
        const systemPrompt = `You are a strategic analyst specializing in PESTLE analysis. Your role is to identify macro-environmental factors that could impact businesses based on their industry, geography, and context.

IMPORTANT: You must output valid JSON only. No markdown, no code blocks, no explanations.

For each PESTLE domain, generate 2-4 specific, evidence-based claims about trends that could impact the business. Each claim must:
1. Be specific and actionable (not generic)
2. Be relevant to the industry and geography
3. Include a time horizon (short-term: 0-1 year, medium-term: 1-3 years, long-term: 3+ years)
4. Include rationale explaining the potential impact

PESTLE domains:
- POLITICAL: Government policies, political stability, trade regulations, tax policies
- ECONOMIC: Economic growth, inflation, exchange rates, unemployment, market conditions
- SOCIAL: Demographics, cultural trends, consumer behavior, lifestyle changes
- TECHNOLOGICAL: Innovation, automation, digital transformation, emerging technologies
- LEGAL: Laws, regulations, compliance requirements, intellectual property
- ENVIRONMENTAL: Climate change, sustainability, environmental regulations, resource availability

Output must be valid JSON in this exact structure:
{
  "political": [{"domain": "POLITICAL", "claim": "...", "timeHorizon": "short-term|medium-term|long-term", "rationale": "..."}],
  "economic": [...],
  "social": [...],
  "technological": [...],
  "legal": [...],
  "environmental": [...]
}`;
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt,
            userMessage,
            maxTokens: 4096
          });
          const parsed = this.parsePESTLEResponse(response.content);
          return {
            claims: parsed,
            provider: response.provider
          };
        } catch (error) {
          console.error("Error generating PESTLE claims:", error);
          throw new Error("Failed to generate PESTLE claims");
        }
      }
      /**
       * Build prompt for PESTLE analysis based on domain context
       */
      buildPESTLEPrompt(domain) {
        let prompt = `Generate a PESTLE analysis for the following business context:

`;
        if (domain.industry) {
          prompt += `Industry: ${domain.industry}
`;
        }
        if (domain.geography) {
          prompt += `Geography: ${domain.geography}
`;
        }
        if (domain.language && domain.language !== "en") {
          prompt += `Primary Language/Market: ${domain.language}
`;
        }
        if (domain.regulatory && domain.regulatory.length > 0) {
          prompt += `Regulatory Context: ${domain.regulatory.join(", ")}
`;
        }
        if (domain.context && domain.context.length > 0) {
          prompt += `
Business Context:
${domain.context.slice(0, 5).map((c) => `- ${c}`).join("\n")}
`;
        }
        if (domain.assumptions && domain.assumptions.length > 0) {
          prompt += `
Current Assumptions:
${domain.assumptions.slice(0, 5).map((a) => `- ${a}`).join("\n")}
`;
        }
        prompt += `
Generate 2-4 specific, evidence-based claims for each PESTLE domain that could impact this business. Focus on trends that are:
1. Relevant to the specific industry and geography
2. Backed by observable market trends or policy changes
3. Actionable for strategic planning

Return valid JSON only. No markdown, no code blocks.`;
        return prompt;
      }
      /**
       * Parse LLM response into PESTLE factors
       */
      parsePESTLEResponse(text2) {
        try {
          let cleanedText = text2.trim();
          if (cleanedText.startsWith("```json")) {
            cleanedText = cleanedText.replace(/^```json\n/, "").replace(/\n```$/, "");
          } else if (cleanedText.startsWith("```")) {
            cleanedText = cleanedText.replace(/^```\n/, "").replace(/\n```$/, "");
          }
          const parsed = JSON.parse(cleanedText);
          const validatedFactors = {
            political: this.validateClaims(parsed.political || [], "POLITICAL"),
            economic: this.validateClaims(parsed.economic || [], "ECONOMIC"),
            social: this.validateClaims(parsed.social || [], "SOCIAL"),
            technological: this.validateClaims(parsed.technological || [], "TECHNOLOGICAL"),
            legal: this.validateClaims(parsed.legal || [], "LEGAL"),
            environmental: this.validateClaims(parsed.environmental || [], "ENVIRONMENTAL")
          };
          return validatedFactors;
        } catch (error) {
          console.error("Error parsing PESTLE response:", error);
          console.error("Raw text:", text2);
          throw new Error("Failed to parse PESTLE response");
        }
      }
      /**
       * Validate and normalize claims for a specific domain
       */
      validateClaims(claims, domain) {
        if (!Array.isArray(claims)) {
          return [];
        }
        return claims.filter((c) => c.claim && c.timeHorizon).map((c) => ({
          domain,
          claim: c.claim.trim(),
          timeHorizon: this.normalizeTimeHorizon(c.timeHorizon),
          rationale: c.rationale?.trim(),
          sources: []
        }));
      }
      /**
       * Normalize time horizon to valid enum value
       */
      normalizeTimeHorizon(horizon) {
        const normalized = horizon.toLowerCase().trim();
        if (normalized.includes("short")) return "short-term";
        if (normalized.includes("medium") || normalized.includes("mid")) return "medium-term";
        if (normalized.includes("long")) return "long-term";
        return "medium-term";
      }
      /**
       * Convert PESTLE factors to flat array of claims
       */
      flattenClaims(factors) {
        return [
          ...factors.political,
          ...factors.economic,
          ...factors.social,
          ...factors.technological,
          ...factors.legal,
          ...factors.environmental
        ];
      }
      /**
       * Group claims by domain
       */
      groupByDomain(claims) {
        const factors = {
          political: [],
          economic: [],
          social: [],
          technological: [],
          legal: [],
          environmental: []
        };
        for (const claim of claims) {
          switch (claim.domain) {
            case "POLITICAL":
              factors.political.push(claim);
              break;
            case "ECONOMIC":
              factors.economic.push(claim);
              break;
            case "SOCIAL":
              factors.social.push(claim);
              break;
            case "TECHNOLOGICAL":
              factors.technological.push(claim);
              break;
            case "LEGAL":
              factors.legal.push(claim);
              break;
            case "ENVIRONMENTAL":
              factors.environmental.push(claim);
              break;
          }
        }
        return factors;
      }
    };
    pestleClaimsService = new PESTLEClaimsService();
  }
});

// server/assumption-comparison-service.ts
import { eq as eq20 } from "drizzle-orm";
var AssumptionComparisonService, assumptionComparisonService;
var init_assumption_comparison_service = __esm({
  "server/assumption-comparison-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_ai_clients();
    AssumptionComparisonService = class {
      /**
       * Compare PESTLE claims with assumptions from strategic understanding
       * Returns comparisons and provider info for telemetry
       */
      async compareWithAssumptions(understandingId, claims) {
        const assumptions = await this.loadAssumptions(understandingId);
        if (assumptions.length === 0) {
          console.log("[AssumptionComparison] No assumptions found for understanding", understandingId);
          return { comparisons: [], providers: [] };
        }
        const comparisons = [];
        const providers = [];
        for (const assumption of assumptions) {
          const result = await this.compareAssumptionWithClaims(assumption, claims);
          comparisons.push(result.comparison);
          providers.push(result.provider);
        }
        return { comparisons, providers };
      }
      /**
       * Load assumptions from strategic_entities
       */
      async loadAssumptions(understandingId) {
        const entities = await db.select().from(strategicEntities).where(eq20(strategicEntities.understandingId, understandingId));
        return entities.filter((e) => e.type === "explicit_assumption" || e.type === "implicit_implication").map((e) => ({
          id: e.id,
          claim: e.claim,
          type: e.type,
          metadata: e.metadata
        }));
      }
      /**
       * Compare a single assumption with all PESTLE claims
       * Returns comparison and provider for telemetry
       */
      async compareAssumptionWithClaims(assumption, claims) {
        const systemPrompt = `You are an expert at analyzing strategic assumptions and trend data. Your task is to compare a business assumption with macro-environmental trends and identify relationships.

For each trend claim, determine if it:
- VALIDATES the assumption (supports or strengthens it)
- CONTRADICTS the assumption (opposes or weakens it)
- Is NEUTRAL (unrelated or no clear relationship)

Provide evidence explaining the relationship and a confidence score (0-1).

Output must be valid JSON only. No markdown, no code blocks.

Output format:
{
  "relationship": "validates|contradicts|neutral",
  "relatedClaims": [
    {
      "claimIndex": 0,
      "relationship": "validates|contradicts|neutral",
      "evidence": "Explanation of why this claim validates/contradicts/is neutral to the assumption",
      "confidence": 0.85
    }
  ]
}

Only include claims with "validates" or "contradicts" relationship. Skip neutral claims.`;
        const userMessage = `Assumption: ${assumption.claim}

PESTLE Trend Claims:
${claims.map((c, i) => `${i}. [${c.domain}] ${c.claim} (${c.timeHorizon})`).join("\n")}

Compare the assumption with each trend claim and identify relationships.`;
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt,
            userMessage,
            maxTokens: 2048
          });
          const parsed = this.parseComparisonResponse(response.content, claims);
          const validates = parsed.relatedClaims.filter((c) => c.relationship === "validates").length;
          const contradicts = parsed.relatedClaims.filter((c) => c.relationship === "contradicts").length;
          let relationship = "neutral";
          if (validates > contradicts) {
            relationship = "validates";
          } else if (contradicts > validates) {
            relationship = "contradicts";
          } else if (validates > 0 && contradicts > 0) {
            const validateConfidence = parsed.relatedClaims.filter((c) => c.relationship === "validates").reduce((sum, c) => sum + c.confidence, 0) / validates;
            const contradictConfidence = parsed.relatedClaims.filter((c) => c.relationship === "contradicts").reduce((sum, c) => sum + c.confidence, 0) / contradicts;
            relationship = validateConfidence >= contradictConfidence ? "validates" : "contradicts";
          }
          return {
            comparison: {
              assumptionId: assumption.id,
              assumption: assumption.claim,
              relationship,
              relatedClaims: parsed.relatedClaims.map((rc) => ({
                claim: rc.claim,
                evidence: rc.evidence,
                confidence: rc.confidence
              }))
            },
            provider: response.provider
          };
        } catch (error) {
          console.error("[AssumptionComparison] Error comparing assumption:", error);
          return {
            comparison: {
              assumptionId: assumption.id,
              assumption: assumption.claim,
              relationship: "neutral",
              relatedClaims: []
            },
            provider: "unknown"
            // Error case
          };
        }
      }
      /**
       * Parse LLM comparison response
       */
      parseComparisonResponse(text2, claims) {
        try {
          let cleanedText = text2.trim();
          if (cleanedText.startsWith("```json")) {
            cleanedText = cleanedText.replace(/^```json\n/, "").replace(/\n```$/, "");
          } else if (cleanedText.startsWith("```")) {
            cleanedText = cleanedText.replace(/^```\n/, "").replace(/\n```$/, "");
          }
          const parsed = JSON.parse(cleanedText);
          const relatedClaims = (parsed.relatedClaims || []).filter(
            (rc) => rc.claimIndex !== void 0 && rc.relationship && rc.evidence && claims[rc.claimIndex]
          ).map((rc) => ({
            claim: claims[rc.claimIndex],
            relationship: rc.relationship,
            evidence: rc.evidence,
            confidence: rc.confidence || 0.5
          }));
          return { relatedClaims };
        } catch (error) {
          console.error("[AssumptionComparison] Error parsing response:", error);
          console.error("Raw text:", text2);
          return { relatedClaims: [] };
        }
      }
      /**
       * Filter comparisons to only show significant relationships
       */
      filterSignificantComparisons(comparisons, minConfidence = 0.6) {
        return comparisons.map((comp) => ({
          ...comp,
          relatedClaims: comp.relatedClaims.filter((rc) => rc.confidence >= minConfidence)
        })).filter((comp) => comp.relatedClaims.length > 0);
      }
      /**
       * Get summary statistics
       */
      getSummaryStats(comparisons) {
        const total = comparisons.length;
        const validated = comparisons.filter((c) => c.relationship === "validates").length;
        const contradicted = comparisons.filter((c) => c.relationship === "contradicts").length;
        const neutral = comparisons.filter((c) => c.relationship === "neutral").length;
        return {
          total,
          validated,
          contradicted,
          neutral,
          validationRate: total > 0 ? validated / total : 0,
          contradictionRate: total > 0 ? contradicted / total : 0
        };
      }
    };
    assumptionComparisonService = new AssumptionComparisonService();
  }
});

// server/trend-synthesis-service.ts
var TrendSynthesisService, trendSynthesisService;
var init_trend_synthesis_service = __esm({
  "server/trend-synthesis-service.ts"() {
    "use strict";
    init_ai_clients();
    TrendSynthesisService = class {
      /**
       * Generate synthesis summary from trend analysis results
       */
      async generateSynthesis(domain, pestleFactors, comparisons, telemetry) {
        const startTime = Date.now();
        const systemPrompt = `You are a strategic consultant synthesizing PESTLE trend analysis into actionable insights. Your role is to provide an executive summary that:

1. Highlights the most significant macro-environmental factors
2. Identifies strategic implications for the business
3. Provides clear, actionable recommendations
4. Flags risks and opportunities

Output must be valid JSON only. No markdown, no code blocks.

Output format:
{
  "executiveSummary": "A concise 2-3 paragraph summary of the key trends and their implications",
  "keyFindings": ["Finding 1", "Finding 2", ...],
  "strategicImplications": ["Implication 1", "Implication 2", ...],
  "recommendedActions": ["Action 1", "Action 2", ...],
  "riskAreas": ["Risk 1", "Risk 2", ...],
  "opportunities": ["Opportunity 1", "Opportunity 2", ...]
}`;
        const userMessage = this.buildSynthesisPrompt(domain, pestleFactors, comparisons);
        try {
          const response = await aiClients.callWithFallback({
            systemPrompt,
            userMessage,
            maxTokens: 3072
          });
          if (telemetry) {
            this.trackLLMCall(telemetry, response.provider);
            const elapsed = Date.now() - startTime;
            telemetry.totalLatencyMs += elapsed;
          }
          const synthesis = this.parseSynthesisResponse(response.content);
          return synthesis;
        } catch (error) {
          console.error("[TrendSynthesis] Error generating synthesis:", error);
          if (telemetry) {
            this.trackRetry(telemetry);
          }
          throw new Error("Failed to generate synthesis summary");
        }
      }
      /**
       * Build synthesis prompt from analysis results
       */
      buildSynthesisPrompt(domain, pestleFactors, comparisons) {
        let prompt = `# Business Context

`;
        if (domain.industry) {
          prompt += `Industry: ${domain.industry}
`;
        }
        if (domain.geography) {
          prompt += `Geography: ${domain.geography}
`;
        }
        if (domain.regulatory && domain.regulatory.length > 0) {
          prompt += `Regulatory Context: ${domain.regulatory.join(", ")}
`;
        }
        prompt += `
# PESTLE Trend Analysis

`;
        const allClaims = [
          { domain: "Political", claims: pestleFactors.political },
          { domain: "Economic", claims: pestleFactors.economic },
          { domain: "Social", claims: pestleFactors.social },
          { domain: "Technological", claims: pestleFactors.technological },
          { domain: "Legal", claims: pestleFactors.legal },
          { domain: "Environmental", claims: pestleFactors.environmental }
        ];
        for (const { domain: d, claims } of allClaims) {
          if (claims.length > 0) {
            prompt += `## ${d}
`;
            for (const claim of claims) {
              prompt += `- ${claim.claim} (${claim.timeHorizon})`;
              if (claim.rationale) {
                prompt += `
  Rationale: ${claim.rationale}`;
              }
              prompt += "\n";
            }
            prompt += "\n";
          }
        }
        if (comparisons.length > 0) {
          prompt += `# Assumption Validation

`;
          const validated = comparisons.filter((c) => c.relationship === "validates");
          const contradicted = comparisons.filter((c) => c.relationship === "contradicts");
          if (validated.length > 0) {
            prompt += `## Validated Assumptions (${validated.length})
`;
            for (const comp of validated.slice(0, 5)) {
              prompt += `- "${comp.assumption}"
`;
              if (comp.relatedClaims.length > 0) {
                const topClaim = comp.relatedClaims[0];
                prompt += `  Supporting Evidence: ${topClaim.evidence}
`;
              }
            }
            prompt += "\n";
          }
          if (contradicted.length > 0) {
            prompt += `## Contradicted Assumptions (${contradicted.length})
`;
            for (const comp of contradicted.slice(0, 5)) {
              prompt += `- "${comp.assumption}"
`;
              if (comp.relatedClaims.length > 0) {
                const topClaim = comp.relatedClaims[0];
                prompt += `  Contradicting Evidence: ${topClaim.evidence}
`;
              }
            }
            prompt += "\n";
          }
        }
        prompt += `
Based on this analysis, provide a strategic synthesis with:
1. Executive summary of key macro-environmental factors
2. Key findings from the PESTLE analysis
3. Strategic implications for the business
4. Recommended actions (3-5 specific, actionable items)
5. Risk areas that need attention
6. Opportunities to capitalize on

Focus on actionable insights that can inform strategic planning and decision-making.`;
        return prompt;
      }
      /**
       * Parse synthesis response
       */
      parseSynthesisResponse(text2) {
        try {
          let cleanedText = text2.trim();
          if (cleanedText.startsWith("```json")) {
            cleanedText = cleanedText.replace(/^```json\n/, "").replace(/\n```$/, "");
          } else if (cleanedText.startsWith("```")) {
            cleanedText = cleanedText.replace(/^```\n/, "").replace(/\n```$/, "");
          }
          const parsed = JSON.parse(cleanedText);
          return {
            executiveSummary: parsed.executiveSummary || "",
            keyFindings: Array.isArray(parsed.keyFindings) ? parsed.keyFindings : [],
            strategicImplications: Array.isArray(parsed.strategicImplications) ? parsed.strategicImplications : [],
            recommendedActions: Array.isArray(parsed.recommendedActions) ? parsed.recommendedActions : [],
            riskAreas: Array.isArray(parsed.riskAreas) ? parsed.riskAreas : [],
            opportunities: Array.isArray(parsed.opportunities) ? parsed.opportunities : []
          };
        } catch (error) {
          console.error("[TrendSynthesis] Error parsing synthesis:", error);
          console.error("Raw text:", text2);
          throw new Error("Failed to parse synthesis response");
        }
      }
      /**
       * Create initial telemetry object
       */
      createTelemetry() {
        return {
          totalLatencyMs: 0,
          llmCalls: 0,
          totalTokens: 0,
          cacheHits: 0,
          apiCalls: 0,
          retries: 0,
          providerUsage: {
            openai: 0,
            anthropic: 0,
            gemini: 0
          }
        };
      }
      /**
       * Track LLM call in telemetry
       */
      trackLLMCall(telemetry, provider, tokens) {
        telemetry.llmCalls++;
        if (tokens) {
          telemetry.totalTokens += tokens;
        }
        const validProviders = ["openai", "anthropic", "gemini"];
        if (validProviders.includes(provider)) {
          telemetry.providerUsage[provider]++;
        } else {
          console.warn(`[TrendSynthesis] Unknown provider: ${provider}`);
        }
      }
      /**
       * Track API call in telemetry
       */
      trackAPICall(telemetry) {
        telemetry.apiCalls++;
      }
      /**
       * Track cache hit in telemetry
       */
      trackCacheHit(telemetry) {
        telemetry.cacheHits++;
      }
      /**
       * Track retry in telemetry
       */
      trackRetry(telemetry) {
        telemetry.retries++;
      }
      /**
       * Add latency to total in telemetry (accumulates)
       */
      addLatency(telemetry, latencyMs) {
        telemetry.totalLatencyMs += latencyMs;
      }
    };
    trendSynthesisService = new TrendSynthesisService();
  }
});

// server/trend-analysis-agent.ts
var TrendAnalysisAgent, trendAnalysisAgent;
var init_trend_analysis_agent = __esm({
  "server/trend-analysis-agent.ts"() {
    "use strict";
    init_domain_extraction_service();
    init_pestle_claims_service();
    init_assumption_comparison_service();
    init_trend_synthesis_service();
    TrendAnalysisAgent = class {
      /**
       * Generate references from PESTLE claims and comparisons
       */
      generateReferences(pestleFactors, comparisons) {
        const references3 = [];
        const categories = [
          { name: "Political", claims: pestleFactors.political },
          { name: "Economic", claims: pestleFactors.economic },
          { name: "Social", claims: pestleFactors.social },
          { name: "Technological", claims: pestleFactors.technological },
          { name: "Legal", claims: pestleFactors.legal },
          { name: "Environmental", claims: pestleFactors.environmental }
        ];
        categories.forEach(({ name, claims }) => {
          claims.forEach((claimObj) => {
            references3.push({
              title: `PESTLE Trend: ${name} - ${claimObj.claim.substring(0, 60)}...`,
              sourceType: "internal_doc",
              description: claimObj.claim,
              topics: ["pestle trends", name.toLowerCase(), claimObj.timeHorizon],
              confidence: 0.7,
              // Default confidence for LLM-generated claims
              snippet: `${claimObj.claim} (${claimObj.timeHorizon})`,
              origin: "llm_generation"
            });
          });
        });
        comparisons.forEach((comp) => {
          if (comp.relationship !== "neutral") {
            const avgConfidence = comp.relatedClaims.length > 0 ? comp.relatedClaims.reduce((sum, rc) => sum + rc.confidence, 0) / comp.relatedClaims.length : 0.5;
            references3.push({
              title: `Assumption ${comp.relationship}: ${comp.assumption.substring(0, 50)}...`,
              sourceType: "internal_doc",
              description: comp.assumption,
              topics: ["assumption validation", comp.relationship],
              confidence: avgConfidence,
              snippet: `${comp.assumption} (${comp.relatedClaims.length} related claims)`,
              origin: "llm_generation"
            });
          }
        });
        return references3;
      }
      /**
       * Analyze trends for a strategic understanding
       */
      async analyzeTrends(understandingId) {
        const startTime = Date.now();
        const telemetry = trendSynthesisService.createTelemetry();
        console.log(`[TrendAnalysis] Starting analysis for understanding ${understandingId}`);
        try {
          console.log("[TrendAnalysis] Phase 1: Extracting domain context...");
          const phase1Start = Date.now();
          const domain = await domainExtractionService.extractDomain(understandingId);
          trendSynthesisService.addLatency(telemetry, Date.now() - phase1Start);
          console.log("[TrendAnalysis] Domain extracted:", {
            industry: domain.industry,
            geography: domain.geography,
            language: domain.language,
            assumptionCount: domain.assumptions.length
          });
          console.log("[TrendAnalysis] Phase 2: Generating PESTLE claims...");
          const phase2Start = Date.now();
          const { claims: pestleFactors, provider: pestleProvider } = await pestleClaimsService.generateClaims(domain);
          const phase2Elapsed = Date.now() - phase2Start;
          trendSynthesisService.addLatency(telemetry, phase2Elapsed);
          trendSynthesisService.trackLLMCall(telemetry, pestleProvider);
          const totalClaims = this.countClaims(pestleFactors);
          console.log(`[TrendAnalysis] Generated ${totalClaims} PESTLE claims`);
          console.log("[TrendAnalysis] Phase 3: Comparing with assumptions...");
          const phase3Start = Date.now();
          const flatClaims = pestleClaimsService.flattenClaims(pestleFactors);
          const { comparisons, providers: comparisonProviders } = await assumptionComparisonService.compareWithAssumptions(
            understandingId,
            flatClaims
          );
          const phase3Elapsed = Date.now() - phase3Start;
          trendSynthesisService.addLatency(telemetry, phase3Elapsed);
          for (const provider of comparisonProviders) {
            if (provider !== "unknown") {
              trendSynthesisService.trackLLMCall(telemetry, provider);
            }
          }
          const significantComparisons = assumptionComparisonService.filterSignificantComparisons(
            comparisons,
            0.6
            // 60% confidence threshold
          );
          const stats = assumptionComparisonService.getSummaryStats(significantComparisons);
          console.log("[TrendAnalysis] Comparison stats:", stats);
          console.log("[TrendAnalysis] Phase 4: Generating synthesis...");
          const synthesis = await trendSynthesisService.generateSynthesis(
            domain,
            pestleFactors,
            significantComparisons,
            telemetry
          );
          console.log(`[TrendAnalysis] Analysis complete in ${telemetry.totalLatencyMs}ms`);
          console.log("[TrendAnalysis] Telemetry:", telemetry);
          const references3 = this.generateReferences(pestleFactors, significantComparisons);
          console.log(`[TrendAnalysis] Generated ${references3.length} references`);
          return {
            understandingId,
            pestleFactors,
            comparisons: significantComparisons,
            synthesis,
            references: references3,
            telemetry,
            completedAt: /* @__PURE__ */ new Date()
          };
        } catch (error) {
          console.error("[TrendAnalysis] Error during analysis:", error);
          trendSynthesisService.trackRetry(telemetry);
          throw error;
        }
      }
      /**
       * Count total claims across all PESTLE domains
       */
      countClaims(pestleFactors) {
        return pestleFactors.political.length + pestleFactors.economic.length + pestleFactors.social.length + pestleFactors.technological.length + pestleFactors.legal.length + pestleFactors.environmental.length;
      }
      /**
       * Get analysis status summary
       */
      getStatusSummary(result) {
        const claimCount = this.countClaims(result.pestleFactors);
        const assumptionCount = result.comparisons.length;
        const stats = assumptionComparisonService.getSummaryStats(result.comparisons);
        return {
          claimCount,
          assumptionCount,
          validatedAssumptions: stats.validated,
          contradictedAssumptions: stats.contradicted,
          neutralAssumptions: stats.neutral,
          validationRate: stats.validationRate,
          contradictionRate: stats.contradictionRate,
          keyFindings: result.synthesis.keyFindings.length,
          recommendedActions: result.synthesis.recommendedActions.length,
          telemetry: result.telemetry
        };
      }
    };
    trendAnalysisAgent = new TrendAnalysisAgent();
  }
});

// server/trend-job-queue-service.ts
import { eq as eq21, and as and15 } from "drizzle-orm";
var TrendJobQueueService;
var init_trend_job_queue_service = __esm({
  "server/trend-job-queue-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    TrendJobQueueService = class {
      /**
       * Create or retrieve existing job (idempotent)
       * Returns existing job if idempotency key matches
       * Handles concurrent calls safely by catching unique violations
       */
      async createJob(understandingId, idempotencyKey, data) {
        try {
          const [job] = await db.insert(trendAnalysisJobs).values({
            idempotencyKey,
            understandingId,
            status: "pending",
            data: data || null
          }).returning();
          console.log("[TrendJobQueue] Created new job:", job.jobId);
          return job;
        } catch (error) {
          if (error.code === "23505" || error.message?.includes("unique")) {
            console.log("[TrendJobQueue] Unique violation, fetching existing job");
            const existing = await db.select().from(trendAnalysisJobs).where(eq21(trendAnalysisJobs.idempotencyKey, idempotencyKey)).limit(1);
            if (existing.length > 0) {
              console.log("[TrendJobQueue] Found existing job:", existing[0].jobId);
              return existing[0];
            }
          }
          throw error;
        }
      }
      /**
       * Get job by ID
       */
      async getJob(jobId) {
        const [job] = await db.select().from(trendAnalysisJobs).where(eq21(trendAnalysisJobs.jobId, jobId)).limit(1);
        return job ? job : null;
      }
      /**
       * Get job by idempotency key
       */
      async getJobByIdempotencyKey(idempotencyKey) {
        const [job] = await db.select().from(trendAnalysisJobs).where(eq21(trendAnalysisJobs.idempotencyKey, idempotencyKey)).limit(1);
        return job ? job : null;
      }
      /**
       * Update job status to running
       */
      async markAsRunning(jobId) {
        await db.update(trendAnalysisJobs).set({
          status: "running",
          startedAt: /* @__PURE__ */ new Date()
        }).where(eq21(trendAnalysisJobs.jobId, jobId));
        console.log("[TrendJobQueue] Marked job as running:", jobId);
      }
      /**
       * Update job status to completed with result
       */
      async markAsCompleted(jobId, result) {
        await db.update(trendAnalysisJobs).set({
          status: "completed",
          result,
          completedAt: /* @__PURE__ */ new Date()
        }).where(eq21(trendAnalysisJobs.jobId, jobId));
        console.log("[TrendJobQueue] Marked job as completed:", jobId);
      }
      /**
       * Update job status to failed with error
       */
      async markAsFailed(jobId, error) {
        await db.update(trendAnalysisJobs).set({
          status: "failed",
          error,
          completedAt: /* @__PURE__ */ new Date()
        }).where(eq21(trendAnalysisJobs.jobId, jobId));
        console.log("[TrendJobQueue] Marked job as failed:", jobId);
      }
      /**
       * Get all jobs for an understanding
       */
      async getJobsForUnderstanding(understandingId) {
        const jobs = await db.select().from(trendAnalysisJobs).where(eq21(trendAnalysisJobs.understandingId, understandingId));
        return jobs;
      }
      /**
       * Check if there's already a completed job for an understanding
       */
      async hasCompletedJob(understandingId) {
        const [job] = await db.select().from(trendAnalysisJobs).where(
          and15(
            eq21(trendAnalysisJobs.understandingId, understandingId),
            eq21(trendAnalysisJobs.status, "completed")
          )
        ).limit(1);
        return !!job;
      }
    };
  }
});

// server/routes/trend-analysis.ts
import { Router as Router4 } from "express";
import { eq as eq22, and as and16, desc as desc11 } from "drizzle-orm";
var router4, trendAgent, jobQueue, trend_analysis_default;
var init_trend_analysis = __esm({
  "server/routes/trend-analysis.ts"() {
    "use strict";
    init_trend_analysis_agent();
    init_trend_job_queue_service();
    init_db();
    init_schema();
    router4 = Router4();
    trendAgent = new TrendAnalysisAgent();
    jobQueue = new TrendJobQueueService();
    router4.post("/:understandingId", async (req, res) => {
      const { understandingId } = req.params;
      const { versionNumber, sessionId } = req.body;
      if (!understandingId) {
        return res.status(400).json({ error: "understandingId is required" });
      }
      const idempotencyKey = `trend-${understandingId}-${versionNumber || "latest"}`;
      try {
        const job = await jobQueue.createJob(understandingId, idempotencyKey, {
          versionNumber,
          sessionId
        });
        if (job.status === "completed") {
          return res.json({
            success: true,
            cached: true,
            result: job.result
          });
        }
        if (job.status === "running") {
          return res.json({
            success: true,
            jobId: job.jobId,
            status: "running",
            message: "Analysis is already in progress"
          });
        }
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        console.log("[TrendAnalysis] Starting analysis with SSE streaming:", job.jobId);
        await jobQueue.markAsRunning(job.jobId);
        res.write(
          `data: ${JSON.stringify({
            type: "progress",
            message: "\u{1F50D} Extracting domain context from strategic understanding...",
            phase: "domain_extraction",
            step: 1,
            totalSteps: 4
          })}

`
        );
        await new Promise((resolve) => setTimeout(resolve, 500));
        res.write(
          `data: ${JSON.stringify({
            type: "progress",
            message: "\u{1F30D} Analyzing PESTLE factors across geographies...",
            phase: "pestle_generation",
            step: 2,
            totalSteps: 4
          })}

`
        );
        await new Promise((resolve) => setTimeout(resolve, 1e3));
        res.write(
          `data: ${JSON.stringify({
            type: "progress",
            message: "\u{1F517} Comparing trends with your strategic assumptions...",
            phase: "assumption_comparison",
            step: 3,
            totalSteps: 4
          })}

`
        );
        const result = await trendAgent.analyzeTrends(understandingId);
        if (result.references && result.references.length > 0) {
          try {
            const { referenceService: referenceService2 } = await Promise.resolve().then(() => (init_reference_service(), reference_service_exports));
            console.log(`[TrendAnalysis] Persisting ${result.references.length} references to knowledge graph...`);
            const userId = req.user?.claims?.sub || "system";
            const normalized = result.references.map(
              (ref, idx) => referenceService2.normalizeReference(
                ref,
                userId,
                { component: "pestle_trends", claim: ref.description },
                { understandingId, sessionId }
              )
            );
            await referenceService2.persistReferences(normalized, {
              understandingId,
              sessionId
            });
            console.log(`[TrendAnalysis] \u2713 Persisted ${normalized.length} references and updated metadata cache`);
          } catch (error) {
            console.error("[TrendAnalysis] Failed to persist references:", error);
          }
        }
        res.write(
          `data: ${JSON.stringify({
            type: "progress",
            message: "\u{1F4CA} Synthesizing insights and recommendations...",
            phase: "synthesis",
            step: 4,
            totalSteps: 4
          })}

`
        );
        await new Promise((resolve) => setTimeout(resolve, 500));
        const [insight] = await db.insert(frameworkInsights).values({
          understandingId,
          frameworkName: "PESTLE",
          frameworkVersion: "1.0",
          insights: {
            pestleFactors: result.pestleFactors,
            comparisons: result.comparisons,
            synthesis: result.synthesis
          },
          telemetry: result.telemetry
        }).returning();
        console.log("[TrendAnalysis] Stored in framework_insights:", insight.id);
        if (sessionId && versionNumber) {
          const [version] = await db.select().from(strategyVersions).where(
            and16(
              eq22(strategyVersions.sessionId, sessionId),
              eq22(strategyVersions.versionNumber, versionNumber)
            )
          ).limit(1);
          if (version) {
            await db.update(strategyVersions).set({
              analysisData: {
                ...version.analysisData || {},
                trendAnalysis: {
                  pestleFactors: result.pestleFactors,
                  comparisons: result.comparisons,
                  synthesis: result.synthesis,
                  telemetry: result.telemetry
                }
              }
            }).where(eq22(strategyVersions.id, version.id));
            console.log("[TrendAnalysis] Updated strategyVersions:", version.id);
          }
        }
        await jobQueue.markAsCompleted(job.jobId, {
          insightId: insight.id,
          ...result
        });
        res.write(
          `data: ${JSON.stringify({
            type: "complete",
            message: "\u2705 Trend analysis complete!",
            result: {
              insightId: insight.id,
              summary: result.synthesis.executiveSummary,
              telemetry: result.telemetry
            }
          })}

`
        );
        res.end();
      } catch (error) {
        console.error("[TrendAnalysis] Error:", error);
        try {
          const job = await jobQueue.getJobByIdempotencyKey(idempotencyKey);
          if (job) {
            await jobQueue.markAsFailed(job.jobId, error.message);
          }
        } catch (jobError) {
          console.error("[TrendAnalysis] Failed to mark job as failed:", jobError);
        }
        if (!res.headersSent) {
          res.status(500).json({ error: error.message || "Trend analysis failed" });
        } else {
          res.write(
            `data: ${JSON.stringify({
              type: "error",
              message: error.message || "Trend analysis failed"
            })}

`
          );
          res.end();
        }
      }
    });
    router4.get("/:understandingId/status", async (req, res) => {
      const { understandingId } = req.params;
      const { versionNumber } = req.query;
      const idempotencyKey = `trend-${understandingId}-${versionNumber || "latest"}`;
      try {
        const job = await jobQueue.getJobByIdempotencyKey(idempotencyKey);
        if (!job) {
          return res.status(404).json({ error: "No analysis found" });
        }
        res.json({
          jobId: job.jobId,
          status: job.status,
          result: job.result,
          error: job.error,
          createdAt: job.createdAt,
          completedAt: job.completedAt
        });
      } catch (error) {
        console.error("[TrendAnalysis] Status check error:", error);
        res.status(500).json({ error: error.message || "Failed to check status" });
      }
    });
    router4.get("/:understandingId/latest", async (req, res) => {
      const { understandingId } = req.params;
      try {
        const [insight] = await db.select().from(frameworkInsights).where(
          and16(
            eq22(frameworkInsights.understandingId, understandingId),
            eq22(frameworkInsights.frameworkName, "PESTLE")
          )
        ).orderBy(desc11(frameworkInsights.createdAt)).limit(1);
        if (!insight) {
          return res.status(404).json({ error: "No trend analysis found" });
        }
        res.json({
          id: insight.id,
          data: insight.insights,
          telemetry: insight.telemetry,
          createdAt: insight.createdAt
        });
      } catch (error) {
        console.error("[TrendAnalysis] Latest fetch error:", error);
        res.status(500).json({ error: error.message || "Failed to fetch latest analysis" });
      }
    });
    trend_analysis_default = router4;
  }
});

// server/routes/statement-repository.routes.ts
import { Router as Router5 } from "express";
import { eq as eq23, desc as desc12, sql as sql9, inArray as inArray5, and as and17 } from "drizzle-orm";
var router5, statement_repository_routes_default;
var init_statement_repository_routes = __esm({
  "server/routes/statement-repository.routes.ts"() {
    "use strict";
    init_db();
    init_storage();
    init_schema();
    init_secure_data_service();
    init_kms_encryption();
    init_whys_path();
    router5 = Router5();
    router5.get("/statements", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const rawStatements = await db.selectDistinct({
          understandingId: strategicUnderstanding.id,
          sessionId: strategicUnderstanding.sessionId,
          statement: strategicUnderstanding.userInput,
          title: strategicUnderstanding.title,
          createdAt: strategicUnderstanding.createdAt
        }).from(strategicUnderstanding).innerJoin(journeySessions, eq23(strategicUnderstanding.id, journeySessions.understandingId)).where(and17(
          eq23(journeySessions.userId, userId),
          eq23(strategicUnderstanding.archived, false)
        )).orderBy(desc12(strategicUnderstanding.createdAt));
        const statements = await Promise.all(
          rawStatements.map(async (stmt) => ({
            ...stmt,
            statement: await decryptKMS(stmt.statement) || stmt.statement
          }))
        );
        const enrichedStatements = await Promise.all(
          statements.map(async (stmt) => {
            const oldAnalyses = await db.select({
              frameworkName: frameworkInsights.frameworkName,
              frameworkVersion: frameworkInsights.frameworkVersion,
              createdAt: frameworkInsights.createdAt
            }).from(frameworkInsights).where(eq23(frameworkInsights.understandingId, stmt.understandingId)).orderBy(desc12(frameworkInsights.createdAt));
            const newAnalyses = await storage.getStrategyVersionsBySession(stmt.sessionId);
            const analysisSummary = {};
            let latestActivity = stmt.createdAt || /* @__PURE__ */ new Date();
            oldAnalyses.forEach((analysis) => {
              const framework = analysis.frameworkName;
              if (!analysisSummary[framework]) {
                analysisSummary[framework] = {
                  count: 0,
                  latestVersion: analysis.frameworkVersion || "1.0"
                };
              }
              analysisSummary[framework].count++;
              if (analysis.createdAt && analysis.createdAt > latestActivity) {
                latestActivity = analysis.createdAt;
              }
            });
            newAnalyses.forEach((version) => {
              const data = version.analysisData;
              if (data?.bmc_research) {
                const framework = "Business Model Canvas";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const fiveWhysData = data?.five_whys || (data?.rootCause && data?.framework === "five_whys" ? data : null);
              if (fiveWhysData && (fiveWhysData.rootCause || fiveWhysData.whysPath)) {
                const framework = "Five Whys";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const portersData = data?.porters_five_forces || data?.porters;
              if (portersData) {
                const framework = "Porter's Five Forces";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const swotData = data?.swot?.data?.output || data?.swot?.output || data?.swot;
              if (swotData?.strengths || swotData?.weaknesses || swotData?.opportunities || swotData?.threats) {
                const framework = "SWOT";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const pestleData = data?.pestle?.data?.pestleResults || data?.pestle?.pestleResults || data?.pestle;
              if (pestleData?.political || pestleData?.economic || pestleData?.social || pestleData?.technological || pestleData?.legal || pestleData?.environmental) {
                const framework = "PESTLE";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const ansoffData = data?.ansoff?.output || data?.ansoff;
              if (ansoffData?.marketPenetration || ansoffData?.marketDevelopment || ansoffData?.productDevelopment || ansoffData?.diversification) {
                const framework = "Ansoff Matrix";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const blueOceanData = data?.blue_ocean?.output || data?.blue_ocean || data?.ocean_strategy?.output || data?.ocean_strategy;
              if (blueOceanData?.eliminateFactors || blueOceanData?.reduceFactors || blueOceanData?.raiseFactors || blueOceanData?.createFactors || blueOceanData?.strategyCanvas) {
                const framework = "Blue Ocean";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const vrioData = data?.vrio?.output || data?.vrio;
              if (vrioData?.resources || vrioData?.capabilities || vrioData?.analysis) {
                const framework = "VRIO";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const bcgData = data?.bcg?.output || data?.bcg || data?.bcg_matrix;
              if (bcgData?.stars || bcgData?.cashCows || bcgData?.questionMarks || bcgData?.dogs || bcgData?.products || bcgData?.portfolio) {
                const framework = "BCG Matrix";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const valueChainData = data?.value_chain?.output || data?.value_chain || data?.valueChain;
              if (valueChainData?.primaryActivities || valueChainData?.supportActivities || valueChainData?.inboundLogistics || valueChainData?.operations) {
                const framework = "Value Chain";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const oceanStrategyData = data?.ocean_strategy?.output || data?.ocean_strategy;
              if (oceanStrategyData?.strategicMoves || oceanStrategyData?.valueInnovation || oceanStrategyData?.marketCreation) {
                const framework = "Ocean Strategy";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const jtbdData = data?.jtbd?.output || data?.jtbd || data?.jobs_to_be_done;
              if (jtbdData?.jobs || jtbdData?.outcomes || jtbdData?.customerJobs) {
                const framework = "Jobs to Be Done";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const compPosData = data?.competitive_positioning?.output || data?.competitive_positioning;
              if (compPosData?.positioning || compPosData?.competitors || compPosData?.differentiators) {
                const framework = "Competitive Positioning";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const scenarioData = data?.scenario_planning?.output || data?.scenario_planning;
              if (scenarioData?.scenarios || scenarioData?.drivers || scenarioData?.implications) {
                const framework = "Scenario Planning";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const okrData = data?.okr_generator?.output || data?.okr_generator || data?.okr;
              if (okrData?.objectives || okrData?.keyResults || okrData?.okrs) {
                const framework = "OKR";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
              const selectedDecisions = version.selectedDecisions;
              if (selectedDecisions && typeof selectedDecisions === "object" && Object.keys(selectedDecisions).length > 0) {
                const framework = "Strategic Decisions";
                if (!analysisSummary[framework]) {
                  analysisSummary[framework] = { count: 0, latestVersion: `v${version.versionNumber}` };
                }
                analysisSummary[framework].count++;
                if (version.createdAt && version.createdAt > latestActivity) {
                  latestActivity = version.createdAt;
                }
              }
            });
            const totalAnalyses = oldAnalyses.length + newAnalyses.length;
            return {
              understandingId: stmt.understandingId,
              sessionId: stmt.sessionId,
              statement: stmt.statement,
              title: stmt.title,
              createdAt: stmt.createdAt,
              analyses: analysisSummary,
              totalAnalyses,
              lastActivity: latestActivity
            };
          })
        );
        res.json(enrichedStatements);
      } catch (error) {
        console.error("Error fetching statements:", error);
        res.status(500).json({ error: "Failed to fetch statements" });
      }
    });
    router5.delete("/statements/:understandingId", async (req, res) => {
      try {
        const { understandingId } = req.params;
        const [understanding] = await db.select().from(strategicUnderstanding).where(eq23(strategicUnderstanding.id, understandingId));
        if (!understanding) {
          return res.status(404).json({ error: "Statement not found" });
        }
        await db.delete(frameworkInsights).where(eq23(frameworkInsights.understandingId, understandingId));
        await db.delete(strategicEntities).where(eq23(strategicEntities.understandingId, understandingId));
        await db.delete(strategicUnderstanding).where(eq23(strategicUnderstanding.id, understandingId));
        res.json({ success: true, message: "Statement and all analyses deleted successfully" });
      } catch (error) {
        console.error("Error deleting statement:", error);
        res.status(500).json({ error: "Failed to delete statement" });
      }
    });
    router5.delete("/analyses/:analysisId", async (req, res) => {
      try {
        const { analysisId } = req.params;
        const [analysis] = await db.select().from(frameworkInsights).where(eq23(frameworkInsights.id, analysisId));
        if (!analysis) {
          return res.status(404).json({ error: "Analysis not found" });
        }
        await db.delete(frameworkInsights).where(eq23(frameworkInsights.id, analysisId));
        res.json({ success: true, message: "Analysis deleted successfully" });
      } catch (error) {
        console.error("Error deleting analysis:", error);
        res.status(500).json({ error: "Failed to delete analysis" });
      }
    });
    router5.get("/statements/:understandingId", async (req, res) => {
      try {
        const { understandingId } = req.params;
        const understanding = await getStrategicUnderstanding(understandingId);
        if (!understanding) {
          return res.status(404).json({ error: "Statement not found" });
        }
        const oldAnalyses = await db.select({
          id: frameworkInsights.id,
          frameworkName: frameworkInsights.frameworkName,
          frameworkVersion: frameworkInsights.frameworkVersion,
          insights: frameworkInsights.insights,
          telemetry: frameworkInsights.telemetry,
          createdAt: frameworkInsights.createdAt
        }).from(frameworkInsights).where(eq23(frameworkInsights.understandingId, understandingId)).orderBy(desc12(frameworkInsights.createdAt));
        const newAnalyses = await storage.getStrategyVersionsBySession(understanding.sessionId);
        const groupedAnalyses = {};
        oldAnalyses.forEach((analysis) => {
          const framework = analysis.frameworkName;
          if (!groupedAnalyses[framework]) {
            groupedAnalyses[framework] = [];
          }
          let summary = "";
          let keyFindings = [];
          if (framework === "PESTLE" && analysis.insights) {
            const insights = analysis.insights;
            if (insights.synthesis?.executiveSummary) {
              summary = insights.synthesis.executiveSummary.substring(0, 200) + "...";
            }
            if (insights.synthesis?.keyFindings) {
              keyFindings = insights.synthesis.keyFindings.slice(0, 3);
            }
          }
          groupedAnalyses[framework].push({
            id: analysis.id,
            frameworkName: analysis.frameworkName,
            version: analysis.frameworkVersion || "1.0",
            createdAt: analysis.createdAt,
            duration: analysis.telemetry?.totalLatencyMs,
            summary,
            keyFindings
          });
        });
        newAnalyses.forEach((version) => {
          const analysisData = version.analysisData;
          if (analysisData?.bmc_research) {
            const bmcData = analysisData.bmc_research;
            const framework = "Business Model Canvas";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            let keyFindings = [];
            if (bmcData.blocks && Array.isArray(bmcData.blocks)) {
              const allImplications = bmcData.blocks.map((block) => block.strategicImplications).filter(Boolean);
              if (allImplications.length > 0) {
                summary = allImplications.slice(0, 2).join(" ").substring(0, 200) + "...";
                keyFindings = allImplications.slice(0, 3);
              }
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const fiveWhysData = analysisData?.five_whys || (analysisData?.rootCause && analysisData?.framework === "five_whys" ? analysisData : null);
          if (fiveWhysData && (fiveWhysData.rootCause || fiveWhysData.whysPath)) {
            const framework = "Five Whys";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            const rootCause = fiveWhysData.rootCause || "";
            const summary = rootCause.substring(0, 200) + (rootCause.length > 200 ? "..." : "");
            const keyFindings = [];
            if (fiveWhysData.whysPath && Array.isArray(fiveWhysData.whysPath)) {
              keyFindings.push(...whysPathToText(fiveWhysData.whysPath).slice(0, 3));
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const portersData = analysisData?.porters_five_forces || analysisData?.porters;
          if (portersData) {
            const framework = "Porter's Five Forces";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            let keyFindings = [];
            const forces = portersData.forces || portersData.data?.forces;
            if (forces && Array.isArray(forces)) {
              const allImplications = forces.map((force) => force.strategicImplication || force.analysis).filter(Boolean);
              if (allImplications.length > 0) {
                summary = allImplications.slice(0, 2).join(" ").substring(0, 200) + "...";
                keyFindings = allImplications.slice(0, 3);
              }
            }
            if (!summary && portersData.overallAttractiveness?.summary) {
              summary = portersData.overallAttractiveness.summary.substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const swotData = analysisData?.swot?.data?.output || analysisData?.swot?.output || analysisData?.swot;
          if (swotData?.strengths || swotData?.weaknesses || swotData?.opportunities || swotData?.threats) {
            const framework = "SWOT";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            if (swotData.strengths && Array.isArray(swotData.strengths)) {
              const topStrength = swotData.strengths[0];
              if (topStrength?.name) keyFindings.push(`Strength: ${topStrength.name}`);
            }
            if (swotData.opportunities && Array.isArray(swotData.opportunities)) {
              const topOpp = swotData.opportunities[0];
              if (topOpp?.name) keyFindings.push(`Opportunity: ${topOpp.name}`);
            }
            if (swotData.threats && Array.isArray(swotData.threats)) {
              const topThreat = swotData.threats[0];
              if (topThreat?.name) keyFindings.push(`Threat: ${topThreat.name}`);
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.join("; ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const pestleData = analysisData?.pestle?.data?.pestleResults || analysisData?.pestle?.pestleResults || analysisData?.pestle;
          if (pestleData?.political || pestleData?.economic || pestleData?.social || pestleData?.technological || pestleData?.legal || pestleData?.environmental) {
            const framework = "PESTLE";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            const factors = ["political", "economic", "social", "technological", "legal", "environmental"];
            for (const factor of factors) {
              const factorData = pestleData[factor];
              if (factorData?.trends && Array.isArray(factorData.trends) && factorData.trends.length > 0) {
                const trend = factorData.trends[0];
                if (trend?.description) {
                  keyFindings.push(`${factor.charAt(0).toUpperCase() + factor.slice(1)}: ${trend.description.substring(0, 50)}`);
                }
              }
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.slice(0, 2).join("; ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings: keyFindings.slice(0, 3)
            });
          }
          const ansoffData = analysisData?.ansoff?.output || analysisData?.ansoff;
          if (ansoffData?.marketPenetration || ansoffData?.marketDevelopment || ansoffData?.productDevelopment || ansoffData?.diversification) {
            const framework = "Ansoff Matrix";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            if (ansoffData.recommendation?.primaryStrategy) {
              summary = `Recommended: ${ansoffData.recommendation.primaryStrategy}`;
              keyFindings.push(summary);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const blueOceanData = analysisData?.blue_ocean?.output || analysisData?.blue_ocean || analysisData?.ocean_strategy?.output || analysisData?.ocean_strategy;
          if (blueOceanData?.eliminateFactors || blueOceanData?.reduceFactors || blueOceanData?.raiseFactors || blueOceanData?.createFactors || blueOceanData?.strategyCanvas || blueOceanData?.strategicMoves) {
            const framework = "Blue Ocean";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            if (blueOceanData.createFactors?.length) {
              keyFindings.push(`Create: ${blueOceanData.createFactors[0]?.factor || blueOceanData.createFactors[0]}`);
            }
            if (blueOceanData.eliminateFactors?.length) {
              keyFindings.push(`Eliminate: ${blueOceanData.eliminateFactors[0]?.factor || blueOceanData.eliminateFactors[0]}`);
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.join("; ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const vrioData = analysisData?.vrio?.output || analysisData?.vrio;
          if (vrioData?.resources || vrioData?.capabilities || vrioData?.analysis) {
            const framework = "VRIO";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            const resources2 = vrioData.resources || vrioData.analysis || [];
            if (Array.isArray(resources2) && resources2.length > 0) {
              const sustained = resources2.filter((r) => r.sustainedAdvantage || r.competitiveAdvantage === "sustained");
              if (sustained.length > 0) {
                keyFindings.push(`Sustained advantages: ${sustained.length}`);
              }
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.join("; ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const bcgData = analysisData?.bcg_matrix?.output || analysisData?.bcg_matrix || analysisData?.bcg;
          if (bcgData?.stars || bcgData?.cashCows || bcgData?.questionMarks || bcgData?.dogs || bcgData?.products || bcgData?.portfolio) {
            const framework = "BCG Matrix";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            if (bcgData.stars?.length) keyFindings.push(`Stars: ${bcgData.stars.length}`);
            if (bcgData.cashCows?.length) keyFindings.push(`Cash Cows: ${bcgData.cashCows.length}`);
            if (keyFindings.length > 0) {
              summary = keyFindings.join(", ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const valueChainData = analysisData?.value_chain?.output || analysisData?.value_chain || analysisData?.valueChain;
          if (valueChainData?.primaryActivities || valueChainData?.supportActivities || valueChainData?.inboundLogistics || valueChainData?.operations) {
            const framework = "Value Chain";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            if (valueChainData.primaryActivities?.length) {
              keyFindings.push(`Primary activities: ${valueChainData.primaryActivities.length}`);
            }
            if (valueChainData.supportActivities?.length) {
              keyFindings.push(`Support activities: ${valueChainData.supportActivities.length}`);
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.join(", ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const jtbdData = analysisData?.jtbd?.output || analysisData?.jtbd || analysisData?.jobs_to_be_done;
          if (jtbdData?.jobs || jtbdData?.outcomes || jtbdData?.customerJobs) {
            const framework = "Jobs to Be Done";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            const jobs = jtbdData.jobs || jtbdData.customerJobs || [];
            if (Array.isArray(jobs) && jobs.length > 0) {
              keyFindings.push(`Jobs identified: ${jobs.length}`);
              if (jobs[0]?.job || jobs[0]?.description) {
                keyFindings.push(jobs[0].job || jobs[0].description);
              }
            }
            if (keyFindings.length > 0) {
              summary = keyFindings[0].substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const compPosData = analysisData?.competitive_positioning?.output || analysisData?.competitive_positioning;
          if (compPosData?.positioning || compPosData?.competitors || compPosData?.differentiators) {
            const framework = "Competitive Positioning";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            if (compPosData.positioning) {
              keyFindings.push(`Position: ${compPosData.positioning}`);
            }
            if (compPosData.differentiators?.length) {
              keyFindings.push(`Differentiators: ${compPosData.differentiators.length}`);
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.join("; ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const scenarioData = analysisData?.scenario_planning?.output || analysisData?.scenario_planning;
          if (scenarioData?.scenarios || scenarioData?.drivers || scenarioData?.implications) {
            const framework = "Scenario Planning";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            if (scenarioData.scenarios?.length) {
              keyFindings.push(`Scenarios: ${scenarioData.scenarios.length}`);
            }
            if (scenarioData.drivers?.length) {
              keyFindings.push(`Key drivers: ${scenarioData.drivers.length}`);
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.join(", ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const okrData = analysisData?.okr_generator?.output || analysisData?.okr_generator || analysisData?.okr;
          if (okrData?.objectives || okrData?.keyResults || okrData?.okrs) {
            const framework = "OKR";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            let summary = "";
            const keyFindings = [];
            const objectives = okrData.objectives || okrData.okrs || [];
            if (Array.isArray(objectives) && objectives.length > 0) {
              keyFindings.push(`Objectives: ${objectives.length}`);
            }
            if (keyFindings.length > 0) {
              summary = keyFindings.join(", ").substring(0, 200);
            }
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
          const selectedDecisions = version.selectedDecisions;
          if (selectedDecisions && typeof selectedDecisions === "object" && Object.keys(selectedDecisions).length > 0) {
            const framework = "Strategic Decisions";
            if (!groupedAnalyses[framework]) {
              groupedAnalyses[framework] = [];
            }
            const decisionCount = Object.keys(selectedDecisions).length;
            const summary = `${decisionCount} strategic decision${decisionCount !== 1 ? "s" : ""} made`;
            const keyFindings = Object.entries(selectedDecisions).slice(0, 3).map(
              ([key, value]) => `${key}: ${value}`.substring(0, 100)
            );
            groupedAnalyses[framework].push({
              id: version.id,
              frameworkName: framework,
              version: `v${version.versionNumber}`,
              versionNumber: version.versionNumber,
              createdAt: version.createdAt,
              summary,
              keyFindings
            });
          }
        });
        res.json({
          understandingId: understanding.id,
          sessionId: understanding.sessionId,
          statement: understanding.userInput,
          title: understanding.title,
          companyContext: understanding.companyContext,
          createdAt: understanding.createdAt,
          analyses: groupedAnalyses
        });
      } catch (error) {
        console.error("Error fetching statement detail:", error);
        res.status(500).json({ error: "Failed to fetch statement detail" });
      }
    });
    router5.get("/:id/deletion-preview", async (req, res) => {
      try {
        const understandingId = req.params.id;
        const [understanding] = await db.select({ sessionId: strategicUnderstanding.sessionId }).from(strategicUnderstanding).where(eq23(strategicUnderstanding.id, understandingId));
        if (!understanding) {
          return res.status(404).json({ error: "Analysis not found" });
        }
        const sessionId = understanding.sessionId;
        const [journeyCount] = await db.select({ count: sql9`COUNT(*)` }).from(journeySessions).where(eq23(journeySessions.understandingId, understandingId));
        const [versionCount] = sessionId ? await db.select({ count: sql9`COUNT(*)` }).from(strategyVersions).where(eq23(strategyVersions.sessionId, sessionId)) : [{ count: 0 }];
        const [epmCount] = sessionId ? await db.select({ count: sql9`COUNT(DISTINCT ${epmPrograms.id})` }).from(epmPrograms).innerJoin(strategyVersions, eq23(epmPrograms.strategyVersionId, strategyVersions.id)).where(eq23(strategyVersions.sessionId, sessionId)) : [{ count: 0 }];
        const [refCount] = await db.select({ count: sql9`COUNT(*)` }).from(references).where(eq23(references.understandingId, understandingId));
        res.json({
          journeys: journeyCount?.count || 0,
          versions: versionCount?.count || 0,
          epmPrograms: epmCount?.count || 0,
          references: refCount?.count || 0
        });
      } catch (error) {
        console.error("Error fetching deletion preview:", error);
        res.status(500).json({ error: "Failed to fetch deletion preview" });
      }
    });
    router5.post("/batch-delete", async (req, res) => {
      try {
        const { ids } = req.body;
        if (!ids || !Array.isArray(ids) || ids.length === 0) {
          return res.status(400).json({ error: "Invalid request: ids array is required" });
        }
        const understandings = await db.select({ sessionId: strategicUnderstanding.sessionId }).from(strategicUnderstanding).where(inArray5(strategicUnderstanding.id, ids));
        const sessionIds = understandings.map((u) => u.sessionId).filter((id) => id !== null);
        await db.delete(journeySessions).where(inArray5(journeySessions.understandingId, ids));
        await db.delete(references).where(inArray5(references.understandingId, ids));
        await db.delete(frameworkInsights).where(inArray5(frameworkInsights.understandingId, ids));
        await db.delete(strategicEntities).where(inArray5(strategicEntities.understandingId, ids));
        if (sessionIds.length > 0) {
          const versions = await db.select({ id: strategyVersions.id }).from(strategyVersions).where(inArray5(strategyVersions.sessionId, sessionIds));
          const versionIds = versions.map((v) => v.id);
          if (versionIds.length > 0) {
            await db.update(strategyVersions).set({ convertedProgramId: null }).where(inArray5(strategyVersions.id, versionIds));
            await db.delete(epmPrograms).where(inArray5(epmPrograms.strategyVersionId, versionIds));
            await db.delete(strategyDecisions).where(inArray5(strategyDecisions.strategyVersionId, versionIds));
          }
          await db.delete(strategyVersions).where(inArray5(strategyVersions.sessionId, sessionIds));
        }
        await db.delete(strategicUnderstanding).where(inArray5(strategicUnderstanding.id, ids));
        res.json({ success: true, count: ids.length });
      } catch (error) {
        console.error("Error batch deleting statements:", error);
        res.status(500).json({ error: "Failed to delete statements" });
      }
    });
    router5.post("/batch-archive", async (req, res) => {
      try {
        const { ids, archive = true } = req.body;
        if (!ids || !Array.isArray(ids) || ids.length === 0) {
          return res.status(400).json({ error: "Invalid request: ids array is required" });
        }
        const understandings = await db.select({ sessionId: strategicUnderstanding.sessionId }).from(strategicUnderstanding).where(inArray5(strategicUnderstanding.id, ids));
        const sessionIds = understandings.map((u) => u.sessionId).filter((id) => id !== null);
        await db.update(strategicUnderstanding).set({ archived: archive, updatedAt: /* @__PURE__ */ new Date() }).where(inArray5(strategicUnderstanding.id, ids));
        if (sessionIds.length > 0) {
          await db.update(strategyVersions).set({ archived: archive, updatedAt: /* @__PURE__ */ new Date() }).where(inArray5(strategyVersions.sessionId, sessionIds));
        }
        res.json({ success: true, count: ids.length, archived: archive });
      } catch (error) {
        console.error("Error batch archiving statements:", error);
        res.status(500).json({ error: "Failed to archive statements" });
      }
    });
    router5.post("/batch-export", async (req, res) => {
      try {
        const { ids } = req.body;
        if (!ids || !Array.isArray(ids) || ids.length === 0) {
          return res.status(400).json({ error: "Invalid request: ids array is required" });
        }
        const statements = await db.select().from(strategicUnderstanding).where(inArray5(strategicUnderstanding.id, ids));
        const exportData = await Promise.all(
          statements.map(async (stmt) => {
            const analyses = await db.select().from(frameworkInsights).where(eq23(frameworkInsights.understandingId, stmt.id));
            const versions = await storage.getStrategyVersionsBySession(stmt.sessionId);
            return {
              statement: stmt,
              oldAnalyses: analyses,
              newAnalyses: versions
            };
          })
        );
        res.json({ success: true, data: exportData });
      } catch (error) {
        console.error("Error batch exporting statements:", error);
        res.status(500).json({ error: "Failed to export statements" });
      }
    });
    statement_repository_routes_default = router5;
  }
});

// server/intelligence/types.ts
var init_types3 = __esm({
  "server/intelligence/types.ts"() {
    "use strict";
  }
});

// server/intelligence/bmc-analyzer.ts
var BMCAnalyzer;
var init_bmc_analyzer2 = __esm({
  "server/intelligence/bmc-analyzer.ts"() {
    "use strict";
    BMCAnalyzer = class {
      async analyze(frameworkResults) {
        const insights = [];
        insights.push(...await this.extractWorkstreams(frameworkResults));
        insights.push(...await this.extractResources(frameworkResults));
        insights.push(...await this.extractRisks(frameworkResults));
        insights.push(...await this.extractStakeholders(frameworkResults));
        insights.push(...await this.extractBenefits(frameworkResults));
        insights.push(...await this.extractCosts(frameworkResults));
        const timelineInsight = await this.inferTimeline(frameworkResults);
        insights.push(timelineInsight);
        if (frameworkResults.executiveSummary) {
          insights.push({
            type: "other",
            source: "BMC.executiveSummary",
            content: frameworkResults.executiveSummary,
            confidence: 0.95,
            reasoning: "Direct extraction from BMC executive summary"
          });
        }
        if (frameworkResults.recommendations) {
          frameworkResults.recommendations.forEach((rec, idx) => {
            insights.push({
              type: "other",
              source: `BMC.recommendations[${idx}]`,
              content: rec,
              confidence: 0.85,
              reasoning: "Strategic recommendation from BMC analysis"
            });
          });
        }
        const overallConfidence = this.calculateConfidence(insights);
        return {
          frameworkType: "bmc",
          frameworkRunId: "bmc-run-id",
          // This will be set by the caller
          insights,
          marketContext: {
            urgency: this.inferUrgency(frameworkResults),
            budgetRange: this.inferBudgetRange(frameworkResults),
            riskTolerance: this.inferRiskTolerance(frameworkResults)
          },
          overallConfidence
        };
      }
      async extractWorkstreams(frameworkResults) {
        const insights = [];
        if (frameworkResults.keyActivities) {
          const activities = this.parseMultiLineContent(frameworkResults.keyActivities);
          activities.forEach((activity, idx) => {
            insights.push({
              type: "workstream",
              source: `BMC.keyActivities[${idx}]`,
              content: activity,
              confidence: 0.85,
              reasoning: "Direct extraction from Key Activities",
              metadata: { category: "Core Operations" }
            });
          });
        }
        if (frameworkResults.channels) {
          insights.push({
            type: "workstream",
            source: "BMC.channels",
            content: `Go-to-Market Strategy
${frameworkResults.channels}`,
            confidence: 0.8,
            reasoning: "Channels mapped to go-to-market workstream",
            metadata: { category: "Market Access" }
          });
        }
        if (frameworkResults.customerRelationships) {
          insights.push({
            type: "workstream",
            source: "BMC.customerRelationships",
            content: `Customer Success & Retention
${frameworkResults.customerRelationships}`,
            confidence: 0.75,
            reasoning: "Customer relationships mapped to success workstream",
            metadata: { category: "Customer Management" }
          });
        }
        if (this.involvesTechnology(frameworkResults)) {
          insights.push({
            type: "workstream",
            source: "BMC.inference",
            content: "Technology Platform Development\nBuild and maintain core platform capabilities",
            confidence: 0.7,
            reasoning: "Inferred from technology-related key activities",
            metadata: { category: "Technology" }
          });
        }
        return insights;
      }
      async extractResources(frameworkResults) {
        const insights = [];
        if (frameworkResults.keyResources) {
          const resources2 = this.parseMultiLineContent(frameworkResults.keyResources);
          resources2.forEach((resource, idx) => {
            insights.push({
              type: "resource",
              source: `BMC.keyResources[${idx}]`,
              content: resource,
              confidence: 0.8,
              reasoning: "Direct extraction from Key Resources",
              metadata: {
                category: this.categorizeResource(resource)
              }
            });
          });
        }
        if (this.involvesTechnology(frameworkResults)) {
          insights.push({
            type: "resource",
            source: "BMC.inference",
            content: "Software Engineers, DevOps, Technical Infrastructure",
            confidence: 0.7,
            reasoning: "Inferred technical resources from technology-related activities",
            metadata: { category: "Technical" }
          });
        }
        return insights;
      }
      async extractRisks(frameworkResults) {
        const insights = [];
        if (frameworkResults.contradictions && frameworkResults.contradictions.length > 0) {
          frameworkResults.contradictions.forEach((contradiction, idx) => {
            const contradictionAny = contradiction;
            let contradictionContent;
            if (typeof contradictionAny === "object" && contradictionAny !== null) {
              const obj = contradictionAny;
              contradictionContent = `${obj.assumption || "Assumption"}: ${obj.recommendation || "Risk identified"}`;
            } else {
              contradictionContent = String(contradiction);
            }
            insights.push({
              type: "risk",
              source: `BMC.contradictions[${idx}]`,
              content: contradictionContent,
              confidence: 0.9,
              // HIGH confidence - explicit contradictions
              reasoning: "Contradiction indicates strategic risk",
              metadata: {
                severity: this.assessContradictionSeverity(contradictionAny)
              }
            });
          });
        }
        if (frameworkResults.keyPartnerships) {
          const partners = this.parseMultiLineContent(frameworkResults.keyPartnerships);
          if (partners.length > 0) {
            insights.push({
              type: "risk",
              source: "BMC.keyPartnerships",
              content: `Partner dependency risk: Reliance on ${partners.length} key partner${partners.length > 1 ? "s" : ""} creates operational dependencies`,
              confidence: 0.75,
              reasoning: "Multiple key partnerships introduce dependency risks",
              metadata: { severity: partners.length > 3 ? "High" : "Medium" }
            });
          }
        }
        if (frameworkResults.customerSegments) {
          const segments = this.parseMultiLineContent(frameworkResults.customerSegments);
          if (segments.length > 3) {
            insights.push({
              type: "risk",
              source: "BMC.customerSegments",
              content: "Market focus risk: Targeting multiple customer segments may dilute go-to-market effectiveness",
              confidence: 0.7,
              reasoning: "Multiple customer segments increase execution complexity",
              metadata: { severity: "Medium" }
            });
          }
        }
        if (frameworkResults.costStructure && frameworkResults.costStructure.toLowerCase().includes("high")) {
          insights.push({
            type: "risk",
            source: "BMC.costStructure",
            content: "Financial risk: High cost structure requires strong revenue generation to achieve profitability",
            confidence: 0.65,
            reasoning: "High costs mentioned in cost structure",
            metadata: { severity: "High" }
          });
        }
        if (this.involvesTechnology(frameworkResults)) {
          insights.push({
            type: "risk",
            source: "BMC.inference",
            content: "Technical execution risk: Technology development timelines and complexity may exceed estimates",
            confidence: 0.7,
            reasoning: "Technology projects commonly face execution risks",
            metadata: { severity: "Medium" }
          });
        }
        return insights;
      }
      async extractStakeholders(frameworkResults) {
        const insights = [];
        if (frameworkResults.customerSegments) {
          const segments = this.parseMultiLineContent(frameworkResults.customerSegments);
          segments.forEach((segment, idx) => {
            insights.push({
              type: "stakeholder",
              source: `BMC.customerSegments[${idx}]`,
              content: `Customer Segment: ${segment}`,
              confidence: 0.9,
              reasoning: "Customer segments are key stakeholders",
              metadata: {
                power: "High",
                interest: "High",
                group: "Customers"
              }
            });
          });
        }
        if (frameworkResults.keyPartnerships) {
          const partners = this.parseMultiLineContent(frameworkResults.keyPartnerships);
          partners.forEach((partner, idx) => {
            insights.push({
              type: "stakeholder",
              source: `BMC.keyPartnerships[${idx}]`,
              content: `Key Partner: ${partner}`,
              confidence: 0.85,
              reasoning: "Key partnerships are critical stakeholders",
              metadata: {
                power: "High",
                interest: "Medium",
                group: "Partners"
              }
            });
          });
        }
        insights.push({
          type: "stakeholder",
          source: "BMC.inference",
          content: "Internal Team: Product, Engineering, Sales, Marketing",
          confidence: 0.8,
          reasoning: "Internal teams required to execute business model",
          metadata: {
            power: "Medium",
            interest: "High",
            group: "Internal"
          }
        });
        if (frameworkResults.revenueStreams) {
          insights.push({
            type: "stakeholder",
            source: "BMC.revenueStreams",
            content: "Investors/Board: Financial stakeholders requiring return on investment",
            confidence: 0.75,
            reasoning: "Revenue model requires financial backing",
            metadata: {
              power: "High",
              interest: "High",
              group: "Financial"
            }
          });
        }
        return insights;
      }
      async extractBenefits(frameworkResults) {
        const insights = [];
        if (frameworkResults.valuePropositions) {
          const props = this.parseMultiLineContent(frameworkResults.valuePropositions);
          props.forEach((prop, idx) => {
            insights.push({
              type: "benefit",
              source: `BMC.valuePropositions[${idx}]`,
              content: `Strategic benefit: ${prop}`,
              confidence: 0.85,
              reasoning: "Value propositions deliver customer and strategic benefits",
              metadata: { category: "Strategic" }
            });
          });
        }
        if (frameworkResults.revenueStreams) {
          insights.push({
            type: "benefit",
            source: "BMC.revenueStreams",
            content: `Revenue generation: ${frameworkResults.revenueStreams}`,
            confidence: 0.9,
            reasoning: "Revenue streams represent financial benefits",
            metadata: { category: "Financial" }
          });
        }
        if (frameworkResults.keyActivities) {
          if (frameworkResults.keyActivities.toLowerCase().includes("automat") || frameworkResults.keyActivities.toLowerCase().includes("efficienc")) {
            insights.push({
              type: "benefit",
              source: "BMC.keyActivities",
              content: "Operational efficiency: Automated processes reduce operational costs",
              confidence: 0.7,
              reasoning: "Automation/efficiency mentioned in key activities",
              metadata: { category: "Operational" }
            });
          }
        }
        if (frameworkResults.customerSegments) {
          const segments = this.parseMultiLineContent(frameworkResults.customerSegments);
          if (segments.length > 0) {
            insights.push({
              type: "benefit",
              source: "BMC.customerSegments",
              content: `Market expansion: Access to ${segments.length} customer segment${segments.length > 1 ? "s" : ""}`,
              confidence: 0.75,
              reasoning: "Multiple customer segments provide market diversification",
              metadata: { category: "Strategic" }
            });
          }
        }
        return insights;
      }
      async extractCosts(frameworkResults) {
        const insights = [];
        if (frameworkResults.costStructure) {
          const costs = this.parseMultiLineContent(frameworkResults.costStructure);
          costs.forEach((cost, idx) => {
            insights.push({
              type: "cost",
              source: `BMC.costStructure[${idx}]`,
              content: cost,
              confidence: 0.85,
              reasoning: "Direct extraction from cost structure",
              metadata: {
                estimatedAmount: this.estimateCostAmount(cost)
              }
            });
          });
        }
        if (frameworkResults.keyResources) {
          const resources2 = this.parseMultiLineContent(frameworkResults.keyResources);
          const humanResources = resources2.filter(
            (r) => r.toLowerCase().includes("team") || r.toLowerCase().includes("engineer") || r.toLowerCase().includes("staff")
          );
          if (humanResources.length > 0) {
            insights.push({
              type: "cost",
              source: "BMC.keyResources",
              content: `Personnel costs: Team staffing and talent acquisition`,
              confidence: 0.8,
              reasoning: "Human resources require personnel budget",
              metadata: { estimatedAmount: 5e5 }
              // Base estimate
            });
          }
        }
        return insights;
      }
      async inferTimeline(frameworkResults) {
        let urgency = "Strategic";
        let confidence = 0.65;
        let reasoning = "Default strategic timeline (12 months)";
        const allText = Object.values(frameworkResults).join(" ").toLowerCase();
        if (allText.includes("urgent") || allText.includes("immediate") || allText.includes("asap")) {
          urgency = "ASAP";
          confidence = 0.75;
          reasoning = "Urgency keywords detected \u2192 6-month timeline";
        } else if (allText.includes("exploration") || allText.includes("experiment") || allText.includes("test")) {
          urgency = "Exploratory";
          confidence = 0.7;
          reasoning = "Exploratory keywords detected \u2192 18-month timeline";
        }
        const activityCount = this.parseMultiLineContent(frameworkResults.keyActivities || "").length;
        const segmentCount = this.parseMultiLineContent(frameworkResults.customerSegments || "").length;
        const partnerCount = this.parseMultiLineContent(frameworkResults.keyPartnerships || "").length;
        const complexity = activityCount + segmentCount + partnerCount;
        if (complexity > 10) {
          reasoning += "; High complexity may extend timeline";
        }
        return {
          type: "timeline",
          source: "BMC.inference",
          content: `Recommended timeline: ${urgency === "ASAP" ? "6" : urgency === "Exploratory" ? "18" : "12"} months based on ${urgency.toLowerCase()} urgency`,
          confidence,
          reasoning,
          metadata: {
            urgency,
            complexity,
            estimatedMonths: urgency === "ASAP" ? 6 : urgency === "Exploratory" ? 18 : 12
          }
        };
      }
      calculateConfidence(insights) {
        if (insights.length === 0) return 0.5;
        const avgConfidence = insights.reduce((sum, i) => sum + i.confidence, 0) / insights.length;
        const insightPenalty = insights.length < 10 ? 0.05 : 0;
        const types = new Set(insights.map((i) => i.type));
        const requiredTypes = ["workstream", "risk", "stakeholder", "benefit"];
        const missingTypes = requiredTypes.filter((t) => !types.has(t));
        const typePenalty = missingTypes.length * 0.03;
        return Math.max(0.5, Math.min(0.95, avgConfidence - insightPenalty - typePenalty));
      }
      // ============================================================================
      // Helper Methods
      // ============================================================================
      parseMultiLineContent(content) {
        if (!content) return [];
        return content.split("\n").map((line) => line.trim()).filter((line) => line.length > 0 && !line.startsWith("#")).map((line) => line.replace(/^[-*]\s*/, "")).filter((line) => line.length > 5);
      }
      involvesTechnology(frameworkResults) {
        const allText = Object.values(frameworkResults).join(" ").toLowerCase();
        const techKeywords = ["software", "platform", "app", "digital", "technology", "ai", "ml", "algorithm", "api"];
        return techKeywords.some((keyword) => allText.includes(keyword));
      }
      categorizeResource(resource) {
        const lower = resource.toLowerCase();
        if (lower.includes("engineer") || lower.includes("developer") || lower.includes("technical")) return "Technical";
        if (lower.includes("infrastructure") || lower.includes("platform") || lower.includes("server")) return "Infrastructure";
        if (lower.includes("team") || lower.includes("staff") || lower.includes("talent")) return "Human";
        if (lower.includes("data") || lower.includes("ip") || lower.includes("intellectual")) return "Intellectual Property";
        return "Other";
      }
      assessContradictionSeverity(contradiction) {
        if (typeof contradiction === "object" && contradiction !== null) {
          const impact = contradiction.impact?.toUpperCase();
          if (impact === "HIGH") return "High";
          if (impact === "MEDIUM") return "Medium";
          if (impact === "LOW") return "Low";
          const text2 = contradiction.assumption || "";
          return this.assessContradictionSeverity(text2);
        }
        const lower = String(contradiction).toLowerCase();
        if (lower.includes("critical") || lower.includes("catastrophic") || lower.includes("fatal")) return "Critical";
        if (lower.includes("high") || lower.includes("significant") || lower.includes("major")) return "High";
        if (lower.includes("medium") || lower.includes("moderate")) return "Medium";
        return "Low";
      }
      estimateCostAmount(cost) {
        const match = cost.match(/\$([0-9,]+)/);
        if (match) {
          return parseInt(match[1].replace(/,/g, ""));
        }
        const lower = cost.toLowerCase();
        if (lower.includes("infrastructure") || lower.includes("platform")) return 3e5;
        if (lower.includes("personnel") || lower.includes("team") || lower.includes("staff")) return 5e5;
        if (lower.includes("marketing") || lower.includes("sales")) return 2e5;
        if (lower.includes("technology") || lower.includes("software")) return 15e4;
        return 1e5;
      }
      inferUrgency(frameworkResults) {
        const allText = Object.values(frameworkResults).join(" ").toLowerCase();
        if (allText.includes("urgent") || allText.includes("immediate")) return "ASAP";
        if (allText.includes("exploration") || allText.includes("experiment")) return "Exploratory";
        return "Strategic";
      }
      inferBudgetRange(frameworkResults) {
        const costMatch = frameworkResults.costStructure?.match(/\$([0-9,]+)/);
        const revenueMatch = frameworkResults.revenueStreams?.match(/\$([0-9,]+)/);
        if (costMatch || revenueMatch) {
          const amount = Math.max(
            costMatch ? parseInt(costMatch[1].replace(/,/g, "")) : 0,
            revenueMatch ? parseInt(revenueMatch[1].replace(/,/g, "")) : 0
          );
          if (amount < 5e5) return "$250k - $500k";
          if (amount < 1e6) return "$500k - $1M";
          if (amount < 2e6) return "$1M - $2M";
          return "$2M+";
        }
        return void 0;
      }
      inferRiskTolerance(frameworkResults) {
        const contradictionCount = frameworkResults.contradictions?.length || 0;
        const allText = Object.values(frameworkResults).join(" ").toLowerCase();
        if (allText.includes("innovati") || allText.includes("disrupt")) {
          return "Aggressive";
        }
        if (contradictionCount > 5) {
          return "Conservative";
        }
        if (contradictionCount > 2) {
          return "Moderate";
        }
        return void 0;
      }
    };
  }
});

// server/intelligence/analysis-aggregator.ts
import { eq as eq24, desc as desc13 } from "drizzle-orm";
async function getAggregatedAnalysis(sessionId) {
  console.log(`[AnalysisAggregator] Fetching insights for sessionId: ${sessionId}`);
  const analyses = {};
  const availableFrameworks = [];
  let understandingId = null;
  let journeySessionId = null;
  const [understanding] = await db.select().from(strategicUnderstanding).where(eq24(strategicUnderstanding.sessionId, sessionId)).limit(1);
  if (understanding) {
    understandingId = understanding.id;
    console.log(`[AnalysisAggregator] Resolved URL sessionId to understanding: ${understandingId}`);
    const [journeySession] = await db.select().from(journeySessions).where(eq24(journeySessions.understandingId, understandingId)).orderBy(desc13(journeySessions.updatedAt)).limit(1);
    if (journeySession) {
      journeySessionId = journeySession.id;
      console.log(`[AnalysisAggregator] Found journey session: ${journeySessionId}`);
    }
  } else {
    const [directJourneySession] = await db.select().from(journeySessions).where(eq24(journeySessions.id, sessionId)).limit(1);
    if (directJourneySession) {
      journeySessionId = directJourneySession.id;
      understandingId = directJourneySession.understandingId;
      console.log(`[AnalysisAggregator] sessionId is journeySession.id: ${journeySessionId}, understandingId: ${understandingId}`);
    } else {
      understandingId = sessionId;
      console.log(`[AnalysisAggregator] Fallback: treating sessionId as direct understandingId: ${understandingId}`);
    }
  }
  let frameworkInsightsData = [];
  if (journeySessionId) {
    frameworkInsightsData = await db.select().from(frameworkInsights).where(eq24(frameworkInsights.sessionId, journeySessionId));
    console.log(`[AnalysisAggregator] Queried by journeySessionId: ${journeySessionId}, found ${frameworkInsightsData.length} insights`);
  }
  if (frameworkInsightsData.length === 0 && understandingId) {
    frameworkInsightsData = await db.select().from(frameworkInsights).where(eq24(frameworkInsights.understandingId, understandingId));
    console.log(`[AnalysisAggregator] Queried by understandingId: ${understandingId}, found ${frameworkInsightsData.length} insights`);
  }
  if (frameworkInsightsData && frameworkInsightsData.length > 0) {
    console.log(`[AnalysisAggregator] Processing ${frameworkInsightsData.length} framework insights`);
    for (const insight of frameworkInsightsData) {
      try {
        const decrypted = await decryptJSONKMS(insight.insights);
        const data = decrypted?.output || decrypted;
        const frameworkName = insight.frameworkName.toLowerCase();
        analyses[frameworkName] = data;
        availableFrameworks.push(frameworkName);
        console.log(`[AnalysisAggregator] Found ${frameworkName} from framework_insights`);
      } catch (err) {
        console.error(`[AnalysisAggregator] Failed to decrypt ${insight.frameworkName}:`, err);
      }
    }
  }
  const journeyData = understandingId ? await db.select().from(journeySessions).where(eq24(journeySessions.understandingId, understandingId)).orderBy(desc13(journeySessions.updatedAt)).limit(1) : [];
  const accumulatedContext = journeyData.length > 0 ? journeyData[0].accumulatedContext : null;
  if (accumulatedContext) {
    console.log(`[AnalysisAggregator] Found journey session accumulated context`);
    const analysisData = accumulatedContext;
    const swotData = analysisData?.swot?.data?.output || analysisData?.swot?.output || analysisData?.swot;
    if (swotData?.strengths && !analyses.swot) {
      analyses.swot = swotData;
      if (!availableFrameworks.includes("swot")) availableFrameworks.push("swot");
      console.log(`[AnalysisAggregator] Found swot from journey_sessions`);
    }
    const pestleData = analysisData?.pestle?.data?.pestleResults || analysisData?.pestle?.pestleResults || analysisData?.pestle;
    if (pestleData && !analyses.pestle) {
      analyses.pestle = pestleData;
      if (!availableFrameworks.includes("pestle")) availableFrameworks.push("pestle");
      console.log(`[AnalysisAggregator] Found pestle from journey_sessions`);
    }
    const portersData = analysisData?.porters?.data?.portersResults || analysisData?.porters?.portersResults || analysisData?.porters;
    if (portersData && !analyses.porters) {
      analyses.porters = portersData;
      if (!availableFrameworks.includes("porters")) availableFrameworks.push("porters");
      console.log(`[AnalysisAggregator] Found porters from journey_sessions`);
    }
    const bmcData = analysisData?.bmc?.data?.output || analysisData?.bmc?.output || analysisData?.bmc;
    if (bmcData && !analyses.bmc) {
      analyses.bmc = bmcData;
      if (!availableFrameworks.includes("bmc")) availableFrameworks.push("bmc");
      console.log(`[AnalysisAggregator] Found bmc from journey_sessions`);
    }
    const fiveWhysData = analysisData?.five_whys?.data?.output || analysisData?.five_whys?.output || analysisData?.five_whys;
    if (fiveWhysData && !analyses.five_whys) {
      analyses.five_whys = fiveWhysData;
      if (!availableFrameworks.includes("five_whys")) availableFrameworks.push("five_whys");
      console.log(`[AnalysisAggregator] Found five_whys from journey_sessions`);
    }
  }
  if (availableFrameworks.length === 0) {
    console.log("[AnalysisAggregator] No analysis found in either framework_insights or journey_sessions");
    return { insights: null, availableFrameworks: [], primaryFramework: null };
  }
  console.log(`[AnalysisAggregator] Total frameworks available: ${availableFrameworks.join(", ")}`);
  let normalizedInsights = null;
  let primaryFramework = null;
  if (analyses.bmc || analyses.business_model_canvas) {
    const bmcData = analyses.bmc || analyses.business_model_canvas;
    normalizedInsights = await normalizeBMC(bmcData);
    primaryFramework = "bmc";
  } else if (analyses.swot) {
    normalizedInsights = await normalizeSWOT(analyses.swot);
    primaryFramework = "swot";
  } else if (analyses.porters || analyses.porters_five_forces) {
    const portersData = analyses.porters || analyses.porters_five_forces;
    normalizedInsights = await portersAnalyzer.analyze(portersData);
    primaryFramework = "porters";
  } else if (analyses.pestle) {
    normalizedInsights = await pestleAnalyzer.analyze(analyses.pestle);
    primaryFramework = "pestle";
  } else {
    const firstKey = availableFrameworks[0];
    primaryFramework = firstKey;
    normalizedInsights = createMinimalInsights(analyses[firstKey], firstKey);
  }
  if (normalizedInsights && availableFrameworks.length > 1) {
    normalizedInsights = await mergeAdditionalInsights(normalizedInsights, analyses, primaryFramework);
  }
  console.log(`[AnalysisAggregator] Primary framework: ${primaryFramework}, total frameworks: ${availableFrameworks.length}`);
  return {
    insights: normalizedInsights,
    availableFrameworks,
    primaryFramework
  };
}
async function normalizeBMC(bmcData) {
  const blocks = bmcData.blocks || [];
  const findBlock = (name) => blocks.find(
    (b) => b.blockName?.toLowerCase().includes(name.toLowerCase())
  )?.description || "";
  const bmcResults = {
    customerSegments: findBlock("Customer Segments"),
    valuePropositions: findBlock("Value Propositions"),
    channels: findBlock("Channels"),
    customerRelationships: findBlock("Customer Relationships"),
    revenueStreams: findBlock("Revenue Streams"),
    keyActivities: findBlock("Key Activities"),
    keyResources: findBlock("Key Resources"),
    keyPartnerships: findBlock("Key Partnerships"),
    costStructure: findBlock("Cost Structure"),
    contradictions: bmcData.contradictions || [],
    recommendations: bmcData.recommendations || [],
    executiveSummary: (bmcData.keyInsights || []).join(". ")
  };
  return bmcAnalyzer.analyze(bmcResults);
}
async function normalizeSWOT(swotData) {
  const data = swotData.output || swotData;
  const insights = [];
  const strengths = data.strengths || [];
  for (let idx = 0; idx < strengths.length; idx++) {
    const s = strengths[idx];
    const factor = normalizeFactor(s);
    insights.push({
      type: "resource",
      source: `SWOT.strengths[${idx}]`,
      content: factor.factor,
      confidence: 0.85,
      reasoning: "Strength indicates existing capability",
      metadata: { impact: factor.impact }
    });
  }
  const weaknesses = data.weaknesses || [];
  for (let idx = 0; idx < weaknesses.length; idx++) {
    const w = weaknesses[idx];
    const factor = normalizeFactor(w);
    insights.push({
      type: "risk",
      source: `SWOT.weaknesses[${idx}]`,
      content: `Internal weakness: ${factor.factor}`,
      confidence: 0.85,
      reasoning: "Weakness indicates internal risk",
      metadata: { severity: factor.impact === "high" ? "High" : "Medium", category: "Internal" }
    });
  }
  const opportunities = data.opportunities || [];
  for (let idx = 0; idx < opportunities.length; idx++) {
    const o = opportunities[idx];
    const factor = normalizeFactor(o);
    insights.push({
      type: "workstream",
      source: `SWOT.opportunities[${idx}]`,
      content: `Capitalize on: ${factor.factor}`,
      confidence: 0.8,
      reasoning: "Opportunity suggests strategic initiative",
      metadata: { category: "Growth", priority: factor.impact }
    });
    insights.push({
      type: "benefit",
      source: `SWOT.opportunities[${idx}]`,
      content: factor.factor,
      confidence: 0.75,
      reasoning: "Opportunity represents potential value",
      metadata: { category: "Strategic" }
    });
  }
  const threats = data.threats || [];
  for (let idx = 0; idx < threats.length; idx++) {
    const t = threats[idx];
    const factor = normalizeFactor(t);
    insights.push({
      type: "risk",
      source: `SWOT.threats[${idx}]`,
      content: `External threat: ${factor.factor}`,
      confidence: 0.85,
      reasoning: "Threat indicates external risk",
      metadata: { severity: factor.impact === "high" ? "High" : "Medium", category: "External" }
    });
  }
  const strategicOptions = data.strategicOptions || data.strategic_options;
  if (strategicOptions) {
    const addOptions = (arr, source, reasoning, priority) => {
      arr?.forEach((strategy, idx) => {
        insights.push({
          type: "workstream",
          source: `SWOT.strategicOptions.${source}[${idx}]`,
          content: strategy,
          confidence: 0.8,
          reasoning,
          metadata: { category: "Strategic", priority }
        });
      });
    };
    addOptions(strategicOptions.so || strategicOptions.soStrategies, "SO", "Leverage strengths to pursue opportunities", "high");
    addOptions(strategicOptions.wo || strategicOptions.woStrategies, "WO", "Address weaknesses to pursue opportunities", "medium");
    addOptions(strategicOptions.st || strategicOptions.stStrategies, "ST", "Use strengths to mitigate threats", "medium");
    addOptions(strategicOptions.wt || strategicOptions.wtStrategies, "WT", "Minimize weaknesses and avoid threats", "low");
  }
  const totalFactors = strengths.length + weaknesses.length + opportunities.length + threats.length;
  const months = totalFactors > 16 ? 18 : totalFactors < 8 ? 6 : 12;
  insights.push({
    type: "timeline",
    source: "SWOT.inference",
    content: `Recommended timeline: ${months} months`,
    confidence: 0.7,
    reasoning: `Based on ${totalFactors} strategic factors`,
    metadata: { estimatedMonths: months }
  });
  const highThreats = threats.filter((t) => normalizeFactor(t).impact === "high").length;
  const urgency = highThreats > 2 ? "ASAP" : highThreats > 0 ? "Strategic" : "Exploratory";
  const risks2 = weaknesses.length + threats.length;
  const riskTolerance = risks2 > strengths.length + 3 ? "Conservative" : strengths.length > risks2 + 2 ? "Aggressive" : "Moderate";
  const overallConfidence = insights.length > 0 ? Math.max(0.5, Math.min(0.95, insights.reduce((sum, i) => sum + i.confidence, 0) / insights.length)) : 0.5;
  return {
    frameworkType: "swot",
    frameworkRunId: `swot-${Date.now()}`,
    insights,
    references: [],
    marketContext: {
      urgency,
      riskTolerance
    },
    overallConfidence
  };
}
function normalizeFactor(factor) {
  if (typeof factor === "string") {
    return { factor, impact: "medium" };
  }
  return {
    factor: factor.factor || factor.description || String(factor),
    impact: factor.impact || factor.importance || "medium"
  };
}
function createMinimalInsights(data, frameworkName) {
  return {
    frameworkType: "swot",
    // default
    frameworkRunId: `${frameworkName}-run`,
    insights: [{
      type: "other",
      source: frameworkName,
      content: JSON.stringify(data).substring(0, 500),
      confidence: 0.6,
      reasoning: `Extracted from ${frameworkName} analysis`
    }],
    references: [],
    marketContext: {
      urgency: "Strategic"
    },
    overallConfidence: 0.6
  };
}
async function mergeAdditionalInsights(primary, analyses, primaryFramework) {
  for (const [framework, data] of Object.entries(analyses)) {
    if (framework === primaryFramework) continue;
    try {
      let additionalInsights = [];
      if (framework === "swot" && data) {
        const swotInsights = await normalizeSWOT(data);
        additionalInsights = swotInsights.insights.slice(0, 5);
      } else if ((framework === "porters" || framework === "porters_five_forces") && data) {
        const portersInsights = await portersAnalyzer.analyze(data);
        additionalInsights = portersInsights.insights.filter((i) => i.type === "risk").slice(0, 3);
      } else if (framework === "pestle" && data) {
        const pestleInsights = await pestleAnalyzer.analyze(data);
        additionalInsights = pestleInsights.insights.filter((i) => i.type === "risk").slice(0, 3);
      }
      additionalInsights.forEach((i) => {
        i.source = `[Supplementary:${framework}] ${i.source}`;
        i.confidence = i.confidence * 0.9;
      });
      primary.insights.push(...additionalInsights);
    } catch (err) {
      console.error(`[AnalysisAggregator] Failed to merge ${framework}:`, err);
    }
  }
  return primary;
}
var bmcAnalyzer, portersAnalyzer, pestleAnalyzer;
var init_analysis_aggregator = __esm({
  "server/intelligence/analysis-aggregator.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_kms_encryption();
    init_bmc_analyzer2();
    init_porters_analyzer();
    init_pestle_analyzer();
    bmcAnalyzer = new BMCAnalyzer();
    portersAnalyzer = new PortersAnalyzer();
    pestleAnalyzer = new PESTLEAnalyzer();
  }
});

// server/intelligence/index.ts
var intelligence_exports = {};
__export(intelligence_exports, {
  AnsoffAnalyzer: () => AnsoffAnalyzer,
  BMCAnalyzer: () => BMCAnalyzer,
  EPMSynthesizer: () => EPMSynthesizer,
  JTBDAnalyzer: () => JTBDAnalyzer,
  OKRGenerator: () => OKRGenerator,
  OceanStrategyAnalyzer: () => OceanStrategyAnalyzer,
  PESTLEAnalyzer: () => PESTLEAnalyzer,
  PortersAnalyzer: () => PortersAnalyzer,
  SWOTAnalyzer: () => SWOTAnalyzer,
  ScenarioPlanningAnalyzer: () => ScenarioPlanningAnalyzer,
  VRIOAnalyzer: () => VRIOAnalyzer,
  ansoffAnalyzer: () => ansoffAnalyzer,
  getAggregatedAnalysis: () => getAggregatedAnalysis,
  jtbdAnalyzer: () => jtbdAnalyzer,
  normalizeSWOT: () => normalizeSWOT,
  oceanStrategyAnalyzer: () => oceanStrategyAnalyzer,
  okrGenerator: () => okrGenerator,
  scenarioPlanningAnalyzer: () => scenarioPlanningAnalyzer,
  swotAnalyzer: () => swotAnalyzer,
  vrioAnalyzer: () => vrioAnalyzer
});
var init_intelligence = __esm({
  "server/intelligence/index.ts"() {
    "use strict";
    init_types3();
    init_epm_synthesizer();
    init_bmc_analyzer2();
    init_porters_analyzer();
    init_pestle_analyzer();
    init_swot_analyzer();
    init_ansoff_analyzer();
    init_jtbd_analyzer();
    init_vrio_analyzer();
    init_scenario_planning_analyzer();
    init_okr_generator();
    init_ocean_strategy_analyzer();
    init_analysis_aggregator();
  }
});

// scripts/validate-export-package.ts
var validate_export_package_exports = {};
__export(validate_export_package_exports, {
  EPMPackageValidator: () => EPMPackageValidator
});
import * as fs3 from "fs";
var EPMPackageValidator;
var init_validate_export_package = __esm({
  "scripts/validate-export-package.ts"() {
    "use strict";
    EPMPackageValidator = class {
      errors = [];
      warnings = [];
      score = 100;
      /**
       * Main validation entry point
       */
      validate(packagePath) {
        console.log("\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
        console.log("\u2551                     EPM EXPORT PACKAGE VALIDATOR                            \u2551");
        console.log("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D\n");
        if (!fs3.existsSync(packagePath)) {
          this.errors.push(`Package file not found: ${packagePath}`);
          return this.getResult();
        }
        let epmPackage;
        try {
          const content = fs3.readFileSync(packagePath, "utf-8");
          epmPackage = JSON.parse(content);
        } catch (error) {
          this.errors.push(`Failed to parse package: ${error.message}`);
          return this.getResult();
        }
        console.log("\u{1F4CB} Running validation checks...\n");
        this.check1_WorkstreamsExist(epmPackage);
        this.check2_TimelineValidity(epmPackage);
        this.check3_DependencyIntegrity(epmPackage);
        this.check4_ResourceAllocation(epmPackage);
        this.check5_MilestoneSequencing(epmPackage);
        this.check6_ProgressCalculation(epmPackage);
        this.check7_DomainKnowledge(epmPackage);
        this.check8_DataCompleteness(epmPackage);
        this.check9_LogicalCoherence(epmPackage);
        this.check10_ExportReadiness(epmPackage);
        return this.getResult();
      }
      /**
       * Check 1: Workstreams exist and have valid structure
       */
      check1_WorkstreamsExist(pkg) {
        console.log("\u2713 Check 1: Workstream Structure");
        if (!pkg.workstreams || !Array.isArray(pkg.workstreams)) {
          this.addError("No workstreams found in package", 20);
          return;
        }
        if (pkg.workstreams.length === 0) {
          this.addError("Workstreams array is empty", 20);
          return;
        }
        pkg.workstreams.forEach((ws2, idx) => {
          if (!ws2.id) this.addError(`Workstream ${idx + 1} missing ID`, 5);
          if (!ws2.name) this.addError(`Workstream ${idx + 1} missing name`, 5);
          if (!ws2.deliverables || ws2.deliverables.length === 0) {
            this.addWarning(`Workstream "${ws2.name || idx}" has no deliverables`);
          }
        });
      }
      /**
       * Check 2: Timeline validity
       */
      check2_TimelineValidity(pkg) {
        console.log("\u2713 Check 2: Timeline Validity");
        if (!pkg.workstreams) return;
        pkg.workstreams.forEach((ws2) => {
          if (ws2.startMonth === 0 && ws2.endMonth === 0) {
            this.addError(`Workstream "${ws2.name}" has invalid timeline (all zeros)`, 15);
          }
          if (ws2.startMonth > ws2.endMonth) {
            this.addError(`Workstream "${ws2.name}" ends before it starts`, 10);
          }
          if (ws2.deliverables) {
            ws2.deliverables.forEach((d) => {
              if (d.dueMonth === 0) {
                this.addError(`Deliverable "${d.name}" has invalid due month (0)`, 5);
              }
              if (d.dueMonth < ws2.startMonth || d.dueMonth > ws2.endMonth) {
                this.addWarning(`Deliverable "${d.name}" due outside workstream timeline`);
              }
            });
          }
        });
      }
      /**
       * Check 3: Dependency integrity
       */
      check3_DependencyIntegrity(pkg) {
        console.log("\u2713 Check 3: Dependency Integrity");
        if (!pkg.workstreams) return;
        const wsIds = new Set(pkg.workstreams.map((ws2) => ws2.id));
        pkg.workstreams.forEach((ws2) => {
          if (ws2.dependencies && ws2.dependencies.length > 0) {
            ws2.dependencies.forEach((depId) => {
              if (!wsIds.has(depId)) {
                this.addError(`Workstream "${ws2.name}" depends on non-existent workstream "${depId}"`, 10);
              }
            });
            if (this.hasCircularDependency(ws2.id, pkg.workstreams)) {
              this.addError(`Circular dependency detected involving "${ws2.name}"`, 15);
            }
          }
        });
      }
      /**
       * Check 4: Resource allocation
       */
      check4_ResourceAllocation(pkg) {
        console.log("\u2713 Check 4: Resource Allocation");
        if (!pkg.resources) {
          this.addWarning("No resource plan found");
          return;
        }
        if (!pkg.resources.totalBudget || pkg.resources.totalBudget === 0) {
          this.addWarning("No budget allocated");
        }
        if (!pkg.resources.allocations || pkg.resources.allocations.length === 0) {
          this.addWarning("No resource allocations defined");
        }
      }
      /**
       * Check 5: Milestone sequencing
       */
      check5_MilestoneSequencing(pkg) {
        console.log("\u2713 Check 5: Milestone Sequencing");
        if (!pkg.stageGates || pkg.stageGates.length === 0) {
          this.addWarning("No stage gates/milestones defined");
          return;
        }
        const sorted = [...pkg.stageGates].sort((a, b) => a.month - b.month);
        for (let i = 0; i < sorted.length - 1; i++) {
          if (sorted[i].month === sorted[i + 1].month) {
            this.addWarning(`Multiple milestones at month ${sorted[i].month}`);
          }
        }
      }
      /**
       * Check 6: Progress calculation (detect LLM hallucinations)
       */
      check6_ProgressCalculation(pkg) {
        console.log("\u2713 Check 6: Progress Calculation");
        const percentageRegex = /\b\d{1,3}%\s*(complete|progress|done)/gi;
        pkg.workstreams?.forEach((ws2) => {
          if (ws2.description && percentageRegex.test(ws2.description)) {
            this.addError(`Workstream "${ws2.name}" contains hallucinated progress percentage`, 10);
          }
          ws2.deliverables?.forEach((d) => {
            if (d.description && percentageRegex.test(d.description)) {
              this.addError(`Deliverable "${d.name}" contains hallucinated progress percentage`, 5);
            }
          });
        });
      }
      /**
       * Check 7: Domain knowledge (restaurant-specific for this example)
       */
      check7_DomainKnowledge(pkg) {
        console.log("\u2713 Check 7: Domain Knowledge Validation");
        const isRestaurant = pkg.metadata?.domain === "restaurant" || pkg.metadata?.businessType?.toLowerCase().includes("restaurant");
        if (isRestaurant) {
          const requiredPhases = ["permits", "construction", "equipment", "staffing", "training"];
          const foundPhases = /* @__PURE__ */ new Set();
          pkg.workstreams?.forEach((ws2) => {
            const wsLower = ws2.name.toLowerCase();
            requiredPhases.forEach((phase) => {
              if (wsLower.includes(phase)) foundPhases.add(phase);
            });
          });
          const missing = requiredPhases.filter((p) => !foundPhases.has(p));
          if (missing.length > 0) {
            this.addWarning(`Restaurant project missing critical phases: ${missing.join(", ")}`);
          }
        }
      }
      /**
       * Check 8: Data completeness
       */
      check8_DataCompleteness(pkg) {
        console.log("\u2713 Check 8: Data Completeness");
        const placeholderPatterns = [
          /^(tbd|tba|todo|xxx|placeholder|temp|test)/i,
          /^to be (determined|defined|decided)/i,
          /^\[.*\]$/,
          // Bracketed placeholders
          /^<.*>$/
          // Angle bracket placeholders
        ];
        pkg.workstreams?.forEach((ws2) => {
          placeholderPatterns.forEach((pattern) => {
            if (pattern.test(ws2.name)) {
              this.addError(`Workstream contains placeholder text: "${ws2.name}"`, 5);
            }
            if (ws2.description && pattern.test(ws2.description)) {
              this.addWarning(`Workstream "${ws2.name}" description contains placeholder text`);
            }
          });
        });
      }
      /**
       * Check 9: Logical coherence
       */
      check9_LogicalCoherence(pkg) {
        console.log("\u2713 Check 9: Logical Coherence");
        if (!pkg.workstreams) return;
        pkg.workstreams.forEach((ws2) => {
          if (ws2.dependencies && ws2.dependencies.length > 0) {
            ws2.dependencies.forEach((depId) => {
              const dep = pkg.workstreams?.find((w) => w.id === depId);
              if (dep && dep.endMonth >= ws2.startMonth) {
                this.addWarning(
                  `Workstream "${ws2.name}" may start before dependency "${dep.name}" completes`
                );
              }
            });
          }
        });
        const maxEnd = Math.max(...pkg.workstreams.map((ws2) => ws2.endMonth || 0));
        if (maxEnd > 36) {
          this.addWarning(`Project duration exceeds 3 years (${maxEnd} months)`);
        }
        if (maxEnd < 3) {
          this.addWarning(`Project duration seems too short (${maxEnd} months)`);
        }
      }
      /**
       * Check 10: Export readiness
       */
      check10_ExportReadiness(pkg) {
        console.log("\u2713 Check 10: Export Readiness");
        if (!pkg.metadata) {
          this.addError("Missing metadata", 5);
        }
        if (!pkg.metadata?.sessionId) {
          this.addError("Missing session ID in metadata", 5);
        }
        if (!pkg.metadata?.generatedAt) {
          this.addWarning("Missing generation timestamp");
        }
        const wsCount = pkg.workstreams?.length || 0;
        const deliverableCount = pkg.workstreams?.reduce(
          (sum, ws2) => sum + (ws2.deliverables?.length || 0),
          0
        ) || 0;
        if (wsCount < 3) {
          this.addError(`Insufficient workstreams (${wsCount} < 3)`, 10);
        }
        if (deliverableCount < wsCount * 2) {
          this.addWarning(`Low deliverable count (${deliverableCount} for ${wsCount} workstreams)`);
        }
      }
      /**
       * Helper: Check for circular dependencies
       */
      hasCircularDependency(wsId, workstreams2, visited = /* @__PURE__ */ new Set()) {
        if (visited.has(wsId)) return true;
        visited.add(wsId);
        const ws2 = workstreams2.find((w) => w.id === wsId);
        if (!ws2 || !ws2.dependencies) return false;
        for (const depId of ws2.dependencies) {
          if (this.hasCircularDependency(depId, workstreams2, new Set(visited))) {
            return true;
          }
        }
        return false;
      }
      /**
       * Add error and deduct from score
       */
      addError(message, penalty) {
        this.errors.push(message);
        this.score = Math.max(0, this.score - penalty);
        console.log(`  \u274C ERROR: ${message} (-${penalty} points)`);
      }
      /**
       * Add warning (no score penalty)
       */
      addWarning(message) {
        this.warnings.push(message);
        console.log(`  \u26A0\uFE0F  WARNING: ${message}`);
      }
      /**
       * Get validation result
       */
      getResult() {
        const isValid = this.errors.length === 0 && this.score >= 70;
        console.log("\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557");
        console.log("\u2551                           VALIDATION RESULTS                                \u2551");
        console.log("\u255A\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255D");
        console.log(`
\u{1F4CA} Quality Score: ${this.score}/100`);
        console.log(`\u2705 Valid for Export: ${isValid ? "YES" : "NO"}`);
        console.log(`\u274C Errors: ${this.errors.length}`);
        console.log(`\u26A0\uFE0F  Warnings: ${this.warnings.length}`);
        if (this.errors.length > 0) {
          console.log("\n\u{1F534} ERRORS FOUND:");
          this.errors.forEach((e, i) => console.log(`  ${i + 1}. ${e}`));
        }
        if (this.warnings.length > 0) {
          console.log("\n\u{1F7E1} WARNINGS:");
          this.warnings.forEach((w, i) => console.log(`  ${i + 1}. ${w}`));
        }
        if (!isValid) {
          console.log("\n\u274C EXPORT BLOCKED: Package does not meet quality standards");
          console.log("Fix the errors above and re-run validation.");
        } else if (this.warnings.length > 0) {
          console.log("\n\u2705 EXPORT ALLOWED: Package meets minimum standards");
          console.log("Consider addressing warnings for better quality.");
        } else {
          console.log("\n\u2705 EXCELLENT: Package passes all quality checks!");
        }
        return {
          isValid,
          errors: this.errors,
          warnings: this.warnings,
          score: this.score
        };
      }
    };
    if (__require.main === module) {
      const args = process.argv.slice(2);
      if (args.length === 0) {
        console.error("Usage: ts-node scripts/validate-export-package.ts <path-to-epm-package.json>");
        process.exit(1);
      }
      const validator = new EPMPackageValidator();
      const result = validator.validate(args[0]);
      process.exit(result.isValid ? 0 : 1);
    }
  }
});

// server/routes/strategy-workspace.ts
import { Router as Router6 } from "express";
import { eq as eq25, desc as desc14, inArray as inArray6, and as and18 } from "drizzle-orm";
function sendSSEEvent(progressId, data) {
  const stream = progressStreams.get(progressId);
  if (!stream) return;
  stream.lastEventId++;
  const eventData = JSON.stringify(data);
  stream.res.write(`id: ${stream.lastEventId}
`);
  stream.res.write(`data: ${eventData}

`);
}
function extractComponentConfidence(epmProgram) {
  return {
    executiveSummary: epmProgram.executiveSummary.confidence || 0.75,
    workstreams: epmProgram.workstreams.confidence || 0.75,
    timeline: epmProgram.timeline.confidence || 0.75,
    resourcePlan: epmProgram.resourcePlan.confidence || 0.75,
    financialPlan: epmProgram.financialPlan.confidence || 0.75,
    benefitsRealization: epmProgram.benefitsRealization.confidence || 0.75,
    riskRegister: epmProgram.riskRegister.confidence || 0.75,
    stageGates: epmProgram.stageGates.confidence || 0.75,
    kpis: epmProgram.kpis.confidence || 0.75,
    stakeholderMap: epmProgram.stakeholderMap.confidence || 0.75,
    governance: epmProgram.governance.confidence || 0.75,
    qaPlan: epmProgram.qaPlan.confidence || 0.75,
    procurement: epmProgram.procurement.confidence || 0.75,
    exitStrategy: epmProgram.exitStrategy.confidence || 0.75
  };
}
function boostConfidenceWithDecisions(baseConfidence, userDecisions) {
  if (!userDecisions) {
    return baseConfidence;
  }
  const boostedConfidence = { ...baseConfidence };
  let decisionCompleteness = 0;
  let decisionFields = 0;
  let completedFields = 0;
  if (userDecisions.primaryCustomerSegment) completedFields++;
  decisionFields++;
  if (userDecisions.revenueModel) completedFields++;
  decisionFields++;
  if (userDecisions.channelPriorities?.length > 0) completedFields++;
  decisionFields++;
  if (userDecisions.partnershipStrategy) completedFields++;
  decisionFields++;
  if (userDecisions.riskTolerance) completedFields++;
  decisionFields++;
  if (userDecisions.investmentCapacityMin !== void 0) completedFields++;
  decisionFields++;
  if (userDecisions.timelinePreference) completedFields++;
  decisionFields++;
  if (userDecisions.validatedAssumptions?.length > 0) completedFields++;
  decisionFields++;
  if (userDecisions.concerns?.length > 0) completedFields++;
  decisionFields++;
  if (userDecisions.topPriorities?.length > 0) completedFields++;
  decisionFields++;
  if (userDecisions.goDecision) completedFields++;
  decisionFields++;
  decisionCompleteness = completedFields / decisionFields;
  const maxBoost = 0.1;
  const actualBoost = maxBoost * decisionCompleteness;
  if (userDecisions.primaryCustomerSegment) {
    boostedConfidence.stakeholderMap = Math.min(1, boostedConfidence.stakeholderMap + actualBoost);
    boostedConfidence.benefitsRealization = Math.min(1, boostedConfidence.benefitsRealization + actualBoost * 0.5);
  }
  if (userDecisions.revenueModel) {
    boostedConfidence.financialPlan = Math.min(1, boostedConfidence.financialPlan + actualBoost);
    boostedConfidence.benefitsRealization = Math.min(1, boostedConfidence.benefitsRealization + actualBoost * 0.5);
  }
  if (userDecisions.timelinePreference) {
    boostedConfidence.timeline = Math.min(1, boostedConfidence.timeline + actualBoost);
    boostedConfidence.stageGates = Math.min(1, boostedConfidence.stageGates + actualBoost * 0.7);
  }
  if (userDecisions.riskTolerance) {
    boostedConfidence.riskRegister = Math.min(1, boostedConfidence.riskRegister + actualBoost);
    boostedConfidence.governance = Math.min(1, boostedConfidence.governance + actualBoost * 0.5);
  }
  if (userDecisions.investmentCapacityMin !== void 0 || userDecisions.investmentCapacityMax !== void 0) {
    boostedConfidence.resourcePlan = Math.min(1, boostedConfidence.resourcePlan + actualBoost);
    boostedConfidence.financialPlan = Math.min(1, boostedConfidence.financialPlan + actualBoost * 0.7);
  }
  if (userDecisions.successMetricsPriority?.length > 0) {
    boostedConfidence.kpis = Math.min(1, boostedConfidence.kpis + actualBoost);
  }
  if (userDecisions.topPriorities?.length > 0) {
    boostedConfidence.workstreams = Math.min(1, boostedConfidence.workstreams + actualBoost);
    boostedConfidence.executiveSummary = Math.min(1, boostedConfidence.executiveSummary + actualBoost * 0.5);
  }
  Object.keys(boostedConfidence).forEach((key) => {
    boostedConfidence[key] = Math.min(1, boostedConfidence[key] + actualBoost * 0.3);
  });
  return boostedConfidence;
}
function calculateOverallConfidence(componentConfidence) {
  const scores = Object.values(componentConfidence);
  const average = scores.reduce((sum, score) => sum + score, 0) / scores.length;
  return Math.round(average * 100) / 100;
}
async function processEPMGeneration(strategyVersionId, decisionId, prioritizedOrder, progressId, req) {
  const startTime = Date.now();
  const userId = req.user?.claims?.sub || null;
  let jobId = null;
  try {
    sendSSEEvent(progressId, {
      type: "step-start",
      step: "initialization",
      progress: 5,
      description: "Preparing strategic analysis..."
    });
    const version = await storage.getStrategyVersionById(strategyVersionId);
    if (!version) {
      throw new Error("Strategy version not found");
    }
    let initiativeType = void 0;
    let journeyTitle = void 0;
    if (version.sessionId) {
      try {
        const [understanding] = await db.select({
          initiativeType: strategicUnderstanding.initiativeType,
          title: strategicUnderstanding.title
        }).from(strategicUnderstanding).where(eq25(strategicUnderstanding.sessionId, version.sessionId)).limit(1);
        if (understanding?.initiativeType) {
          initiativeType = understanding.initiativeType;
          console.log(`[EPM Generation] \u2705 Initiative type fetched: "${initiativeType}"`);
        }
        if (understanding?.title) {
          journeyTitle = understanding.title;
          console.log(`[EPM Generation] \u2705 Journey title fetched: "${journeyTitle}"`);
        }
        if (!understanding) {
          console.warn(`[EPM Generation] \u26A0\uFE0F No strategic understanding found for id: ${version.sessionId}`);
        }
      } catch (error) {
        console.error("[EPM Generation] \u274C Error fetching strategic understanding:", error);
      }
    } else {
      console.warn("[EPM Generation] \u26A0\uFE0F No sessionId available - cannot fetch strategic context");
    }
    try {
      jobId = await backgroundJobService.createJob({
        userId,
        jobType: "epm_generation",
        inputData: {
          strategyVersionId,
          decisionId,
          prioritizedOrder,
          progressId,
          // Store progressId for SSE reconnection
          // Store strategy context for meaningful job titles
          strategyName: version.inputSummary || version.strategicApproach || version.marketContext || `Strategy v${version.versionNumber}`,
          sessionId: version.sessionId,
          versionNumber: version.versionNumber
        },
        sessionId: version.sessionId ?? void 0,
        // Store sessionId for session-based lookups
        relatedEntityId: strategyVersionId,
        relatedEntityType: "strategy_version"
      });
      console.log("[EPM Generation] Background job created:", jobId, "for session:", version.sessionId);
      if (jobId) {
        await backgroundJobService.updateJob(jobId, {
          status: "running",
          progress: 5,
          progressMessage: "Preparing strategic analysis..."
        }).catch((err) => console.error("[EPM Generation] Job update failed:", err));
      }
    } catch (jobError) {
      console.error("[EPM Generation] Failed to create background job:", jobError);
    }
    const { insights: aggregatedInsights, availableFrameworks, primaryFramework } = version.sessionId ? await getAggregatedAnalysis(version.sessionId) : { insights: null, availableFrameworks: [], primaryFramework: null };
    const analysisData = version.analysisData;
    const bmcAnalysis = analysisData?.bmc_research;
    const journeySwotData = analysisData?.swot?.data?.output || analysisData?.swot?.output || analysisData?.swot;
    const journeyPestleData = analysisData?.pestle?.data?.pestleResults || analysisData?.pestle?.pestleResults;
    const journeyPortersData = analysisData?.porters?.data?.portersResults || analysisData?.porters?.portersResults;
    const hasJourneyAnalysis = !!(journeySwotData?.strengths || journeyPestleData || journeyPortersData);
    if (!aggregatedInsights && !bmcAnalysis && !hasJourneyAnalysis) {
      throw new Error("No strategic analysis available. Run at least one framework (SWOT, BMC, Porters, or PESTLE) before generating EPM.");
    }
    let effectivePrimaryFramework = primaryFramework;
    if (!aggregatedInsights && hasJourneyAnalysis) {
      if (journeySwotData?.strengths) effectivePrimaryFramework = "swot";
      else if (journeyPortersData) effectivePrimaryFramework = "porters";
      else if (journeyPestleData) effectivePrimaryFramework = "pestle";
    }
    console.log(`[EPM Generation] Using ${effectivePrimaryFramework || "bmc"} as primary framework, ${availableFrameworks.length} aggregated + journey analysis available: ${hasJourneyAnalysis}`);
    let decisionsData = version.decisionsData;
    let selectedDecisions = version.selectedDecisions;
    let journeyBuilderSwot = null;
    const hasLegacyDecisions = decisionsData && decisionsData?.decisions?.length > 0;
    if (!hasLegacyDecisions && version.sessionId) {
      console.log("[EPM Generation] Legacy decisionsData empty, checking Journey Builder path (frameworkInsights)...");
      try {
        const [understanding] = await db.select().from(strategicUnderstanding).where(eq25(strategicUnderstanding.sessionId, version.sessionId)).limit(1);
        if (understanding) {
          const [journeySession] = await db.select().from(journeySessions).where(
            and18(
              eq25(journeySessions.understandingId, understanding.id),
              eq25(journeySessions.versionNumber, version.versionNumber)
            )
          ).limit(1);
          if (journeySession) {
            const [decisionInsight] = await db.select().from(frameworkInsights).where(
              and18(
                eq25(frameworkInsights.sessionId, journeySession.id),
                eq25(frameworkInsights.frameworkName, "strategic_decisions")
              )
            ).orderBy(desc14(frameworkInsights.createdAt)).limit(1);
            if (decisionInsight?.insights) {
              console.log("[EPM Generation] \u2713 Found decisions in frameworkInsights (Journey Builder path)");
              decisionsData = decisionInsight.insights;
            }
            const [swotInsight] = await db.select().from(frameworkInsights).where(
              and18(
                eq25(frameworkInsights.sessionId, journeySession.id),
                eq25(frameworkInsights.frameworkName, "swot")
              )
            ).orderBy(desc14(frameworkInsights.createdAt)).limit(1);
            if (swotInsight?.insights) {
              console.log("[EPM Generation] \u2713 Found SWOT in frameworkInsights (Journey Builder path)");
              journeyBuilderSwot = swotInsight.insights;
            }
          }
        }
      } catch (fbError) {
        console.warn("[EPM Generation] Failed to fetch from frameworkInsights:", fbError);
      }
    }
    const namingContext = {
      journeyTitle,
      // From strategic_understanding.title - USE THIS!
      bmcKeyInsights: bmcAnalysis?.keyInsights || [],
      bmcRecommendations: bmcAnalysis?.recommendations || [],
      selectedDecisions: selectedDecisions || null,
      decisionsData: decisionsData || null,
      framework: effectivePrimaryFramework || "bmc",
      // Pass Journey Builder SWOT for benefit generation
      journeyBuilderSwot
    };
    let userDecisions = null;
    if (decisionId) {
      const [decision] = await db.select().from(strategyDecisions).where(eq25(strategyDecisions.id, decisionId)).limit(1);
      if (decision) {
        const missingFields = [];
        let page1Fields = 0;
        if (decision.primaryCustomerSegment) page1Fields++;
        if (decision.revenueModel) page1Fields++;
        if (Array.isArray(decision.channelPriorities) && decision.channelPriorities.length > 0) page1Fields++;
        if (decision.partnershipStrategy) page1Fields++;
        if (page1Fields < 2) {
          missingFields.push("Strategic Choices (need at least 2 decisions)");
        }
        if (!decision.riskTolerance) missingFields.push("Risk Tolerance");
        if (!decision.timelinePreference) missingFields.push("Timeline Preference");
        if ((!Array.isArray(decision.validatedAssumptions) || decision.validatedAssumptions.length === 0) && (!Array.isArray(decision.concerns) || decision.concerns.length === 0)) {
          missingFields.push("Validated Assumptions or Concerns");
        }
        if (!decision.topPriorities?.length) {
          missingFields.push("Top Priorities");
        }
        if (!decision.goDecision) {
          missingFields.push("Go/No-Go Decision");
        }
        if (missingFields.length > 0) {
          throw new Error(`Incomplete strategic decisions: ${missingFields.join(", ")}`);
        }
        userDecisions = decision;
      }
    }
    sendSSEEvent(progressId, {
      type: "step-start",
      step: "analyze",
      progress: 10,
      description: `Analyzing ${primaryFramework || "strategic"} framework...`
    });
    let insights;
    if (aggregatedInsights) {
      insights = aggregatedInsights;
      console.log(`[EPM Generation] Using aggregated insights from ${availableFrameworks.join(", ")}`);
    } else if (bmcAnalysis) {
      const blocks = bmcAnalysis.blocks || [];
      const findBlock = (name) => blocks.find((b) => b.blockName === name)?.description || "";
      const bmcResults = {
        customerSegments: findBlock("Customer Segments"),
        valuePropositions: findBlock("Value Propositions"),
        channels: findBlock("Channels"),
        customerRelationships: findBlock("Customer Relationships"),
        revenueStreams: findBlock("Revenue Streams"),
        keyActivities: findBlock("Key Activities"),
        keyResources: findBlock("Key Resources"),
        keyPartnerships: findBlock("Key Partnerships"),
        costStructure: findBlock("Cost Structure"),
        contradictions: [],
        recommendations: bmcAnalysis.recommendations || [],
        executiveSummary: (bmcAnalysis.keyInsights || []).join(". ")
      };
      insights = await bmcAnalyzer2.analyze(bmcResults);
      console.log("[EPM Generation] Using BMC analyzer fallback");
    } else if (journeySwotData?.strengths) {
      console.log("[EPM Generation] Using journey SWOT analysis fallback");
      insights = await normalizeSWOT(journeySwotData);
    } else if (journeyPortersData) {
      console.log("[EPM Generation] Using journey Porter's analysis fallback");
      const portersAnalyzer3 = new PortersAnalyzer();
      insights = await portersAnalyzer3.analyze(journeyPortersData);
    } else if (journeyPestleData) {
      console.log("[EPM Generation] Using journey PESTLE analysis fallback");
      const pestleAnalyzer3 = new PESTLEAnalyzer();
      insights = await pestleAnalyzer3.analyze(journeyPestleData);
    } else {
      throw new Error("No strategic analysis available");
    }
    const decisionsWithPriority = userDecisions ? {
      ...userDecisions,
      prioritizedOrder: prioritizedOrder || [],
      sessionId: version.sessionId
      // Pass sessionId for initiative type lookup
    } : {
      prioritizedOrder: prioritizedOrder || [],
      sessionId: version.sessionId
      // Pass sessionId for initiative type lookup
    };
    const epmProgram = await epmSynthesizer.synthesize(
      insights,
      decisionsWithPriority,
      namingContext,
      {
        onProgress: (event) => {
          sendSSEEvent(progressId, event);
          if (jobId && event.progress !== void 0) {
            backgroundJobService.updateJob(jobId, {
              progress: event.progress,
              progressMessage: event.description || event.message
            }).catch((err) => console.error("[EPM Generation] Job progress update failed:", err));
          }
        },
        initiativeType
        // EXPLICIT: Pass initiative type from database
      }
    );
    console.log("[EPM Generation] \u{1F50D} Running quality validation...");
    try {
      const { EPMPackageValidator: EPMPackageValidator2 } = await Promise.resolve().then(() => (init_validate_export_package(), validate_export_package_exports));
      const validator = new EPMPackageValidator2();
      const tempPackage = {
        workstreams: epmProgram.workstreams,
        timeline: epmProgram.timeline,
        resources: epmProgram.resourcePlan,
        stageGates: epmProgram.stageGates,
        metadata: {
          sessionId: version.sessionId,
          generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
          domain: namingContext?.businessSector || "general",
          businessType: namingContext?.businessName || "unknown"
        }
      };
      const tempPath = `/tmp/epm-validation-${Date.now()}.json`;
      const fs4 = await import("fs");
      fs4.writeFileSync(tempPath, JSON.stringify(tempPackage, null, 2));
      const validationResult = validator.validate(tempPath);
      fs4.unlinkSync(tempPath);
      if (!validationResult.isValid) {
        console.error("[EPM Generation] \u274C VALIDATION FAILED:");
        validationResult.errors.forEach((e) => console.error(`  - ${e}`));
        sendSSEEvent(progressId, {
          type: "validation_failed",
          errors: validationResult.errors,
          warnings: validationResult.warnings,
          score: validationResult.score,
          message: `Quality validation failed (score: ${validationResult.score}/100). Please review and try again.`
        });
        throw new Error(`EPM quality validation failed with ${validationResult.errors.length} errors. Score: ${validationResult.score}/100`);
      }
      if (validationResult.warnings.length > 0) {
        console.warn("[EPM Generation] \u26A0\uFE0F  Validation warnings:");
        validationResult.warnings.forEach((w) => console.warn(`  - ${w}`));
      }
      console.log(`[EPM Generation] \u2705 Validation passed (score: ${validationResult.score}/100)`);
    } catch (validationError) {
      if (validationError.message?.includes("validation failed")) {
        throw validationError;
      } else {
        console.error("[EPM Generation] \u26A0\uFE0F  Validation process error (continuing):", validationError.message);
      }
    }
    const componentConfidence = extractComponentConfidence(epmProgram);
    const finalConfidence = boostConfidenceWithDecisions(componentConfidence, userDecisions);
    const overallConfidence = calculateOverallConfidence(finalConfidence);
    const epmRepo = getService(ServiceKeys.EPM_REPOSITORY);
    const savedProgram = await epmRepo.create({
      strategyVersionId,
      strategyDecisionId: decisionId || null,
      userId,
      frameworkType: effectivePrimaryFramework || "bmc",
      executiveSummary: epmProgram.executiveSummary,
      workstreams: epmProgram.workstreams,
      timeline: epmProgram.timeline,
      resourcePlan: epmProgram.resourcePlan,
      financialPlan: epmProgram.financialPlan,
      benefitsRealization: epmProgram.benefitsRealization,
      riskRegister: epmProgram.riskRegister,
      stageGates: epmProgram.stageGates,
      kpis: epmProgram.kpis,
      stakeholderMap: epmProgram.stakeholderMap,
      governance: epmProgram.governance,
      qaPlan: epmProgram.qaPlan,
      procurement: epmProgram.procurement,
      exitStrategy: epmProgram.exitStrategy,
      componentConfidence: finalConfidence,
      overallConfidence: overallConfidence.toString(),
      editTracking: {},
      status: "draft"
    });
    if (!savedProgram || !savedProgram.id) {
      console.error("[EPM Generation] \u274C Program save failed - no ID returned:", savedProgram);
      throw new Error("Failed to save EPM program - no ID returned from database");
    }
    const programId = savedProgram.id;
    const elapsedSeconds = Math.round((Date.now() - startTime) / 1e3);
    console.log(`[EPM Generation] \u2705 Program saved with ID: ${programId}`);
    console.log(`[EPM Generation] Total elapsed time: ${elapsedSeconds}s`);
    try {
      console.log(`[EPM Generation] \u{1F4CB} Generating task assignments...`);
      const assignments = await epmSynthesizer.generateAssignments(epmProgram, programId);
      if (assignments && assignments.length > 0) {
        await epmRepo.createTaskAssignments(assignments);
        console.log(`[EPM Generation] \u2705 Saved ${assignments.length} task assignments`);
      } else {
        console.log(`[EPM Generation] \u2139\uFE0F  No assignments generated (program may lack resources or tasks)`);
      }
    } catch (assignmentError) {
      console.error(`[EPM Generation] \u26A0\uFE0F  Assignment generation failed (non-critical):`, assignmentError);
    }
    console.log(`[EPM Generation] Sending completion event with programId: ${programId}`);
    sendSSEEvent(progressId, {
      type: "complete",
      progress: 100,
      epmProgramId: programId,
      overallConfidence,
      componentsGenerated: 14,
      elapsedSeconds,
      message: "EPM program generation complete!"
    });
    if (jobId) {
      await backgroundJobService.updateJob(jobId, {
        status: "completed",
        progress: 100,
        resultData: {
          programId,
          overallConfidence,
          elapsedSeconds
        }
      }).catch((err) => console.error("[EPM Generation] Job completion update failed:", err));
    }
    if (isJourneyRegistryV2Enabled() && version.sessionId) {
      try {
        const [understanding] = await db.select().from(strategicUnderstanding).where(eq25(strategicUnderstanding.sessionId, version.sessionId)).limit(1);
        if (understanding) {
          const [journeySession] = await db.select().from(journeySessions).where(
            and18(
              eq25(journeySessions.understandingId, understanding.id),
              eq25(journeySessions.versionNumber, version.versionNumber)
            )
          ).limit(1);
          if (journeySession && journeySession.journeyType === "business_model_innovation") {
            console.log(`[EPM Completion Hook] Found BMI journey session ${journeySession.id}, saving summary...`);
            const context = {
              understandingId: journeySession.understandingId,
              sessionId: version.sessionId,
              userInput: version.inputSummary || version.marketContext || "",
              journeyType: journeySession.journeyType,
              currentFrameworkIndex: 2,
              // Completed Five Whys and BMC
              completedFrameworks: ["five_whys", "bmc"],
              status: "completed",
              insights: {
                rootCauses: [],
                bmcBlocks: bmcAnalysis || {},
                strategicImplications: [],
                businessModelGaps: []
              },
              createdAt: new Date(journeySession.createdAt || /* @__PURE__ */ new Date()),
              updatedAt: /* @__PURE__ */ new Date()
            };
            const fiveWhysData = analysisData?.five_whys;
            if (fiveWhysData?.rootCauses) {
              context.insights.rootCauses = fiveWhysData.rootCauses;
            }
            const journeyDef = journeyRegistry.getJourney("business_model_innovation");
            if (journeyDef?.summaryBuilder) {
              const summary = journeySummaryService.buildSummary(
                journeyDef.summaryBuilder,
                context,
                {
                  versionNumber: journeySession.versionNumber || 1,
                  completedAt: (/* @__PURE__ */ new Date()).toISOString()
                }
              );
              await journeySummaryService.saveSummary(journeySession.id, summary);
              await db.update(journeySessions).set({
                status: "completed",
                completedAt: /* @__PURE__ */ new Date()
              }).where(eq25(journeySessions.id, journeySession.id));
              console.log(`[EPM Completion Hook] \u2713 Journey summary saved and session marked as completed for version ${journeySession.versionNumber}`);
              const autoCaptureEnabled = process.env.AUTO_CAPTURE_GOLDEN === "true";
              if (autoCaptureEnabled) {
                console.log(`[EPM Completion Hook] \u{1F504} Triggering golden records auto-capture for BMI journey ${journeySession.id}`);
                setImmediate(async () => {
                  try {
                    const {
                      fetchJourneySessionData: fetchJourneySessionData2,
                      sanitizeGoldenRecordData: sanitizeGoldenRecordData2,
                      saveGoldenRecordToFile: saveGoldenRecordToFile2
                    } = await Promise.resolve().then(() => (init_golden_records_service(), golden_records_service_exports));
                    const { screenshotCaptureService: screenshotCaptureService2 } = await Promise.resolve().then(() => (init_screenshot_capture_service(), screenshot_capture_service_exports));
                    const rawData = await fetchJourneySessionData2(journeySession.id);
                    if (!rawData) {
                      console.error("[EPM Completion Hook] Failed to fetch journey session data for auto-capture");
                      return;
                    }
                    let sanitizedData = await sanitizeGoldenRecordData2(rawData);
                    const existingRecords = await db.select().from(goldenRecords).where(eq25(goldenRecords.journeyType, "business_model_innovation")).orderBy(desc14(goldenRecords.version));
                    const maxVersion = existingRecords.length > 0 ? existingRecords[0].version : 0;
                    const nextVersion = maxVersion + 1;
                    sanitizedData.versionNumber = nextVersion;
                    try {
                      const stepsWithScreenshots = await screenshotCaptureService2.captureStepScreenshots({
                        journeyType: "business_model_innovation",
                        versionNumber: nextVersion,
                        steps: sanitizedData.steps,
                        adminSessionCookie: void 0
                      });
                      sanitizedData.steps = stepsWithScreenshots;
                      const screenshotCount = stepsWithScreenshots.filter((s) => s.screenshot).length;
                      console.log(`[EPM Completion Hook] \u2713 Captured ${screenshotCount} screenshots for version ${nextVersion}`);
                    } catch (screenshotError) {
                      console.warn("[EPM Completion Hook] Screenshot capture failed (non-critical):", screenshotError);
                    }
                    const filePath = await saveGoldenRecordToFile2(sanitizedData);
                    await db.insert(goldenRecords).values({
                      journeyType: "business_model_innovation",
                      version: nextVersion,
                      filePath,
                      capturedAt: /* @__PURE__ */ new Date(),
                      capturedBy: "system",
                      status: "captured",
                      metadata: {
                        autoCapture: true,
                        source: "epm_completion_hook",
                        sessionId: journeySession.id,
                        versionNumber: journeySession.versionNumber
                      }
                    });
                    console.log(`[EPM Completion Hook] \u2705 Auto-captured golden record v${nextVersion} for BMI journey`);
                  } catch (captureError) {
                    console.error("[EPM Completion Hook] Golden records auto-capture failed (non-critical):", captureError);
                  }
                });
              } else {
                console.log("[EPM Completion Hook] Golden records auto-capture disabled (AUTO_CAPTURE_GOLDEN=false)");
              }
            }
          } else if (journeySession) {
            console.log(`[EPM Completion Hook] Journey type is ${journeySession.journeyType}, not BMI - skipping summary`);
          } else {
            console.log(`[EPM Completion Hook] No journey session found for understanding ${understanding.id} v${version.versionNumber}`);
          }
        } else {
          console.log(`[EPM Completion Hook] No understanding found for sessionId ${version.sessionId}`);
        }
      } catch (summaryError) {
        console.error("[EPM Completion Hook] Failed to save journey summary (non-critical):", summaryError);
      }
    }
    const stream = progressStreams.get(progressId);
    if (stream) {
      stream.res.end();
      progressStreams.delete(progressId);
    }
  } catch (error) {
    console.error("Error in processEPMGeneration:", error);
    if (jobId) {
      await backgroundJobService.failJob(jobId, error).catch(
        (err) => console.error("[EPM Generation] Job failure update failed:", err)
      );
    }
    throw error;
  }
}
var router6, progressStreams, llm, epmSynthesizer, bmcAnalyzer2, portersAnalyzer2, pestleAnalyzer2, strategy_workspace_default;
var init_strategy_workspace = __esm({
  "server/routes/strategy-workspace.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_intelligence();
    init_storage();
    init_llm_provider();
    init_background_job_service();
    init_journey_summary_service();
    init_journey_registry();
    init_config();
    init_container();
    init_interfaces();
    init_replitAuth();
    router6 = Router6();
    progressStreams = /* @__PURE__ */ new Map();
    if (!process.env.OPENAI_API_KEY) {
      console.warn("[strategy-workspace] OPENAI_API_KEY not set - EPM synthesis will fail if attempted");
    }
    llm = createOpenAIProvider({
      apiKey: process.env.OPENAI_API_KEY || "",
      model: process.env.OPENAI_MODEL || "gpt-4o"
    });
    epmSynthesizer = new EPMSynthesizer(llm);
    bmcAnalyzer2 = new BMCAnalyzer();
    portersAnalyzer2 = new PortersAnalyzer();
    pestleAnalyzer2 = new PESTLEAnalyzer();
    router6.get("/epm/progress/:progressId", (req, res) => {
      const { progressId } = req.params;
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      res.setHeader("X-Accel-Buffering", "no");
      progressStreams.set(progressId, {
        res,
        lastEventId: 0
      });
      sendSSEEvent(progressId, {
        type: "connected",
        message: "Planning progress stream connected"
      });
      req.on("close", () => {
        progressStreams.delete(progressId);
      });
    });
    router6.post("/decisions", async (req, res) => {
      try {
        const {
          strategyVersionId,
          primaryCustomerSegment,
          revenueModel,
          channelPriorities,
          partnershipStrategy,
          riskTolerance,
          investmentCapacityMin,
          investmentCapacityMax,
          timelinePreference,
          successMetricsPriority,
          validatedAssumptions,
          concerns,
          topPriorities,
          goDecision,
          decisionRationale
        } = req.body;
        if (!strategyVersionId || !goDecision) {
          return res.status(400).json({
            error: "strategyVersionId and goDecision are required"
          });
        }
        const userId = req.user?.claims?.sub || null;
        const [decision] = await db.insert(strategyDecisions).values({
          strategyVersionId,
          userId,
          primaryCustomerSegment: primaryCustomerSegment || null,
          revenueModel: revenueModel || null,
          channelPriorities: channelPriorities || [],
          partnershipStrategy: partnershipStrategy || null,
          riskTolerance: riskTolerance || "balanced",
          investmentCapacityMin: investmentCapacityMin || 0,
          investmentCapacityMax: investmentCapacityMax || 0,
          timelinePreference: timelinePreference || "sustainable_pace",
          successMetricsPriority: successMetricsPriority || [],
          validatedAssumptions: validatedAssumptions || [],
          concerns: concerns || [],
          topPriorities: topPriorities || [],
          goDecision,
          decisionRationale: decisionRationale || null
        }).returning();
        res.json({
          success: true,
          decisionId: decision.id,
          goDecision: decision.goDecision
        });
      } catch (error) {
        console.error("Error in POST /decisions:", error);
        res.status(500).json({ error: error.message || "Failed to save decisions" });
      }
    });
    router6.post("/epm/generate", async (req, res) => {
      const progressId = `progress-${Date.now()}-${Math.random().toString(36).substring(7)}`;
      try {
        const tokenValid = await refreshTokenProactively(req, 600);
        if (!tokenValid) {
          return res.status(401).json({
            error: "Session expired",
            message: "Please log in again to continue"
          });
        }
        const { strategyVersionId, decisionId, prioritizedOrder } = req.body;
        if (!strategyVersionId) {
          return res.status(400).json({ error: "strategyVersionId is required" });
        }
        res.json({
          success: true,
          progressId,
          message: "EPM generation started. Connect to progress stream for updates."
        });
        processEPMGeneration(strategyVersionId, decisionId, prioritizedOrder, progressId, req).catch((error) => {
          console.error("Background EPM generation error:", error);
          sendSSEEvent(progressId, {
            type: "error",
            message: error.message || "EPM generation failed"
          });
          const stream = progressStreams.get(progressId);
          if (stream) {
            stream.res.end();
            progressStreams.delete(progressId);
          }
        });
      } catch (error) {
        console.error("Error in POST /epm/generate:", error);
        sendSSEEvent(progressId, {
          type: "error",
          message: error.message || "EPM generation failed"
        });
      }
    });
    router6.get("/epm", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({ error: "User not authenticated" });
        }
        const programs2 = await db.select({
          id: epmPrograms.id,
          frameworkType: epmPrograms.frameworkType,
          status: epmPrograms.status,
          overallConfidence: epmPrograms.overallConfidence,
          createdAt: epmPrograms.createdAt,
          updatedAt: epmPrograms.updatedAt,
          finalizedAt: epmPrograms.finalizedAt,
          executiveSummary: epmPrograms.executiveSummary,
          strategyVersionId: epmPrograms.strategyVersionId
        }).from(epmPrograms).where(eq25(epmPrograms.userId, userId)).orderBy(desc14(epmPrograms.createdAt));
        const programsWithTitles = programs2.map((prog) => ({
          id: prog.id,
          title: prog.executiveSummary?.title || "Untitled Program",
          frameworkType: prog.frameworkType,
          status: prog.status,
          overallConfidence: parseFloat(prog.overallConfidence || "0"),
          createdAt: prog.createdAt,
          updatedAt: prog.updatedAt,
          finalizedAt: prog.finalizedAt,
          strategyVersionId: prog.strategyVersionId
        }));
        res.json({ programs: programsWithTitles });
      } catch (error) {
        console.error("Error in GET /epm:", error);
        res.status(500).json({ error: error.message || "Failed to fetch EPM programs" });
      }
    });
    router6.get("/epm/:id", async (req, res) => {
      try {
        const { id } = req.params;
        const [program] = await db.select().from(epmPrograms).where(eq25(epmPrograms.id, id)).limit(1);
        if (!program) {
          return res.status(404).json({ error: "EPM program not found" });
        }
        res.json({ program });
      } catch (error) {
        console.error("Error in GET /epm/:id:", error);
        res.status(500).json({ error: error.message || "Failed to fetch EPM program" });
      }
    });
    router6.get("/epm/:id/session", async (req, res) => {
      try {
        const { id } = req.params;
        const [program] = await db.select({
          strategyVersionId: epmPrograms.strategyVersionId
        }).from(epmPrograms).where(eq25(epmPrograms.id, id)).limit(1);
        if (!program || !program.strategyVersionId) {
          return res.status(404).json({ error: "EPM program not found or has no linked strategy version" });
        }
        const [version] = await db.select({
          sessionId: strategyVersions.sessionId
        }).from(strategyVersions).where(eq25(strategyVersions.id, program.strategyVersionId)).limit(1);
        if (!version || !version.sessionId) {
          return res.status(404).json({ error: "Strategy version not found or has no session" });
        }
        const [journeySession] = await db.select({
          understandingId: journeySessions.understandingId
        }).from(journeySessions).where(eq25(journeySessions.id, version.sessionId)).limit(1);
        if (!journeySession || !journeySession.understandingId) {
          return res.status(404).json({ error: "Journey session not found or has no understanding" });
        }
        res.json({ sessionId: journeySession.understandingId });
      } catch (error) {
        console.error("Error in GET /epm/:id/session:", error);
        res.status(500).json({ error: error.message || "Failed to fetch session ID" });
      }
    });
    router6.patch("/epm/:id", async (req, res) => {
      try {
        const { id } = req.params;
        const { component, value } = req.body;
        if (!component || !value) {
          return res.status(400).json({ error: "component and value are required" });
        }
        const validComponents = [
          "executiveSummary",
          "workstreams",
          "timeline",
          "resourcePlan",
          "financialPlan",
          "benefitsRealization",
          "riskRegister",
          "stageGates",
          "kpis",
          "stakeholderMap",
          "governance",
          "qaPlan",
          "procurement",
          "exitStrategy"
        ];
        if (!validComponents.includes(component)) {
          return res.status(400).json({ error: "Invalid component name" });
        }
        const [currentProgram] = await db.select().from(epmPrograms).where(eq25(epmPrograms.id, id)).limit(1);
        if (!currentProgram) {
          return res.status(404).json({ error: "EPM program not found" });
        }
        const editTracking = currentProgram.editTracking || {};
        editTracking[component] = {
          modified: true,
          modifiedAt: (/* @__PURE__ */ new Date()).toISOString(),
          source: "user"
        };
        const updateData = {
          [component]: value,
          editTracking,
          updatedAt: /* @__PURE__ */ new Date()
        };
        await db.update(epmPrograms).set(updateData).where(eq25(epmPrograms.id, id));
        res.json({ success: true, component, updated: true });
      } catch (error) {
        console.error("Error in PATCH /epm/:id:", error);
        res.status(500).json({ error: error.message || "Failed to update EPM program" });
      }
    });
    router6.post("/epm/:id/finalize", async (req, res) => {
      try {
        const { id } = req.params;
        const [program] = await db.select().from(epmPrograms).where(eq25(epmPrograms.id, id)).limit(1);
        if (!program) {
          return res.status(404).json({ error: "EPM program not found" });
        }
        if (program.status === "finalized") {
          return res.status(400).json({ error: "Program already finalized" });
        }
        const overallConfidence = parseFloat(program.overallConfidence);
        if (overallConfidence < 0.6) {
          return res.status(400).json({
            error: "Confidence too low to finalize",
            overallConfidence,
            message: "Please review and edit low-confidence components before finalizing"
          });
        }
        await db.update(epmPrograms).set({
          status: "finalized",
          finalizedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq25(epmPrograms.id, id));
        res.json({
          success: true,
          status: "finalized",
          finalizedAt: /* @__PURE__ */ new Date()
        });
      } catch (error) {
        console.error("Error in POST /epm/:id/finalize:", error);
        res.status(500).json({ error: error.message || "Failed to finalize EPM program" });
      }
    });
    router6.post("/epm/batch-delete", async (req, res) => {
      try {
        const { ids } = req.body;
        if (!ids || !Array.isArray(ids) || ids.length === 0) {
          return res.status(400).json({ error: "Invalid request: ids array is required" });
        }
        await db.update(strategyVersions).set({ convertedProgramId: null }).where(inArray6(strategyVersions.convertedProgramId, ids));
        await db.delete(epmPrograms).where(inArray6(epmPrograms.id, ids));
        res.json({ success: true, count: ids.length });
      } catch (error) {
        console.error("Error batch deleting EPM programs:", error);
        res.status(500).json({ error: error.message || "Failed to delete EPM programs" });
      }
    });
    router6.post("/epm/batch-archive", async (req, res) => {
      try {
        const { ids, archive = true } = req.body;
        if (!ids || !Array.isArray(ids) || ids.length === 0) {
          return res.status(400).json({ error: "Invalid request: ids array is required" });
        }
        await db.update(epmPrograms).set({ archived: archive, updatedAt: /* @__PURE__ */ new Date() }).where(inArray6(epmPrograms.id, ids));
        res.json({ success: true, count: ids.length, archived: archive });
      } catch (error) {
        console.error("Error batch archiving EPM programs:", error);
        res.status(500).json({ error: error.message || "Failed to archive EPM programs" });
      }
    });
    router6.post("/epm/batch-export", async (req, res) => {
      try {
        const { ids } = req.body;
        if (!ids || !Array.isArray(ids) || ids.length === 0) {
          return res.status(400).json({ error: "Invalid request: ids array is required" });
        }
        const programs2 = await db.select().from(epmPrograms).where(inArray6(epmPrograms.id, ids));
        res.json({ success: true, data: programs2 });
      } catch (error) {
        console.error("Error batch exporting EPM programs:", error);
        res.status(500).json({ error: error.message || "Failed to export EPM programs" });
      }
    });
    strategy_workspace_default = router6;
  }
});

// server/services/journey-builder-service.ts
import { eq as eq26, desc as desc15 } from "drizzle-orm";
var JourneyBuilderService, journeyBuilderService;
var init_journey_builder_service = __esm({
  "server/services/journey-builder-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_journey_orchestrator();
    JourneyBuilderService = class {
      /**
       * Create a new journey template
       * Used for both system templates (pre-defined) and custom user journeys
       */
      async createTemplate(params) {
        console.log("[Journey Builder] Creating template:", params.name);
        this.validateSteps(params.steps);
        const estimatedDuration = params.steps.reduce((total, step) => {
          return total + (step.estimatedDuration || 0);
        }, 0);
        const [template] = await db.insert(journeyTemplates).values({
          name: params.name,
          description: params.description,
          steps: params.steps,
          category: params.category,
          tags: params.tags,
          isSystemTemplate: params.isSystemTemplate || false,
          createdBy: params.createdBy,
          estimatedDuration,
          difficulty: params.difficulty
        }).returning();
        console.log("[Journey Builder] \u2713 Template created:", template.id);
        return template.id;
      }
      /**
       * Start a journey from a template or custom steps
       * Creates a new knowledge graph for this journey
       */
      async startJourney(params) {
        console.log("[Journey Builder] Starting journey for user:", params.userId);
        let steps;
        let name;
        let templateId;
        if (params.templateId) {
          const [template] = await db.select().from(journeyTemplates).where(eq26(journeyTemplates.id, params.templateId));
          if (!template) {
            throw new Error(`Template not found: ${params.templateId}`);
          }
          steps = template.steps;
          name = params.name || template.name;
          templateId = template.id;
          await db.update(journeyTemplates).set({ usageCount: template.usageCount + 1 }).where(eq26(journeyTemplates.id, template.id));
        } else if (params.customSteps) {
          this.validateSteps(params.customSteps);
          steps = params.customSteps;
          name = params.name || "Custom Journey";
          templateId = void 0;
        } else {
          throw new Error("Must provide either templateId or customSteps");
        }
        const sessionId = `journey_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const [journey] = await db.insert(userJourneys).values({
          userId: params.userId,
          sessionId,
          templateId,
          name,
          steps,
          currentStepIndex: 0,
          status: "in_progress"
        }).returning();
        console.log("[Journey Builder] \u2713 Journey started:", {
          journeyId: journey.id,
          sessionId: journey.sessionId,
          steps: steps.length,
          note: "Each journey creates its own isolated knowledge graph"
        });
        return {
          journeyId: journey.id,
          sessionId: journey.sessionId
        };
      }
      /**
       * Get journey by session ID
       */
      async getJourney(sessionId) {
        const [journey] = await db.select().from(userJourneys).where(eq26(userJourneys.sessionId, sessionId));
        if (!journey) {
          return null;
        }
        return {
          ...journey,
          steps: journey.steps,
          completedSteps: journey.completedSteps,
          stepResults: journey.stepResults,
          journeyContext: journey.journeyContext
        };
      }
      /**
       * Complete a step and advance to next
       * Updates journey context which feeds into knowledge graph
       */
      async completeStep(params) {
        console.log("[Journey Builder] Completing step:", params.stepId);
        const journey = await this.getJourney(params.sessionId);
        if (!journey) {
          throw new Error(`Journey not found: ${params.sessionId}`);
        }
        const stepIndex = journey.steps.findIndex((s) => s.id === params.stepId);
        if (stepIndex === -1) {
          throw new Error(`Step not found: ${params.stepId}`);
        }
        const completedSteps = [...journey.completedSteps, params.stepId];
        const stepResults = { ...journey.stepResults, [params.stepId]: params.result };
        const journeyContext = { ...journey.journeyContext, ...params.contextUpdates };
        let nextStepIndex = stepIndex + 1;
        if (nextStepIndex >= journey.steps.length) {
          nextStepIndex = -1;
        }
        const updateData = {
          completedSteps,
          stepResults,
          journeyContext,
          lastActivityAt: /* @__PURE__ */ new Date()
        };
        if (nextStepIndex === -1) {
          updateData.status = "completed";
          updateData.completedAt = /* @__PURE__ */ new Date();
          updateData.currentStepIndex = journey.steps.length;
          console.log("[Journey Builder] \u{1F389} Journey completed! Knowledge graph is complete.");
        } else {
          updateData.currentStepIndex = nextStepIndex;
        }
        await db.update(userJourneys).set(updateData).where(eq26(userJourneys.sessionId, params.sessionId));
        console.log("[Journey Builder] \u2713 Step completed:", {
          stepId: params.stepId,
          nextStepIndex: nextStepIndex === -1 ? null : nextStepIndex,
          journeyComplete: nextStepIndex === -1
        });
        return {
          completed: nextStepIndex === -1,
          nextStepIndex: nextStepIndex === -1 ? null : nextStepIndex
        };
      }
      /**
       * Register a framework in the registry
       */
      async registerFramework(params) {
        console.log("[Journey Builder] Registering framework:", params.frameworkKey);
        const [framework] = await db.insert(frameworkRegistry).values({
          frameworkKey: params.frameworkKey,
          name: params.name,
          description: params.description,
          category: params.category,
          estimatedDuration: params.estimatedDuration,
          difficulty: params.difficulty,
          requiredInputs: params.requiredInputs,
          providedOutputs: params.providedOutputs,
          processorPath: params.processorPath
        }).returning();
        console.log("[Journey Builder] \u2713 Framework registered:", framework.id);
        return framework.id;
      }
      /**
       * Get all available templates
       */
      async getTemplates(params) {
        const templates2 = await db.select().from(journeyTemplates);
        return templates2.map((t) => ({
          ...t,
          steps: t.steps,
          tags: t.tags
        }));
      }
      /**
       * Get templates created by a specific user (custom journeys from wizard)
       */
      async getUserTemplates(userId) {
        const templates2 = await db.select().from(journeyTemplates).where(eq26(journeyTemplates.createdBy, userId)).orderBy(desc15(journeyTemplates.createdAt));
        return templates2.map((t) => ({
          ...t,
          steps: t.steps,
          tags: t.tags
        }));
      }
      /**
       * Get all registered frameworks (user-selectable only)
       */
      async getFrameworks() {
        const frameworks = await db.select().from(frameworkRegistry).where(eq26(frameworkRegistry.isActive, true));
        return frameworks.map((f) => ({
          ...f,
          requiredInputs: f.requiredInputs,
          providedOutputs: f.providedOutputs
        }));
      }
      /**
       * Validate journey steps structure
       */
      validateSteps(steps) {
        if (!steps || steps.length === 0) {
          throw new Error("Journey must have at least one step");
        }
        const ids = /* @__PURE__ */ new Set();
        for (const step of steps) {
          if (ids.has(step.id)) {
            throw new Error(`Duplicate step ID: ${step.id}`);
          }
          ids.add(step.id);
        }
        for (const step of steps) {
          if (step.dependsOn) {
            for (const depId of step.dependsOn) {
              if (!ids.has(depId)) {
                throw new Error(`Step ${step.id} depends on non-existent step: ${depId}`);
              }
            }
          }
        }
      }
      /**
       * Get a template by its ID
       */
      async getTemplateById(templateId) {
        const [template] = await db.select().from(journeyTemplates).where(eq26(journeyTemplates.id, templateId));
        if (!template) {
          return null;
        }
        return {
          ...template,
          steps: template.steps,
          tags: template.tags
        };
      }
      /**
       * Start a custom journey execution from a template
       * Uses JourneyOrchestrator to create a proper journey session with framework sequence
       */
      async startCustomJourneyExecution(params) {
        console.log("[Journey Builder] Starting custom journey execution for understanding:", params.understandingId);
        const template = await this.getTemplateById(params.templateId);
        if (!template) {
          throw new Error("Template not found");
        }
        if (!template.isSystemTemplate && template.createdBy && template.createdBy !== params.userId) {
          console.warn("[Journey Builder] Unauthorized access attempt to template:", params.templateId, "by user:", params.userId);
          throw new Error("Not authorized to use this template");
        }
        if (!template.steps || template.steps.length === 0) {
          throw new Error("Template has no steps");
        }
        const frameworkKeyMap = {
          "business_model_canvas": "bmc",
          "porters_five_forces": "porters",
          "strategic_decisions": "strategic_decisions"
          // Pass through (not executed)
        };
        const allSteps = template.steps.filter((step) => step.frameworkKey !== "strategic_understanding").map((step) => frameworkKeyMap[step.frameworkKey] || step.frameworkKey);
        const nonExecutableSteps = ["strategic_decisions"];
        const executableFrameworks = allSteps.filter((key) => !nonExecutableSteps.includes(key));
        if (executableFrameworks.length === 0) {
          throw new Error("Template has no executable frameworks after filtering");
        }
        const firstFramework = executableFrameworks[0];
        console.log("[Journey Builder] All journey steps:", allSteps.join(", "));
        console.log("[Journey Builder] Executable frameworks:", executableFrameworks.join(", "));
        const orchestrator = new JourneyOrchestrator();
        const { journeySessionId, versionNumber } = await orchestrator.startCustomJourney({
          understandingId: params.understandingId,
          userId: params.userId,
          frameworks: executableFrameworks,
          allSteps,
          // Pass ALL steps including non-executable ones for navigation
          templateId: params.templateId
        });
        await this.startJourney({
          userId: params.userId,
          templateId: params.templateId,
          name: template.name
        });
        console.log("[Journey Builder] \u2713 Custom journey started via orchestrator:", {
          journeySessionId,
          versionNumber,
          firstFramework,
          templateId: params.templateId
        });
        return {
          journeySessionId,
          firstFramework,
          versionNumber
        };
      }
    };
    journeyBuilderService = new JourneyBuilderService();
  }
});

// server/services/journey-validator-service.ts
var JourneyValidatorService, journeyValidatorService;
var init_journey_validator_service = __esm({
  "server/services/journey-validator-service.ts"() {
    "use strict";
    init_llm_provider2();
    JourneyValidatorService = class {
      /**
       * Define what INFORMATION EPM Generator needs to work effectively
       * These map to knowledge graph entities that must be present
       */
      EPM_REQUIRED_INFORMATION = {
        strategic_context: "Strategic understanding and business context",
        business_model: "Validated business model (value proposition, customers, revenue)",
        strategic_decisions: "Key strategic choices (risk tolerance, priorities)"
      };
      /**
       * Map frameworks to what knowledge graph entities they produce
       * This is based on your existing framework implementations
       */
      FRAMEWORK_INFO_MAP = {
        strategic_understanding: ["strategic_context", "company_context", "goals", "assumptions"],
        five_whys: ["root_causes", "causal_chains", "assumptions_validated"],
        business_model_canvas: ["business_model", "value_proposition", "customer_segments", "revenue_streams"],
        porters_five_forces: ["competitive_analysis", "industry_attractiveness", "competitive_threats"],
        pestle: ["macro_environment", "trends", "external_factors"],
        swot: ["strengths", "weaknesses", "opportunities", "threats"],
        strategic_decisions: ["strategic_decisions", "risk_tolerance", "priorities", "go_decision"]
      };
      /**
       * Validate if journey collects enough information for EPM Generator
       */
      async validateJourney(params) {
        console.log("[Journey Validator] Validating journey for EPM readiness...");
        const { selectedFrameworks } = params;
        const result = {
          isValid: true,
          hasRequiredInfo: true,
          missingInformation: [],
          warnings: [],
          recommendations: [],
          informationCollected: []
        };
        const infoCollected = /* @__PURE__ */ new Set();
        selectedFrameworks.forEach((fk) => {
          const info = this.FRAMEWORK_INFO_MAP[fk] || [];
          info.forEach((i) => infoCollected.add(i));
        });
        result.informationCollected = Array.from(infoCollected);
        if (!infoCollected.has("strategic_context")) {
          result.missingInformation.push("strategic_context");
          result.warnings.push("\u{1F6A8} CRITICAL: Missing Strategic Understanding - EPM will lack business context and goals");
          result.hasRequiredInfo = false;
          result.isValid = false;
        }
        if (!infoCollected.has("business_model")) {
          result.missingInformation.push("business_model");
          result.warnings.push("\u{1F6A8} CRITICAL: Missing Business Model - EPM cannot generate coherent workstreams and tasks");
          result.hasRequiredInfo = false;
          result.isValid = false;
        }
        if (!infoCollected.has("strategic_decisions")) {
          result.warnings.push("\u26A0\uFE0F RECOMMENDED: Add Strategic Decisions to capture risk tolerance and priorities");
          result.recommendations.push("Strategic Decisions step ensures EPM reflects your specific choices");
        }
        if (!infoCollected.has("root_causes") && !infoCollected.has("assumptions_validated")) {
          result.recommendations.push("Consider 5 Whys to uncover assumptions and root causes - strengthens EPM risk analysis");
        }
        if (!infoCollected.has("competitive_analysis") && !infoCollected.has("macro_environment")) {
          result.recommendations.push("Consider Porter's Five Forces or PESTLE for market context - improves EPM stakeholder and risk analysis");
        }
        const llmAnalysis = await this.getLLMRecommendations(
          selectedFrameworks,
          Array.from(infoCollected),
          params.userGoal
        );
        if (llmAnalysis.recommendations.length > 0) {
          result.recommendations.push(...llmAnalysis.recommendations);
        }
        console.log("[Journey Validator] \u2713 Validation complete:", {
          hasRequiredInfo: result.hasRequiredInfo,
          infoCollected: result.informationCollected.length,
          warnings: result.warnings.length,
          recommendations: result.recommendations.length
        });
        return result;
      }
      /**
       * Use LLM to analyze information completeness for EPM generation
       */
      async getLLMRecommendations(selectedFrameworks, infoCollected, userGoal) {
        try {
          const llm2 = getLLMProvider();
          const frameworkNames = selectedFrameworks.map((fk) => {
            const names = {
              strategic_understanding: "Strategic Understanding",
              five_whys: "5 Whys",
              business_model_canvas: "Business Model Canvas",
              porters_five_forces: "Porter's Five Forces",
              pestle: "PESTLE",
              swot: "SWOT",
              strategic_decisions: "Strategic Decisions"
            };
            return names[fk] || fk;
          });
          const prompt = `A user is building a strategic journey with these frameworks:
${frameworkNames.map((f, i) => `${i + 1}. ${f}`).join("\n")}

Knowledge graph entities that will be collected:
${infoCollected.map((i) => `- ${i}`).join("\n")}

${userGoal ? `User's goal: ${userGoal}` : ""}

This journey will end with EPM Generation which produces a complete 14-component execution program including:
- Work breakdown structure
- Timeline & schedule  
- Resource plan (roles, team composition)
- Financial plan (budget, costs)
- Risk register
- Benefits realization
- KPIs & success metrics
- Stakeholder map
- Governance structure
- Stage gates
- QA plan
- Procurement plan
- Exit strategy
- Executive summary

Context enrichment will automatically run between frameworks to build connections in the knowledge graph.

Does this journey collect enough information for EPM Generator to produce high-quality outputs? 

Provide 1-2 specific, actionable recommendations to improve the journey (or return empty array if it's already complete).

Format as JSON:
{
  "recommendations": ["specific recommendation"]
}`;
          const response = await llm2.generateStructuredResponse(prompt, {
            recommendations: "array"
          });
          return response;
        } catch (error) {
          console.error("[Journey Validator] LLM analysis failed:", error);
          return { recommendations: [] };
        }
      }
    };
    journeyValidatorService = new JourneyValidatorService();
  }
});

// server/services/journey-recommendation-service.ts
var JourneyRecommendationService, journeyRecommendationService;
var init_journey_recommendation_service = __esm({
  "server/services/journey-recommendation-service.ts"() {
    "use strict";
    init_llm_provider2();
    init_journey_validator_service();
    JourneyRecommendationService = class {
      /**
       * Analyze a custom journey and provide recommendations
       */
      async analyzeJourney(params) {
        console.log("[Journey Recommendation] Analyzing journey with validation...");
        const selectedFrameworks = params.steps.map((s) => s.frameworkKey);
        const validation = await journeyValidatorService.validateJourney({
          selectedFrameworks,
          userGoal: params.userGoal
        });
        const llm2 = getLLMProvider();
        const prompt = `Analyze this strategic journey:

Frameworks selected:
${params.steps.map((s, i) => `${i + 1}. ${s.name}`).join("\n")}

Knowledge graph entities that will be collected:
${validation.informationCollected.map((i) => `- ${i}`).join("\n")}

${params.userGoal ? `User's stated goal: ${params.userGoal}` : ""}

CONTEXT:
- Context enrichment runs automatically between each framework
- Each framework adds entities and relationships to a growing knowledge graph
- The journey ends with EPM Generation (which includes WBS Builder, Resource Planner, etc.)
- Each journey creates its own isolated knowledge graph

Provide analysis:
1. What is this journey suitable for? (2-4 specific use cases)
2. What are the strengths of this framework sequence?
3. Are there any gaps in the knowledge graph that would limit EPM quality?
4. One-sentence summary of what this journey achieves

Format as JSON:
{
  "suitableFor": ["specific use case 1", "specific use case 2"],
  "strengths": ["strength 1 with reasoning", "strength 2 with reasoning"],
  "potentialGaps": ["gap 1 (or empty if none)"],
  "recommendation": "One clear sentence about what this journey achieves"
}`;
        const aiAnalysis = await llm2.generateStructuredResponse(prompt, {
          suitableFor: "array",
          strengths: "array",
          potentialGaps: "array",
          recommendation: "string"
        });
        const estimatedDuration = params.steps.length * 8;
        console.log("[Journey Recommendation] \u2713 Analysis complete");
        return {
          ...aiAnalysis,
          estimatedDuration,
          validation: {
            hasRequiredInfo: validation.hasRequiredInfo,
            missingInformation: validation.missingInformation,
            warnings: validation.warnings,
            recommendations: validation.recommendations,
            informationCollected: validation.informationCollected
          }
        };
      }
      /**
       * Suggest frameworks based on user goal
       */
      async suggestFrameworks(userGoal) {
        console.log("[Journey Recommendation] Suggesting frameworks for goal...");
        const llm2 = getLLMProvider();
        const prompt = `User wants to: "${userGoal}"

Available frameworks:
- strategic_understanding: Build strategic context and knowledge graph foundation
- five_whys: Root cause analysis - uncover assumptions
- business_model_canvas: Business model validation
- porters_five_forces: Competitive and industry analysis
- pestle: Macro-environmental factors and trends
- swot: Strengths, weaknesses, opportunities, threats analysis
- strategic_decisions: Make strategic choices (risk, priorities, go/no-go)

RULES:
- strategic_understanding should ALWAYS be first (builds knowledge graph foundation)
- strategic_decisions should come near the end (after analysis frameworks)
- Journey automatically ends with EPM generation (don't include it)
- Recommend 3-5 frameworks total

Recommend a sequence that will build a complete knowledge graph for this goal.

Format as JSON:
{
  "recommended": ["strategic_understanding", "framework_2", "framework_3", ...],
  "reasoning": "Why this sequence makes sense for the user's goal"
}`;
        const response = await llm2.generateStructuredResponse(prompt, {
          recommended: "array",
          reasoning: "string"
        });
        return response;
      }
    };
    journeyRecommendationService = new JourneyRecommendationService();
  }
});

// server/routes/journey-builder.ts
import { Router as Router7 } from "express";
var router7, journey_builder_default;
var init_journey_builder = __esm({
  "server/routes/journey-builder.ts"() {
    "use strict";
    init_journey_builder_service();
    init_journey_validator_service();
    init_journey_recommendation_service();
    router7 = Router7();
    router7.get("/templates", async (req, res) => {
      try {
        const templates2 = await journeyBuilderService.getTemplates();
        res.json({
          success: true,
          templates: templates2,
          count: templates2.length
        });
      } catch (error) {
        console.error("[Journey Builder API] Error fetching templates:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch journey templates"
        });
      }
    });
    router7.get("/my-templates", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const templates2 = await journeyBuilderService.getUserTemplates(userId);
        res.json({
          success: true,
          templates: templates2,
          count: templates2.length
        });
      } catch (error) {
        console.error("[Journey Builder API] Error fetching user templates:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch user templates"
        });
      }
    });
    router7.get("/templates/:templateId", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        const { templateId } = req.params;
        const template = await journeyBuilderService.getTemplateById(templateId);
        if (!template) {
          return res.status(404).json({
            success: false,
            error: "Template not found"
          });
        }
        if (!template.isSystemTemplate && template.createdBy && template.createdBy !== userId) {
          return res.status(403).json({
            success: false,
            error: "Not authorized to access this template"
          });
        }
        res.json({
          success: true,
          template
        });
      } catch (error) {
        console.error("[Journey Builder API] Error fetching template:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch template"
        });
      }
    });
    router7.post("/start-custom-journey", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const { understandingId, templateId } = req.body;
        if (!understandingId || !templateId) {
          return res.status(400).json({
            success: false,
            error: "understandingId and templateId are required"
          });
        }
        const result = await journeyBuilderService.startCustomJourneyExecution({
          userId,
          understandingId,
          templateId
        });
        res.json({
          success: true,
          ...result
        });
      } catch (error) {
        console.error("[Journey Builder API] Error starting custom journey:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Failed to start custom journey"
        });
      }
    });
    router7.get("/frameworks", async (req, res) => {
      try {
        const frameworks = await journeyBuilderService.getFrameworks();
        res.json({
          success: true,
          frameworks,
          count: frameworks.length
        });
      } catch (error) {
        console.error("[Journey Builder API] Error fetching frameworks:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch frameworks"
        });
      }
    });
    router7.post("/start", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const { templateId, customSteps, name } = req.body;
        const result = await journeyBuilderService.startJourney({
          userId,
          templateId,
          customSteps,
          name
        });
        res.json({
          success: true,
          ...result
        });
      } catch (error) {
        console.error("[Journey Builder API] Error starting journey:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Failed to start journey"
        });
      }
    });
    router7.get("/:sessionId", async (req, res) => {
      try {
        const { sessionId } = req.params;
        const journey = await journeyBuilderService.getJourney(sessionId);
        if (!journey) {
          return res.status(404).json({
            success: false,
            error: "Journey not found"
          });
        }
        res.json({
          success: true,
          journey
        });
      } catch (error) {
        console.error("[Journey Builder API] Error fetching journey:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch journey"
        });
      }
    });
    router7.post("/:sessionId/complete-step", async (req, res) => {
      try {
        const { sessionId } = req.params;
        const { stepId, result, contextUpdates } = req.body;
        if (!stepId) {
          return res.status(400).json({
            success: false,
            error: "stepId is required"
          });
        }
        const completion = await journeyBuilderService.completeStep({
          sessionId,
          stepId,
          result,
          contextUpdates
        });
        res.json({
          success: true,
          ...completion
        });
      } catch (error) {
        console.error("[Journey Builder API] Error completing step:", error);
        res.status(500).json({
          success: false,
          error: error instanceof Error ? error.message : "Failed to complete step"
        });
      }
    });
    router7.post("/validate", async (req, res) => {
      try {
        const { selectedFrameworks, userGoal } = req.body;
        if (!selectedFrameworks || !Array.isArray(selectedFrameworks)) {
          return res.status(400).json({
            success: false,
            error: "selectedFrameworks array is required"
          });
        }
        const validation = await journeyValidatorService.validateJourney({
          selectedFrameworks,
          userGoal
        });
        res.json({
          success: true,
          validation
        });
      } catch (error) {
        console.error("[Journey Builder API] Error validating journey:", error);
        res.status(500).json({
          success: false,
          error: "Failed to validate journey"
        });
      }
    });
    router7.post("/analyze", async (req, res) => {
      try {
        const { steps, userGoal } = req.body;
        if (!steps || !Array.isArray(steps)) {
          return res.status(400).json({
            success: false,
            error: "steps array is required"
          });
        }
        const analysis = await journeyRecommendationService.analyzeJourney({
          steps,
          userGoal
        });
        res.json({
          success: true,
          analysis
        });
      } catch (error) {
        console.error("[Journey Builder API] Error analyzing journey:", error);
        res.status(500).json({
          success: false,
          error: "Failed to analyze journey"
        });
      }
    });
    router7.post("/journeys", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const { name, description, steps, tags } = req.body;
        if (!name || !steps || !Array.isArray(steps)) {
          return res.status(400).json({
            success: false,
            error: "name and steps are required"
          });
        }
        const template = await journeyBuilderService.createTemplate({
          name,
          description,
          steps,
          tags: tags || ["custom"],
          createdBy: userId
        });
        res.json({
          success: true,
          journey: template
        });
      } catch (error) {
        console.error("[Journey Builder API] Error creating custom journey:", error);
        res.status(500).json({
          success: false,
          error: "Failed to create custom journey"
        });
      }
    });
    router7.post("/suggest", async (req, res) => {
      try {
        const { userGoal } = req.body;
        if (!userGoal) {
          return res.status(400).json({
            success: false,
            error: "userGoal is required"
          });
        }
        const suggestions = await journeyRecommendationService.suggestFrameworks(userGoal);
        res.json({
          success: true,
          ...suggestions
        });
      } catch (error) {
        console.error("[Journey Builder API] Error suggesting frameworks:", error);
        res.status(500).json({
          success: false,
          error: "Failed to suggest frameworks"
        });
      }
    });
    journey_builder_default = router7;
  }
});

// server/services/assignment-engine.ts
import { addDays, differenceInDays, isWithinInterval } from "date-fns";
function validateAssignment(assignment, existingAssignments = []) {
  const errors = [];
  const warnings = [];
  if (assignment.assignedFrom >= assignment.assignedTo) {
    errors.push("Assignment end date must be after start date");
  }
  const allocationPercent = assignment.allocationPercent ?? 100;
  if (allocationPercent < 0 || allocationPercent > 100) {
    errors.push("Allocation percentage must be between 0 and 100");
  }
  const resourceAssignments = existingAssignments.filter(
    (a) => a.resourceId === assignment.resourceId && a.status === "active" && a.id !== assignment.id
    // Exclude self if editing
  );
  const conflictingAssignments = resourceAssignments.filter((a) => {
    const assignmentInterval = {
      start: assignment.assignedFrom,
      end: assignment.assignedTo
    };
    const existingInterval = {
      start: new Date(a.assignedFrom),
      end: new Date(a.assignedTo)
    };
    return isWithinInterval(existingInterval.start, assignmentInterval) || isWithinInterval(existingInterval.end, assignmentInterval) || isWithinInterval(assignmentInterval.start, existingInterval) || isWithinInterval(assignmentInterval.end, existingInterval);
  });
  if (conflictingAssignments.length > 0) {
    const totalAllocation = conflictingAssignments.reduce(
      (sum, a) => sum + (a.allocationPercent || 0),
      assignment.allocationPercent || 0
    );
    if (totalAllocation > 100) {
      warnings.push(
        `Resource ${assignment.resourceName} is overallocated (${totalAllocation}%) during this period. Conflicting tasks: ${conflictingAssignments.map((a) => a.taskName).join(", ")}`
      );
    }
  }
  return {
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function validateAllAssignments(assignments) {
  const results = /* @__PURE__ */ new Map();
  let allValid = true;
  for (let i = 0; i < assignments.length; i++) {
    const assignment = assignments[i];
    const key = assignment.id || `temp-${i}`;
    const result = validateAssignment(
      assignment,
      assignments.filter((a) => a !== assignment)
    );
    results.set(key, result);
    if (!result.valid) {
      allValid = false;
    }
  }
  return { valid: allValid, results };
}
function calculateResourceWorkload(resourceId, assignments) {
  const resourceAssignments = assignments.filter(
    (a) => a.resourceId === resourceId && a.status === "active"
  );
  if (resourceAssignments.length === 0) {
    return null;
  }
  const resourceName = resourceAssignments[0].resourceName;
  const allDates = [];
  resourceAssignments.forEach((a) => {
    const start = new Date(a.assignedFrom);
    const end = new Date(a.assignedTo);
    const days = differenceInDays(end, start) + 1;
    for (let i = 0; i < days; i++) {
      allDates.push(addDays(start, i));
    }
  });
  const uniqueDates = Array.from(new Set(allDates.map((d) => d.toISOString().split("T")[0]))).sort();
  const timeline = uniqueDates.map((dateStr) => {
    const date2 = new Date(dateStr);
    const activeAssignments = resourceAssignments.filter((a) => {
      const start = new Date(a.assignedFrom);
      const end = new Date(a.assignedTo);
      return date2 >= start && date2 <= end;
    });
    const totalAllocation = activeAssignments.reduce(
      (sum, a) => sum + (a.allocationPercent || 0),
      0
    );
    return {
      date: dateStr,
      allocation: totalAllocation,
      assignments: activeAssignments.map((a) => a.taskId)
    };
  });
  const conflicts = timeline.filter((t) => t.allocation > 100).map((t) => ({
    date: t.date,
    overallocation: t.allocation - 100,
    conflictingTasks: t.assignments
  }));
  const totalDays = uniqueDates.length;
  const averageAllocation = timeline.reduce((sum, t) => sum + t.allocation, 0) / timeline.length;
  const peakAllocation = Math.max(...timeline.map((t) => t.allocation));
  return {
    resourceId,
    resourceName,
    totalAssignments: resourceAssignments.length,
    totalDays,
    averageAllocation,
    peakAllocation,
    utilizationTimeline: timeline,
    conflicts
  };
}
function calculateProgramWorkload(assignments) {
  const workloadMap = /* @__PURE__ */ new Map();
  const resourceIds = Array.from(new Set(assignments.map((a) => a.resourceId)));
  for (const resourceId of resourceIds) {
    const workload = calculateResourceWorkload(resourceId, assignments);
    if (workload) {
      workloadMap.set(resourceId, workload);
    }
  }
  return workloadMap;
}
function getAssignmentSummary(assignments) {
  const active = assignments.filter((a) => a.status === "active");
  const uniqueResources = Array.from(new Set(assignments.map((a) => a.resourceId))).length;
  const uniqueTasks = Array.from(new Set(assignments.map((a) => a.taskId))).length;
  const confidenceValues = { high: 3, medium: 2, low: 1 };
  const totalConfidence = assignments.reduce((sum, a) => {
    return sum + (a.confidence ? confidenceValues[a.confidence] : 2);
  }, 0);
  const averageConfidence = assignments.length > 0 ? totalConfidence / assignments.length : 0;
  const assignmentsBySource = {};
  assignments.forEach((a) => {
    assignmentsBySource[a.source] = (assignmentsBySource[a.source] || 0) + 1;
  });
  return {
    totalAssignments: assignments.length,
    activeAssignments: active.length,
    uniqueResources,
    uniqueTasks,
    averageConfidence,
    assignmentsBySource
  };
}
var init_assignment_engine = __esm({
  "server/services/assignment-engine.ts"() {
    "use strict";
  }
});

// server/routes/task-assignments.ts
import { Router as Router8 } from "express";
import { eq as eq27, and as and19, inArray as inArray7, ne } from "drizzle-orm";
var router8, task_assignments_default;
var init_task_assignments = __esm({
  "server/routes/task-assignments.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_assignment_engine();
    router8 = Router8();
    router8.get("/program/:programId", async (req, res) => {
      try {
        const { programId } = req.params;
        const [program] = await db.select().from(epmPrograms).where(eq27(epmPrograms.id, programId)).limit(1);
        if (!program) {
          return res.status(404).json({ error: "EPM program not found" });
        }
        const assignments = await db.select().from(taskAssignments).where(eq27(taskAssignments.epmProgramId, programId));
        const workloadMap = calculateProgramWorkload(assignments);
        const summary = getAssignmentSummary(assignments);
        res.json({
          assignments,
          workload: Object.fromEntries(workloadMap),
          summary
        });
      } catch (error) {
        console.error("Error fetching assignments:", error);
        res.status(500).json({ error: "Failed to fetch assignments" });
      }
    });
    router8.get("/resource/:resourceId/workload", async (req, res) => {
      try {
        const { resourceId } = req.params;
        const { programId } = req.query;
        let assignments;
        if (programId) {
          assignments = await db.select().from(taskAssignments).where(
            and19(
              eq27(taskAssignments.resourceId, resourceId),
              eq27(taskAssignments.epmProgramId, programId)
            )
          );
        } else {
          assignments = await db.select().from(taskAssignments).where(eq27(taskAssignments.resourceId, resourceId));
        }
        const workload = calculateResourceWorkload(resourceId, assignments);
        if (!workload) {
          return res.json({
            message: "No assignments found for this resource",
            workload: null
          });
        }
        res.json({ workload });
      } catch (error) {
        console.error("Error calculating workload:", error);
        res.status(500).json({ error: "Failed to calculate workload" });
      }
    });
    router8.post("/", async (req, res) => {
      try {
        const parseResult = insertTaskAssignmentSchema.safeParse(req.body);
        if (!parseResult.success) {
          return res.status(400).json({
            error: "Invalid assignment data",
            errors: parseResult.error.errors.map((e) => ({
              path: e.path.join("."),
              message: e.message
            }))
          });
        }
        const assignmentData = parseResult.data;
        if (!assignmentData.epmProgramId || !assignmentData.taskId || !assignmentData.resourceId) {
          return res.status(400).json({
            error: "Missing required fields: epmProgramId, taskId, resourceId"
          });
        }
        const existingAssignments = await db.select().from(taskAssignments).where(eq27(taskAssignments.epmProgramId, assignmentData.epmProgramId));
        const validation = validateAssignment(assignmentData, existingAssignments);
        if (!validation.valid) {
          return res.status(400).json({
            error: "Invalid assignment",
            errors: validation.errors,
            warnings: validation.warnings
          });
        }
        const [newAssignment] = await db.insert(taskAssignments).values(assignmentData).returning();
        res.status(201).json({
          assignment: newAssignment,
          warnings: validation.warnings
        });
      } catch (error) {
        console.error("Error creating assignment:", error);
        res.status(500).json({ error: "Failed to create assignment" });
      }
    });
    router8.patch("/:id", async (req, res) => {
      try {
        const { id } = req.params;
        const [existing] = await db.select().from(taskAssignments).where(eq27(taskAssignments.id, id)).limit(1);
        if (!existing) {
          return res.status(404).json({ error: "Assignment not found" });
        }
        const mergedData = { ...existing, ...req.body };
        const parseResult = insertTaskAssignmentSchema.safeParse(mergedData);
        if (!parseResult.success) {
          return res.status(400).json({
            error: "Invalid assignment update data",
            errors: parseResult.error.errors.map((e) => ({
              path: e.path.join("."),
              message: e.message
            }))
          });
        }
        const updates = req.body;
        const otherAssignments = await db.select().from(taskAssignments).where(
          and19(
            eq27(taskAssignments.epmProgramId, existing.epmProgramId),
            ne(taskAssignments.id, id)
            // Exclude self
          )
        );
        const updatedAssignment = { ...existing, ...updates };
        const validation = validateAssignment(updatedAssignment, otherAssignments);
        if (!validation.valid) {
          return res.status(400).json({
            error: "Invalid assignment update",
            errors: validation.errors,
            warnings: validation.warnings
          });
        }
        const [updated] = await db.update(taskAssignments).set({ ...updates, updatedAt: /* @__PURE__ */ new Date() }).where(eq27(taskAssignments.id, id)).returning();
        res.json({
          assignment: updated,
          warnings: validation.warnings
        });
      } catch (error) {
        console.error("Error updating assignment:", error);
        res.status(500).json({ error: "Failed to update assignment" });
      }
    });
    router8.delete("/:id", async (req, res) => {
      try {
        const { id } = req.params;
        const [deleted] = await db.delete(taskAssignments).where(eq27(taskAssignments.id, id)).returning();
        if (!deleted) {
          return res.status(404).json({ error: "Assignment not found" });
        }
        res.json({ success: true, assignment: deleted });
      } catch (error) {
        console.error("Error deleting assignment:", error);
        res.status(500).json({ error: "Failed to delete assignment" });
      }
    });
    router8.post("/bulk", async (req, res) => {
      try {
        const { assignments: assignmentsData } = req.body;
        if (!Array.isArray(assignmentsData) || assignmentsData.length === 0) {
          return res.status(400).json({ error: "assignments array is required" });
        }
        const validationResult = validateAllAssignments(assignmentsData);
        if (!validationResult.valid) {
          const errors = Array.from(validationResult.results.entries()).filter(([_, result]) => !result.valid).map(([key, result]) => ({
            assignment: key,
            errors: result.errors
          }));
          return res.status(400).json({
            error: "Some assignments are invalid",
            invalidAssignments: errors
          });
        }
        const created = await db.insert(taskAssignments).values(assignmentsData).returning();
        const warnings = Array.from(validationResult.results.values()).flatMap((result) => result.warnings);
        res.status(201).json({
          assignments: created,
          count: created.length,
          warnings: warnings.length > 0 ? warnings : void 0
        });
      } catch (error) {
        console.error("Error bulk creating assignments:", error);
        res.status(500).json({ error: "Failed to create assignments" });
      }
    });
    router8.delete("/bulk", async (req, res) => {
      try {
        const { ids } = req.body;
        if (!Array.isArray(ids) || ids.length === 0) {
          return res.status(400).json({ error: "ids array is required" });
        }
        const deleted = await db.delete(taskAssignments).where(inArray7(taskAssignments.id, ids)).returning();
        res.json({
          success: true,
          count: deleted.length,
          assignments: deleted
        });
      } catch (error) {
        console.error("Error bulk deleting assignments:", error);
        res.status(500).json({ error: "Failed to delete assignments" });
      }
    });
    router8.get("/validate/:programId", async (req, res) => {
      try {
        const { programId } = req.params;
        const assignments = await db.select().from(taskAssignments).where(eq27(taskAssignments.epmProgramId, programId));
        const validationResult = validateAllAssignments(assignments);
        const issues = Array.from(validationResult.results.entries()).map(([id, result]) => ({
          assignmentId: id,
          valid: result.valid,
          errors: result.errors,
          warnings: result.warnings
        }));
        res.json({
          valid: validationResult.valid,
          totalAssignments: assignments.length,
          issues: issues.filter((i) => !i.valid || i.warnings.length > 0)
        });
      } catch (error) {
        console.error("Error validating assignments:", error);
        res.status(500).json({ error: "Failed to validate assignments" });
      }
    });
    task_assignments_default = router8;
  }
});

// server/services/export-service.ts
var init_export_service = __esm({
  "server/services/export-service.ts"() {
    "use strict";
    init_export();
  }
});

// server/routes/exports.ts
import { Router as Router9 } from "express";
import { eq as eq28, or as or3 } from "drizzle-orm";
async function resolveSessionId(sessionId, programId, userId, res) {
  if (sessionId) {
    const [understanding] = await db.select().from(strategicUnderstanding).where(or3(
      eq28(strategicUnderstanding.id, sessionId),
      eq28(strategicUnderstanding.sessionId, sessionId)
    )).limit(1);
    if (!understanding) {
      res.status(404).json({ error: "Strategic session not found" });
      return null;
    }
    const [ownership] = await db.select({ userId: strategyVersions.userId }).from(strategyVersions).where(or3(
      eq28(strategyVersions.sessionId, sessionId),
      eq28(strategyVersions.sessionId, understanding.id)
    )).limit(1);
    if (!ownership || ownership.userId !== userId) {
      res.status(403).json({ error: "Access denied" });
      return null;
    }
    return understanding.id;
  }
  if (programId) {
    const [program] = await db.select().from(epmPrograms).where(eq28(epmPrograms.id, programId)).limit(1);
    if (!program) {
      res.status(404).json({ error: "EPM program not found" });
      return null;
    }
    if (program.userId !== userId) {
      res.status(403).json({ error: "Access denied" });
      return null;
    }
    const [version] = await db.select().from(strategyVersions).where(eq28(strategyVersions.id, program.strategyVersionId)).limit(1);
    return version?.sessionId || null;
  }
  return null;
}
var router9, exports_default;
var init_exports = __esm({
  "server/routes/exports.ts"() {
    "use strict";
    init_export_service();
    init_db();
    init_schema();
    router9 = Router9();
    router9.get("/full-pass", async (req, res) => {
      try {
        let { sessionId, versionNumber, programId } = req.query;
        const userId = req.user?.claims?.sub;
        console.log("[Export] Request received:", { sessionId, versionNumber, programId, userId });
        if (!userId) {
          console.log("[Export] Authentication failed - no userId");
          res.status(401).json({ error: "Authentication required" });
          return;
        }
        if (!sessionId && !programId) {
          console.log("[Export] Validation failed - neither sessionId nor programId provided");
          res.status(400).json({ error: "sessionId or programId is required" });
          return;
        }
        let ownershipVerifiedViaProgram = false;
        if (!sessionId && programId) {
          console.log("[Export] Deriving sessionId from programId:", programId);
          const [program] = await db.select().from(epmPrograms).where(eq28(epmPrograms.id, programId)).limit(1);
          if (!program) {
            console.log("[Export] Program not found:", programId);
            res.status(404).json({ error: "EPM program not found" });
            return;
          }
          if (program.userId !== userId) {
            console.log("[Export] Program ownership check failed:", { programUserId: program.userId, requestUserId: userId });
            res.status(403).json({ error: "You do not have permission to access this program" });
            return;
          }
          ownershipVerifiedViaProgram = true;
          console.log("[Export] Ownership verified via program");
          const [version] = await db.select().from(strategyVersions).where(eq28(strategyVersions.id, program.strategyVersionId)).limit(1);
          if (!version) {
            console.log("[Export] Strategy version not found for program:", program.strategyVersionId);
            res.status(404).json({ error: "Strategy version not found for this program" });
            return;
          }
          sessionId = version.sessionId;
          versionNumber = version.versionNumber.toString();
          console.log("[Export] Derived sessionId and versionNumber:", { sessionId, versionNumber });
        }
        if (typeof sessionId !== "string") {
          console.log("[Export] Invalid sessionId type:", typeof sessionId);
          res.status(400).json({ error: "Invalid sessionId" });
          return;
        }
        console.log("[Export] Checking strategic understanding for sessionId:", sessionId);
        const [understanding] = await db.select().from(strategicUnderstanding).where(or3(
          eq28(strategicUnderstanding.id, sessionId),
          eq28(strategicUnderstanding.sessionId, sessionId)
        )).limit(1);
        if (!understanding) {
          console.log("[Export] Strategic session not found for sessionId:", sessionId);
          res.status(404).json({ error: "Strategic session not found" });
          return;
        }
        if (!ownershipVerifiedViaProgram) {
          console.log("[Export] Verifying ownership for sessionId:", sessionId);
          const ownershipCheck = await db.select({ userId: strategyVersions.userId }).from(strategyVersions).where(or3(
            eq28(strategyVersions.sessionId, sessionId),
            eq28(strategyVersions.sessionId, understanding.id)
          )).limit(1);
          if (!ownershipCheck || ownershipCheck.length === 0) {
            console.log("[Export] No strategy versions found for sessionId:", sessionId);
            res.status(404).json({ error: "No strategy versions found for this session" });
            return;
          }
          if (ownershipCheck[0].userId !== userId) {
            console.log("[Export] Ownership check failed:", { versionUserId: ownershipCheck[0].userId, requestUserId: userId });
            res.status(403).json({ error: "You do not have permission to access this strategic session" });
            return;
          }
          console.log("[Export] Ownership verified for user:", userId);
        }
        if (programId && sessionId === req.query.sessionId) {
          console.log("[Export] Verifying program ownership for programId:", programId);
          const [program] = await db.select().from(epmPrograms).where(eq28(epmPrograms.id, programId)).limit(1);
          if (!program) {
            console.log("[Export] Program not found:", programId);
            res.status(404).json({ error: "EPM program not found" });
            return;
          }
          if (program.userId !== userId) {
            console.log("[Export] Program ownership check failed:", { programUserId: program.userId, requestUserId: userId });
            res.status(403).json({ error: "You do not have permission to access this program" });
            return;
          }
        }
        const sanitizeFilename = (title) => {
          return title.replace(/[^a-zA-Z0-9\s-]/g, "").replace(/\s+/g, "-").replace(/-+/g, "-").trim().substring(0, 100);
        };
        let exportTitle = "Qgentic Export";
        try {
          if (understanding && understanding.title) {
            exportTitle = sanitizeFilename(understanding.title);
            console.log("[Export] Using understanding title for filename:", exportTitle);
          }
        } catch (err) {
          console.warn("[Export] Failed to get title, using default:", err);
        }
        const versionStr = versionNumber ? ` v${versionNumber}` : "";
        const filename = `${exportTitle}${versionStr}.zip`;
        console.log("[Export] Starting export generation:", { sessionId, versionNumber, programId, filename });
        res.setHeader("Content-Type", "application/zip");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
        await generateFullPassExport(
          {
            sessionId,
            versionNumber: versionNumber ? parseInt(versionNumber, 10) : void 0,
            programId,
            userId
          },
          res
        );
        console.log("[Export] Export generation completed successfully");
      } catch (error) {
        console.error("[Export] Error generating full-pass export:", error);
        console.error("[Export] Error stack:", error instanceof Error ? error.stack : "No stack trace");
        if (!res.headersSent) {
          const errorMessage = error instanceof Error ? error.message : "Failed to generate export";
          console.log("[Export] Sending error response:", errorMessage);
          res.status(500).json({ error: errorMessage });
        } else {
          console.log("[Export] Headers already sent, ending response");
          res.end();
        }
      }
    });
    router9.get("/excel", async (req, res) => {
      try {
        const { sessionId, programId } = req.query;
        const userId = req.user?.claims?.sub;
        if (!userId) {
          res.status(401).json({ error: "Authentication required" });
          return;
        }
        if (!sessionId && !programId) {
          res.status(400).json({ error: "sessionId or programId is required" });
          return;
        }
        const resolvedSessionId = await resolveSessionId(sessionId, programId, userId, res);
        if (!resolvedSessionId) return;
        const exportPackage = await loadExportData(resolvedSessionId, void 0, programId, userId);
        if (!exportPackage.epm?.program) {
          res.status(404).json({ error: "No EPM program found for this session. Generate an EPM program first." });
          return;
        }
        const excelBuffer = await generateExcelWorkbook(exportPackage);
        const filename = `epm-program-${resolvedSessionId.substring(0, 8)}.xlsx`;
        res.setHeader("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
        res.send(excelBuffer);
      } catch (error) {
        console.error("[Export] Excel export error:", error);
        res.status(500).json({ error: error instanceof Error ? error.message : "Excel export failed" });
      }
    });
    router9.get("/pdf", async (req, res) => {
      try {
        const { sessionId, programId } = req.query;
        const userId = req.user?.claims?.sub;
        if (!userId) {
          res.status(401).json({ error: "Authentication required" });
          return;
        }
        if (!sessionId && !programId) {
          res.status(400).json({ error: "sessionId or programId is required" });
          return;
        }
        const chromiumPath = findChromiumExecutable();
        if (!chromiumPath) {
          res.status(503).json({ error: "PDF generation unavailable - Chromium not installed" });
          return;
        }
        const resolvedSessionId = await resolveSessionId(sessionId, programId, userId, res);
        if (!resolvedSessionId) return;
        const exportPackage = await loadExportData(resolvedSessionId, void 0, programId, userId);
        const html = generateUiStyledHtml(exportPackage);
        const pdfBuffer = await generatePdfFromHtml(html);
        const filename = `strategic-report-${resolvedSessionId.substring(0, 8)}.pdf`;
        res.setHeader("Content-Type", "application/pdf");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
        res.send(pdfBuffer);
      } catch (error) {
        console.error("[Export] PDF export error:", error);
        res.status(500).json({ error: error instanceof Error ? error.message : "PDF export failed" });
      }
    });
    exports_default = router9;
  }
});

// server/services/knowledge-insights-service.ts
var knowledge_insights_service_exports = {};
__export(knowledge_insights_service_exports, {
  getEvidenceFromPostgres: () => getEvidenceFromPostgres,
  getIncentivesFromPostgres: () => getIncentivesFromPostgres,
  getInsightsForSession: () => getInsightsForSession2,
  getSimilarStrategiesFromPostgres: () => getSimilarStrategiesFromPostgres
});
import { eq as eq29, and as and20, desc as desc16, sql as sql10, isNotNull } from "drizzle-orm";
async function getSimilarStrategiesFromPostgres(understandingId, userId) {
  try {
    console.log(`[PG Insights] Finding similar strategies for user ${userId}, understanding ${understandingId}`);
    const [currentSession] = await db.select().from(journeySessions).where(eq29(journeySessions.understandingId, understandingId)).limit(1);
    if (!currentSession) {
      console.log("[PG Insights] No journey session found for understanding");
      return [];
    }
    const currentContext = currentSession.accumulatedContext;
    const currentInput = currentContext?.userInput || "";
    const currentUnderstandingSessions = await db.select({ id: journeySessions.id }).from(journeySessions).where(eq29(journeySessions.understandingId, understandingId));
    const currentSessionIds = currentUnderstandingSessions.map((s) => s.id);
    let similarStrategies;
    try {
      similarStrategies = await db.select({
        strategyId: strategyVersions.id,
        sessionId: strategyVersions.sessionId,
        versionNumber: strategyVersions.versionNumber,
        inputSummary: strategyVersions.inputSummary,
        analysisData: strategyVersions.analysisData,
        finalizedAt: strategyVersions.finalizedAt,
        createdAt: strategyVersions.createdAt,
        // Calculate similarity score using trigram similarity on inputSummary
        similarity: sql10`
            GREATEST(
              COALESCE(similarity(${strategyVersions.inputSummary}, ${currentInput}), 0),
              0.1
            )
          `
      }).from(strategyVersions).where(
        and20(
          eq29(strategyVersions.userId, userId),
          currentSessionIds.length > 0 ? sql10`${strategyVersions.sessionId} NOT IN (${sql10.join(currentSessionIds.map((id) => sql10`${id}`), sql10`, `)})` : sql10`1=1`,
          // If no sessions, include all
          isNotNull(strategyVersions.finalizedAt)
          // Only completed strategies
        )
      ).orderBy(desc16(sql10`
          GREATEST(
            COALESCE(similarity(${strategyVersions.inputSummary}, ${currentInput}), 0),
            0.1
          )
        `)).limit(5);
    } catch (error) {
      if (error.message?.includes("similarity") || error.message?.includes("pg_trgm") || error.message?.includes("function")) {
        console.error("[PG Insights] similarity() function not available - pg_trgm extension likely missing");
        console.error("[PG Insights] Knowledge Graph features require: CREATE EXTENSION IF NOT EXISTS pg_trgm;");
        console.error("[PG Insights] Returning empty results instead of failing");
        similarStrategies = [];
      } else {
        throw error;
      }
    }
    console.log(`[PG Insights] Found ${similarStrategies.length} potentially similar strategies`);
    const results = await Promise.all(
      similarStrategies.map(async (strategy) => {
        const decryptedInputSummary = strategy.inputSummary ? await decryptKMS(strategy.inputSummary) : null;
        const decryptedAnalysisData = strategy.analysisData ? await decryptJSONKMS(strategy.analysisData) : null;
        let consentTier = "private";
        if (strategy.sessionId) {
          const [session3] = await db.select().from(journeySessions).where(eq29(journeySessions.id, strategy.sessionId)).limit(1);
          if (session3) {
            const context = session3.accumulatedContext;
            const consentValue = context?.consentPeerShare;
            if (typeof consentValue === "string") {
              if (consentValue === "private" || consentValue === "aggregate_only" || consentValue === "share_with_peers") {
                consentTier = consentValue;
              }
            } else if (consentValue === true) {
              consentTier = "share_with_peers";
            }
          }
        }
        const analysisData = decryptedAnalysisData;
        const summary = decryptedInputSummary || analysisData?.summary || analysisData?.executiveSummary || "No summary available";
        return {
          strategyId: strategy.strategyId,
          sessionId: strategy.sessionId,
          versionNumber: strategy.versionNumber,
          title: decryptedInputSummary,
          score: Number(strategy.similarity) || 0.1,
          summary: typeof summary === "string" ? summary : JSON.stringify(summary),
          completedAt: strategy.finalizedAt || strategy.createdAt,
          consent: consentTier
        };
      })
    );
    console.log(`[PG Insights] Returning ${results.length} similar strategies from user's own history`);
    return results.slice(0, 3);
  } catch (error) {
    console.error("[PG Insights] Error finding similar strategies:", error);
    throw error;
  }
}
async function getIncentivesFromPostgres(understandingId, userId) {
  try {
    console.log(`[PG Insights] Finding incentives for user ${userId}, understanding ${understandingId}`);
    const [currentSession] = await db.select().from(journeySessions).where(eq29(journeySessions.understandingId, understandingId)).limit(1);
    if (!currentSession) {
      console.log("[PG Insights] No journey session found for understanding");
      return [];
    }
    const currentContext = currentSession.accumulatedContext;
    const incentiveEntities = await db.select({
      id: strategicEntities.id,
      claim: strategicEntities.claim,
      type: strategicEntities.type,
      confidence: strategicEntities.confidence,
      source: strategicEntities.source,
      evidence: strategicEntities.evidence,
      metadata: strategicEntities.metadata
    }).from(strategicEntities).where(
      and20(
        eq29(strategicEntities.understandingId, understandingId),
        sql10`${strategicEntities.type} IN ('opportunity', 'constraint')`
      )
    ).limit(10);
    console.log(`[PG Insights] Found ${incentiveEntities.length} incentive-related entities`);
    const results = await Promise.all(
      incentiveEntities.map(async (entity) => {
        const decryptedClaim = await decryptKMS(entity.claim);
        const decryptedMetadata = entity.metadata ? await decryptJSONKMS(entity.metadata) || {} : {};
        const decryptedEvidence = entity.evidence ? await decryptKMS(entity.evidence) : null;
        const decryptedSource = await decryptKMS(entity.source);
        const metadata = decryptedMetadata;
        let score = 0.5;
        if (entity.confidence === "high") score = 0.9;
        else if (entity.confidence === "medium") score = 0.6;
        else if (entity.confidence === "low") score = 0.3;
        return {
          id: entity.id,
          name: decryptedClaim || entity.claim,
          jurisdiction: metadata?.jurisdiction || currentContext?.jurisdiction || null,
          deadline: metadata?.deadline || null,
          rationale: decryptedEvidence || decryptedSource || entity.source,
          score
        };
      })
    );
    return results;
  } catch (error) {
    console.error("[PG Insights] Error finding incentives:", error);
    throw error;
  }
}
async function getEvidenceFromPostgres(understandingId, userId) {
  try {
    console.log(`[PG Insights] Finding evidence for user ${userId}, understanding ${understandingId}`);
    const sessions2 = await db.select({ id: journeySessions.id }).from(journeySessions).where(eq29(journeySessions.understandingId, understandingId));
    const sessionIds = sessions2.map((s) => s.id);
    if (sessionIds.length === 0) {
      console.log("[PG Insights] No journey sessions found for understanding");
      return [];
    }
    const sessionReferences = await db.select({
      id: references.id,
      title: references.title,
      url: references.url,
      topics: references.topics,
      confidence: references.confidence,
      sourceType: references.sourceType
    }).from(references).where(
      and20(
        sql10`${references.sessionId} IN (${sql10.join(sessionIds.map((id) => sql10`${id}`), sql10`, `)})`,
        eq29(references.userId, userId)
      )
    ).orderBy(desc16(references.confidence)).limit(10);
    console.log(`[PG Insights] Found ${sessionReferences.length} references`);
    const urlMap = /* @__PURE__ */ new Map();
    for (const ref of sessionReferences) {
      if (ref.url && !urlMap.has(ref.url)) {
        urlMap.set(ref.url, ref);
      } else if (!ref.url) {
        urlMap.set(ref.id, ref);
      }
    }
    const results = await Promise.all(
      Array.from(urlMap.values()).map(async (ref) => {
        const decryptedTitle = await decryptKMS(ref.title);
        const topicsArray = ref.topics || null;
        return {
          referenceId: ref.id,
          title: decryptedTitle || ref.title,
          url: ref.url,
          topic: topicsArray?.[0] || null,
          confidence: ref.confidence ? Number(ref.confidence) : null
        };
      })
    );
    return results;
  } catch (error) {
    console.error("[PG Insights] Error finding evidence:", error);
    throw error;
  }
}
async function getInsightsForSession2(understandingId, userId) {
  console.log(`[PG Insights] Getting all insights for understanding ${understandingId}, user ${userId}`);
  const [similarStrategies, incentives, evidence] = await Promise.all([
    getSimilarStrategiesFromPostgres(understandingId, userId),
    getIncentivesFromPostgres(understandingId, userId),
    getEvidenceFromPostgres(understandingId, userId)
  ]);
  return {
    similarStrategies,
    incentives,
    evidence
  };
}
var init_knowledge_insights_service = __esm({
  "server/services/knowledge-insights-service.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_kms_encryption();
  }
});

// server/routes/knowledge.ts
import { Router as Router10 } from "express";
import { eq as eq30 } from "drizzle-orm";
import { z as z8 } from "zod";
var router10, sessionIdQuerySchema, knowledge_default;
var init_knowledge = __esm({
  "server/routes/knowledge.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_config();
    router10 = Router10();
    sessionIdQuerySchema = z8.object({
      sessionId: z8.string().uuid("Session ID must be a valid UUID")
    });
    router10.get("/similar-strategies", async (req, res) => {
      const startTime = Date.now();
      try {
        const validation = sessionIdQuerySchema.safeParse(req.query);
        if (!validation.success) {
          return res.status(400).json({
            success: false,
            error: "Invalid session ID",
            details: validation.error.errors
          });
        }
        const { sessionId } = validation.data;
        if (!isKnowledgeGraphEnabled() || !isNeo4jConfigured()) {
          console.log("[KG API] Knowledge Graph disabled or not configured, returning empty results");
          return res.json({
            success: true,
            similarJourneys: [],
            message: "Knowledge Graph not available"
          });
        }
        const [journeySession] = await db.select().from(journeySessions).where(eq30(journeySessions.id, sessionId)).limit(1);
        if (!journeySession) {
          return res.status(404).json({
            success: false,
            error: "Journey session not found"
          });
        }
        const kgService = await Promise.resolve().then(() => (init_knowledge_graph_service(), knowledge_graph_service_exports));
        const context = journeySession.accumulatedContext;
        const locationId = context?.locationId;
        const industryId = context?.industryId;
        const rootCause = context?.insights?.primaryRootCause || context?.insights?.rootCauses?.[0];
        const similarJourneys = await kgService.getSimilarJourneys({
          locationId,
          industryId,
          rootCause,
          limit: 3
          // Top 3 similar journeys
        });
        const duration = Date.now() - startTime;
        console.log(`[KG API] Similar strategies query completed in ${duration}ms, found ${similarJourneys.length} results`);
        res.json({
          success: true,
          similarJourneys,
          metadata: {
            sessionId,
            queryTime: duration,
            filters: {
              locationId,
              industryId,
              rootCause: rootCause ? "(root cause matched)" : void 0
            }
          }
        });
      } catch (error) {
        const duration = Date.now() - startTime;
        console.error(`[KG API] Error fetching similar strategies (${duration}ms):`, error.message);
        res.status(500).json({
          success: false,
          error: "Failed to fetch similar strategies",
          message: error.message
        });
      }
    });
    router10.get("/incentives", async (req, res) => {
      const startTime = Date.now();
      try {
        const validation = sessionIdQuerySchema.safeParse(req.query);
        if (!validation.success) {
          return res.status(400).json({
            success: false,
            error: "Invalid session ID",
            details: validation.error.errors
          });
        }
        const { sessionId } = validation.data;
        if (!isKnowledgeGraphEnabled() || !isNeo4jConfigured()) {
          console.log("[KG API] Knowledge Graph disabled or not configured, returning empty results");
          return res.json({
            success: true,
            incentives: [],
            message: "Knowledge Graph not available"
          });
        }
        const [journeySession] = await db.select().from(journeySessions).where(eq30(journeySessions.id, sessionId)).limit(1);
        if (!journeySession) {
          return res.status(404).json({
            success: false,
            error: "Journey session not found"
          });
        }
        const kgService = await Promise.resolve().then(() => (init_knowledge_graph_service(), knowledge_graph_service_exports));
        const context = journeySession.accumulatedContext;
        const jurisdictionId = context?.jurisdictionId;
        const industryId = context?.industryId;
        const locationId = context?.locationId;
        const incentives = await kgService.getAvailableIncentives({
          industryId,
          jurisdictionId,
          limit: 10
          // Top 10 applicable incentives
        });
        const duration = Date.now() - startTime;
        console.log(`[KG API] Incentives query completed in ${duration}ms, found ${incentives.length} results`);
        res.json({
          success: true,
          incentives,
          metadata: {
            sessionId,
            queryTime: duration,
            filters: {
              jurisdictionId,
              industryId,
              locationId
            }
          }
        });
      } catch (error) {
        const duration = Date.now() - startTime;
        console.error(`[KG API] Error fetching incentives (${duration}ms):`, error.message);
        res.status(500).json({
          success: false,
          error: "Failed to fetch incentives",
          message: error.message
        });
      }
    });
    router10.get("/insights/:sessionId", async (req, res) => {
      const startTime = Date.now();
      try {
        const { sessionId } = req.params;
        if (!isKnowledgeGraphEnabled()) {
          console.log("[KG API] Knowledge Graph feature disabled, returning empty insights");
          return res.json({
            success: true,
            similarStrategies: [],
            incentives: [],
            evidence: [],
            message: "Knowledge Graph feature disabled"
          });
        }
        const userId = req.user?.claims?.sub || req.user?.id;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        let understandingId;
        let journeySession;
        if (sessionId.startsWith("session-")) {
          console.log(`[KG API] Received journey session ID: ${sessionId}`);
          const [session3] = await db.select().from(journeySessions).where(eq30(journeySessions.id, sessionId)).limit(1);
          if (!session3) {
            return res.status(404).json({
              success: false,
              error: "Journey session not found"
            });
          }
          if (!session3.understandingId) {
            return res.status(404).json({
              success: false,
              error: "Journey session has no understanding"
            });
          }
          if (session3.userId !== userId) {
            console.log(`[KG API] Access denied: user ${userId} attempted to access session ${sessionId} owned by ${session3.userId}`);
            return res.status(403).json({
              success: false,
              error: "Access denied: session does not belong to authenticated user"
            });
          }
          journeySession = session3;
          understandingId = session3.understandingId;
          console.log(`[KG API] Resolved journey session ${sessionId} to understanding ${understandingId}`);
        } else if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(sessionId)) {
          console.log(`[KG API] Received UUID, treating as understanding ID: ${sessionId}`);
          const [session3] = await db.select().from(journeySessions).where(eq30(journeySessions.understandingId, sessionId)).limit(1);
          if (!session3) {
            return res.status(404).json({
              success: false,
              error: "Understanding session not found"
            });
          }
          if (session3.userId !== userId) {
            console.log(`[KG API] Access denied: user ${userId} attempted to access understanding ${sessionId} owned by ${session3.userId}`);
            return res.status(403).json({
              success: false,
              error: "Access denied: understanding does not belong to authenticated user"
            });
          }
          journeySession = session3;
          understandingId = sessionId;
        } else {
          return res.status(400).json({
            success: false,
            error: "Invalid session ID format"
          });
        }
        const context = journeySession.accumulatedContext;
        const consentPeerShare = context?.consentPeerShare ?? false;
        let insights;
        let dataSource = "postgresql";
        try {
          console.log(`[KG API] Attempting PostgreSQL-based insights for understanding ${understandingId}`);
          const pgService = await Promise.resolve().then(() => (init_knowledge_insights_service(), knowledge_insights_service_exports));
          insights = await pgService.getInsightsForSession(understandingId, userId);
          const duration2 = Date.now() - startTime;
          console.log(`[KG API] \u2713 PostgreSQL insights query completed in ${duration2}ms`);
          console.log(`[KG API]   - Similar strategies: ${insights.similarStrategies?.length || 0}`);
          console.log(`[KG API]   - Incentives: ${insights.incentives?.length || 0}`);
          console.log(`[KG API]   - Evidence: ${insights.evidence?.length || 0}`);
        } catch (pgError) {
          console.error(`[KG API] PostgreSQL insights failed:`, pgError.message);
          if (isNeo4jConfigured()) {
            try {
              console.log(`[KG API] Falling back to Neo4j for understanding ${understandingId}`);
              const kgService = await Promise.resolve().then(() => (init_knowledge_graph_service(), knowledge_graph_service_exports));
              const neo4jInsights = await kgService.getInsightsForSession(understandingId, {
                locationId: context?.locationId,
                industryId: context?.industryId,
                jurisdictionId: context?.jurisdictionId,
                rootCause: context?.insights?.primaryRootCause || context?.insights?.rootCauses?.[0]
              });
              insights = {
                similarStrategies: neo4jInsights.similarStrategies || [],
                incentives: neo4jInsights.incentives || [],
                evidence: []
                // Neo4j doesn't return evidence in same format
              };
              dataSource = "neo4j";
              console.log(`[KG API] \u2713 Neo4j fallback successful`);
            } catch (neo4jError) {
              console.error(`[KG API] Neo4j fallback also failed:`, neo4jError.message);
              throw pgError;
            }
          } else {
            console.log(`[KG API] Neo4j not configured, cannot fallback`);
            throw pgError;
          }
        }
        const duration = Date.now() - startTime;
        res.json({
          success: true,
          hasConsent: true,
          // User always has access to their own data
          similarStrategies: insights.similarStrategies || [],
          incentives: insights.incentives || [],
          evidence: insights.evidence || [],
          dataClassification: "user-scoped",
          // Only shows user's own data
          metadata: {
            sessionId,
            understandingId,
            userId,
            queryTime: duration,
            dataSource,
            consentPeerShare
            // Store actual consent value for future use
          }
        });
      } catch (error) {
        const duration = Date.now() - startTime;
        console.error(`[KG API] Error fetching insights (${duration}ms):`, error.message);
        res.status(500).json({
          success: false,
          error: "Failed to fetch knowledge graph insights",
          message: error.message
        });
      }
    });
    knowledge_default = router10;
  }
});

// server/routes/marketing-consultant.ts
import { Router as Router11 } from "express";
import { eq as eq31, sql as sql11, desc as desc17 } from "drizzle-orm";
import Anthropic7 from "@anthropic-ai/sdk";
async function classifyOffering(description) {
  const prompt = `Analyze this offering description and classify it for marketing strategy purposes:

"${description}"

Classify into these categories:

OFFERING TYPE (pick one):
- b2b_software: SaaS or software sold to businesses
- b2c_software: Apps or software sold to consumers
- professional_services: Consulting, agency, or service-based business (NOT restaurants)
- physical_product: Physical goods, products, restaurants, food & beverage, retail stores, consumer goods
- marketplace_platform: Two-sided marketplace connecting buyers/sellers
- content_education: Courses, content, coaching, education
- other: Doesn't fit above categories

IMPORTANT: Restaurants, cafes, food trucks, and food/beverage businesses are ALWAYS "physical_product" (not professional_services or other).

COMPANY STAGE (suggest based on context clues):
- idea_stage: Just an idea, no product yet
- built_no_users: Product exists but no users/customers
- early_users: Some initial users/customers (< 100)
- growing: Growing user base, finding product-market fit
- scaling: Proven model, scaling operations

GTM CONSTRAINT (suggest based on context):
- solo_founder: Single person operation
- small_team: 2-5 person team
- funded_startup: Has external funding, can invest in growth
- established_company: Existing company with resources

SALES MOTION (suggest based on offering type):
- self_serve: Users sign up and pay without talking to sales
- light_touch: Some sales involvement but quick cycle
- enterprise: Complex sales, multiple stakeholders
- partner_channel: Selling through partners/resellers

Return JSON only:
{
  "offeringType": "one of the types above",
  "suggestedStage": "one of the stages above",
  "suggestedGtmConstraint": "one of the constraints above",
  "suggestedSalesMotion": "one of the motions above",
  "confidence": 0.0-1.0,
  "reasoning": "Brief explanation of classification"
}`;
  const response = await anthropic.messages.create({
    model: "claude-sonnet-4-20250514",
    max_tokens: 500,
    messages: [{ role: "user", content: prompt }]
  });
  const content = response.content[0];
  if (content.type !== "text") {
    throw new Error("Unexpected response type from AI");
  }
  try {
    const jsonMatch = content.text.match(/\{[\s\S]*\}/);
    if (!jsonMatch) {
      throw new Error("No JSON found in response");
    }
    const result = JSON.parse(jsonMatch[0]);
    if (!OFFERING_TYPES.includes(result.offeringType)) {
      result.offeringType = "other";
    }
    if (!COMPANY_STAGES.includes(result.suggestedStage)) {
      result.suggestedStage = "idea_stage";
    }
    if (!GTM_CONSTRAINTS.includes(result.suggestedGtmConstraint)) {
      result.suggestedGtmConstraint = "solo_founder";
    }
    if (!SALES_MOTIONS.includes(result.suggestedSalesMotion)) {
      result.suggestedSalesMotion = "self_serve";
    }
    console.log(`[Marketing Consultant] Classified offering as: ${result.offeringType} (confidence: ${result.confidence})`);
    console.log(`[Marketing Consultant] Reasoning: ${result.reasoning}`);
    return result;
  } catch (error) {
    console.error("[Marketing Consultant] Failed to parse classification:", error);
    return {
      offeringType: "other",
      suggestedStage: "idea_stage",
      suggestedGtmConstraint: "solo_founder",
      suggestedSalesMotion: "self_serve",
      confidence: 0.3,
      reasoning: "Could not parse AI response, using defaults"
    };
  }
}
async function runSegmentDiscovery(id, context) {
  try {
    const { segmentDiscoveryEngine: segmentDiscoveryEngine2 } = await Promise.resolve().then(() => (init_segment_discovery_engine(), segment_discovery_engine_exports));
    const result = await segmentDiscoveryEngine2.runDiscovery(
      context,
      (step, progress) => {
        discoveryProgress.set(id, { step, progress, message: step });
        console.log(`[Segment Discovery ${id}] ${step}: ${progress}%`);
      }
    );
    const encryptedGeneLibrary = await encryptJSONKMS(result.geneLibrary);
    const encryptedGenomes = await encryptJSONKMS(result.genomes);
    const encryptedSynthesis = await encryptJSONKMS(result.synthesis);
    const parseEncrypted = (encrypted, fallback) => {
      if (!encrypted) return fallback;
      try {
        return JSON.parse(encrypted);
      } catch {
        return encrypted;
      }
    };
    await db.update(segmentDiscoveryResults).set({
      geneLibrary: parseEncrypted(encryptedGeneLibrary, result.geneLibrary),
      genomes: parseEncrypted(encryptedGenomes, result.genomes),
      synthesis: parseEncrypted(encryptedSynthesis, result.synthesis),
      status: "completed",
      completedAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq31(segmentDiscoveryResults.id, id));
    discoveryProgress.set(id, { step: "Complete", progress: 100, message: "Discovery complete!" });
    console.log(`[Segment Discovery ${id}] Completed successfully`);
  } catch (error) {
    console.error(`[Segment Discovery ${id}] Failed:`, error);
    await db.update(segmentDiscoveryResults).set({
      status: "failed",
      errorMessage: error.message,
      updatedAt: /* @__PURE__ */ new Date()
    }).where(eq31(segmentDiscoveryResults.id, id));
    discoveryProgress.set(id, { step: "Error", progress: -1, message: error.message });
  }
}
var router11, anthropic, OFFERING_TYPES, COMPANY_STAGES, GTM_CONSTRAINTS, SALES_MOTIONS, discoveryProgress, marketing_consultant_default;
var init_marketing_consultant = __esm({
  "server/routes/marketing-consultant.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_kms_encryption();
    router11 = Router11();
    anthropic = new Anthropic7({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
    OFFERING_TYPES = [
      "b2b_software",
      "b2c_software",
      "professional_services",
      "physical_product",
      "marketplace_platform",
      "content_education",
      "other"
    ];
    COMPANY_STAGES = [
      "idea_stage",
      "built_no_users",
      "early_users",
      "growing",
      "scaling"
    ];
    GTM_CONSTRAINTS = [
      "solo_founder",
      "small_team",
      "funded_startup",
      "established_company"
    ];
    SALES_MOTIONS = [
      "self_serve",
      "light_touch",
      "enterprise",
      "partner_channel"
    ];
    router11.post("/check-ambiguities", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const { userInput } = req.body;
        if (!userInput) {
          return res.status(400).json({ error: "userInput is required" });
        }
        const prompt = `Analyze this marketing/business offering for ambiguities that would affect segment discovery:

"${userInput}"

MARKETING-SPECIFIC AMBIGUITIES TO CHECK:

1. **Target Customer Ambiguity**
   - Is this B2B (businesses) or B2C (consumers)?
   - Who is the economic buyer vs the user?

2. **Value Proposition Ambiguity**
   - What specific problem does this solve?
   - Is the benefit clear?

3. **Delivery/Distribution Ambiguity**
   - How is the offering delivered (digital, physical, in-person)?
   - Is this a product or service?

4. **Pricing Model Ambiguity**
   - One-time, subscription, or usage-based?
   - What price tier are we targeting?

5. **Geographic Scope Ambiguity**
   - Local, regional, national, or global?
   - Any market-specific focus?

INSTRUCTIONS:
- Identify CRITICAL ambiguities for market segmentation
- Generate clear multiple-choice questions
- Provide 2-4 specific options per question
- Focus on marketing and go-to-market clarity

Return as JSON:
{
  "hasAmbiguities": true/false,
  "questions": [
    {
      "id": "unique_id",
      "question": "Clear question?",
      "multiSelect": false,
      "options": [
        { "value": "option_key", "label": "Short Label", "description": "Longer explanation" }
      ]
    }
  ],
  "reasoning": "Why these ambiguities matter for segmentation"
}`;
        const response = await anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1e3,
          messages: [{ role: "user", content: prompt }]
        });
        const content = response.content[0];
        if (content.type !== "text") {
          return res.status(500).json({ error: "Unexpected AI response" });
        }
        try {
          const jsonMatch = content.text.match(/\{[\s\S]*\}/);
          if (!jsonMatch) {
            return res.json({ hasAmbiguities: false, questions: [] });
          }
          const result = JSON.parse(jsonMatch[0]);
          res.json({
            hasAmbiguities: result.hasAmbiguities ?? false,
            questions: result.questions ?? [],
            reasoning: result.reasoning
          });
        } catch (parseError) {
          console.error("[Marketing Consultant] Failed to parse ambiguity response:", parseError);
          res.json({ hasAmbiguities: false, questions: [] });
        }
      } catch (error) {
        console.error("[Marketing Consultant] Error in check-ambiguities:", error);
        res.status(500).json({ error: error.message || "Failed to check ambiguities" });
      }
    });
    router11.post("/understanding", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { input, clarifications } = req.body;
        if (!input) {
          return res.status(400).json({ error: "input is required" });
        }
        const classification = await classifyOffering(input);
        const encryptedDescription = await encryptKMS(input);
        const encryptedClarifications = clarifications ? await encryptJSONKMS(clarifications) : null;
        const [newRecord] = await db.insert(segmentDiscoveryResults).values({
          userId,
          offeringDescription: encryptedDescription || input,
          offeringType: classification.offeringType,
          stage: classification.suggestedStage,
          gtmConstraint: classification.suggestedGtmConstraint,
          salesMotion: classification.suggestedSalesMotion,
          clarifications: encryptedClarifications,
          status: "pending"
        }).returning();
        res.json({
          understandingId: newRecord.id,
          classification: {
            offeringType: classification.offeringType,
            suggestedStage: classification.suggestedStage,
            suggestedGtmConstraint: classification.suggestedGtmConstraint,
            suggestedSalesMotion: classification.suggestedSalesMotion,
            confidence: classification.confidence,
            reasoning: classification.reasoning
          }
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error in understanding:", error);
        res.status(500).json({ error: error.message || "Failed to create understanding" });
      }
    });
    router11.post("/classification/confirm", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { understandingId, offeringType, stage, gtmConstraint, salesMotion, existingHypothesis } = req.body;
        if (!understandingId) {
          return res.status(400).json({ error: "understandingId is required" });
        }
        if (!offeringType || !stage || !gtmConstraint || !salesMotion) {
          return res.status(400).json({ error: "All classification fields are required" });
        }
        const [existing] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, understandingId)).limit(1);
        if (!existing) {
          return res.status(404).json({ error: "Understanding record not found" });
        }
        if (existing.userId !== userId) {
          return res.status(403).json({ error: "Not authorized to update this record" });
        }
        await db.update(segmentDiscoveryResults).set({
          offeringType,
          stage,
          gtmConstraint,
          salesMotion,
          existingHypothesis: existingHypothesis || null,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq31(segmentDiscoveryResults.id, understandingId));
        res.json({
          success: true,
          understandingId
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error in classification/confirm:", error);
        res.status(500).json({ error: error.message || "Failed to confirm classification" });
      }
    });
    router11.get("/beta-status", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const [counter] = await db.select().from(betaUsageCounters).where(eq31(betaUsageCounters.featureName, "segment_discovery")).limit(1);
        if (!counter) {
          return res.json({
            available: true,
            currentCount: 0,
            maxCount: 100
          });
        }
        const available = counter.currentCount < counter.maxCount;
        res.json({
          available,
          currentCount: counter.currentCount,
          maxCount: counter.maxCount
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error in beta-status:", error);
        res.status(500).json({ error: error.message || "Failed to check beta status" });
      }
    });
    router11.post("/beta/increment", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const [counter] = await db.select().from(betaUsageCounters).where(eq31(betaUsageCounters.featureName, "segment_discovery")).limit(1);
        if (!counter) {
          await db.insert(betaUsageCounters).values({
            featureName: "segment_discovery",
            currentCount: 1,
            maxCount: 100
          });
          return res.json({
            success: true,
            available: true
          });
        }
        if (counter.currentCount >= counter.maxCount) {
          return res.json({
            success: false,
            available: false
          });
        }
        await db.update(betaUsageCounters).set({
          currentCount: sql11`${betaUsageCounters.currentCount} + 1`,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq31(betaUsageCounters.featureName, "segment_discovery"));
        res.json({
          success: true,
          available: true
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error in beta/increment:", error);
        res.status(500).json({ error: error.message || "Failed to increment beta counter" });
      }
    });
    router11.get("/discoveries", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const records = await db.select({
          id: segmentDiscoveryResults.id,
          offeringType: segmentDiscoveryResults.offeringType,
          stage: segmentDiscoveryResults.stage,
          status: segmentDiscoveryResults.status,
          createdAt: segmentDiscoveryResults.createdAt,
          completedAt: segmentDiscoveryResults.completedAt
        }).from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.userId, userId)).orderBy(desc17(segmentDiscoveryResults.createdAt)).limit(50);
        res.json({ discoveries: records });
      } catch (error) {
        console.error("[Marketing Consultant] Error in GET discoveries:", error);
        res.status(500).json({ error: error.message || "Failed to fetch discoveries" });
      }
    });
    router11.get("/:id", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { id } = req.params;
        if (!id) {
          return res.status(400).json({ error: "ID is required" });
        }
        const [record] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
        if (!record) {
          return res.status(404).json({ error: "Record not found" });
        }
        if (record.userId !== userId) {
          return res.status(403).json({ error: "Not authorized to view this record" });
        }
        const decryptedDescription = await decryptKMS(record.offeringDescription);
        const decryptedHypothesis = record.existingHypothesis ? await decryptKMS(record.existingHypothesis) : null;
        const decryptedClarifications = record.clarifications ? await decryptJSONKMS(record.clarifications) : null;
        res.json({
          id: record.id,
          offeringDescription: decryptedDescription || record.offeringDescription,
          offeringType: record.offeringType,
          stage: record.stage,
          gtmConstraint: record.gtmConstraint,
          salesMotion: record.salesMotion,
          existingHypothesis: decryptedHypothesis,
          clarifications: decryptedClarifications,
          status: record.status,
          createdAt: record.createdAt,
          updatedAt: record.updatedAt
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error in GET /:id:", error);
        res.status(500).json({ error: error.message || "Failed to fetch record" });
      }
    });
    discoveryProgress = /* @__PURE__ */ new Map();
    router11.post("/start-discovery/:id", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { id } = req.params;
        const [record] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
        if (!record) {
          return res.status(404).json({ error: "Record not found" });
        }
        if (record.userId !== userId) {
          return res.status(403).json({ error: "Not authorized" });
        }
        if (record.status === "running") {
          return res.status(400).json({ error: "Discovery already in progress" });
        }
        await db.update(segmentDiscoveryResults).set({ status: "running", updatedAt: /* @__PURE__ */ new Date() }).where(eq31(segmentDiscoveryResults.id, id));
        discoveryProgress.set(id, { step: "Starting", progress: 0, message: "Initializing segment discovery..." });
        const decryptedDescription = await decryptKMS(record.offeringDescription);
        const offeringDescription = decryptedDescription || record.offeringDescription;
        const offeringType = record.offeringType || "other";
        const { detectSegmentationMode: detectSegmentationMode2, extractContextKeywords: extractContextKeywords2 } = await Promise.resolve().then(() => (init_segment_discovery_engine(), segment_discovery_engine_exports));
        const segmentationMode = detectSegmentationMode2(offeringType);
        const contextKeywords = segmentationMode === "b2c" ? extractContextKeywords2(offeringDescription) : void 0;
        console.log(`[Marketing Consultant] Starting discovery with ${segmentationMode.toUpperCase()} mode for offering type: ${offeringType}`);
        if (contextKeywords?.length) {
          console.log(`[Marketing Consultant] Context keywords: ${contextKeywords.join(", ")}`);
        }
        runSegmentDiscovery(id, {
          offeringDescription,
          offeringType,
          stage: record.stage || "idea_stage",
          gtmConstraint: record.gtmConstraint || "solo_founder",
          salesMotion: record.salesMotion || "self_serve",
          existingHypothesis: record.existingHypothesis || void 0,
          segmentationMode,
          contextKeywords
        });
        res.json({
          success: true,
          message: "Discovery started",
          understandingId: id
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error starting discovery:", error);
        res.status(500).json({ error: error.message || "Failed to start discovery" });
      }
    });
    router11.get("/discovery-stream/:id", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { id } = req.params;
        const [record] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
        if (!record) {
          return res.status(404).json({ error: "Record not found" });
        }
        if (record.userId !== userId) {
          return res.status(403).json({ error: "Not authorized" });
        }
        res.setHeader("Content-Type", "text/event-stream");
        res.setHeader("Cache-Control", "no-cache");
        res.setHeader("Connection", "keep-alive");
        res.setHeader("X-Accel-Buffering", "no");
        res.flushHeaders();
        res.write(`data: ${JSON.stringify({ type: "connected", message: "Discovery stream connected" })}

`);
        const heartbeatInterval = setInterval(() => {
          if (!res.writableEnded) {
            res.write(`event: heartbeat
data: ${JSON.stringify({ timestamp: Date.now() })}

`);
          }
        }, 15e3);
        const pollInterval = setInterval(async () => {
          try {
            const progress = discoveryProgress.get(id);
            if (progress) {
              if (progress.progress === 100) {
                res.write(`data: ${JSON.stringify({ type: "complete", ...progress })}

`);
                clearInterval(pollInterval);
                res.end();
                return;
              }
              if (progress.progress === -1) {
                res.write(`data: ${JSON.stringify({ type: "error", message: progress.message })}

`);
                clearInterval(pollInterval);
                res.end();
                return;
              }
              res.write(`data: ${JSON.stringify({ type: "progress", ...progress })}

`);
            } else {
              const [current] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
              if (current?.status === "completed") {
                res.write(`data: ${JSON.stringify({ type: "complete", step: "Complete", progress: 100 })}

`);
                clearInterval(pollInterval);
                res.end();
                return;
              }
              if (current?.status === "failed") {
                res.write(`data: ${JSON.stringify({ type: "error", message: current.errorMessage || "Discovery failed" })}

`);
                clearInterval(pollInterval);
                res.end();
                return;
              }
            }
          } catch (pollError) {
            console.error("[Discovery Stream] Poll error:", pollError);
          }
        }, 1e3);
        req.on("close", () => {
          clearInterval(pollInterval);
          clearInterval(heartbeatInterval);
        });
        setTimeout(() => {
          clearInterval(pollInterval);
          clearInterval(heartbeatInterval);
          res.write(`data: ${JSON.stringify({ type: "error", message: "Discovery timed out" })}

`);
          res.end();
        }, 10 * 60 * 1e3);
      } catch (error) {
        console.error("[Marketing Consultant] Error in discovery stream:", error);
        res.status(500).json({ error: error.message || "Failed to stream discovery" });
      }
    });
    router11.get("/discovery-status/:id", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { id } = req.params;
        const [record] = await db.select({
          id: segmentDiscoveryResults.id,
          status: segmentDiscoveryResults.status,
          progressMessage: segmentDiscoveryResults.progressMessage,
          errorMessage: segmentDiscoveryResults.errorMessage,
          userId: segmentDiscoveryResults.userId
        }).from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
        if (!record) {
          return res.status(404).json({ error: "Discovery not found" });
        }
        if (record.userId !== userId) {
          return res.status(403).json({ error: "Not authorized" });
        }
        res.json({
          status: record.status,
          progressMessage: record.progressMessage,
          error: record.errorMessage
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error in discovery status:", error);
        res.status(500).json({ error: error.message || "Failed to get status" });
      }
    });
    router11.delete("/discovery/:id", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { id } = req.params;
        const [record] = await db.select({
          id: segmentDiscoveryResults.id,
          userId: segmentDiscoveryResults.userId,
          status: segmentDiscoveryResults.status
        }).from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
        if (!record) {
          return res.status(404).json({ error: "Discovery not found" });
        }
        if (record.userId !== userId) {
          return res.status(403).json({ error: "Not authorized" });
        }
        await db.delete(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id));
        console.log(`[Marketing Consultant] Deleted discovery ${id} for user ${userId}`);
        res.json({ success: true, message: "Discovery cancelled and deleted" });
      } catch (error) {
        console.error("[Marketing Consultant] Error deleting discovery:", error);
        res.status(500).json({ error: error.message || "Failed to delete discovery" });
      }
    });
    router11.get("/results/:id", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { id } = req.params;
        const [record] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
        if (!record) {
          return res.status(404).json({ error: "Record not found" });
        }
        if (record.userId !== userId) {
          return res.status(403).json({ error: "Not authorized" });
        }
        let finalRecord = record;
        const maxRetries = 3;
        for (let attempt = 0; attempt < maxRetries; attempt++) {
          if (finalRecord.geneLibrary && finalRecord.genomes && finalRecord.synthesis) {
            break;
          }
          const delay = (attempt + 1) * 500;
          console.log(`[Results] Attempt ${attempt + 1}: Data incomplete, waiting ${delay}ms...`);
          await new Promise((resolve) => setTimeout(resolve, delay));
          const [retryRecord] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, id)).limit(1);
          if (retryRecord) {
            finalRecord = retryRecord;
            console.log(`[Results] Retry ${attempt + 1}: geneLibrary=${!!finalRecord.geneLibrary}, genomes=${!!finalRecord.genomes}, synthesis=${!!finalRecord.synthesis}`);
          }
        }
        if (!finalRecord.geneLibrary || !finalRecord.genomes) {
          console.log("[Results] Warning: Data still incomplete after retries");
        }
        const decryptedDescription = await decryptKMS(finalRecord.offeringDescription);
        const decryptedHypothesis = finalRecord.existingHypothesis ? await decryptKMS(finalRecord.existingHypothesis) : null;
        const decryptedClarifications = finalRecord.clarifications ? await decryptJSONKMS(finalRecord.clarifications) : null;
        const decryptJsonbField = async (field, fieldName) => {
          if (!field) {
            console.log(`[Decrypt ${fieldName}] Field is null/undefined`);
            return null;
          }
          console.log(`[Decrypt ${fieldName}] Type: ${typeof field}, isArray: ${Array.isArray(field)}`);
          if (typeof field === "string") {
            console.log(`[Decrypt ${fieldName}] String length: ${field.length}, starts with: ${field.substring(0, 50)}`);
          }
          if (typeof field === "object" && field !== null && !("dataKeyCiphertext" in field)) {
            console.log(`[Decrypt ${fieldName}] Returning unencrypted object as-is`);
            return field;
          }
          if (typeof field === "object" && "dataKeyCiphertext" in field) {
            console.log(`[Decrypt ${fieldName}] Decrypting object with encryption keys`);
            return await decryptJSONKMS(JSON.stringify(field));
          }
          if (typeof field === "string") {
            console.log(`[Decrypt ${fieldName}] Decrypting string`);
            const result = await decryptJSONKMS(field);
            console.log(`[Decrypt ${fieldName}] Result type: ${typeof result}, isArray: ${Array.isArray(result)}`);
            return result;
          }
          return null;
        };
        let decryptedGeneLibrary = null;
        let decryptedGenomes = null;
        let decryptedSynthesis = null;
        try {
          decryptedGeneLibrary = await decryptJsonbField(finalRecord.geneLibrary, "geneLibrary");
          console.log("[Results] geneLibrary decrypted, dimensions:", decryptedGeneLibrary?.dimensions ? Object.keys(decryptedGeneLibrary.dimensions).length : 0);
        } catch (e) {
          console.error("[Results] geneLibrary decryption failed:", e);
        }
        try {
          decryptedGenomes = await decryptJsonbField(finalRecord.genomes, "genomes");
          console.log("[Results] genomes decrypted, count:", Array.isArray(decryptedGenomes) ? decryptedGenomes.length : 0);
        } catch (e) {
          console.error("[Results] genomes decryption failed:", e);
        }
        try {
          decryptedSynthesis = await decryptJsonbField(finalRecord.synthesis, "synthesis");
          console.log("[Results] synthesis decrypted, has beachhead:", !!decryptedSynthesis?.beachhead);
        } catch (e) {
          console.error("[Results] synthesis decryption failed:", e);
        }
        res.json({
          id: finalRecord.id,
          offeringDescription: decryptedDescription || finalRecord.offeringDescription,
          offeringType: finalRecord.offeringType,
          stage: finalRecord.stage,
          gtmConstraint: finalRecord.gtmConstraint,
          salesMotion: finalRecord.salesMotion,
          existingHypothesis: decryptedHypothesis,
          clarifications: decryptedClarifications,
          geneLibrary: decryptedGeneLibrary,
          genomes: decryptedGenomes,
          synthesis: decryptedSynthesis,
          status: finalRecord.status,
          errorMessage: finalRecord.errorMessage,
          createdAt: finalRecord.createdAt,
          completedAt: finalRecord.completedAt
        });
      } catch (error) {
        console.error("[Marketing Consultant] Error in GET results:", error);
        res.status(500).json({ error: error.message || "Failed to fetch results" });
      }
    });
    router11.get("/strategic-summary/:discoveryId", async (req, res) => {
      try {
        const user = req.user;
        if (!user?.claims?.sub) {
          return res.status(401).json({ error: "Authentication required" });
        }
        const userId = user.claims.sub;
        const { discoveryId } = req.params;
        const [record] = await db.select().from(segmentDiscoveryResults).where(eq31(segmentDiscoveryResults.id, discoveryId)).limit(1);
        if (!record) {
          return res.status(404).json({ error: "Discovery not found" });
        }
        if (record.userId !== userId) {
          return res.status(403).json({ error: "Not authorized" });
        }
        if (record.status !== "completed") {
          return res.status(400).json({ error: "Discovery not yet completed" });
        }
        if (record.strategicSummary) {
          const cachedSummary = await decryptKMS(record.strategicSummary);
          console.log("[Strategic Summary] Returning cached summary for:", discoveryId);
          return res.json({ summary: cachedSummary, cached: true });
        }
        const decryptedDescription = await decryptKMS(record.offeringDescription);
        const decryptJsonbField = async (field) => {
          if (!field) return null;
          if (typeof field === "object" && field !== null && !("dataKeyCiphertext" in field)) {
            return field;
          }
          if (typeof field === "object" && "dataKeyCiphertext" in field) {
            return await decryptJSONKMS(JSON.stringify(field));
          }
          if (typeof field === "string") {
            return await decryptJSONKMS(field);
          }
          return null;
        };
        const decryptedClarifications = record.clarifications ? await decryptJsonbField(record.clarifications) : null;
        const decryptedSynthesis = await decryptJsonbField(record.synthesis);
        const beachhead = decryptedSynthesis?.beachhead;
        const backupSegments = decryptedSynthesis?.backupSegments?.slice(0, 3) || [];
        const offeringTypeLabels = {
          "b2b_software": "B2B Software",
          "b2c_software": "B2C Software",
          "professional_services": "Professional Services",
          "physical_product": "Physical Product",
          "marketplace_platform": "Marketplace/Platform",
          "content_education": "Content/Education",
          "other": "Other"
        };
        const stageLabels = {
          "idea_stage": "Idea Stage",
          "built_no_users": "Built, No Users",
          "early_users": "Early Users",
          "growing": "Growing",
          "scaling": "Scaling"
        };
        const prompt = `You are helping a user transition from market segmentation analysis to strategic planning. Generate a concise summary that will pre-fill their strategic analysis input.

## Segment Discovery Results

**Offering:** ${decryptedDescription}

**Business Context:**
- Type: ${offeringTypeLabels[record.offeringType] || record.offeringType}
- Stage: ${stageLabels[record.stage] || record.stage}
- GTM: ${record.gtmConstraint?.replace(/_/g, " ")}
- Sales Motion: ${record.salesMotion?.replace(/_/g, " ")}

${decryptedClarifications ? `**User Clarifications:** ${JSON.stringify(decryptedClarifications)}` : ""}

**Recommended Beachhead Market:**
${beachhead ? `
- Industry: ${beachhead.genes?.industry_vertical || "Not specified"}
- Company Size: ${beachhead.genes?.company_size || "Not specified"}
- Decision Maker: ${beachhead.genes?.decision_maker || "Not specified"}
- Purchase Trigger: ${beachhead.genes?.purchase_trigger || "Not specified"}
- Score: ${beachhead.fitness?.totalScore || "N/A"}/40
- Rationale: ${beachhead.rationale || "Not provided"}
` : "No beachhead identified"}

${backupSegments.length > 0 ? `**Backup Segments:**
${backupSegments.map((s, i) => `${i + 1}. ${s.genes?.industry_vertical || "Unknown"} - ${s.genes?.decision_maker || "Unknown"} (Score: ${s.fitness?.totalScore || "N/A"}/40)`).join("\n")}
` : ""}

## Task

Write a 2-3 paragraph summary suitable for pasting into a strategic analysis tool. The summary should:
1. Briefly describe what the offering is and who it's for
2. Highlight the recommended beachhead market and why it was selected
3. Note key strategic considerations for the next phase of analysis

Write in first person as if the user is describing their situation. Be concise and actionable. Do NOT use markdown headers or bullet points - write flowing prose paragraphs.`;
        console.log("[Strategic Summary] Generating LLM summary for:", discoveryId);
        const response = await anthropic.messages.create({
          model: "claude-sonnet-4-20250514",
          max_tokens: 1e3,
          messages: [{ role: "user", content: prompt }]
        });
        const summaryText = response.content[0].type === "text" ? response.content[0].text : "";
        const encryptedSummary = await encryptKMS(summaryText);
        await db.update(segmentDiscoveryResults).set({ strategicSummary: encryptedSummary, updatedAt: /* @__PURE__ */ new Date() }).where(eq31(segmentDiscoveryResults.id, discoveryId));
        console.log("[Strategic Summary] Summary generated and cached for:", discoveryId);
        res.json({ summary: summaryText, cached: false });
      } catch (error) {
        console.error("[Strategic Summary] Error:", error);
        res.status(500).json({ error: error.message || "Failed to generate summary" });
      }
    });
    marketing_consultant_default = router11;
  }
});

// server/routes/strategies-hub.ts
import { Router as Router12 } from "express";
import { eq as eq32, and as and21, or as or4, desc as desc18, sql as sql12, inArray as inArray8 } from "drizzle-orm";
var router12, strategies_hub_default;
var init_strategies_hub = __esm({
  "server/routes/strategies-hub.ts"() {
    "use strict";
    init_db();
    init_schema();
    router12 = Router12();
    router12.get("/", async (req, res) => {
      try {
        const userId = req.user.claims.sub;
        const strategies = await db.select({
          id: strategicUnderstanding.id,
          title: strategicUnderstanding.title,
          initiativeType: strategicUnderstanding.initiativeType,
          initiativeDescription: strategicUnderstanding.initiativeDescription,
          strategyMetadata: strategicUnderstanding.strategyMetadata,
          createdAt: strategicUnderstanding.createdAt,
          updatedAt: strategicUnderstanding.updatedAt,
          journeyCount: sql12`COUNT(DISTINCT ${journeySessions.id})`,
          latestJourneyStatus: sql12`MAX(${journeySessions.status})`,
          latestJourneyUpdated: sql12`MAX(${journeySessions.updatedAt})`,
          latestSessionId: sql12`(
          SELECT id FROM journey_sessions 
          WHERE understanding_id = ${strategicUnderstanding.id} 
          AND user_id = ${userId}
          ORDER BY updated_at DESC LIMIT 1
        )`
        }).from(strategicUnderstanding).innerJoin(
          journeySessions,
          and21(
            eq32(strategicUnderstanding.id, journeySessions.understandingId),
            eq32(journeySessions.userId, userId)
          )
        ).where(eq32(strategicUnderstanding.archived, false)).groupBy(strategicUnderstanding.id).orderBy(desc18(strategicUnderstanding.updatedAt));
        const understandingIds = strategies.map((s) => s.id);
        let frameworkCounts = {};
        if (understandingIds.length > 0) {
          const counts = await db.select({
            understandingId: frameworkInsights.understandingId,
            count: sql12`COUNT(DISTINCT ${frameworkInsights.frameworkName})`
          }).from(frameworkInsights).where(inArray8(frameworkInsights.understandingId, understandingIds)).groupBy(frameworkInsights.understandingId);
          frameworkCounts = Object.fromEntries(
            counts.map((c) => [c.understandingId, c.count])
          );
        }
        const serializedStrategies = strategies.map((s) => {
          const metadata = s.strategyMetadata || {};
          const insightFrameworkCount = frameworkCounts[s.id] || 0;
          const metadataFrameworkCount = (metadata.completedFrameworks || []).length;
          return {
            ...s,
            // Merge framework count into strategyMetadata for backward compatibility
            strategyMetadata: {
              ...metadata,
              completedFrameworks: metadata.completedFrameworks || [],
              // Use the higher of the two counts (framework_insights or strategyMetadata)
              frameworkInsightsCount: insightFrameworkCount
            },
            createdAt: s.createdAt instanceof Date ? s.createdAt.toISOString() : s.createdAt,
            updatedAt: s.updatedAt instanceof Date ? s.updatedAt.toISOString() : s.updatedAt,
            latestJourneyUpdated: s.latestJourneyUpdated instanceof Date ? s.latestJourneyUpdated.toISOString() : s.latestJourneyUpdated
          };
        });
        res.json(serializedStrategies);
      } catch (error) {
        console.error("Error fetching strategies:", error);
        res.status(500).json({ message: "Failed to fetch strategies" });
      }
    });
    router12.get("/latest-understanding", async (req, res) => {
      try {
        const userId = req.user.claims.sub;
        const [latestStrategy] = await db.select({
          understandingId: strategicUnderstanding.id
        }).from(strategicUnderstanding).innerJoin(
          journeySessions,
          and21(
            eq32(strategicUnderstanding.id, journeySessions.understandingId),
            eq32(journeySessions.userId, userId)
          )
        ).where(eq32(strategicUnderstanding.archived, false)).groupBy(strategicUnderstanding.id).orderBy(desc18(strategicUnderstanding.updatedAt)).limit(1);
        res.json({ understandingId: latestStrategy?.understandingId || null });
      } catch (error) {
        console.error("Error fetching latest understanding:", error);
        res.status(500).json({ message: "Failed to fetch latest understanding" });
      }
    });
    router12.get("/:id", async (req, res) => {
      try {
        const userId = req.user.claims.sub;
        const strategyId = req.params.id;
        const [ownershipCheck] = await db.select().from(journeySessions).where(
          and21(
            eq32(journeySessions.understandingId, strategyId),
            eq32(journeySessions.userId, userId)
          )
        ).limit(1);
        if (!ownershipCheck) {
          return res.status(404).json({ message: "Strategy not found" });
        }
        const { getStrategicUnderstanding: getStrategicUnderstanding2 } = await Promise.resolve().then(() => (init_secure_data_service(), secure_data_service_exports));
        const understanding = await getStrategicUnderstanding2(strategyId);
        if (!understanding) {
          return res.status(404).json({ message: "Strategy not found" });
        }
        const sessions2 = await db.select().from(journeySessions).where(
          and21(
            eq32(journeySessions.understandingId, strategyId),
            eq32(journeySessions.userId, userId)
          )
        ).orderBy(desc18(journeySessions.versionNumber));
        const sessionIds = /* @__PURE__ */ new Set();
        if (understanding.sessionId) {
          sessionIds.add(understanding.sessionId);
        }
        sessions2.forEach((session3) => sessionIds.add(session3.id));
        const sessionIdList = Array.from(sessionIds);
        const programs2 = sessionIdList.length > 0 ? await db.select({
          id: epmPrograms.id,
          userId: epmPrograms.userId,
          frameworkType: epmPrograms.frameworkType,
          status: epmPrograms.status,
          createdAt: epmPrograms.createdAt,
          strategyVersionId: epmPrograms.strategyVersionId
        }).from(epmPrograms).innerJoin(
          strategyVersions,
          eq32(epmPrograms.strategyVersionId, strategyVersions.id)
        ).where(
          and21(
            inArray8(strategyVersions.sessionId, sessionIdList),
            eq32(epmPrograms.userId, userId)
          )
        ) : [];
        const [refCount] = await db.select({ count: sql12`COUNT(*)` }).from(references).where(
          and21(
            eq32(references.understandingId, strategyId),
            eq32(references.userId, userId)
          )
        );
        res.json({
          understanding,
          sessions: sessions2,
          programs: programs2,
          referenceCount: refCount?.count || 0
        });
      } catch (error) {
        console.error("Error fetching strategy detail:", error);
        res.status(500).json({ message: "Failed to fetch strategy detail" });
      }
    });
    router12.get("/:id/references", async (req, res) => {
      try {
        const userId = req.user.claims.sub;
        const strategyId = req.params.id;
        const [understandingData] = await db.select().from(strategicUnderstanding).leftJoin(
          journeySessions,
          eq32(strategicUnderstanding.id, journeySessions.understandingId)
        ).where(
          and21(
            eq32(strategicUnderstanding.id, strategyId),
            eq32(journeySessions.userId, userId)
          )
        );
        if (!understandingData) {
          return res.status(404).json({ message: "Strategy not found" });
        }
        const strategyReferences = await db.select().from(references).where(
          and21(
            eq32(references.userId, userId),
            or4(
              eq32(references.understandingId, strategyId),
              sql12`${references.sessionId} IN (
              SELECT id FROM ${journeySessions} WHERE ${journeySessions.understandingId} = ${strategyId} AND ${journeySessions.userId} = ${userId}
            )`,
              sql12`${references.programId} IN (
              SELECT ${epmPrograms.id} FROM ${epmPrograms}
              INNER JOIN ${strategyVersions} ON ${epmPrograms.id} = ${strategyVersions.convertedProgramId}
              INNER JOIN ${journeySessions} ON ${strategyVersions.sessionId} = ${journeySessions.id}
              WHERE ${journeySessions.understandingId} = ${strategyId} AND ${epmPrograms.userId} = ${userId}
            )`
            )
          )
        ).orderBy(desc18(references.confidence), desc18(references.createdAt));
        res.json(strategyReferences);
      } catch (error) {
        console.error("Error fetching strategy references:", error);
        res.status(500).json({ message: "Failed to fetch strategy references" });
      }
    });
    strategies_hub_default = router12;
  }
});

// server/routes/epm-crud.ts
import { Router as Router13 } from "express";
var router13, requireRole, epm_crud_default;
var init_epm_crud = __esm({
  "server/routes/epm-crud.ts"() {
    "use strict";
    init_storage();
    init_schema();
    router13 = Router13();
    requireRole = (allowedRoles) => {
      return (req, res, next) => {
        const user = req.user;
        if (!user || !allowedRoles.includes(user.role || "Viewer")) {
          return res.status(403).json({ message: "Insufficient permissions" });
        }
        next();
      };
    };
    router13.get("/programs", async (req, res) => {
      try {
        const programs2 = await storage.getPrograms();
        res.json(programs2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch programs" });
      }
    });
    router13.get("/programs/:id", async (req, res) => {
      try {
        const program = await storage.getProgram(req.params.id);
        if (!program) {
          return res.status(404).json({ message: "Program not found" });
        }
        res.json(program);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch program" });
      }
    });
    router13.post("/programs", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertProgramSchema.parse(req.body);
        const program = await storage.createProgram(validatedData);
        res.status(201).json(program);
      } catch (error) {
        res.status(400).json({ message: "Invalid program data" });
      }
    });
    router13.get("/workstreams", async (req, res) => {
      try {
        const programId = req.query.programId;
        const workstreams2 = await storage.getWorkstreams(programId);
        res.json(workstreams2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch workstreams" });
      }
    });
    router13.post("/workstreams", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertWorkstreamSchema.parse(req.body);
        const workstream = await storage.createWorkstream(validatedData);
        res.status(201).json(workstream);
      } catch (error) {
        res.status(400).json({ message: "Invalid workstream data" });
      }
    });
    router13.get("/resources", async (req, res) => {
      try {
        const programId = req.query.programId;
        const resources2 = await storage.getResources(programId);
        res.json(resources2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch resources" });
      }
    });
    router13.post("/resources", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertResourceSchema.parse(req.body);
        const resource = await storage.createResource(validatedData);
        res.status(201).json(resource);
      } catch (error) {
        res.status(400).json({ message: "Invalid resource data" });
      }
    });
    router13.put("/resources/:id", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const resource = await storage.updateResource(req.params.id, req.body);
        res.json(resource);
      } catch (error) {
        res.status(400).json({ message: "Failed to update resource" });
      }
    });
    router13.get("/stage-gates", async (req, res) => {
      try {
        const programId = req.query.programId;
        const stageGates2 = await storage.getStageGates(programId);
        res.json(stageGates2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch stage gates" });
      }
    });
    router13.post("/stage-gates", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertStageGateSchema.parse(req.body);
        const stageGate = await storage.createStageGate(validatedData);
        res.status(201).json(stageGate);
      } catch (error) {
        console.error("Stage gate validation error:", error);
        res.status(400).json({ message: "Invalid stage gate data", error: error instanceof Error ? error.message : String(error) });
      }
    });
    router13.get("/stage-gates/reviews", async (req, res) => {
      try {
        const programId = req.query.programId;
        const reviews = await storage.getStageGateReviews(programId);
        res.json(reviews);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch stage gate reviews" });
      }
    });
    router13.post("/stage-gates/reviews", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const review = await storage.createStageGateReview(req.body);
        res.status(201).json(review);
      } catch (error) {
        res.status(400).json({ message: "Failed to create stage gate review" });
      }
    });
    router13.get("/tasks", async (req, res) => {
      try {
        const programId = req.query.programId;
        const workstreamId = req.query.workstreamId;
        const tasks2 = await storage.getTasks(programId, workstreamId);
        res.json(tasks2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch tasks" });
      }
    });
    router13.get("/tasks/:id", async (req, res) => {
      try {
        const task = await storage.getTask(req.params.id);
        if (!task) {
          return res.status(404).json({ message: "Task not found" });
        }
        res.json(task);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch task" });
      }
    });
    router13.post("/tasks", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertTaskSchema.parse(req.body);
        const task = await storage.createTask(validatedData);
        res.status(201).json(task);
      } catch (error) {
        res.status(400).json({ message: "Invalid task data" });
      }
    });
    router13.put("/tasks/:id", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const task = await storage.updateTask(req.params.id, req.body);
        res.json(task);
      } catch (error) {
        res.status(400).json({ message: "Failed to update task" });
      }
    });
    router13.delete("/tasks/:id", requireRole(["Admin"]), async (req, res) => {
      try {
        await storage.deleteTask(req.params.id);
        res.status(204).send();
      } catch (error) {
        res.status(400).json({ message: "Failed to delete task" });
      }
    });
    router13.get("/kpis", async (req, res) => {
      try {
        const programId = req.query.programId;
        const kpis2 = await storage.getKpis(programId);
        res.json(kpis2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch KPIs" });
      }
    });
    router13.get("/kpis/:id/measurements", async (req, res) => {
      try {
        const measurements = await storage.getKpiMeasurements(req.params.id);
        res.json(measurements);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch KPI measurements" });
      }
    });
    router13.post("/kpis", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertKpiSchema.parse(req.body);
        const kpi = await storage.createKpi(validatedData);
        res.status(201).json(kpi);
      } catch (error) {
        console.error("KPI validation error:", error);
        res.status(400).json({ message: "Invalid KPI data", error: error instanceof Error ? error.message : String(error) });
      }
    });
    router13.put("/kpis/:id", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const kpi = await storage.updateKpi(req.params.id, req.body);
        res.json(kpi);
      } catch (error) {
        res.status(400).json({ message: "Failed to update KPI" });
      }
    });
    router13.post("/kpis/:id/measurements", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const measurement = await storage.createKpiMeasurement({
          ...req.body,
          kpiId: req.params.id
        });
        res.status(201).json(measurement);
      } catch (error) {
        res.status(400).json({ message: "Failed to create KPI measurement" });
      }
    });
    router13.get("/risks", async (req, res) => {
      try {
        const programId = req.query.programId;
        const risks2 = await storage.getRisks(programId);
        res.json(risks2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch risks" });
      }
    });
    router13.get("/risks/:id", async (req, res) => {
      try {
        const risk = await storage.getRisk(req.params.id);
        if (!risk) {
          return res.status(404).json({ message: "Risk not found" });
        }
        res.json(risk);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch risk" });
      }
    });
    router13.post("/risks", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertRiskSchema.parse(req.body);
        const risk = await storage.createRisk(validatedData);
        res.status(201).json(risk);
      } catch (error) {
        res.status(400).json({ message: "Invalid risk data" });
      }
    });
    router13.put("/risks/:id", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const risk = await storage.updateRisk(req.params.id, req.body);
        res.json(risk);
      } catch (error) {
        res.status(400).json({ message: "Failed to update risk" });
      }
    });
    router13.get("/risks/:id/mitigations", async (req, res) => {
      try {
        const mitigations = await storage.getRiskMitigations(req.params.id);
        res.json(mitigations);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch risk mitigations" });
      }
    });
    router13.post("/risks/:id/mitigations", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const mitigation = await storage.createRiskMitigation({
          ...req.body,
          riskId: req.params.id
        });
        res.status(201).json(mitigation);
      } catch (error) {
        res.status(400).json({ message: "Failed to create risk mitigation" });
      }
    });
    router13.get("/benefits", async (req, res) => {
      try {
        const programId = req.query.programId;
        const benefits2 = await storage.getBenefits(programId);
        res.json(benefits2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch benefits" });
      }
    });
    router13.post("/benefits", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertBenefitSchema.parse(req.body);
        const benefit = await storage.createBenefit(validatedData);
        res.status(201).json(benefit);
      } catch (error) {
        res.status(400).json({ message: "Invalid benefit data" });
      }
    });
    router13.put("/benefits/:id", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const benefit = await storage.updateBenefit(req.params.id, req.body);
        res.json(benefit);
      } catch (error) {
        res.status(400).json({ message: "Failed to update benefit" });
      }
    });
    router13.get("/funding/sources", async (req, res) => {
      try {
        const programId = req.query.programId;
        const sources = await storage.getFundingSources(programId);
        res.json(sources);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch funding sources" });
      }
    });
    router13.get("/funding/expenses", async (req, res) => {
      try {
        const programId = req.query.programId;
        const expenses2 = await storage.getExpenses(programId);
        res.json(expenses2);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch expenses" });
      }
    });
    router13.post("/funding/sources", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertFundingSourceSchema.parse(req.body);
        const source = await storage.createFundingSource(validatedData);
        res.status(201).json(source);
      } catch (error) {
        console.error("Funding source validation error:", error);
        res.status(400).json({ message: "Failed to create funding source", error: error instanceof Error ? error.message : String(error) });
      }
    });
    router13.post("/funding/expenses", requireRole(["Admin", "Editor"]), async (req, res) => {
      try {
        const validatedData = insertExpenseSchema.parse(req.body);
        const expense = await storage.createExpense(validatedData);
        res.status(201).json(expense);
      } catch (error) {
        console.error("Expense validation error:", error);
        res.status(400).json({ message: "Invalid expense data", error: error instanceof Error ? error.message : String(error) });
      }
    });
    router13.get("/dashboard/summary", async (req, res) => {
      try {
        const programId = req.query.programId;
        const [tasks2, risks2, kpis2, benefits2, expenses2, fundingSources2] = await Promise.all([
          storage.getTasks(programId),
          storage.getRisks(programId),
          storage.getKpis(programId),
          storage.getBenefits(programId),
          storage.getExpenses(programId),
          storage.getFundingSources(programId)
        ]);
        const totalBudget = fundingSources2.reduce((sum, source) => sum + parseFloat(source.allocatedAmount || "0"), 0);
        const totalSpent = expenses2.reduce((sum, expense) => sum + parseFloat(expense.amount || "0"), 0);
        const tasksByStatus = tasks2.reduce((acc, task) => {
          const status = task.status || "unknown";
          acc[status] = (acc[status] || 0) + 1;
          return acc;
        }, {});
        const risksByPriority = risks2.reduce((acc, risk) => {
          const priority = risk.priority || "unknown";
          acc[priority] = (acc[priority] || 0) + 1;
          return acc;
        }, {});
        res.json({
          tasks: {
            total: tasks2.length,
            byStatus: tasksByStatus
          },
          risks: {
            total: risks2.length,
            byPriority: risksByPriority
          },
          kpis: {
            total: kpis2.length
          },
          benefits: {
            total: benefits2.length
          },
          financial: {
            totalBudget,
            totalSpent,
            remaining: totalBudget - totalSpent
          }
        });
      } catch (error) {
        console.error("Dashboard summary error:", error);
        res.status(500).json({ message: "Failed to fetch dashboard summary" });
      }
    });
    epm_crud_default = router13;
  }
});

// server/routes/ontology.ts
import { Router as Router14 } from "express";
var router14, ontology_default;
var init_ontology = __esm({
  "server/routes/ontology.ts"() {
    "use strict";
    init_ontology_service();
    router14 = Router14();
    router14.get("/entities", async (req, res) => {
      try {
        const entities = await ontologyService.getAllEntities();
        res.json(entities);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch entity definitions" });
      }
    });
    router14.get("/entities/:entityName", async (req, res) => {
      try {
        const entity = await ontologyService.getEntityDefinition(req.params.entityName);
        if (!entity) {
          return res.status(404).json({ message: "Entity not found" });
        }
        res.json(entity);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch entity definition" });
      }
    });
    router14.get("/entities/:entityName/context", async (req, res) => {
      try {
        const context = await ontologyService.getFullEntityContext(req.params.entityName);
        res.json(context);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch entity context" });
      }
    });
    router14.get("/relationships", async (req, res) => {
      try {
        const { entity, direction } = req.query;
        if (entity) {
          const relationships = await ontologyService.getEntityRelationships(
            entity,
            direction || "both"
          );
          res.json(relationships);
        } else {
          res.status(400).json({ message: "Entity parameter required" });
        }
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch relationships" });
      }
    });
    router14.get("/validation-rules", async (req, res) => {
      try {
        const { entity, category, severity, enabled } = req.query;
        const rules = await ontologyService.getValidationRules({
          entity,
          category,
          severity,
          enabled: enabled === "true" ? true : enabled === "false" ? false : void 0
        });
        res.json(rules);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch validation rules" });
      }
    });
    router14.post("/validate", async (req, res) => {
      try {
        const { entityName, data } = req.body;
        if (!entityName || !data) {
          return res.status(400).json({ message: "entityName and data required" });
        }
        const result = await ontologyService.validateEntityData(entityName, data);
        res.json(result);
      } catch (error) {
        res.status(500).json({ message: "Failed to validate entity data" });
      }
    });
    router14.get("/completeness-checks", async (req, res) => {
      try {
        const { entity, checkType, importance, enabled } = req.query;
        const checks = await ontologyService.getCompletenessChecks({
          entity,
          checkType,
          importance,
          enabled: enabled === "true" ? true : enabled === "false" ? false : void 0
        });
        res.json(checks);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch completeness checks" });
      }
    });
    router14.post("/check-completeness", async (req, res) => {
      try {
        const { entityName, data } = req.body;
        if (!entityName || !data) {
          return res.status(400).json({ message: "entityName and data required" });
        }
        const result = await ontologyService.checkCompleteness(entityName, data);
        res.json(result);
      } catch (error) {
        res.status(500).json({ message: "Failed to check completeness" });
      }
    });
    router14.get("/cascade-impacts", async (req, res) => {
      try {
        const { trigger } = req.query;
        const impacts = await ontologyService.getCascadeImpacts(trigger);
        res.json(impacts);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch cascade impacts" });
      }
    });
    router14.get("/domain-terms", async (req, res) => {
      try {
        const { term } = req.query;
        if (term) {
          const domainTerm = await ontologyService.getDomainTerm(term);
          if (!domainTerm) {
            return res.status(404).json({ message: "Term not found" });
          }
          res.json(domainTerm);
        } else {
          const terms = await ontologyService.getAllDomainTerms();
          res.json(terms);
        }
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch domain terms" });
      }
    });
    router14.get("/framework-mappings", async (req, res) => {
      try {
        const { framework, epmEntity } = req.query;
        const mappings = await ontologyService.getFrameworkMappings({
          framework,
          epmEntity
        });
        res.json(mappings);
      } catch (error) {
        res.status(500).json({ message: "Failed to fetch framework mappings" });
      }
    });
    ontology_default = router14;
  }
});

// server/routes/module-registry.ts
import { Router as Router15 } from "express";
var moduleRegistryRouter;
var init_module_registry = __esm({
  "server/routes/module-registry.ts"() {
    "use strict";
    init_registry();
    moduleRegistryRouter = Router15();
    moduleRegistryRouter.get("/modules", (_req, res) => {
      try {
        const modules = moduleRegistry.listModules();
        res.json({
          success: true,
          count: modules.length,
          modules: modules.map((m) => ({
            id: m.id,
            name: m.name,
            version: m.version,
            description: m.description,
            type: m.type,
            inputs: m.inputs,
            outputs: m.outputs,
            requires: m.requires,
            tags: m.tags,
            estimatedDuration: m.estimatedDuration,
            isActive: m.isActive,
            uiComponent: m.uiComponent
          }))
        });
      } catch (error) {
        console.error("[ModuleRegistry API] Error listing modules:", error);
        res.status(500).json({ success: false, error: "Failed to list modules" });
      }
    });
    moduleRegistryRouter.get("/modules/:id", (req, res) => {
      try {
        const module2 = moduleRegistry.getModule(req.params.id);
        if (!module2) {
          return res.status(404).json({ success: false, error: `Module not found: ${req.params.id}` });
        }
        res.json({ success: true, module: module2 });
      } catch (error) {
        console.error("[ModuleRegistry API] Error getting module:", error);
        res.status(500).json({ success: false, error: "Failed to get module" });
      }
    });
    moduleRegistryRouter.get("/journeys", (_req, res) => {
      try {
        const journeys = moduleRegistry.listJourneys();
        res.json({
          success: true,
          count: journeys.length,
          journeys: journeys.map((j) => ({
            id: j.id,
            name: j.name,
            version: j.version,
            description: j.description,
            modules: j.modules,
            pageSequence: j.pageSequence,
            transitions: j.transitions,
            estimatedDuration: j.estimatedDuration,
            available: j.available,
            summaryBuilder: j.summaryBuilder,
            tags: j.tags
          }))
        });
      } catch (error) {
        console.error("[ModuleRegistry API] Error listing journeys:", error);
        res.status(500).json({ success: false, error: "Failed to list journeys" });
      }
    });
    moduleRegistryRouter.get("/journeys/:id", (req, res) => {
      try {
        const journey = moduleRegistry.getJourney(req.params.id);
        if (!journey) {
          return res.status(404).json({ success: false, error: `Journey not found: ${req.params.id}` });
        }
        res.json({
          success: true,
          journey: {
            id: journey.id,
            name: journey.name,
            version: journey.version,
            description: journey.description,
            modules: journey.modules,
            pageSequence: journey.pageSequence,
            transitions: journey.transitions,
            estimatedDuration: journey.estimatedDuration,
            available: journey.available,
            summaryBuilder: journey.summaryBuilder,
            defaultReadiness: journey.defaultReadiness,
            insightsConfig: journey.insightsConfig,
            tags: journey.tags
          }
        });
      } catch (error) {
        console.error("[ModuleRegistry API] Error getting journey:", error);
        res.status(500).json({ success: false, error: "Failed to get journey" });
      }
    });
    moduleRegistryRouter.get("/stats", (_req, res) => {
      try {
        const stats = moduleRegistry.getStats();
        res.json({ success: true, ...stats });
      } catch (error) {
        console.error("[ModuleRegistry API] Error getting stats:", error);
        res.status(500).json({ success: false, error: "Failed to get stats" });
      }
    });
  }
});

// server/modules/compatibility.ts
function isConnectionAllowed(sourceModuleId, sourcePortId, targetModuleId, targetPortId, sourceOutputType, targetInputType) {
  const explicitRule = connectionRules.find(
    (r) => r.sourceModuleId === sourceModuleId && r.sourcePortId === sourcePortId && r.targetModuleId === targetModuleId && r.targetPortId === targetPortId
  );
  if (explicitRule) {
    return { allowed: explicitRule.allowed, reason: explicitRule.reason };
  }
  const typeCompatibility = dataTypeCompatibility.find((d) => d.outputType === sourceOutputType);
  if (typeCompatibility && typeCompatibility.compatibleInputTypes.includes(targetInputType)) {
    return { allowed: true };
  }
  if (targetInputType === "any") {
    return { allowed: true };
  }
  return { allowed: false, reason: `Type mismatch: ${sourceOutputType} cannot connect to ${targetInputType}` };
}
function detectCycle(nodes, edges) {
  const adjacencyList = /* @__PURE__ */ new Map();
  for (const node of nodes) {
    adjacencyList.set(node.id, []);
  }
  for (const edge of edges) {
    const targets = adjacencyList.get(edge.sourceNodeId) || [];
    targets.push(edge.targetNodeId);
    adjacencyList.set(edge.sourceNodeId, targets);
  }
  const visited = /* @__PURE__ */ new Set();
  const recStack = /* @__PURE__ */ new Set();
  const cyclePath = [];
  function dfs(nodeId) {
    visited.add(nodeId);
    recStack.add(nodeId);
    cyclePath.push(nodeId);
    const neighbors = adjacencyList.get(nodeId) || [];
    for (const neighbor of neighbors) {
      if (!visited.has(neighbor)) {
        if (dfs(neighbor)) {
          return true;
        }
      } else if (recStack.has(neighbor)) {
        cyclePath.push(neighbor);
        return true;
      }
    }
    recStack.delete(nodeId);
    cyclePath.pop();
    return false;
  }
  for (const node of nodes) {
    if (!visited.has(node.id)) {
      if (dfs(node.id)) {
        return { hasCycle: true, cycleNodes: cyclePath };
      }
    }
  }
  return { hasCycle: false };
}
function getExecutionOrder(nodes, edges) {
  const inDegree = /* @__PURE__ */ new Map();
  const adjacencyList = /* @__PURE__ */ new Map();
  for (const node of nodes) {
    inDegree.set(node.id, 0);
    adjacencyList.set(node.id, []);
  }
  for (const edge of edges) {
    const currentDegree = inDegree.get(edge.targetNodeId) || 0;
    inDegree.set(edge.targetNodeId, currentDegree + 1);
    const targets = adjacencyList.get(edge.sourceNodeId) || [];
    targets.push(edge.targetNodeId);
    adjacencyList.set(edge.sourceNodeId, targets);
  }
  const queue = [];
  const result = [];
  inDegree.forEach((degree, nodeId) => {
    if (degree === 0) {
      queue.push(nodeId);
    }
  });
  while (queue.length > 0) {
    const current = queue.shift();
    result.push(current);
    const neighbors = adjacencyList.get(current) || [];
    for (const neighbor of neighbors) {
      const newDegree = (inDegree.get(neighbor) || 1) - 1;
      inDegree.set(neighbor, newDegree);
      if (newDegree === 0) {
        queue.push(neighbor);
      }
    }
  }
  return result;
}
var dataTypeCompatibility, connectionRules;
var init_compatibility = __esm({
  "server/modules/compatibility.ts"() {
    "use strict";
    dataTypeCompatibility = [
      {
        outputType: "strategic_context",
        compatibleInputTypes: ["strategic_context", "any", "business_context"]
      },
      {
        outputType: "bmc_output",
        compatibleInputTypes: ["bmc_output", "business_context", "any"]
      },
      {
        outputType: "five_whys_output",
        compatibleInputTypes: ["five_whys_output", "design_constraints", "any"]
      },
      {
        outputType: "swot_output",
        compatibleInputTypes: ["swot_output", "current_state", "strategic_analysis", "any"]
      },
      {
        outputType: "porters_output",
        compatibleInputTypes: ["porters_output", "competitive_forces", "industry_analysis", "any"]
      },
      {
        outputType: "pestle_output",
        compatibleInputTypes: ["pestle_output", "external_factors", "macro_factors", "any"]
      },
      {
        outputType: "segment_discovery_output",
        compatibleInputTypes: ["segment_discovery_output", "target_segments", "customer_context", "any"]
      },
      {
        outputType: "ansoff_output",
        compatibleInputTypes: ["ansoff_output", "growth_strategy", "any"]
      },
      {
        outputType: "blue_ocean_output",
        compatibleInputTypes: ["blue_ocean_output", "any"]
      },
      {
        outputType: "vrio_output",
        compatibleInputTypes: ["vrio_output", "resource_analysis", "any"]
      },
      {
        outputType: "value_chain_output",
        compatibleInputTypes: ["value_chain_output", "any"]
      },
      {
        outputType: "bcg_matrix_output",
        compatibleInputTypes: ["bcg_matrix_output", "portfolio_analysis", "any"]
      },
      {
        outputType: "scenario_planning_output",
        compatibleInputTypes: ["scenario_planning_output", "future_scenarios", "any"]
      },
      {
        outputType: "jobs_to_be_done_output",
        compatibleInputTypes: ["jobs_to_be_done_output", "customer_jobs", "any"]
      },
      {
        outputType: "okr_output",
        compatibleInputTypes: ["okr_output", "objectives", "any"]
      },
      {
        outputType: "string",
        compatibleInputTypes: ["string", "any"]
      },
      {
        outputType: "marketing_context",
        compatibleInputTypes: ["marketing_context", "classification", "any"]
      }
    ];
    connectionRules = [
      { sourceModuleId: "bmc-analyzer", sourcePortId: "bmcResults", targetModuleId: "swot-analyzer", targetPortId: "business_context", allowed: true },
      { sourceModuleId: "bmc-analyzer", sourcePortId: "bmcResults", targetModuleId: "porters-analyzer", targetPortId: "business_context", allowed: true },
      { sourceModuleId: "bmc-analyzer", sourcePortId: "bmcResults", targetModuleId: "value-chain-analyzer", targetPortId: "business_context", allowed: true },
      { sourceModuleId: "bmc-analyzer", sourcePortId: "bmcResults", targetModuleId: "ansoff-analyzer", targetPortId: "business_context", allowed: true },
      { sourceModuleId: "swot-analyzer", sourcePortId: "output", targetModuleId: "ansoff-analyzer", targetPortId: "swot_analysis", allowed: true },
      { sourceModuleId: "swot-analyzer", sourcePortId: "output", targetModuleId: "blue-ocean-analyzer", targetPortId: "current_state", allowed: true },
      { sourceModuleId: "swot-analyzer", sourcePortId: "output", targetModuleId: "ocean-strategy-analyzer", targetPortId: "current_state", allowed: true },
      { sourceModuleId: "swot-analyzer", sourcePortId: "output", targetModuleId: "okr-generator", targetPortId: "strategic_analysis", allowed: true },
      { sourceModuleId: "porters-analyzer", sourcePortId: "output", targetModuleId: "competitive-positioning-analyzer", targetPortId: "competitive_forces", allowed: true },
      { sourceModuleId: "porters-analyzer", sourcePortId: "output", targetModuleId: "blue-ocean-analyzer", targetPortId: "industry_analysis", allowed: true },
      { sourceModuleId: "porters-analyzer", sourcePortId: "output", targetModuleId: "swot-analyzer", targetPortId: "business_context", allowed: true },
      { sourceModuleId: "segment-discovery-analyzer", sourcePortId: "output", targetModuleId: "jobs-to-be-done-analyzer", targetPortId: "target_segments", allowed: true },
      { sourceModuleId: "segment-discovery-analyzer", sourcePortId: "output", targetModuleId: "value-chain-analyzer", targetPortId: "customer_context", allowed: true },
      { sourceModuleId: "segment-discovery-analyzer", sourcePortId: "output", targetModuleId: "competitive-positioning-analyzer", targetPortId: "target_segments", allowed: true },
      { sourceModuleId: "pestle-analyzer", sourcePortId: "output", targetModuleId: "scenario-planning-analyzer", targetPortId: "macro_factors", allowed: true },
      { sourceModuleId: "pestle-analyzer", sourcePortId: "output", targetModuleId: "swot-analyzer", targetPortId: "external_factors", allowed: true },
      { sourceModuleId: "five-whys-analyzer", sourcePortId: "output", targetModuleId: "bmc-analyzer", targetPortId: "designConstraints", allowed: true },
      { sourceModuleId: "okr-generator", sourcePortId: "output", targetModuleId: "bmc-analyzer", targetPortId: "strategicContext", allowed: false, reason: "OKRs are an output, not input to business model analysis" },
      { sourceModuleId: "okr-generator", sourcePortId: "output", targetModuleId: "five-whys-analyzer", targetPortId: "problem", allowed: false, reason: "OKRs cannot be used as input to root cause analysis" },
      { sourceModuleId: "epm-generator", sourcePortId: "output", targetModuleId: "bmc-analyzer", targetPortId: "strategicContext", allowed: false, reason: "EPM output cannot feed back into analysis" }
    ];
  }
});

// server/journey/bridges/whys-to-swot-bridge.ts
function transformWhysToSwot(rawWhysOutput, context) {
  const whysOutput = normalizeWhysOutput(rawWhysOutput);
  const result = {
    suggestedWeaknesses: [],
    suggestedStrengths: [],
    suggestedThreats: [],
    suggestedOpportunities: [],
    rootCauseContext: "",
    fiveWhysConfidence: "medium"
  };
  if (!whysOutput) return result;
  const rootCauses = whysOutput.rootCauses || whysOutput.root_causes || [];
  const counterMeasures = whysOutput.counterMeasures || whysOutput.counter_measures || whysOutput.countermeasures || [];
  const whysPath = whysOutput.whysPath || whysOutput.whys_path || whysOutput.analysis_path || [];
  const whysText = whysPathToText(whysPath);
  for (const rc of rootCauses) {
    const cause = typeof rc === "string" ? rc : rc.cause || rc.title || rc.name || "";
    const explanation = typeof rc === "string" ? "" : rc.explanation || rc.description || "";
    const depth = typeof rc === "object" ? rc.depth || 3 : 3;
    if (cause) {
      const isExternal = isExternalCause(cause, explanation);
      if (isExternal) {
        result.suggestedThreats.push({
          name: cause,
          description: `External factor identified through root cause analysis: ${explanation}`,
          source: "Five Whys Analysis"
        });
      } else {
        result.suggestedWeaknesses.push({
          name: cause,
          description: `Root cause identified: ${explanation}`,
          severity: depth >= 4 ? "high" : depth >= 2 ? "medium" : "low",
          source: "Five Whys Analysis"
        });
      }
    }
  }
  for (const cm of counterMeasures) {
    const action = typeof cm === "string" ? cm : cm.action || cm.title || cm.name || "";
    const rationale = typeof cm === "string" ? "" : cm.rationale || cm.description || "";
    if (action) {
      result.suggestedStrengths.push({
        name: action,
        description: `Proposed solution capability: ${rationale}`,
        source: "Five Whys Counter-measures"
      });
      result.suggestedOpportunities.push({
        name: `Implement: ${action}`,
        description: `Opportunity to address root cause and gain competitive advantage`,
        source: "Five Whys Counter-measures"
      });
    }
  }
  result.rootCauseContext = buildRootCauseContext(whysText, rootCauses);
  result.fiveWhysConfidence = whysOutput.confidence || "medium";
  console.log(`[Bridge] whys-to-swot: Transformed ${rootCauses.length} root causes \u2192 ${result.suggestedWeaknesses.length} weaknesses, ${result.suggestedThreats.length} threats`);
  return result;
}
function normalizeWhysOutput(raw) {
  if (!raw) return null;
  if (raw.data?.output) return raw.data.output;
  if (raw.output) return raw.output;
  if (raw.data) return raw.data;
  return raw;
}
function isExternalCause(cause, explanation) {
  const combined = `${cause} ${explanation}`.toLowerCase();
  const externalKeywords = [
    "market",
    "competitor",
    "regulation",
    "government",
    "economic",
    "industry",
    "external",
    "supply chain",
    "vendor",
    "customer demand",
    "technology shift",
    "legislation",
    "policy",
    "political",
    "environmental",
    "social trend"
  ];
  return externalKeywords.some((keyword) => combined.includes(keyword));
}
function buildRootCauseContext(whysPath, rootCauses) {
  const pathSummary = Array.isArray(whysPath) ? whysPath.slice(0, 5).map((w, i) => {
    const text2 = typeof w === "string" ? w : w.why || w.question || w.text || "";
    return `Why ${i + 1}: ${text2}`;
  }).join("\n") : "";
  const causesSummary = rootCauses.slice(0, 3).map((rc, i) => {
    const cause = typeof rc === "string" ? rc : rc.cause || rc.title || "";
    return `${i + 1}. ${cause}`;
  }).join("\n");
  return `Five Whys Analysis Summary:
${pathSummary}

Root Causes Identified:
${causesSummary}`;
}
var init_whys_to_swot_bridge = __esm({
  "server/journey/bridges/whys-to-swot-bridge.ts"() {
    "use strict";
    init_whys_path();
  }
});

// server/journey/bridges/swot-to-bmc-bridge.ts
function transformSwotToBmc(rawSwotOutput, context) {
  const swotOutput = normalizeSwotOutput(rawSwotOutput);
  const result = {
    strategicInsights: {
      leverageStrengths: [],
      addressWeaknesses: [],
      pursueOpportunities: [],
      mitigateThreats: []
    },
    bmcGuidance: {
      keyResourcesHints: [],
      keyActivitiesHints: [],
      valuePropositionHints: [],
      customerSegmentHints: [],
      channelHints: [],
      revenueStreamHints: [],
      costStructureHints: []
    },
    swotSummary: "",
    swotConfidence: "medium"
  };
  if (!swotOutput) return result;
  const strengths = swotOutput.strengths || [];
  const weaknesses = swotOutput.weaknesses || [];
  const opportunities = swotOutput.opportunities || [];
  const threats = swotOutput.threats || [];
  for (const s of strengths.slice(0, 5)) {
    const item = normalizeSwotItem(s);
    if (item.name) {
      result.strategicInsights.leverageStrengths.push(item);
      result.bmcGuidance.keyResourcesHints.push(`Leverage: ${item.name}`);
      result.bmcGuidance.keyActivitiesHints.push(`Build on strength: ${item.name}`);
    }
  }
  for (const w of weaknesses.slice(0, 5)) {
    const item = normalizeSwotItem(w);
    if (item.name) {
      result.strategicInsights.addressWeaknesses.push(item);
      result.bmcGuidance.valuePropositionHints.push(`Address gap: ${item.name}`);
      result.bmcGuidance.costStructureHints.push(`Investment needed: ${item.name}`);
    }
  }
  for (const o of opportunities.slice(0, 5)) {
    const item = normalizeSwotItem(o);
    if (item.name) {
      result.strategicInsights.pursueOpportunities.push(item);
      result.bmcGuidance.customerSegmentHints.push(`Target opportunity: ${item.name}`);
      result.bmcGuidance.channelHints.push(`Channel for: ${item.name}`);
      result.bmcGuidance.revenueStreamHints.push(`Revenue from: ${item.name}`);
    }
  }
  for (const t of threats.slice(0, 5)) {
    const item = normalizeSwotItem(t);
    if (item.name) {
      result.strategicInsights.mitigateThreats.push(item);
      result.bmcGuidance.costStructureHints.push(`Mitigate: ${item.name}`);
    }
  }
  result.swotSummary = buildSwotSummary(strengths, weaknesses, opportunities, threats);
  result.swotConfidence = swotOutput.confidence || swotOutput.confidenceLevel || "medium";
  console.log(`[Bridge] swot-to-bmc: Transformed SWOT (${strengths.length}S/${weaknesses.length}W/${opportunities.length}O/${threats.length}T) \u2192 BMC guidance`);
  return result;
}
function normalizeSwotOutput(raw) {
  if (!raw) return null;
  if (raw.data?.output) return raw.data.output;
  if (raw.output) return raw.output;
  if (raw.data) return raw.data;
  return raw;
}
function normalizeSwotItem(item) {
  if (typeof item === "string") {
    return { name: item, description: "" };
  }
  return {
    name: item.name || item.title || item.factor || "",
    description: item.description || item.detail || item.explanation || ""
  };
}
function buildSwotSummary(strengths, weaknesses, opportunities, threats) {
  const summarize = (items, label) => {
    const names = items.slice(0, 3).map((i) => {
      const item = normalizeSwotItem(i);
      return item.name;
    }).filter(Boolean);
    return names.length > 0 ? `${label}: ${names.join(", ")}` : "";
  };
  const parts = [
    summarize(strengths, "Key Strengths"),
    summarize(weaknesses, "Key Weaknesses"),
    summarize(opportunities, "Key Opportunities"),
    summarize(threats, "Key Threats")
  ].filter(Boolean);
  return parts.join("\n");
}
var init_swot_to_bmc_bridge = __esm({
  "server/journey/bridges/swot-to-bmc-bridge.ts"() {
    "use strict";
  }
});

// server/journey/bridges/porters-to-bmc-bridge.ts
function transformPortersToBmc(rawPortersOutput, context) {
  const portersOutput = normalizePortersOutput2(rawPortersOutput);
  const result = {
    valuePropositionHints: [],
    customerSegmentInsights: [],
    keyPartnershipConstraints: [],
    keyActivityRecommendations: [],
    revenueStreamRisks: [],
    competitiveContext: "",
    industryAttractivenessScore: 5
  };
  if (!portersOutput) return result;
  const forces = portersOutput.portersResults || portersOutput;
  let totalScore = 0;
  let scoreCount = 0;
  if (forces.competitiveRivalry || forces.competitive_rivalry) {
    const rivalry = forces.competitiveRivalry || forces.competitive_rivalry;
    const score = rivalry.score || rivalry.intensity || 5;
    totalScore += score;
    scoreCount++;
    if (score >= 7) {
      result.valuePropositionHints.push({
        hint: "Strong differentiation required",
        rationale: `High competitive rivalry (${score}/10) demands unique value proposition`,
        source: "Porter's Competitive Rivalry",
        priority: "high"
      });
    }
    const competitors = rivalry.competitors || rivalry.keyCompetitors || [];
    if (competitors.length > 0) {
      result.valuePropositionHints.push({
        hint: "Competitive positioning clarity needed",
        rationale: `${competitors.length} identified competitors require clear differentiation strategy`,
        source: "Porter's Analysis",
        priority: "medium"
      });
    }
  }
  if (forces.bargainingPowerOfBuyers || forces.buyer_power) {
    const buyerPower = forces.bargainingPowerOfBuyers || forces.buyer_power;
    const score = buyerPower.score || buyerPower.level || 5;
    totalScore += score;
    scoreCount++;
    const powerLevel = score >= 7 ? "high" : score >= 4 ? "moderate" : "low";
    result.customerSegmentInsights.push({
      segment: "Primary customer base",
      buyerPowerLevel: powerLevel,
      implication: score >= 7 ? "Focus on customer retention and switching cost creation" : "Opportunity for premium pricing with value demonstration"
    });
    if (buyerPower.factors || buyerPower.drivers) {
      const factors = buyerPower.factors || buyerPower.drivers || [];
      for (const f of factors.slice(0, 2)) {
        const factor = typeof f === "string" ? f : f.factor || f.driver || f.name || "";
        if (factor) {
          result.customerSegmentInsights.push({
            segment: "Buyer behavior",
            buyerPowerLevel: powerLevel,
            implication: `Consider: ${factor}`
          });
        }
      }
    }
  }
  if (forces.bargainingPowerOfSuppliers || forces.supplier_power) {
    const supplierPower = forces.bargainingPowerOfSuppliers || forces.supplier_power;
    const score = supplierPower.score || supplierPower.level || 5;
    totalScore += score;
    scoreCount++;
    if (score >= 6) {
      result.keyPartnershipConstraints.push({
        constraint: "Supplier dependency risk",
        supplierPowerContext: `Supplier power is ${score >= 7 ? "high" : "moderate"} (${score}/10)`,
        mitigation: "Diversify supplier base and build strategic partnerships"
      });
    }
    const analysis = supplierPower.analysis || supplierPower.description || "";
    if (analysis) {
      result.keyPartnershipConstraints.push({
        constraint: "Supply chain optimization needed",
        supplierPowerContext: analysis.substring(0, 150),
        mitigation: "Develop backup suppliers and negotiate favorable terms"
      });
    }
  }
  if (forces.threatOfNewEntrants || forces.new_entrants) {
    const entrants = forces.threatOfNewEntrants || forces.new_entrants;
    const score = entrants.score || entrants.threatLevel || 5;
    totalScore += score;
    scoreCount++;
    const barriers = entrants.barriers || entrants.entryBarriers || [];
    for (const b of barriers.slice(0, 3)) {
      const barrier = typeof b === "string" ? b : b.barrier || b.name || b.factor || "";
      if (barrier) {
        result.keyActivityRecommendations.push({
          activity: `Strengthen: ${barrier}`,
          rationale: "Maintain competitive moat",
          defensibility: score >= 7 ? "low (high threat)" : "moderate"
        });
      }
    }
    if (score >= 7) {
      result.keyActivityRecommendations.push({
        activity: "Build proprietary capabilities",
        rationale: `High new entrant threat (${score}/10) requires defensible advantages`,
        defensibility: "critical"
      });
    }
  }
  if (forces.threatOfSubstitutes || forces.substitutes) {
    const substitutes = forces.threatOfSubstitutes || forces.substitutes;
    const score = substitutes.score || substitutes.threatLevel || 5;
    totalScore += score;
    scoreCount++;
    if (score >= 6) {
      result.revenueStreamRisks.push({
        risk: "Substitute product threat",
        substitutesThreat: `Substitutes pose ${score >= 7 ? "high" : "moderate"} risk (${score}/10)`,
        recommendation: "Diversify revenue streams and increase switching costs"
      });
    }
    const substitutesAnalysis = substitutes.analysis || substitutes.description || "";
    if (substitutesAnalysis.toLowerCase().includes("digital") || substitutesAnalysis.toLowerCase().includes("online")) {
      result.revenueStreamRisks.push({
        risk: "Digital disruption potential",
        substitutesThreat: "Technology-enabled substitutes identified",
        recommendation: "Consider digital revenue streams and hybrid offerings"
      });
    }
  }
  result.industryAttractivenessScore = scoreCount > 0 ? Math.round((50 - totalScore / scoreCount * 5) / 10) : 3;
  result.competitiveContext = buildCompetitiveContext(forces, result.industryAttractivenessScore);
  console.log(`[Bridge] porters-to-bmc: Generated ${result.valuePropositionHints.length} VP hints, ${result.keyActivityRecommendations.length} activity recommendations`);
  return result;
}
function normalizePortersOutput2(raw) {
  if (!raw) return null;
  if (raw.data?.output) return raw.data.output;
  if (raw.data?.portersResults) return raw.data;
  if (raw.output?.portersResults) return raw.output;
  if (raw.portersResults) return raw;
  if (raw.data) return raw.data;
  if (raw.output) return raw.output;
  return raw;
}
function buildCompetitiveContext(forces, attractiveness) {
  const sections = [];
  sections.push(`Industry Attractiveness: ${attractiveness}/5`);
  if (forces.competitiveRivalry?.score >= 7) {
    sections.push("- High competitive intensity requires strong differentiation");
  }
  if (forces.threatOfNewEntrants?.score >= 7) {
    sections.push("- Low entry barriers necessitate defensible moats");
  }
  if (forces.threatOfSubstitutes?.score >= 7) {
    sections.push("- Substitute threats require value lock-in strategies");
  }
  return sections.join("\n");
}
var init_porters_to_bmc_bridge = __esm({
  "server/journey/bridges/porters-to-bmc-bridge.ts"() {
    "use strict";
  }
});

// server/journey/bridges/bmc-to-blueocean-bridge.ts
function transformBmcToBlueOcean(rawBmcOutput, context) {
  const bmcOutput = normalizeBmcOutput(rawBmcOutput);
  const result = {
    currentValueCurve: [],
    eliminateCandidates: [],
    reduceCandidates: [],
    raiseCandidates: [],
    createCandidates: [],
    nonCustomerInsights: [],
    businessModelContext: ""
  };
  if (!bmcOutput) return result;
  const canvas = bmcOutput.canvas || bmcOutput.bmcResults || bmcOutput;
  const valueProps = canvas.valuePropositions || canvas.value_propositions || canvas.valueProposition || [];
  for (const vp of normalizeToArray(valueProps)) {
    const proposition = extractText(vp, ["proposition", "value", "title", "name"]);
    if (proposition) {
      result.currentValueCurve.push({
        factor: proposition,
        currentLevel: "medium",
        source: "BMC Value Proposition",
        investmentLevel: "medium"
      });
    }
  }
  const costs = canvas.costStructure || canvas.cost_structure || canvas.costs || [];
  for (const cost of normalizeToArray(costs)) {
    const costItem = extractText(cost, ["cost", "item", "name", "category"]);
    const isFixed = typeof cost === "object" && (cost.type === "fixed" || cost.isFixed);
    if (costItem) {
      if (isFixed || costItem.toLowerCase().includes("overhead") || costItem.toLowerCase().includes("infrastructure")) {
        result.reduceCandidates.push({
          factor: costItem,
          rationale: "Fixed/overhead cost may be reduced through innovation",
          currentOverInvestment: "Consider if industry-standard or excessive"
        });
      }
      if (costItem.toLowerCase().includes("traditional") || costItem.toLowerCase().includes("legacy")) {
        result.eliminateCandidates.push({
          factor: costItem,
          rationale: "Legacy cost structure may be unnecessary",
          costSavingPotential: "medium"
        });
      }
    }
  }
  const activities = canvas.keyActivities || canvas.key_activities || canvas.activities || [];
  for (const activity of normalizeToArray(activities)) {
    const activityText = extractText(activity, ["activity", "name", "title"]);
    if (activityText) {
      result.currentValueCurve.push({
        factor: activityText,
        currentLevel: "medium",
        source: "BMC Key Activities",
        investmentLevel: "medium"
      });
    }
  }
  const relationships = canvas.customerRelationships || canvas.customer_relationships || canvas.relationships || [];
  for (const rel of normalizeToArray(relationships)) {
    const relText = extractText(rel, ["relationship", "type", "name"]);
    if (relText) {
      result.raiseCandidates.push({
        factor: `Customer ${relText}`,
        rationale: "Customer relationship factor to potentially enhance",
        customerBenefit: "Improved customer experience and loyalty"
      });
    }
  }
  const segments = canvas.customerSegments || canvas.customer_segments || canvas.segments || [];
  const segmentList = normalizeToArray(segments);
  if (segmentList.length > 0) {
    result.nonCustomerInsights.push({
      segment: "Adjacent market segments",
      reason: "Not currently served by existing value proposition",
      opportunity: "Potential new demand through value innovation"
    });
  }
  const channels = canvas.channels || [];
  const channelList = normalizeToArray(channels);
  const hasDigital = channelList.some((c) => {
    const text2 = extractText(c, ["channel", "name", "type"]);
    return text2 && (text2.toLowerCase().includes("digital") || text2.toLowerCase().includes("online"));
  });
  if (!hasDigital) {
    result.createCandidates.push({
      factor: "Digital/online channel presence",
      rationale: "No digital channels identified in current BMC",
      differentiationPotential: "high"
    });
  }
  const resources2 = canvas.keyResources || canvas.key_resources || canvas.resources || [];
  for (const res of normalizeToArray(resources2)) {
    const resText = extractText(res, ["resource", "name", "type"]);
    if (resText && (resText.toLowerCase().includes("unique") || resText.toLowerCase().includes("proprietary"))) {
      result.createCandidates.push({
        factor: resText,
        rationale: "Unique resource could be leveraged for differentiation",
        differentiationPotential: "high"
      });
    }
  }
  const revenues = canvas.revenueStreams || canvas.revenue_streams || canvas.revenues || [];
  const revenueList = normalizeToArray(revenues);
  if (revenueList.length === 1) {
    result.createCandidates.push({
      factor: "Diversified revenue model",
      rationale: "Single revenue stream identified - opportunity to create new models",
      differentiationPotential: "medium"
    });
  }
  result.businessModelContext = buildBmcContext(canvas, result);
  console.log(`[Bridge] bmc-to-blueocean: Generated ${result.eliminateCandidates.length} eliminate, ${result.reduceCandidates.length} reduce, ${result.raiseCandidates.length} raise, ${result.createCandidates.length} create candidates`);
  return result;
}
function normalizeBmcOutput(raw) {
  if (!raw) return null;
  if (raw.data?.output) return raw.data.output;
  if (raw.data?.canvas) return raw.data;
  if (raw.output?.canvas) return raw.output;
  if (raw.canvas) return raw;
  if (raw.bmcResults) return raw;
  if (raw.data) return raw.data;
  if (raw.output) return raw.output;
  return raw;
}
function normalizeToArray(input) {
  if (!input) return [];
  if (Array.isArray(input)) return input;
  if (typeof input === "object" && input.items) return input.items;
  if (typeof input === "string") return [input];
  return [input];
}
function extractText(item, keys) {
  if (typeof item === "string") return item;
  if (!item || typeof item !== "object") return "";
  for (const key of keys) {
    if (item[key] && typeof item[key] === "string") {
      return item[key];
    }
  }
  return item.description || item.text || item.value || "";
}
function buildBmcContext(canvas, enhancement) {
  const sections = [];
  sections.push("Business Model Summary for Blue Ocean Analysis:");
  sections.push(`- Value curve factors identified: ${enhancement.currentValueCurve.length}`);
  sections.push(`- Cost reduction opportunities: ${enhancement.reduceCandidates.length + enhancement.eliminateCandidates.length}`);
  sections.push(`- Value enhancement opportunities: ${enhancement.raiseCandidates.length + enhancement.createCandidates.length}`);
  return sections.join("\n");
}
var init_bmc_to_blueocean_bridge = __esm({
  "server/journey/bridges/bmc-to-blueocean-bridge.ts"() {
    "use strict";
  }
});

// server/journey/bridges/pestle-to-bmc-bridge.ts
function transformPestleToBmc(rawPestleOutput, context) {
  const pestleOutput = normalizePESTLEOutput(rawPestleOutput);
  const result = {
    customerSegmentHints: [],
    valuePropositionHints: [],
    channelHints: [],
    keyPartnershipHints: [],
    keyResourceHints: [],
    keyActivityHints: [],
    revenueStreamHints: [],
    costStructureHints: [],
    environmentalContext: "",
    pestleConfidence: pestleOutput?.confidenceLevel || "medium"
  };
  if (!pestleOutput?.factors) return result;
  const factors = pestleOutput.factors;
  if (factors.political && Array.isArray(factors.political)) {
    for (const f of factors.political.slice(0, 3)) {
      if (f.impact === "opportunity") {
        result.keyPartnershipHints.push({
          partner: "Government/regulatory bodies",
          rationale: `Leverage: ${f.factor}`,
          source: "PESTLE Political"
        });
      }
    }
  }
  if (factors.legal && Array.isArray(factors.legal)) {
    for (const f of factors.legal.slice(0, 3)) {
      result.keyPartnershipHints.push({
        partner: "Legal/compliance consultants",
        rationale: `Navigate: ${f.factor}`,
        source: "PESTLE Legal"
      });
      result.keyActivityHints.push({
        activity: "Regulatory compliance management",
        rationale: `Ensure compliance with: ${f.factor}`,
        source: "PESTLE Legal"
      });
    }
  }
  if (factors.economic && Array.isArray(factors.economic)) {
    for (const f of factors.economic.slice(0, 3)) {
      const lower = (f.factor || "").toLowerCase();
      if (lower.includes("growth") || lower.includes("spending") || f.impact === "opportunity") {
        result.revenueStreamHints.push({
          stream: "Market expansion revenue",
          rationale: `Capitalize on: ${f.factor}`,
          source: "PESTLE Economic"
        });
      }
      if (lower.includes("inflation") || lower.includes("cost") || f.impact === "threat") {
        result.costStructureHints.push({
          cost: "Variable costs management",
          rationale: `Monitor: ${f.factor}`,
          source: "PESTLE Economic"
        });
      }
    }
  }
  if (factors.social && Array.isArray(factors.social)) {
    for (const f of factors.social.slice(0, 3)) {
      result.customerSegmentHints.push({
        segment: "Trend-aligned customer segment",
        rationale: `Target based on: ${f.factor}`,
        source: "PESTLE Social"
      });
      if (f.impact === "opportunity") {
        result.valuePropositionHints.push({
          hint: "Align with social trends",
          rationale: `Address: ${f.factor}`,
          source: "PESTLE Social"
        });
      }
    }
  }
  if (factors.technological && Array.isArray(factors.technological)) {
    for (const f of factors.technological.slice(0, 3)) {
      result.keyResourceHints.push({
        resource: "Technology infrastructure",
        rationale: `Leverage: ${f.factor}`,
        source: "PESTLE Technological"
      });
      const lower = (f.factor || "").toLowerCase();
      if (lower.includes("digital") || lower.includes("online") || lower.includes("platform")) {
        result.channelHints.push({
          channel: "Digital channels",
          rationale: `Enabled by: ${f.factor}`,
          source: "PESTLE Technological"
        });
      }
    }
  }
  if (factors.environmental && Array.isArray(factors.environmental)) {
    const envFactors = factors.environmental.slice(0, 3);
    for (const f of envFactors) {
      if (f.impact === "opportunity") {
        result.valuePropositionHints.push({
          hint: "Sustainability-focused value proposition",
          rationale: `Capitalize on: ${f.factor}`,
          source: "PESTLE Environmental"
        });
      }
    }
    result.environmentalContext = envFactors.map((f) => f.factor || "").join("; ");
  }
  console.log(`[Bridge] pestle-to-bmc: Generated ${result.customerSegmentHints.length} segment hints, ${result.valuePropositionHints.length} VP hints`);
  return result;
}
var init_pestle_to_bmc_bridge = __esm({
  "server/journey/bridges/pestle-to-bmc-bridge.ts"() {
    "use strict";
    init_output_normalizer();
  }
});

// server/journey/bridges/bmc-to-ansoff-bridge.ts
function transformBmcToAnsoff(rawBmcOutput, context) {
  const bmcOutput = normalizeBmcOutput2(rawBmcOutput);
  const result = {
    marketPenetrationFactors: [],
    marketDevelopmentOpportunities: [],
    productDevelopmentIdeas: [],
    diversificationCandidates: [],
    currentPositionSummary: "",
    growthReadinessScore: 3
  };
  if (!bmcOutput) return result;
  const canvas = bmcOutput.canvas || bmcOutput.bmcResults || bmcOutput;
  const segments = canvas.customerSegments || canvas.customer_segments || canvas.segments || [];
  const segmentList = normalizeToArray2(segments);
  for (const seg of segmentList.slice(0, 3)) {
    const segmentText = extractText2(seg, ["segment", "name", "title", "description"]);
    if (segmentText) {
      result.marketPenetrationFactors.push({
        factor: `Deepen engagement with: ${segmentText}`,
        rationale: "Existing customer segment with established relationship",
        growthPotential: "medium",
        source: "BMC Customer Segments"
      });
    }
  }
  const valueProps = canvas.valuePropositions || canvas.value_propositions || canvas.valueProposition || [];
  const vpList = normalizeToArray2(valueProps);
  for (const vp of vpList.slice(0, 3)) {
    const vpText = extractText2(vp, ["proposition", "value", "title", "name"]);
    if (vpText) {
      result.productDevelopmentIdeas.push({
        idea: `Enhance/extend: ${vpText}`,
        existingCapability: vpText,
        rationale: "Build on proven value proposition with new features or variants",
        feasibility: "medium"
      });
    }
  }
  const channels = canvas.channels || [];
  const channelList = normalizeToArray2(channels);
  const existingChannels = /* @__PURE__ */ new Set();
  for (const ch of channelList) {
    const chText = extractText2(ch, ["channel", "name", "type"]);
    if (chText) existingChannels.add(chText.toLowerCase());
  }
  const potentialChannels = ["digital", "direct", "partnerships", "retail", "online marketplace"];
  for (const potential of potentialChannels) {
    const hasChannel = Array.from(existingChannels).some((ch) => ch.includes(potential));
    if (!hasChannel && existingChannels.size > 0) {
      result.marketDevelopmentOpportunities.push({
        opportunity: `Expand via ${potential} channel`,
        targetMarket: "Adjacent customer segments",
        rationale: `${potential} channel not currently utilized in business model`,
        riskLevel: "medium"
      });
      break;
    }
  }
  const relationships = canvas.customerRelationships || canvas.customer_relationships || canvas.relationships || [];
  const relList = normalizeToArray2(relationships);
  if (relList.length > 0) {
    result.marketPenetrationFactors.push({
      factor: "Enhance customer loyalty programs",
      rationale: `Build on existing ${relList.length} relationship type(s)`,
      growthPotential: "medium",
      source: "BMC Customer Relationships"
    });
  }
  const resources2 = canvas.keyResources || canvas.key_resources || canvas.resources || [];
  const resourceList = normalizeToArray2(resources2);
  for (const res of resourceList.slice(0, 2)) {
    const resText = extractText2(res, ["resource", "name", "type"]);
    if (resText) {
      result.productDevelopmentIdeas.push({
        idea: `Leverage ${resText} for new offerings`,
        existingCapability: resText,
        rationale: "Existing resource can support product extension",
        feasibility: "medium"
      });
    }
  }
  const partners = canvas.keyPartnerships || canvas.key_partnerships || canvas.partners || canvas.keyPartners || [];
  const partnerList = normalizeToArray2(partners);
  if (partnerList.length > 0) {
    result.diversificationCandidates.push({
      direction: "Strategic partnership expansion",
      rationale: `Leverage existing ${partnerList.length} partner relationship(s) for new ventures`,
      riskLevel: "medium",
      synergies: "Existing partner trust and collaboration frameworks"
    });
  }
  const revenues = canvas.revenueStreams || canvas.revenue_streams || canvas.revenues || [];
  const revenueList = normalizeToArray2(revenues);
  if (revenueList.length === 1) {
    result.marketDevelopmentOpportunities.push({
      opportunity: "New revenue model exploration",
      targetMarket: "Price-sensitive or premium segments",
      rationale: "Single revenue stream suggests opportunity for model diversification",
      riskLevel: "low"
    });
  }
  result.growthReadinessScore = calculateGrowthReadiness(canvas, result);
  result.currentPositionSummary = buildPositionSummary(canvas, result);
  console.log(`[Bridge] bmc-to-ansoff: Generated ${result.marketPenetrationFactors.length} penetration, ${result.marketDevelopmentOpportunities.length} development, ${result.productDevelopmentIdeas.length} product, ${result.diversificationCandidates.length} diversification factors`);
  return result;
}
function normalizeBmcOutput2(raw) {
  if (!raw) return null;
  if (raw.data?.output) return raw.data.output;
  if (raw.data?.canvas) return raw.data;
  if (raw.output?.canvas) return raw.output;
  if (raw.canvas) return raw;
  if (raw.bmcResults) return raw;
  if (raw.data) return raw.data;
  if (raw.output) return raw.output;
  return raw;
}
function normalizeToArray2(input) {
  if (!input) return [];
  if (Array.isArray(input)) return input;
  if (typeof input === "object" && input.items) return input.items;
  if (typeof input === "string") return [input];
  return [input];
}
function extractText2(item, keys) {
  if (typeof item === "string") return item;
  if (!item || typeof item !== "object") return "";
  for (const key of keys) {
    if (item[key] && typeof item[key] === "string") {
      return item[key];
    }
  }
  return item.description || item.text || item.value || "";
}
function calculateGrowthReadiness(canvas, enhancement) {
  let score = 3;
  const segments = normalizeToArray2(canvas.customerSegments || canvas.customer_segments || []);
  if (segments.length >= 3) score += 0.5;
  const partners = normalizeToArray2(canvas.keyPartnerships || canvas.key_partnerships || []);
  if (partners.length >= 2) score += 0.5;
  const revenues = normalizeToArray2(canvas.revenueStreams || canvas.revenue_streams || []);
  if (revenues.length >= 2) score += 0.5;
  const channels = normalizeToArray2(canvas.channels || []);
  const hasDigital = channels.some((c) => {
    const text2 = extractText2(c, ["channel", "name", "type"]);
    return text2 && (text2.toLowerCase().includes("digital") || text2.toLowerCase().includes("online"));
  });
  if (hasDigital) score += 0.5;
  return Math.min(5, Math.round(score));
}
function buildPositionSummary(canvas, enhancement) {
  const segments = normalizeToArray2(canvas.customerSegments || canvas.customer_segments || []);
  const valueProps = normalizeToArray2(canvas.valuePropositions || canvas.value_propositions || []);
  return `Business Model Position: ${segments.length} customer segment(s), ${valueProps.length} value proposition(s). Growth Readiness: ${enhancement.growthReadinessScore}/5.`;
}
var init_bmc_to_ansoff_bridge = __esm({
  "server/journey/bridges/bmc-to-ansoff-bridge.ts"() {
    "use strict";
  }
});

// server/journey/bridges/pestle-to-ansoff-bridge.ts
function transformPestleToAnsoff(rawPestleOutput, context) {
  const pestleOutput = normalizePESTLEOutput(rawPestleOutput);
  const result = {
    marketPenetrationSignals: [],
    marketDevelopmentOpportunities: [],
    productDevelopmentEnablers: [],
    diversificationIndicators: [],
    macroEnvironmentSummary: "",
    growthReadinessScore: 3
  };
  if (!pestleOutput?.factors) return result;
  const factors = pestleOutput.factors;
  let opportunityCount = 0;
  let threatCount = 0;
  if (factors.economic && Array.isArray(factors.economic)) {
    for (const f of factors.economic.slice(0, 4)) {
      const factorText = f.factor || "";
      const lower = factorText.toLowerCase();
      if (f.impact === "opportunity") opportunityCount++;
      else if (f.impact === "threat") threatCount++;
      if (lower.includes("growth") || lower.includes("demand") || lower.includes("spending")) {
        result.marketPenetrationSignals.push({
          signal: "Favorable economic conditions for market deepening",
          factor: factorText,
          rationale: "Economic indicator supports increased market penetration",
          source: "PESTLE Economic"
        });
      }
      if (lower.includes("emerging") || lower.includes("international") || lower.includes("export")) {
        result.marketDevelopmentOpportunities.push({
          opportunity: "Geographic/market expansion",
          factor: factorText,
          targetMarket: "Emerging or adjacent markets",
          riskLevel: f.impact === "opportunity" ? "medium" : "high"
        });
      }
    }
  }
  if (factors.social && Array.isArray(factors.social)) {
    for (const f of factors.social.slice(0, 3)) {
      const factorText = f.factor || "";
      const lower = factorText.toLowerCase();
      if (f.impact === "opportunity") opportunityCount++;
      else if (f.impact === "threat") threatCount++;
      if (lower.includes("demographic") || lower.includes("population") || lower.includes("generation")) {
        result.marketDevelopmentOpportunities.push({
          opportunity: "New demographic segments",
          factor: factorText,
          targetMarket: "Underserved demographic groups",
          riskLevel: "medium"
        });
      }
      if (lower.includes("trend") || lower.includes("lifestyle") || lower.includes("behavior")) {
        result.marketPenetrationSignals.push({
          signal: "Social trend alignment opportunity",
          factor: factorText,
          rationale: "Align messaging and offerings with evolving preferences",
          source: "PESTLE Social"
        });
      }
    }
  }
  if (factors.technological && Array.isArray(factors.technological)) {
    for (const f of factors.technological.slice(0, 4)) {
      const factorText = f.factor || "";
      const lower = factorText.toLowerCase();
      if (f.impact === "opportunity") opportunityCount++;
      else if (f.impact === "threat") threatCount++;
      result.productDevelopmentEnablers.push({
        enabler: factorText,
        factor: factorText,
        rationale: "Technology factor enables new product/service capabilities",
        feasibility: f.impact === "opportunity" ? "high" : "medium"
      });
      if (lower.includes("digital") || lower.includes("platform") || lower.includes("ai") || lower.includes("automation")) {
        result.diversificationIndicators.push({
          indicator: "Technology-enabled diversification",
          factor: factorText,
          direction: "related",
          riskLevel: "medium"
        });
      }
    }
  }
  if (factors.political && Array.isArray(factors.political)) {
    for (const f of factors.political.slice(0, 2)) {
      const factorText = f.factor || "";
      if (f.impact === "opportunity") opportunityCount++;
      else if (f.impact === "threat") threatCount++;
      if (f.impact === "opportunity") {
        result.marketDevelopmentOpportunities.push({
          opportunity: "Policy-enabled market access",
          factor: factorText,
          targetMarket: "Newly accessible markets",
          riskLevel: "low"
        });
      } else if (f.impact === "threat") {
        result.diversificationIndicators.push({
          indicator: "Regulatory risk diversification",
          factor: factorText,
          direction: "related",
          riskLevel: "high"
        });
      }
    }
  }
  if (factors.legal && Array.isArray(factors.legal)) {
    for (const f of factors.legal.slice(0, 2)) {
      if (f.impact === "opportunity") opportunityCount++;
      else if (f.impact === "threat") threatCount++;
    }
  }
  if (factors.environmental && Array.isArray(factors.environmental)) {
    for (const f of factors.environmental.slice(0, 2)) {
      const factorText = f.factor || "";
      if (f.impact === "opportunity") opportunityCount++;
      else if (f.impact === "threat") threatCount++;
      if (f.impact === "opportunity") {
        result.productDevelopmentEnablers.push({
          enabler: "Sustainability-driven innovation",
          factor: factorText,
          rationale: "Environmental trend creates product development opportunity",
          feasibility: "medium"
        });
      }
    }
  }
  const netOpportunity = opportunityCount - threatCount * 0.5;
  result.growthReadinessScore = Math.min(5, Math.max(1, Math.round(3 + netOpportunity / 3)));
  result.macroEnvironmentSummary = buildMacroSummary(result);
  console.log(`[Bridge] pestle-to-ansoff: Generated ${result.marketPenetrationSignals.length} penetration, ${result.marketDevelopmentOpportunities.length} development, ${result.productDevelopmentEnablers.length} product, ${result.diversificationIndicators.length} diversification factors`);
  return result;
}
function buildMacroSummary(enhancement) {
  const total = enhancement.marketPenetrationSignals.length + enhancement.marketDevelopmentOpportunities.length + enhancement.productDevelopmentEnablers.length + enhancement.diversificationIndicators.length;
  return `Macro Environment Analysis: ${total} growth factors identified. Growth Readiness Score: ${enhancement.growthReadinessScore}/5.`;
}
var init_pestle_to_ansoff_bridge = __esm({
  "server/journey/bridges/pestle-to-ansoff-bridge.ts"() {
    "use strict";
    init_output_normalizer();
  }
});

// server/journey/bridges/ansoff-to-bmc-bridge.ts
function transformAnsoffToBmc(rawAnsoffOutput, context) {
  const ansoffOutput = normalizeAnsoffOutput(rawAnsoffOutput);
  const result = {
    customerSegmentHints: [],
    valuePropositionHints: [],
    channelHints: [],
    customerRelationshipHints: [],
    revenueStreamHints: [],
    keyPartnershipHints: [],
    keyActivityHints: [],
    keyResourceHints: [],
    growthStrategyContext: "",
    recommendedQuadrant: "penetration"
  };
  if (!ansoffOutput) return result;
  const matrix = ansoffOutput.ansoffResults || ansoffOutput.matrix || ansoffOutput;
  let bestQuadrant = "penetration";
  let bestScore = 0;
  const quadrants = [
    { key: "marketPenetration", name: "penetration", bmcFocus: ["relationships", "channels"] },
    { key: "marketDevelopment", name: "development", bmcFocus: ["segments", "channels"] },
    { key: "productDevelopment", name: "product", bmcFocus: ["value_prop", "activities"] },
    { key: "diversification", name: "diversification", bmcFocus: ["partnerships", "revenue"] }
  ];
  for (const q of quadrants) {
    const quadrantData = matrix[q.key] || matrix[q.name];
    if (quadrantData) {
      const score = quadrantData.score || quadrantData.attractiveness || 0;
      if (score > bestScore) {
        bestScore = score;
        bestQuadrant = q.name;
      }
    }
  }
  result.recommendedQuadrant = bestQuadrant;
  const penetration = matrix.marketPenetration || matrix.market_penetration || matrix.penetration;
  if (penetration) {
    const strategies = penetration.strategies || penetration.actions || [];
    result.customerRelationshipHints.push({
      relationship: "Enhanced loyalty programs",
      quadrant: "Market Penetration",
      rationale: "Deepen relationships with existing customers"
    });
    result.channelHints.push({
      channel: "Existing channels optimization",
      quadrant: "Market Penetration",
      rationale: "Maximize reach through current distribution"
    });
    for (const s of normalizeToArray3(strategies).slice(0, 2)) {
      const strategyText = extractText3(s, ["strategy", "action", "name", "description"]);
      if (strategyText) {
        result.keyActivityHints.push({
          activity: strategyText,
          quadrant: "Market Penetration",
          rationale: "Activity to increase market share"
        });
      }
    }
  }
  const development = matrix.marketDevelopment || matrix.market_development || matrix.development;
  if (development) {
    const segments = development.targetMarkets || development.segments || development.markets || [];
    const strategies = development.strategies || development.actions || [];
    for (const seg of normalizeToArray3(segments).slice(0, 2)) {
      const segText = extractText3(seg, ["market", "segment", "name", "description"]);
      if (segText) {
        result.customerSegmentHints.push({
          segment: segText,
          quadrant: "development",
          rationale: "New market segment identified through Ansoff analysis",
          priority: "high"
        });
      }
    }
    if (normalizeToArray3(strategies).length > 0 || normalizeToArray3(segments).length > 0) {
      result.channelHints.push({
        channel: "New distribution channels",
        quadrant: "Market Development",
        rationale: "Reach new market segments"
      });
    }
  }
  const productDev = matrix.productDevelopment || matrix.product_development || matrix.product;
  if (productDev) {
    const products = productDev.products || productDev.offerings || productDev.ideas || [];
    const strategies = productDev.strategies || productDev.actions || [];
    for (const prod of normalizeToArray3(products).slice(0, 2)) {
      const prodText = extractText3(prod, ["product", "name", "offering", "description"]);
      if (prodText) {
        result.valuePropositionHints.push({
          hint: prodText,
          quadrant: "Product Development",
          rationale: "New product/service identified through Ansoff analysis",
          priority: "high"
        });
      }
    }
    for (const s of normalizeToArray3(strategies).slice(0, 2)) {
      const strategyText = extractText3(s, ["strategy", "action", "name", "description"]);
      if (strategyText) {
        result.keyActivityHints.push({
          activity: strategyText,
          quadrant: "Product Development",
          rationale: "R&D or innovation activity"
        });
      }
    }
    result.keyResourceHints.push({
      resource: "R&D capabilities",
      quadrant: "Product Development",
      rationale: "Support new product/service development"
    });
  }
  const diversification = matrix.diversification || matrix.diversify;
  if (diversification) {
    const opportunities = diversification.opportunities || diversification.options || [];
    const strategies = diversification.strategies || diversification.actions || [];
    result.keyPartnershipHints.push({
      partner: "Strategic M&A or JV partners",
      quadrant: "Diversification",
      rationale: "Enable entry into new markets/products"
    });
    for (const opp of normalizeToArray3(opportunities).slice(0, 2)) {
      const oppText = extractText3(opp, ["opportunity", "option", "name", "description"]);
      if (oppText) {
        result.revenueStreamHints.push({
          stream: oppText,
          quadrant: "Diversification",
          rationale: "New revenue opportunity from diversification"
        });
        result.customerSegmentHints.push({
          segment: `New segment: ${oppText}`,
          quadrant: "diversification",
          rationale: "Diversification target segment",
          priority: "medium"
        });
      }
    }
  }
  result.growthStrategyContext = buildGrowthContext(result, bestQuadrant);
  console.log(`[Bridge] ansoff-to-bmc: Generated hints for ${result.customerSegmentHints.length} segments, ${result.valuePropositionHints.length} VP, ${result.keyPartnershipHints.length} partnerships. Recommended: ${bestQuadrant}`);
  return result;
}
function normalizeAnsoffOutput(raw) {
  if (!raw) return null;
  if (raw.data?.output) return raw.data.output;
  if (raw.data?.ansoffResults) return raw.data;
  if (raw.output?.ansoffResults) return raw.output;
  if (raw.ansoffResults) return raw;
  if (raw.matrix) return raw;
  if (raw.data) return raw.data;
  if (raw.output) return raw.output;
  return raw;
}
function normalizeToArray3(input) {
  if (!input) return [];
  if (Array.isArray(input)) return input;
  if (typeof input === "object" && input.items) return input.items;
  if (typeof input === "string") return [input];
  return [input];
}
function extractText3(item, keys) {
  if (typeof item === "string") return item;
  if (!item || typeof item !== "object") return "";
  for (const key of keys) {
    if (item[key] && typeof item[key] === "string") {
      return item[key];
    }
  }
  return item.description || item.text || item.value || "";
}
function buildGrowthContext(enhancement, quadrant) {
  const quadrantNames = {
    penetration: "Market Penetration",
    development: "Market Development",
    product: "Product Development",
    diversification: "Diversification"
  };
  const focus = quadrantNames[quadrant] || "Market Penetration";
  return `Growth Strategy Focus: ${focus}. BMC should be optimized to support this growth direction with appropriate customer segments, value propositions, and resource allocation.`;
}
var init_ansoff_to_bmc_bridge = __esm({
  "server/journey/bridges/ansoff-to-bmc-bridge.ts"() {
    "use strict";
  }
});

// server/services/custom-journey-executor.ts
import { eq as eq33 } from "drizzle-orm";
var FRAMEWORK_KEY_TO_MODULE_ID, USER_INPUT_STEPS, CustomJourneyExecutor, customJourneyExecutor;
var init_custom_journey_executor = __esm({
  "server/services/custom-journey-executor.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_compatibility();
    init_registry();
    init_pestle_to_porters_bridge();
    init_porters_to_swot_bridge();
    init_whys_to_bmc_bridge();
    init_whys_to_swot_bridge();
    init_swot_to_bmc_bridge();
    init_porters_to_bmc_bridge();
    init_bmc_to_blueocean_bridge();
    init_pestle_to_bmc_bridge();
    init_bmc_to_ansoff_bridge();
    init_pestle_to_ansoff_bridge();
    init_ansoff_to_bmc_bridge();
    init_swot_analyzer();
    init_decision_generator();
    init_ansoff_analyzer();
    init_jtbd_analyzer();
    init_vrio_analyzer();
    init_scenario_planning_analyzer();
    init_ocean_strategy_analyzer();
    init_blue_ocean_analyzer();
    init_bcg_matrix_analyzer();
    init_value_chain_analyzer();
    init_competitive_positioning_analyzer();
    init_bmc_analyzer2();
    init_porters_analyzer();
    init_pestle_analyzer();
    init_five_whys_coach();
    init_segment_discovery_engine();
    init_okr_generator();
    init_epm_synthesizer();
    init_llm_provider();
    FRAMEWORK_KEY_TO_MODULE_ID = {
      "strategic_understanding": "input-processor",
      "five_whys": "five-whys-analyzer",
      "business_model_canvas": "bmc-analyzer",
      "bmc": "bmc-analyzer",
      "porters_five_forces": "porters-analyzer",
      "porters": "porters-analyzer",
      "pestle": "pestle-analyzer",
      "swot": "swot-analyzer",
      "ansoff": "ansoff-analyzer",
      "blue_ocean": "blue-ocean-analyzer",
      "bcg_matrix": "bcg-matrix-analyzer",
      "value_chain": "value-chain-analyzer",
      "vrio": "vrio-analyzer",
      "scenario_planning": "scenario-planning-analyzer",
      "jobs_to_be_done": "jtbd-analyzer",
      "jtbd": "jtbd-analyzer",
      "competitive_positioning": "competitive-positioning-analyzer",
      "ocean_strategy": "ocean-strategy-analyzer",
      "segment_discovery": "segment-discovery-analyzer",
      "okr": "okr-generator",
      "epm": "epm-generator",
      // User input steps (not AI modules)
      "strategic_decisions": "strategic-decisions",
      "strategic_understanding": "strategic-understanding",
      "prioritization": "prioritization"
    };
    USER_INPUT_STEPS = [
      "strategic_decisions",
      "strategic-decisions",
      "strategic_understanding",
      "strategic-understanding",
      "prioritization"
    ];
    CustomJourneyExecutor = class {
      abortController = null;
      isAborted = false;
      async executeJourney(executionId, res) {
        this.abortController = new AbortController();
        this.isAborted = false;
        res.on("close", () => {
          console.log(`[CustomJourneyExecutor] Client disconnected for execution ${executionId}`);
          this.isAborted = true;
          this.abortController?.abort();
        });
        try {
          const [execution] = await db.select().from(customJourneyExecutions).where(eq33(customJourneyExecutions.id, executionId));
          if (!execution) {
            this.sendEvent(res, { type: "journey_error", error: "Execution not found" });
            return;
          }
          const [config] = await db.select().from(customJourneyConfigs).where(eq33(customJourneyConfigs.id, execution.configId));
          if (!config) {
            this.sendEvent(res, { type: "journey_error", error: "Journey config not found" });
            return;
          }
          const nodes = config.nodes || [];
          const edges = config.edges || [];
          if (nodes.length === 0) {
            this.sendEvent(res, { type: "journey_error", error: "Journey has no nodes" });
            return;
          }
          const executionOrder = getExecutionOrder(
            nodes.map((n) => ({ id: n.id })),
            edges.map((e) => ({ sourceNodeId: e.sourceNodeId, targetNodeId: e.targetNodeId }))
          );
          console.log(`[CustomJourneyExecutor] Execution order: ${executionOrder.join(" -> ")}`);
          await db.update(customJourneyExecutions).set({
            status: "running",
            startedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq33(customJourneyExecutions.id, executionId));
          this.sendEvent(res, {
            type: "execution_started",
            executionId,
            totalNodes: executionOrder.length
          });
          const nodeStates = {};
          const aggregatedOutputs = {};
          const nodeMap = new Map(nodes.map((n) => [n.id, n]));
          for (const nodeId of executionOrder) {
            nodeStates[nodeId] = { status: "pending" };
          }
          let completedCount = 0;
          let hasError = false;
          for (const nodeId of executionOrder) {
            if (this.isAborted) {
              console.log(`[CustomJourneyExecutor] Execution aborted for ${executionId}`);
              break;
            }
            const node = nodeMap.get(nodeId);
            if (!node) {
              console.error(`[CustomJourneyExecutor] Node ${nodeId} not found`);
              continue;
            }
            const module2 = moduleRegistry.getModule(node.moduleId);
            const moduleName = module2?.name || node.moduleId;
            nodeStates[nodeId] = {
              status: "running",
              startedAt: (/* @__PURE__ */ new Date()).toISOString()
            };
            await this.updateExecutionState(executionId, nodeStates, aggregatedOutputs, nodeId, completedCount, executionOrder.length);
            const progress = Math.round(completedCount / executionOrder.length * 100);
            this.sendEvent(res, {
              type: "node_start",
              nodeId,
              moduleId: node.moduleId,
              nodeName: moduleName,
              progress
            });
            try {
              const normalizedModuleId = this.normalizeModuleId(node.moduleId);
              if (this.isUserInputStep(node.moduleId)) {
                console.log(`[CustomJourneyExecutor] User input step detected: ${node.moduleId}`);
                let sessionId = execution.inputData?.understandingId || "";
                let versionNumber = 1;
                let redirectUrl = `/strategies/${sessionId}`;
                if (node.moduleId.includes("decision") || node.moduleId.includes("strategic_decisions")) {
                  if (!sessionId) {
                    const journeySession = await db.select().from(journeySessions).where(eq33(journeySessions.id, executionId)).limit(1);
                    if (journeySession.length > 0 && journeySession[0].understandingId) {
                      sessionId = journeySession[0].understandingId;
                      console.log(`[CustomJourneyExecutor] Retrieved understandingId from journey session: ${sessionId}`);
                    } else {
                      sessionId = executionId;
                      console.warn(`[CustomJourneyExecutor] WARNING: Could not find understandingId, falling back to executionId: ${sessionId}`);
                    }
                  }
                  const existingUnderstanding = await db.select().from(strategicUnderstanding).where(eq33(strategicUnderstanding.sessionId, sessionId)).limit(1);
                  if (existingUnderstanding.length === 0) {
                    console.log(`[CustomJourneyExecutor] Creating placeholder understanding for session: ${sessionId}`);
                    const journeyName = execution.configId ? "Custom Journey Analysis" : "Strategic Analysis";
                    const completedFrameworks = aggregatedOutputs ? Object.keys(aggregatedOutputs) : [];
                    const userInputText = completedFrameworks.length > 0 ? `Custom journey analysis with frameworks: ${completedFrameworks.join(", ")}` : "Custom strategic journey - awaiting user input";
                    try {
                      await db.insert(strategicUnderstanding).values({
                        sessionId,
                        userInput: userInputText || "Strategic analysis pending user input",
                        title: journeyName || "Strategic Analysis",
                        initiativeType: "software_development",
                        strategyMetadata: {
                          completedFrameworks,
                          lastUpdated: (/* @__PURE__ */ new Date()).toISOString()
                        }
                      });
                      console.log(`[CustomJourneyExecutor] Created understanding record for session: ${sessionId}`);
                    } catch (insertError) {
                      console.error(`[CustomJourneyExecutor] Failed to create understanding:`, insertError.message);
                      throw new Error(`Cannot proceed with user input step: failed to create strategic understanding record - ${insertError.message}`);
                    }
                  }
                  const existingVersions = await db.select().from(strategyVersions).where(eq33(strategyVersions.sessionId, sessionId));
                  if (existingVersions.length === 0) {
                    versionNumber = 1;
                    const analysisData = aggregatedOutputs || {};
                    const inputData = execution.inputData || {};
                    const businessContext = inputData.businessContext || inputData.userInput || "";
                    const isValidSwotOutput = (obj) => {
                      if (!obj) return false;
                      const candidate = obj.output || obj;
                      return candidate && Array.isArray(candidate.strengths) && Array.isArray(candidate.weaknesses);
                    };
                    const extractSwot = (obj) => {
                      if (!obj) return null;
                      const candidate = obj.output || obj;
                      if (candidate && Array.isArray(candidate.strengths) && Array.isArray(candidate.weaknesses)) {
                        return candidate;
                      }
                      return null;
                    };
                    let normalizedSwot = null;
                    normalizedSwot = extractSwot(aggregatedOutputs["swot"]) || extractSwot(aggregatedOutputs["swot-analyzer"]);
                    if (!normalizedSwot) {
                      for (const [key, value] of Object.entries(aggregatedOutputs)) {
                        if (key.toLowerCase().includes("swot") && isValidSwotOutput(value)) {
                          normalizedSwot = extractSwot(value);
                          console.log(`[CustomJourneyExecutor] Found SWOT output via nodeId: ${key}`);
                          break;
                        }
                      }
                    }
                    if (!normalizedSwot) {
                      for (const [key, value] of Object.entries(aggregatedOutputs)) {
                        if (isValidSwotOutput(value)) {
                          normalizedSwot = extractSwot(value);
                          console.log(`[CustomJourneyExecutor] Found SWOT output by shape detection in: ${key}`);
                          break;
                        }
                      }
                    }
                    if (normalizedSwot) {
                      console.log(`[CustomJourneyExecutor] Valid SWOT output found with ${normalizedSwot.strengths.length} strengths, ${normalizedSwot.weaknesses.length} weaknesses`);
                    }
                    let decisionsData;
                    if (normalizedSwot) {
                      console.log(`[CustomJourneyExecutor] Generating AI decisions from SWOT output`);
                      try {
                        const decisionGenerator2 = new DecisionGenerator();
                        const generatedDecisions = await decisionGenerator2.generateDecisionsFromSWOT(
                          normalizedSwot,
                          businessContext
                        );
                        decisionsData = generatedDecisions;
                        console.log(`[CustomJourneyExecutor] AI generated ${generatedDecisions.decisions?.length || 0} decision points`);
                      } catch (decisionError) {
                        console.error(`[CustomJourneyExecutor] AI decision generation failed, using fallback:`, decisionError.message);
                        decisionsData = this.generatePlaceholderDecisions(aggregatedOutputs);
                      }
                    } else {
                      console.log(`[CustomJourneyExecutor] No valid SWOT output available, using placeholder decisions`);
                      decisionsData = this.generatePlaceholderDecisions(aggregatedOutputs);
                    }
                    console.log(`[CustomJourneyExecutor] Creating version ${versionNumber} for session: ${sessionId}`);
                    const [insertedVersion] = await db.insert(strategyVersions).values({
                      sessionId,
                      versionNumber,
                      versionLabel: `Strategic Decisions v${versionNumber}`,
                      analysisData,
                      decisionsData,
                      status: "draft",
                      createdBy: execution.userId || "system",
                      userId: execution.userId || null
                    }).returning({
                      id: strategyVersions.id,
                      sessionId: strategyVersions.sessionId,
                      versionNumber: strategyVersions.versionNumber
                    });
                    if (!insertedVersion || insertedVersion.sessionId !== sessionId || insertedVersion.versionNumber !== versionNumber) {
                      console.error(`[CustomJourneyExecutor] VALIDATION FAILED: Insert did not return expected row for session=${sessionId}, version=${versionNumber}`);
                      throw new Error(`Failed to create strategy version ${versionNumber} for session ${sessionId}`);
                    }
                    console.log(`[CustomJourneyExecutor] \u2713 VALIDATION PASSED: strategy_versions row (id=${insertedVersion.id}, session=${sessionId}, version=${versionNumber}) atomically verified`);
                  } else {
                    versionNumber = existingVersions.length + 1;
                  }
                  redirectUrl = `/strategic-consultant/decisions/${sessionId}/${versionNumber}`;
                }
                this.sendEvent(res, {
                  type: "user_input_required",
                  stepType: node.moduleId,
                  redirectUrl,
                  message: "Please make your strategic selections"
                });
                nodeStates[nodeId] = {
                  status: "pending",
                  startedAt: nodeStates[nodeId].startedAt
                };
                await db.update(customJourneyExecutions).set({
                  status: "paused",
                  // Paused for user input
                  currentNodeId: nodeId,
                  nodeStates,
                  aggregatedOutputs,
                  progressMessage: `Awaiting user input: ${node.moduleId}`,
                  updatedAt: /* @__PURE__ */ new Date()
                }).where(eq33(customJourneyExecutions.id, executionId));
                return;
              }
              const nodeInputs = this.gatherNodeInputs(nodeId, edges, aggregatedOutputs, execution.inputData);
              this.sendEvent(res, {
                type: "node_progress",
                nodeId,
                message: `Processing ${moduleName}...`,
                progress
              });
              let output;
              const startTime = Date.now();
              if (module2?.status === "stub" || !module2) {
                output = await this.executeRealAnalyzer(normalizedModuleId, nodeInputs, res, nodeId);
              } else {
                output = await this.executeImplementedModule(module2, nodeInputs, node.config, normalizedModuleId);
              }
              const duration = Date.now() - startTime;
              nodeStates[nodeId] = {
                status: "completed",
                startedAt: nodeStates[nodeId].startedAt,
                completedAt: (/* @__PURE__ */ new Date()).toISOString(),
                output
              };
              aggregatedOutputs[nodeId] = output;
              const outgoingEdges = edges.filter((e) => e.sourceNodeId === nodeId);
              for (const edge of outgoingEdges) {
                const targetNode = nodeMap.get(edge.targetNodeId);
                if (targetNode) {
                  const bridgeEnhancement = await this.applyBridgeIfExists(
                    normalizedModuleId,
                    this.normalizeModuleId(targetNode.moduleId),
                    output,
                    aggregatedOutputs
                  );
                  if (bridgeEnhancement) {
                    const bridgeKey = `bridge_${nodeId}_to_${edge.targetNodeId}`;
                    aggregatedOutputs[bridgeKey] = bridgeEnhancement;
                    console.log(`[CustomJourneyExecutor] Applied bridge: ${normalizedModuleId} \u2192 ${targetNode.moduleId}`);
                  }
                }
              }
              const understandingId = execution.inputData?.understandingId;
              if (understandingId && output) {
                await this.saveToFrameworkInsights(
                  understandingId,
                  executionId,
                  normalizedModuleId,
                  output,
                  duration
                );
              }
              completedCount++;
              const newProgress = Math.round(completedCount / executionOrder.length * 100);
              await this.updateExecutionState(executionId, nodeStates, aggregatedOutputs, null, completedCount, executionOrder.length);
              this.sendEvent(res, {
                type: "node_complete",
                nodeId,
                output,
                progress: newProgress
              });
            } catch (error) {
              console.error(`[CustomJourneyExecutor] Error executing node ${nodeId}:`, error);
              nodeStates[nodeId] = {
                status: "error",
                startedAt: nodeStates[nodeId].startedAt,
                completedAt: (/* @__PURE__ */ new Date()).toISOString(),
                error: error.message || "Unknown error"
              };
              hasError = true;
              await this.updateExecutionState(executionId, nodeStates, aggregatedOutputs, null, completedCount, executionOrder.length);
              this.sendEvent(res, {
                type: "node_error",
                nodeId,
                error: error.message || "Unknown error"
              });
            }
          }
          const finalStatus = this.isAborted ? "paused" : hasError ? "failed" : "completed";
          await db.update(customJourneyExecutions).set({
            status: finalStatus,
            nodeStates,
            aggregatedOutputs,
            progress: 100,
            completedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq33(customJourneyExecutions.id, executionId));
          if (!this.isAborted) {
            this.sendEvent(res, {
              type: "journey_complete",
              aggregatedOutputs
            });
          }
        } catch (error) {
          console.error(`[CustomJourneyExecutor] Fatal error for execution ${executionId}:`, error);
          await db.update(customJourneyExecutions).set({
            status: "failed",
            errorMessage: error.message || "Unknown error",
            completedAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq33(customJourneyExecutions.id, executionId));
          this.sendEvent(res, {
            type: "journey_error",
            error: error.message || "Unknown error"
          });
        }
      }
      sendEvent(res, event) {
        try {
          const eventData = JSON.stringify({
            ...event,
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
          res.write(`data: ${eventData}

`);
          return true;
        } catch (error) {
          console.error("[CustomJourneyExecutor] Error sending SSE event:", error);
          return false;
        }
      }
      async updateExecutionState(executionId, nodeStates, aggregatedOutputs, currentNodeId, completedCount, totalCount) {
        const progress = Math.round(completedCount / totalCount * 100);
        await db.update(customJourneyExecutions).set({
          nodeStates,
          aggregatedOutputs,
          currentNodeId,
          progress,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq33(customJourneyExecutions.id, executionId));
      }
      gatherNodeInputs(nodeId, edges, aggregatedOutputs, initialInputData) {
        const inputs = {};
        if (initialInputData) {
          Object.assign(inputs, initialInputData);
        }
        const incomingEdges = edges.filter((e) => e.targetNodeId === nodeId);
        for (const edge of incomingEdges) {
          const sourceOutput = aggregatedOutputs[edge.sourceNodeId];
          if (sourceOutput !== void 0) {
            inputs[edge.targetPortId] = sourceOutput;
            inputs[edge.sourcePortId] = sourceOutput;
            inputs[`from_${edge.sourceNodeId}`] = sourceOutput;
            const bridgeKey = `bridge_${edge.sourceNodeId}_to_${nodeId}`;
            const bridgeEnhancement = aggregatedOutputs[bridgeKey];
            if (bridgeEnhancement) {
              inputs.bridgeContext = bridgeEnhancement;
              inputs[`bridge_from_${edge.sourceNodeId}`] = bridgeEnhancement;
              console.log(`[CustomJourneyExecutor] Including bridge context for node ${nodeId}`);
            }
          }
        }
        return inputs;
      }
      async simulateStubModule(moduleId, inputs, res, nodeId) {
        return this.executeRealAnalyzer(moduleId, inputs, res, nodeId);
      }
      async executeImplementedModule(module2, inputs, nodeConfig, normalizedModuleId) {
        const moduleId = normalizedModuleId || module2.id;
        console.log(`[CustomJourneyExecutor] Executing real analyzer for: ${moduleId}`);
        return this.executeRealAnalyzer(moduleId, inputs, null, null);
      }
      /**
       * Route to real analyzers based on module ID
       */
      async executeRealAnalyzer(moduleId, inputs, res, nodeId) {
        console.log(`[CustomJourneyExecutor] Routing to real analyzer: ${moduleId}`);
        const businessContext = inputs.businessContext || inputs.strategic_context || inputs.context || inputs.originalInput || JSON.stringify(inputs);
        try {
          switch (moduleId) {
            case "swot-analyzer":
            case "swot":
              return await swotAnalyzer.analyze({
                businessContext,
                bmcOutput: inputs.bmc_output || inputs.bmcOutput,
                portersOutput: inputs.porters_output || inputs.portersOutput,
                pestleOutput: inputs.pestle_output || inputs.pestleOutput
              });
            case "ansoff-analyzer":
            case "ansoff":
              return await ansoffAnalyzer.analyze({
                businessContext,
                currentProducts: inputs.currentProducts,
                currentMarkets: inputs.currentMarkets,
                swotOutput: inputs.swot_output || inputs.swotOutput,
                bmcOutput: inputs.bmc_output || inputs.bmcOutput
              });
            case "bmc-analyzer":
            case "business_model_canvas":
            case "bmc":
              const bmcAnalyzer3 = new BMCAnalyzer();
              if (inputs.bmcResults || inputs.frameworkResults) {
                return await bmcAnalyzer3.analyze(inputs.bmcResults || inputs.frameworkResults);
              }
              console.log("[CustomJourneyExecutor] BMC analyzer needs framework results input");
              return this.generateMockOutput(moduleId, inputs);
            case "porters-analyzer":
            case "porters_five_forces":
            case "porters":
              const portersAnalyzer3 = new PortersAnalyzer();
              if (inputs.portersResults || inputs.frameworkResults) {
                return await portersAnalyzer3.analyze(inputs.portersResults || inputs.frameworkResults);
              }
              console.log("[CustomJourneyExecutor] Porter's analyzer needs framework results input");
              return this.generateMockOutput(moduleId, inputs);
            case "pestle-analyzer":
            case "pestle":
              const pestleAnalyzer3 = new PESTLEAnalyzer();
              if (inputs.pestleResults || inputs.frameworkResults) {
                return await pestleAnalyzer3.analyze(inputs.pestleResults || inputs.frameworkResults);
              }
              console.log("[CustomJourneyExecutor] PESTLE analyzer needs framework results input");
              return this.generateMockOutput(moduleId, inputs);
            case "jtbd-analyzer":
            case "jobs_to_be_done":
            case "jtbd":
              return await jtbdAnalyzer.analyze({
                businessContext,
                targetSegments: inputs.targetSegments || inputs.target_segments
              });
            case "vrio-analyzer":
            case "vrio":
              const resources2 = inputs.resources || inputs.keyResources || ["General capabilities"];
              return await vrioAnalyzer.analyze({
                businessContext,
                resources: Array.isArray(resources2) ? resources2 : [resources2]
              });
            case "scenario-planning-analyzer":
            case "scenario_planning":
              return await scenarioPlanningAnalyzer.analyze({
                businessContext,
                timeHorizon: inputs.timeHorizon || inputs.time_horizon || "3-5 years",
                uncertainties: inputs.uncertainties || inputs.macro_factors || ["Market conditions", "Technology changes"]
              });
            case "blue-ocean-analyzer":
            case "blue_ocean":
              return await blueOceanAnalyzer.analyze({
                businessContext,
                industry: inputs.industry || inputs.industryAnalysis || "General",
                currentOffering: inputs.currentOffering || inputs.offerings || ["Current products/services"],
                swotOutput: inputs.swot_output || inputs.swotOutput,
                portersOutput: inputs.porters_output || inputs.portersOutput
              });
            case "ocean-strategy-analyzer":
            case "ocean_strategy":
              return await oceanStrategyAnalyzer.analyze({
                businessContext,
                industry: inputs.industry || inputs.industryAnalysis || "General",
                currentMarketPosition: inputs.currentMarketPosition,
                competitiveLandscape: inputs.competitiveLandscape,
                blueOceanOutput: inputs.blue_ocean_output || inputs.blueOceanOutput,
                swotOutput: inputs.swot_output || inputs.swotOutput
              });
            case "bcg-matrix-analyzer":
            case "bcg_matrix":
              const products = inputs.products || inputs.businessUnits || [
                { name: "Main Product", marketShare: 0.5, marketGrowth: 0.1 }
              ];
              return await bcgMatrixAnalyzer.analyze({
                businessContext,
                products: Array.isArray(products) ? products : [products],
                industryData: inputs.industryData,
                portersOutput: inputs.porters_output || inputs.portersOutput
              });
            case "value-chain-analyzer":
            case "value_chain":
              return await valueChainAnalyzer.analyze({
                businessContext,
                industry: inputs.industry || "General",
                portersOutput: inputs.porters_output || inputs.portersOutput
              });
            case "competitive-positioning-analyzer":
            case "competitive_positioning":
              const competitors = inputs.competitors || [
                { name: "Competitor 1", strengths: ["Market presence"], weaknesses: ["Limited offerings"] }
              ];
              return await competitivePositioningAnalyzer.analyze({
                businessContext,
                competitors: Array.isArray(competitors) ? competitors : [competitors],
                targetMarket: inputs.targetMarket || inputs.target_market || "General market",
                bmcOutput: inputs.bmc_output || inputs.bmcOutput,
                portersOutput: inputs.porters_output || inputs.portersOutput
              });
            case "five-whys-analyzer":
            case "five_whys":
              const fiveWhysCoach2 = new FiveWhysCoach();
              const problemStatement = inputs.problemStatement || inputs.problem_statement || businessContext;
              return {
                problemStatement,
                whyChain: [],
                rootCause: null,
                status: "initialized",
                message: "Five Whys analysis initialized - requires user interaction to complete the why chain",
                metadata: {
                  generatedAt: (/* @__PURE__ */ new Date()).toISOString(),
                  moduleId
                }
              };
            case "segment-discovery-analyzer":
            case "segment_discovery":
              const segmentEngine = new SegmentDiscoveryEngine();
              const segmentMode = inputs.mode || (businessContext.toLowerCase().includes("b2b") ? "b2b" : "b2c");
              try {
                const geneLibrary = await segmentEngine.generateGeneLibrary(businessContext, segmentMode);
                return {
                  type: "segment_discovery_output",
                  mode: segmentMode,
                  geneLibrary,
                  segments: [],
                  status: "gene_library_generated",
                  metadata: {
                    generatedAt: (/* @__PURE__ */ new Date()).toISOString()
                  }
                };
              } catch (segmentError) {
                console.error("[CustomJourneyExecutor] Segment Discovery error:", segmentError.message);
                return this.generateMockOutput(moduleId, inputs);
              }
            case "okr-generator":
            case "okr":
              const okrGenerator2 = new OKRGenerator();
              const strategicGoals = inputs.strategicGoals || inputs.strategic_goals || (inputs.decisions?.map((d) => d.title) || ["Improve operations", "Increase market share"]);
              const timeframe = inputs.timeframe || inputs.time_horizon || "12 months";
              return await okrGenerator2.generate({
                businessContext,
                strategicGoals: Array.isArray(strategicGoals) ? strategicGoals : [strategicGoals],
                timeframe
              });
            case "epm-generator":
            case "epm":
              if (!process.env.OPENAI_API_KEY) {
                console.error("[CustomJourneyExecutor] OPENAI_API_KEY not set, EPM synthesis will fail");
                throw new Error("EPM synthesis requires OPENAI_API_KEY environment variable");
              }
              const epmLlm = createOpenAIProvider({
                apiKey: process.env.OPENAI_API_KEY,
                model: process.env.OPENAI_MODEL || "gpt-4o"
              });
              const epmSynthesizer2 = new EPMSynthesizer(epmLlm);
              const strategyInsights2 = {
                analysisType: inputs.frameworkType || "comprehensive",
                data: inputs.analysisResults || inputs.aggregatedOutputs || inputs
              };
              try {
                const epmProgram = await epmSynthesizer2.synthesize(
                  { insights: [strategyInsights2] },
                  {
                    userInput: businessContext,
                    initiativeType: inputs.initiativeType || "strategic"
                  }
                );
                return epmProgram;
              } catch (epmError) {
                console.error("[CustomJourneyExecutor] EPM Synthesizer error:", epmError.message);
                return {
                  error: epmError.message,
                  type: "epm_program",
                  status: "failed",
                  partialData: inputs
                };
              }
            default:
              console.log(`[CustomJourneyExecutor] No real analyzer found for ${moduleId}, using mock`);
              return this.generateMockOutput(moduleId, inputs);
          }
        } catch (error) {
          console.error(`[CustomJourneyExecutor] Analyzer error for ${moduleId}:`, error.message);
          return this.generateMockOutput(moduleId, inputs);
        }
      }
      /**
       * Check if module ID represents a user input step
       */
      isUserInputStep(moduleId) {
        const normalized = moduleId.toLowerCase().replace(/_/g, "-");
        return USER_INPUT_STEPS.some(
          (step) => moduleId === step || normalized === step.replace(/_/g, "-") || moduleId.includes("strategic") && moduleId.includes("decision")
        );
      }
      /**
       * Generate placeholder decisions structure based on prior analysis
       */
      generatePlaceholderDecisions(aggregatedOutputs) {
        const decisions = [];
        const swotOutput = aggregatedOutputs["swot"] || aggregatedOutputs["swot-analyzer"] || null;
        if (swotOutput) {
          decisions.push({
            id: "strategic_direction",
            title: "Strategic Direction",
            question: "Based on the analysis, what strategic direction should we pursue?",
            context: "Consider the strengths, weaknesses, opportunities, and threats identified.",
            options: [
              {
                id: "growth",
                label: "Growth Strategy",
                description: "Focus on expanding market share and capabilities",
                pros: ["Increased revenue potential", "Market leadership"],
                cons: ["Higher investment required", "Increased risk"]
              },
              {
                id: "consolidation",
                label: "Consolidation Strategy",
                description: "Focus on optimizing current operations and market position",
                pros: ["Lower risk", "Improved efficiency"],
                cons: ["Limited growth", "Potential market share loss"]
              },
              {
                id: "transformation",
                label: "Transformation Strategy",
                description: "Pursue significant changes to business model or offerings",
                pros: ["Innovation potential", "New market opportunities"],
                cons: ["High disruption", "Significant investment"]
              }
            ],
            impact_areas: ["Market Position", "Revenue", "Operations"]
          });
        }
        if (decisions.length === 0) {
          decisions.push({
            id: "initial_focus",
            title: "Initial Focus Area",
            question: "What should be the initial focus area for this initiative?",
            context: "Select the primary area to focus strategic efforts.",
            options: [
              {
                id: "market_expansion",
                label: "Market Expansion",
                description: "Focus on entering new markets or segments",
                pros: ["Growth opportunities", "Diversification"],
                cons: ["Market research needed", "Competitive challenges"]
              },
              {
                id: "product_innovation",
                label: "Product Innovation",
                description: "Focus on developing new products or services",
                pros: ["Differentiation", "Premium pricing potential"],
                cons: ["R&D investment", "Time to market"]
              },
              {
                id: "operational_excellence",
                label: "Operational Excellence",
                description: "Focus on improving efficiency and reducing costs",
                pros: ["Quick wins", "Improved margins"],
                cons: ["Limited growth impact", "Employee concerns"]
              }
            ],
            impact_areas: ["Operations", "Strategy", "Resources"]
          });
        }
        return {
          decisions,
          decision_flow: "sequential",
          estimated_completion_time_minutes: 10
        };
      }
      /**
       * Normalize module ID to analyzer ID format
       */
      normalizeModuleId(moduleId) {
        const mapped = FRAMEWORK_KEY_TO_MODULE_ID[moduleId];
        if (mapped) return mapped;
        const hyphenated = moduleId.replace(/_/g, "-");
        const mappedHyphen = FRAMEWORK_KEY_TO_MODULE_ID[hyphenated];
        if (mappedHyphen) return mappedHyphen;
        return moduleId;
      }
      /**
       * Apply cognitive bridge between frameworks if one exists
       * Bridges transform outputs from one framework into enriched context for the next
       */
      async applyBridgeIfExists(sourceModuleId, targetModuleId, sourceOutput, allOutputs) {
        const normalizedSource = this.getFrameworkKey(sourceModuleId);
        const normalizedTarget = this.getFrameworkKey(targetModuleId);
        console.log(`[CustomJourneyExecutor] Checking for bridge: ${normalizedSource} \u2192 ${normalizedTarget}`);
        try {
          switch (`${normalizedSource}_to_${normalizedTarget}`) {
            case "pestle_to_porters":
              return await applyPESTLEToPortersBridge(sourceOutput, {});
            case "porters_to_swot":
              const pestleForSwot = this.findOutputByType(allOutputs, "pestle");
              return await applyPortersToSWOTBridge(sourceOutput, pestleForSwot, {});
            case "five_whys_to_bmc":
            case "whys_to_bmc":
              const whysInput = {
                rootCauses: sourceOutput.rootCauses || sourceOutput.root_causes || [],
                whysPath: sourceOutput.whysPath || sourceOutput.whys_path || [],
                strategicImplications: sourceOutput.strategicImplications || sourceOutput.strategic_implications || [],
                userInput: sourceOutput.userInput || sourceOutput.businessContext || ""
              };
              return transformWhysToBMC(whysInput);
            case "five_whys_to_swot":
            case "whys_to_swot":
              return transformWhysToSwot(sourceOutput);
            case "swot_to_bmc":
              return transformSwotToBmc(sourceOutput);
            case "porters_to_bmc":
              return transformPortersToBmc(sourceOutput);
            case "bmc_to_blue_ocean":
            case "bmc_to_blueocean":
              return transformBmcToBlueOcean(sourceOutput);
            case "pestle_to_bmc":
              return transformPestleToBmc(sourceOutput);
            case "bmc_to_ansoff":
              return transformBmcToAnsoff(sourceOutput);
            case "pestle_to_ansoff":
              return transformPestleToAnsoff(sourceOutput);
            case "ansoff_to_bmc":
              return transformAnsoffToBmc(sourceOutput);
            default:
              return null;
          }
        } catch (error) {
          console.warn(`[CustomJourneyExecutor] Bridge error (${normalizedSource} \u2192 ${normalizedTarget}):`, error.message);
          return null;
        }
      }
      /**
       * Get the canonical framework key for bridge lookup
       */
      getFrameworkKey(moduleId) {
        const reverseMap = {
          "pestle-analyzer": "pestle",
          "porters-analyzer": "porters",
          "swot-analyzer": "swot",
          "bmc-analyzer": "bmc",
          "five-whys-analyzer": "five_whys",
          "ansoff-analyzer": "ansoff",
          "blue-ocean-analyzer": "blue_ocean",
          "value-chain-analyzer": "value_chain",
          "vrio-analyzer": "vrio",
          "bcg-matrix-analyzer": "bcg_matrix"
        };
        return reverseMap[moduleId] || moduleId.replace(/-analyzer$/, "").replace(/-/g, "_");
      }
      /**
       * Find output by framework type from all outputs
       */
      findOutputByType(allOutputs, frameworkType) {
        for (const [key, value] of Object.entries(allOutputs)) {
          if (key.includes(frameworkType) || key.includes(frameworkType.replace(/_/g, "-"))) {
            return value;
          }
        }
        return null;
      }
      /**
       * Save framework analysis results to frameworkInsights table
       */
      async saveToFrameworkInsights(understandingId, sessionId, frameworkName, insights, duration) {
        try {
          const storedFrameworkName = frameworkName.replace("-analyzer", "").replace(/-/g, "_");
          console.log(`[CustomJourneyExecutor] Saving ${storedFrameworkName} to frameworkInsights`);
          await db.insert(frameworkInsights).values({
            understandingId,
            sessionId,
            frameworkName: storedFrameworkName,
            frameworkVersion: "1.0",
            insights,
            telemetry: {
              duration,
              executedAt: (/* @__PURE__ */ new Date()).toISOString(),
              source: "custom_journey_executor"
            }
          }).onConflictDoNothing();
          console.log(`[CustomJourneyExecutor] \u2713 Saved ${storedFrameworkName} insights`);
        } catch (error) {
          console.error(`[CustomJourneyExecutor] Failed to save framework insights:`, error.message);
        }
      }
      generateMockOutput(moduleId, inputs) {
        const baseOutput = {
          moduleId,
          processedAt: (/* @__PURE__ */ new Date()).toISOString(),
          inputSummary: Object.keys(inputs).length > 0 ? `Processed ${Object.keys(inputs).length} inputs` : "No inputs received"
        };
        if (moduleId.includes("bmc") || moduleId.includes("business-model")) {
          return {
            ...baseOutput,
            type: "bmc_output",
            blocks: {
              customerSegments: ["Segment A", "Segment B"],
              valuePropositions: ["Value Prop 1", "Value Prop 2"],
              channels: ["Channel 1"],
              customerRelationships: ["Relationship type"],
              revenueStreams: ["Revenue stream 1"],
              keyResources: ["Resource 1"],
              keyActivities: ["Activity 1"],
              keyPartnerships: ["Partner 1"],
              costStructure: ["Cost 1"]
            }
          };
        }
        if (moduleId.includes("swot")) {
          return {
            ...baseOutput,
            type: "swot_output",
            strengths: ["Strength 1", "Strength 2"],
            weaknesses: ["Weakness 1"],
            opportunities: ["Opportunity 1", "Opportunity 2"],
            threats: ["Threat 1"]
          };
        }
        if (moduleId.includes("porter")) {
          return {
            ...baseOutput,
            type: "porters_output",
            forces: {
              competitiveRivalry: "Medium",
              supplierPower: "Low",
              buyerPower: "High",
              threatOfSubstitution: "Medium",
              threatOfNewEntry: "Low"
            }
          };
        }
        if (moduleId.includes("pestle")) {
          return {
            ...baseOutput,
            type: "pestle_output",
            factors: {
              political: ["Factor 1"],
              economic: ["Factor 2"],
              social: ["Factor 3"],
              technological: ["Factor 4"],
              legal: ["Factor 5"],
              environmental: ["Factor 6"]
            }
          };
        }
        if (moduleId.includes("five-whys")) {
          return {
            ...baseOutput,
            type: "five_whys_output",
            rootCause: "Identified root cause",
            whysChain: ["Why 1", "Why 2", "Why 3", "Why 4", "Why 5"]
          };
        }
        return {
          ...baseOutput,
          type: "generic_output",
          result: `Output from ${moduleId}`,
          data: { success: true }
        };
      }
      sleep(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
      }
    };
    customJourneyExecutor = new CustomJourneyExecutor();
  }
});

// server/routes/custom-journey-builder.ts
import { Router as Router16 } from "express";
import { eq as eq34, desc as desc19, and as and23, ne as ne3 } from "drizzle-orm";
import { z as z9 } from "zod";
var router15, nodeSchema, edgeSchema, createJourneyConfigSchema, updateJourneyConfigSchema, validateJourneySchema, custom_journey_builder_default;
var init_custom_journey_builder = __esm({
  "server/routes/custom-journey-builder.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_registry();
    init_compatibility();
    init_custom_journey_executor();
    router15 = Router16();
    nodeSchema = z9.object({
      id: z9.string(),
      moduleId: z9.string(),
      position: z9.object({
        x: z9.number(),
        y: z9.number()
      }),
      config: z9.record(z9.any()).optional()
    });
    edgeSchema = z9.object({
      id: z9.string(),
      sourceNodeId: z9.string(),
      sourcePortId: z9.string(),
      targetNodeId: z9.string(),
      targetPortId: z9.string()
    });
    createJourneyConfigSchema = z9.object({
      name: z9.string().min(1).max(255),
      description: z9.string().optional(),
      nodes: z9.array(nodeSchema).default([]),
      edges: z9.array(edgeSchema).default([]),
      metadata: z9.record(z9.any()).optional()
    });
    updateJourneyConfigSchema = createJourneyConfigSchema.partial().extend({
      status: z9.enum(["draft", "published", "archived"]).optional()
    });
    validateJourneySchema = z9.object({
      nodes: z9.array(nodeSchema),
      edges: z9.array(edgeSchema)
    });
    router15.get("/modules", async (_req, res) => {
      try {
        const allModules = moduleRegistry.listModules();
        const modules = allModules.map((m) => ({
          id: m.id,
          name: m.name,
          description: m.description,
          category: m.category,
          icon: m.icon,
          status: m.status,
          inputs: m.inputs.map((i) => ({
            id: i.id,
            name: i.name,
            type: i.type,
            required: i.required,
            description: i.description
          })),
          outputs: m.outputs.map((o) => ({
            id: o.id,
            name: o.name,
            type: o.type,
            description: o.description
          })),
          estimatedDuration: m.estimatedDuration,
          tags: m.tags
        }));
        res.json({
          success: true,
          modules,
          count: modules.length
        });
      } catch (error) {
        console.error("[Custom Journey Builder] Error fetching modules:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch modules"
        });
      }
    });
    router15.get("/configs", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const status = req.query.status;
        const includeArchived = req.query.includeArchived === "true";
        let whereClause;
        if (status && ["draft", "published", "archived"].includes(status)) {
          whereClause = and23(
            eq34(customJourneyConfigs.createdBy, userId),
            eq34(customJourneyConfigs.status, status)
          );
        } else if (includeArchived) {
          whereClause = eq34(customJourneyConfigs.createdBy, userId);
        } else {
          whereClause = and23(
            eq34(customJourneyConfigs.createdBy, userId),
            ne3(customJourneyConfigs.status, "archived")
          );
        }
        const configs = await db.select().from(customJourneyConfigs).where(whereClause).orderBy(desc19(customJourneyConfigs.updatedAt));
        res.json({
          success: true,
          configs,
          count: configs.length
        });
      } catch (error) {
        console.error("[Custom Journey Builder] Error fetching configs:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch journey configs"
        });
      }
    });
    router15.get("/configs/:id", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        const { id } = req.params;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const [config] = await db.select().from(customJourneyConfigs).where(eq34(customJourneyConfigs.id, id));
        if (!config) {
          return res.status(404).json({
            success: false,
            error: "Journey config not found"
          });
        }
        if (config.createdBy !== userId && config.status !== "published") {
          return res.status(403).json({
            success: false,
            error: "Not authorized to view this config"
          });
        }
        res.json({
          success: true,
          config
        });
      } catch (error) {
        console.error("[Custom Journey Builder] Error fetching config:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch journey config"
        });
      }
    });
    router15.post("/configs", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const validatedData = createJourneyConfigSchema.parse(req.body);
        let estimatedDuration = 0;
        const nodes = validatedData.nodes;
        for (const node of nodes) {
          const module2 = moduleRegistry.getModule(node.moduleId);
          if (module2) {
            estimatedDuration += module2.estimatedDuration || 0;
          }
        }
        const [newConfig] = await db.insert(customJourneyConfigs).values({
          name: validatedData.name,
          description: validatedData.description,
          createdBy: userId,
          nodes: validatedData.nodes,
          edges: validatedData.edges,
          metadata: validatedData.metadata,
          estimatedDurationMinutes: estimatedDuration
        }).returning();
        res.status(201).json({
          success: true,
          config: newConfig
        });
      } catch (error) {
        if (error instanceof z9.ZodError) {
          return res.status(400).json({
            success: false,
            error: "Invalid request data",
            details: error.errors
          });
        }
        console.error("[Custom Journey Builder] Error creating config:", error);
        res.status(500).json({
          success: false,
          error: "Failed to create journey config"
        });
      }
    });
    router15.put("/configs/:id", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        const { id } = req.params;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const [existingConfig] = await db.select().from(customJourneyConfigs).where(eq34(customJourneyConfigs.id, id));
        if (!existingConfig) {
          return res.status(404).json({
            success: false,
            error: "Journey config not found"
          });
        }
        if (existingConfig.createdBy !== userId) {
          return res.status(403).json({
            success: false,
            error: "Not authorized to update this config"
          });
        }
        const validatedData = updateJourneyConfigSchema.parse(req.body);
        let estimatedDuration = existingConfig.estimatedDurationMinutes;
        if (validatedData.nodes) {
          estimatedDuration = 0;
          const nodes = validatedData.nodes;
          for (const node of nodes) {
            const module2 = moduleRegistry.getModule(node.moduleId);
            if (module2) {
              estimatedDuration += module2.estimatedDuration || 0;
            }
          }
        }
        const publishedAt = validatedData.status === "published" && existingConfig.status !== "published" ? /* @__PURE__ */ new Date() : existingConfig.publishedAt;
        const [updatedConfig] = await db.update(customJourneyConfigs).set({
          ...validatedData,
          estimatedDurationMinutes: estimatedDuration,
          publishedAt,
          version: existingConfig.version + 1,
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq34(customJourneyConfigs.id, id)).returning();
        res.json({
          success: true,
          config: updatedConfig
        });
      } catch (error) {
        if (error instanceof z9.ZodError) {
          return res.status(400).json({
            success: false,
            error: "Invalid request data",
            details: error.errors
          });
        }
        console.error("[Custom Journey Builder] Error updating config:", error);
        res.status(500).json({
          success: false,
          error: "Failed to update journey config"
        });
      }
    });
    router15.delete("/configs/:id", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        const { id } = req.params;
        const permanent = req.query.permanent === "true";
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const [existingConfig] = await db.select().from(customJourneyConfigs).where(eq34(customJourneyConfigs.id, id));
        if (!existingConfig) {
          return res.status(404).json({
            success: false,
            error: "Journey config not found"
          });
        }
        if (existingConfig.createdBy !== userId) {
          return res.status(403).json({
            success: false,
            error: "Not authorized to delete this config"
          });
        }
        const runningExecutions = await db.select().from(customJourneyExecutions).where(and23(
          eq34(customJourneyExecutions.configId, id),
          eq34(customJourneyExecutions.status, "running")
        ));
        if (runningExecutions.length > 0) {
          return res.status(409).json({
            success: false,
            error: "Cannot delete config with running executions"
          });
        }
        const completedExecutions = await db.select().from(customJourneyExecutions).where(and23(
          eq34(customJourneyExecutions.configId, id),
          eq34(customJourneyExecutions.status, "completed")
        ));
        if (permanent && completedExecutions.length === 0) {
          await db.delete(customJourneyExecutions).where(eq34(customJourneyExecutions.configId, id));
          await db.delete(customJourneyConfigs).where(eq34(customJourneyConfigs.id, id));
          res.json({
            success: true,
            message: "Journey config permanently deleted",
            deletedExecutions: 0
          });
        } else {
          await db.update(customJourneyConfigs).set({
            status: "archived",
            updatedAt: /* @__PURE__ */ new Date()
          }).where(eq34(customJourneyConfigs.id, id));
          res.json({
            success: true,
            message: completedExecutions.length > 0 ? "Journey archived (has execution history with artifacts)" : "Journey archived",
            archived: true,
            executionCount: completedExecutions.length
          });
        }
      } catch (error) {
        console.error("[Custom Journey Builder] Error deleting config:", error);
        res.status(500).json({
          success: false,
          error: "Failed to delete journey config"
        });
      }
    });
    router15.post("/validate", async (req, res) => {
      try {
        const validatedData = validateJourneySchema.parse(req.body);
        const { nodes, edges } = validatedData;
        const errors = [];
        const warnings = [];
        if (nodes.length === 0) {
          errors.push("Journey must have at least one node");
        }
        const nodeMap = new Map(nodes.map((n) => [n.id, n]));
        const allModules = moduleRegistry.listModules();
        const moduleMap = new Map(allModules.map((m) => [m.id, m]));
        for (const node of nodes) {
          const module2 = moduleMap.get(node.moduleId);
          if (!module2) {
            errors.push(`Unknown module: ${node.moduleId}`);
          } else if (module2.status === "stub") {
            warnings.push(`Module "${module2.name}" is not yet implemented`);
          }
        }
        const cycleResult = detectCycle(
          nodes.map((n) => ({ id: n.id })),
          edges.map((e) => ({ sourceNodeId: e.sourceNodeId, targetNodeId: e.targetNodeId }))
        );
        if (cycleResult.hasCycle) {
          errors.push(`Cycle detected in journey: ${cycleResult.cycleNodes?.join(" \u2192 ")}`);
        }
        for (const edge of edges) {
          const sourceNode = nodeMap.get(edge.sourceNodeId);
          const targetNode = nodeMap.get(edge.targetNodeId);
          if (!sourceNode || !targetNode) {
            errors.push(`Invalid edge: missing node ${!sourceNode ? edge.sourceNodeId : edge.targetNodeId}`);
            continue;
          }
          const sourceModule = moduleMap.get(sourceNode.moduleId);
          const targetModule = moduleMap.get(targetNode.moduleId);
          if (!sourceModule || !targetModule) continue;
          const sourcePort = sourceModule.outputs.find((o) => o.id === edge.sourcePortId);
          const targetPort = targetModule.inputs.find((i) => i.id === edge.targetPortId);
          if (!sourcePort) {
            errors.push(`Invalid source port: ${edge.sourcePortId} on ${sourceModule.name}`);
            continue;
          }
          if (!targetPort) {
            errors.push(`Invalid target port: ${edge.targetPortId} on ${targetModule.name}`);
            continue;
          }
          const connectionCheck = isConnectionAllowed(
            sourceNode.moduleId,
            edge.sourcePortId,
            targetNode.moduleId,
            edge.targetPortId,
            sourcePort.type,
            targetPort.type
          );
          if (!connectionCheck.allowed) {
            errors.push(`Invalid connection: ${connectionCheck.reason}`);
          }
        }
        const targetedNodes = new Set(edges.map((e) => e.targetNodeId));
        for (const node of nodes) {
          const module2 = moduleMap.get(node.moduleId);
          if (!module2) continue;
          const requiredInputs = module2.inputs.filter((i) => i.required);
          if (requiredInputs.length > 0 && !targetedNodes.has(node.id)) {
            const hasInputConnection = edges.some((e) => e.targetNodeId === node.id);
            if (!hasInputConnection && module2.type !== "processor") {
              warnings.push(`"${module2.name}" has no input connections`);
            }
          }
        }
        const executionOrder = !cycleResult.hasCycle ? getExecutionOrder(
          nodes.map((n) => ({ id: n.id })),
          edges.map((e) => ({ sourceNodeId: e.sourceNodeId, targetNodeId: e.targetNodeId }))
        ) : [];
        res.json({
          success: true,
          isValid: errors.length === 0,
          errors,
          warnings,
          executionOrder
        });
      } catch (error) {
        if (error instanceof z9.ZodError) {
          return res.status(400).json({
            success: false,
            error: "Invalid request data",
            details: error.errors
          });
        }
        console.error("[Custom Journey Builder] Error validating journey:", error);
        res.status(500).json({
          success: false,
          error: "Failed to validate journey"
        });
      }
    });
    router15.get("/executions", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const executions = await db.select().from(customJourneyExecutions).where(eq34(customJourneyExecutions.userId, userId)).orderBy(desc19(customJourneyExecutions.createdAt));
        res.json({
          success: true,
          executions,
          count: executions.length
        });
      } catch (error) {
        console.error("[Custom Journey Builder] Error fetching executions:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch executions"
        });
      }
    });
    router15.get("/executions/:id", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        const { id } = req.params;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const [execution] = await db.select().from(customJourneyExecutions).where(eq34(customJourneyExecutions.id, id));
        if (!execution) {
          return res.status(404).json({
            success: false,
            error: "Execution not found"
          });
        }
        if (execution.userId !== userId) {
          return res.status(403).json({
            success: false,
            error: "Not authorized to view this execution"
          });
        }
        res.json({
          success: true,
          execution
        });
      } catch (error) {
        console.error("[Custom Journey Builder] Error fetching execution:", error);
        res.status(500).json({
          success: false,
          error: "Failed to fetch execution"
        });
      }
    });
    router15.post("/executions", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const { configId, inputData } = req.body;
        if (!configId) {
          return res.status(400).json({
            success: false,
            error: "configId is required"
          });
        }
        const [config] = await db.select().from(customJourneyConfigs).where(eq34(customJourneyConfigs.id, configId));
        if (!config) {
          return res.status(404).json({
            success: false,
            error: "Journey config not found"
          });
        }
        const [execution] = await db.insert(customJourneyExecutions).values({
          configId,
          userId,
          inputData,
          status: "pending"
        }).returning();
        res.status(201).json({
          success: true,
          execution
        });
      } catch (error) {
        console.error("[Custom Journey Builder] Error creating execution:", error);
        res.status(500).json({
          success: false,
          error: "Failed to create execution"
        });
      }
    });
    router15.post("/executions/:id/start", async (req, res) => {
      try {
        const userId = req.user?.claims?.sub;
        const { id } = req.params;
        if (!userId) {
          return res.status(401).json({
            success: false,
            error: "Authentication required"
          });
        }
        const [execution] = await db.select().from(customJourneyExecutions).where(eq34(customJourneyExecutions.id, id));
        if (!execution) {
          return res.status(404).json({
            success: false,
            error: "Execution not found"
          });
        }
        if (execution.userId !== userId) {
          return res.status(403).json({
            success: false,
            error: "Not authorized to start this execution"
          });
        }
        if (execution.status === "running") {
          return res.status(409).json({
            success: false,
            error: "Execution is already running"
          });
        }
        if (execution.status === "completed") {
          return res.status(409).json({
            success: false,
            error: "Execution has already completed"
          });
        }
        await db.update(customJourneyExecutions).set({
          status: "running",
          startedAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date()
        }).where(eq34(customJourneyExecutions.id, id));
        console.log(`[Custom Journey Builder] Started execution: ${id}`);
        res.json({
          success: true,
          executionId: id,
          message: "Execution started. Connect to the stream endpoint for progress updates.",
          streamUrl: `/api/custom-journey-builder/executions/${id}/stream`
        });
      } catch (error) {
        console.error("[Custom Journey Builder] Error starting execution:", error);
        res.status(500).json({
          success: false,
          error: "Failed to start execution"
        });
      }
    });
    router15.get("/executions/:id/stream", async (req, res) => {
      const { id } = req.params;
      console.log(`[Custom Journey Builder] SSE stream requested for execution: ${id}`);
      res.setHeader("Content-Type", "text/event-stream");
      res.setHeader("Cache-Control", "no-cache");
      res.setHeader("Connection", "keep-alive");
      res.setHeader("X-Accel-Buffering", "no");
      res.flushHeaders();
      try {
        const [execution] = await db.select().from(customJourneyExecutions).where(eq34(customJourneyExecutions.id, id));
        if (!execution) {
          res.write(`data: ${JSON.stringify({ type: "journey_error", error: "Execution not found", timestamp: (/* @__PURE__ */ new Date()).toISOString() })}

`);
          res.end();
          return;
        }
        if (execution.status === "completed") {
          res.write(`data: ${JSON.stringify({ type: "journey_complete", aggregatedOutputs: execution.aggregatedOutputs || {}, timestamp: (/* @__PURE__ */ new Date()).toISOString() })}

`);
          res.end();
          return;
        }
        if (execution.status === "failed") {
          res.write(`data: ${JSON.stringify({ type: "journey_error", error: execution.errorMessage || "Execution failed", timestamp: (/* @__PURE__ */ new Date()).toISOString() })}

`);
          res.end();
          return;
        }
        if (execution.status !== "running") {
          res.write(`data: ${JSON.stringify({ type: "journey_error", error: "Execution has not been started. Call POST /executions/:id/start first.", timestamp: (/* @__PURE__ */ new Date()).toISOString() })}

`);
          res.end();
          return;
        }
        await customJourneyExecutor.executeJourney(id, res);
        if (!res.writableEnded) {
          res.end();
        }
      } catch (error) {
        console.error(`[Custom Journey Builder] Error in SSE stream for execution ${id}:`, error);
        if (!res.writableEnded) {
          res.write(`data: ${JSON.stringify({ type: "journey_error", error: error.message || "Stream error", timestamp: (/* @__PURE__ */ new Date()).toISOString() })}

`);
          res.end();
        }
      }
    });
    custom_journey_builder_default = router15;
  }
});

// server/modules/journey-loader.ts
import { readFileSync as readFileSync4, readdirSync } from "fs";
import { join as join5 } from "path";
import * as yaml from "js-yaml";
function loadJourneyConfigs() {
  const configs = [];
  try {
    const files = readdirSync(JOURNEYS_DIR).filter((f) => f.endsWith(".yaml") || f.endsWith(".yml"));
    for (const file of files) {
      try {
        const filePath = join5(JOURNEYS_DIR, file);
        const content = readFileSync4(filePath, "utf-8");
        const yamlConfig = yaml.load(content);
        const config = yamlToJourneyConfig(yamlConfig);
        configs.push(config);
        console.log(`[JourneyLoader] Loaded journey config: ${config.id} from ${file}`);
      } catch (err) {
        console.error(`[JourneyLoader] Failed to load journey from ${file}:`, err);
      }
    }
  } catch (err) {
    console.warn(`[JourneyLoader] Journeys directory not found or empty: ${JOURNEYS_DIR}`);
  }
  return configs;
}
var JOURNEYS_DIR;
var init_journey_loader = __esm({
  "server/modules/journey-loader.ts"() {
    "use strict";
    init_journey_config();
    JOURNEYS_DIR = join5(process.cwd(), "server", "modules", "journeys");
  }
});

// server/modules/initialize.ts
function initializeModuleSystem() {
  if (initialized) {
    console.log("[ModuleSystem] Already initialized, skipping");
    return;
  }
  console.log("[ModuleSystem] Initializing module catalog and journey config system...");
  for (const manifest of allManifests) {
    const result = moduleRegistry.registerModule(manifest);
    if (!result.success) {
      console.error(`[ModuleSystem] Failed to register ${manifest.id}: ${result.errors.join(", ")}`);
    }
  }
  const journeyConfigs = loadJourneyConfigs();
  for (const config of journeyConfigs) {
    const result = moduleRegistry.loadJourney(config);
    if (!result.success) {
      console.error(`[ModuleSystem] Failed to load journey ${config.id}: ${result.errors.join(", ")}`);
    }
  }
  const stats = moduleRegistry.getStats();
  console.log(`[ModuleSystem] \u2713 Initialization complete: Registered ${stats.moduleCount} modules, loaded ${stats.journeyCount} journeys`);
  initialized = true;
}
var initialized;
var init_initialize = __esm({
  "server/modules/initialize.ts"() {
    "use strict";
    init_registry();
    init_manifests();
    init_journey_loader();
    initialized = false;
  }
});

// server/services/encryption-migration.ts
var encryption_migration_exports = {};
__export(encryption_migration_exports, {
  runEncryptionMigration: () => runEncryptionMigration
});
import { eq as eq35, sql as sql13 } from "drizzle-orm";
async function isPlaintextJSON(value) {
  if (!value) return false;
  let parsed;
  try {
    parsed = typeof value === "string" ? JSON.parse(value) : value;
  } catch (e) {
    return true;
  }
  if (parsed && typeof parsed === "object" && "dataKeyCiphertext" in parsed && "iv" in parsed && "ciphertext" in parsed && "authTag" in parsed) {
    return false;
  }
  return true;
}
async function runEncryptionMigration(options) {
  const { dryRun, batchSize = 50, onProgress } = options;
  const stats = {
    total: 0,
    encrypted: 0,
    skipped: 0,
    failed: 0,
    duration: 0
  };
  const startTime = Date.now();
  try {
    const versions = await db.select({
      id: strategyVersions.id,
      analysisData: strategyVersions.analysisData,
      decisionsData: strategyVersions.decisionsData,
      createdAt: strategyVersions.createdAt
    }).from(strategyVersions).where(sql13`${strategyVersions.analysisData} IS NOT NULL OR ${strategyVersions.decisionsData} IS NOT NULL`);
    stats.total = versions.length;
    let processed = 0;
    for (const version of versions) {
      processed++;
      try {
        const needsUpdate = {
          analysisData: await isPlaintextJSON(version.analysisData),
          decisionsData: await isPlaintextJSON(version.decisionsData)
        };
        if (!needsUpdate.analysisData && !needsUpdate.decisionsData) {
          stats.skipped++;
          continue;
        }
        if (onProgress) {
          onProgress({
            id: version.id,
            analysisPlaintext: needsUpdate.analysisData,
            decisionsPlaintext: needsUpdate.decisionsData
          }, processed, versions.length);
        }
        if (dryRun) {
          stats.encrypted++;
          continue;
        }
        const updateData = {};
        if (needsUpdate.analysisData && version.analysisData) {
          updateData.analysisData = await encryptJSONKMS(version.analysisData);
        }
        if (needsUpdate.decisionsData && version.decisionsData) {
          updateData.decisionsData = await encryptJSONKMS(version.decisionsData);
        }
        await db.update(strategyVersions).set(updateData).where(eq35(strategyVersions.id, version.id));
        stats.encrypted++;
        if (processed % batchSize === 0) {
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      } catch (error) {
        stats.failed++;
        console.error(`Error encrypting record ${version.id}:`, error);
      }
    }
    stats.duration = Date.now() - startTime;
  } catch (error) {
    console.error("Migration failed:", error);
    throw error;
  }
  return stats;
}
var init_encryption_migration = __esm({
  "server/services/encryption-migration.ts"() {
    "use strict";
    init_db();
    init_schema();
    init_kms_encryption();
  }
});

// server/routes.ts
var routes_exports = {};
__export(routes_exports, {
  registerRoutes: () => registerRoutes
});
import { createServer } from "http";
import { eq as eq36, and as and24, or as or5, desc as desc20, sql as sql14 } from "drizzle-orm";
async function registerRoutes(app2) {
  initializeModuleSystem();
  setupAuthMiddleware(app2);
  const shouldSkipOIDC = process.env.DEV_AUTH_BYPASS === "true" && process.env.NODE_ENV === "development";
  if (!shouldSkipOIDC) {
    const { finishAuthSetup: finishAuthSetup2 } = await Promise.resolve().then(() => (init_replitAuth(), replitAuth_exports));
    await finishAuthSetup2(app2);
    console.log("[Auth] OIDC authentication configured");
  } else {
    console.log("[Auth] Skipping OIDC setup (DEV_AUTH_BYPASS=true in development)");
  }
  app2.get("/api/auth/user", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await storage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
  app2.get("/api/dashboard-summary", isAuthenticated, async (req, res) => {
    try {
      const userId = req.user.claims.sub;
      const summary = await storage.getDashboardSummary(userId);
      res.json(summary);
    } catch (error) {
      console.error("Error fetching dashboard summary:", error);
      res.status(500).json({ message: "Failed to fetch dashboard summary" });
    }
  });
  app2.post("/api/test/intelligent-planning", async (req, res) => {
    try {
      console.log("\n========================================");
      console.log("\u{1F9EA} TEST MODE: Intelligent Planning ENABLED (request-scoped)");
      console.log("========================================\n");
      const { EPMSynthesizer: EPMSynthesizer2 } = await Promise.resolve().then(() => (init_intelligence(), intelligence_exports));
      const { createOpenAIProvider: createOpenAIProvider2 } = await Promise.resolve().then(() => (init_llm_provider(), llm_provider_exports));
      const llm2 = createOpenAIProvider2({
        apiKey: process.env.OPENAI_API_KEY || "",
        model: "gpt-5"
      });
      const epmSynthesizer2 = new EPMSynthesizer2(llm2);
      const { insights, userDecisions, namingContext } = req.body;
      if (!insights) {
        return res.status(400).json({ error: "Missing required field: insights" });
      }
      const epmProgram = await epmSynthesizer2.synthesize(
        insights,
        userDecisions,
        namingContext,
        { forceIntelligentPlanning: true }
        // Request-scoped override
      );
      console.log("\n========================================");
      console.log("\u2705 TEST COMPLETE: Intelligent Planning Result");
      console.log("========================================\n");
      res.json({
        success: true,
        usedIntelligentPlanning: true,
        program: epmProgram,
        testMode: true,
        message: "This was generated with intelligent planning enabled (request-scoped)"
      });
    } catch (error) {
      console.error("\u274C TEST FAILED: Intelligent Planning Error:", error);
      res.status(500).json({
        error: error.message || "Intelligent planning test failed",
        stack: error.stack,
        usedIntelligentPlanning: true,
        testMode: true
      });
    }
  });
  app2.post("/api/dev/quick-epm-test", async (req, res) => {
    if (process.env.NODE_ENV === "production") {
      return res.status(404).json({ error: "Endpoint not available in production" });
    }
    try {
      console.log("\n\u{1F680} DEV MODE: Quick EPM Test Starting...\n");
      const { EPMSynthesizer: EPMSynthesizer2, BMCAnalyzer: BMCAnalyzer2 } = await Promise.resolve().then(() => (init_intelligence(), intelligence_exports));
      const { createOpenAIProvider: createOpenAIProvider2 } = await Promise.resolve().then(() => (init_llm_provider(), llm_provider_exports));
      const sampleBMC = {
        customerSegments: `Local Brooklyn residents (Williamsburg neighborhood)
Remote workers seeking workspace
Morning commuters (6-9am rush)
Students and freelancers
Weekend brunch crowd`,
        valuePropositions: `Artisanal single-origin coffee from Brooklyn roasters
Cozy community gathering space with free WiFi
Fresh daily-baked pastries and breakfast sandwiches
Laptop-friendly environment for remote work
Local art displays and community events`,
        revenueStreams: `Coffee and espresso drinks ($4-7 per drink)
Food sales (pastries, sandwiches, bagels)
Merchandise (mugs, bags of beans)
Catering for local businesses and events
Private event space rental`,
        channels: `Walk-in storefront (Bedford Ave location)
Instagram and local social media
Partnerships with neighborhood gyms and offices
Word-of-mouth and community events
Simple online ordering for pickup`,
        customerRelationships: `Personalized barista service and name recognition
Loyalty punch card program (10th drink free)
Weekly community events (open mic, art shows)
Regular customer relationships
Active neighborhood presence`,
        keyResources: `Prime Brooklyn retail location (1200 sq ft)
Experienced baristas and staff (8 employees)
Commercial espresso machines and grinders
Relationships with local Brooklyn coffee roasters
Cozy interior atmosphere with 30 seats`,
        keyActivities: `Daily coffee preparation and beverage service
Fresh food preparation (in-house baking)
Customer service and relationship building
Social media marketing and community engagement
Inventory management and supplier coordination`,
        keyPartnerships: `Brooklyn coffee roasters (Cafe Grumpy, Devoci\xF3n)
Local bakeries for pastries
Food suppliers (dairy, produce)
Neighborhood businesses for cross-promotion
Local artists for rotating displays`,
        costStructure: `Rent and utilities: $8k/month
Staff salaries: $25k/month
Coffee and food inventory: $12k/month
Equipment maintenance: $2k/month
Marketing and events: $3k/month`,
        viability: "strong",
        contradictions: [],
        criticalGaps: [],
        overallConfidence: 0.85,
        recommendations: [
          "Focus on building strong community presence and regular customer base",
          "Develop signature drinks and food items for differentiation",
          "Create a welcoming third-place environment for remote workers",
          "Build strategic partnerships with local Brooklyn roasters and suppliers"
        ],
        executiveSummary: "Traditional Brooklyn coffee shop serving artisanal coffee in a community-focused environment. Business model centers on quality beverages, fresh food, and creating a neighborhood gathering space for local residents and remote workers."
      };
      console.log("\u{1F4CA} Converting sample BMC to StrategyInsights...");
      const bmcAnalyzer3 = new BMCAnalyzer2();
      const insights = await bmcAnalyzer3.analyze(sampleBMC);
      console.log(`\u2713 Insights extracted: ${insights.insights.length} total`);
      console.log(`\u2713 Overall confidence: ${Math.round(insights.overallConfidence * 100)}%`);
      console.log(`\u2713 Market context: ${insights.marketContext.industry || "tech-enabled retail"}`);
      const llm2 = createOpenAIProvider2({
        apiKey: process.env.OPENAI_API_KEY || "",
        model: "gpt-4o"
      });
      const epmSynthesizer2 = new EPMSynthesizer2(llm2);
      const userContext = {
        timelineUrgency: "Strategic",
        budgetRange: {
          min: 4e5,
          max: 5e5
        }
      };
      const namingContext = {
        businessName: "Brooklyn Artisan Coffee Shop",
        executiveInput: "Launch neighborhood coffee shop in Williamsburg, Brooklyn"
      };
      console.log("\n\u26A1 Generating EPM with Intelligent Planning enabled...\n");
      const epmProgram = await epmSynthesizer2.synthesize(
        insights,
        userContext,
        namingContext,
        { forceIntelligentPlanning: true }
      );
      console.log("\n\u2705 DEV TEST COMPLETE!\n");
      console.log(`Program: ${epmProgram.programName || "Unnamed"}`);
      console.log(`Workstreams: ${epmProgram.workstreams.length}`);
      console.log(`Overall Confidence: ${Math.round(epmProgram.overallConfidence * 100)}%`);
      res.json({
        success: true,
        message: "Quick EPM test completed - check server logs for intelligent planning output",
        program: epmProgram,
        testData: {
          insights,
          userContext,
          namingContext
        }
      });
    } catch (error) {
      console.error("\u274C Quick EPM test failed:", error);
      res.status(500).json({
        error: error.message,
        stack: error.stack
      });
    }
  });
  const requireAuth = isAuthenticated;
  app2.use("/api/strategic-consultant-v2", requireAuth, strategic_consultant_v2_default);
  app2.use("/api/strategic-consultant", requireAuth, strategic_consultant_legacy_default);
  app2.use("/api/strategic-consultant-legacy", requireAuth, strategic_consultant_legacy_default);
  app2.use("/api/document-enrichment", document_enrichment_default);
  app2.use("/api/trend-analysis", requireAuth, trend_analysis_default);
  app2.use("/api/repository", requireAuth, statement_repository_routes_default);
  app2.use("/api/strategy-workspace", requireAuth, strategy_workspace_default);
  app2.use("/api/journey-builder", requireAuth, journey_builder_default);
  app2.use("/api/task-assignments", requireAuth, task_assignments_default);
  app2.use("/api/exports", requireAuth, exports_default);
  app2.use("/api/knowledge", requireAuth, knowledge_default);
  app2.use("/api/marketing-consultant", requireAuth, marketing_consultant_default);
  app2.use("/api/strategies", requireAuth, strategies_hub_default);
  app2.use("/api", requireAuth, epm_crud_default);
  app2.use("/api/ontology", requireAuth, ontology_default);
  app2.use("/api/module-registry", moduleRegistryRouter);
  app2.use("/api/custom-journey-builder", requireAuth, custom_journey_builder_default);
  const requireRole2 = (roles) => async (req, res, next) => {
    if (!req.user?.claims?.sub) {
      return res.status(401).json({ message: "Authentication required" });
    }
    try {
      const user = await storage.getUser(req.user.claims.sub);
      if (!user || !roles.includes(user.role)) {
        return res.status(403).json({ message: "Insufficient permissions" });
      }
      next();
    } catch (error) {
      return res.status(500).json({ message: "Failed to verify permissions" });
    }
  };
  app2.get("/api/session-context", requireAuth, async (req, res) => {
    try {
      const userId = req.user?.claims?.sub;
      if (!userId) {
        return res.status(401).json({ message: "Unauthorized" });
      }
      const [activeJourney] = await db.select().from(journeySessions).where(
        and24(
          eq36(journeySessions.userId, userId),
          eq36(journeySessions.status, "in_progress")
        )
      ).orderBy(desc20(journeySessions.updatedAt)).limit(1);
      if (activeJourney) {
        const accumulatedContext = activeJourney.accumulatedContext || {};
        const currentFramework = accumulatedContext.currentFramework || "Unknown Framework";
        const completedFrameworks = activeJourney.completedFrameworks || [];
        const insights = accumulatedContext.insights || {};
        const keyInsights = [];
        if (insights.rootCauses && Array.isArray(insights.rootCauses)) {
          keyInsights.push(...insights.rootCauses.slice(0, 3));
        }
        if (insights.strategicImplications && Array.isArray(insights.strategicImplications)) {
          keyInsights.push(...insights.strategicImplications.slice(0, 2));
        }
        const sessionContext3 = {
          id: activeJourney.id,
          goal: `Strategic Analysis Journey: ${activeJourney.journeyType}`,
          successCriteria: [
            `\u2713 Complete ${currentFramework} analysis`,
            `${completedFrameworks.length} of ${(activeJourney.currentFrameworkIndex || 0) + 1} frameworks completed`,
            ...keyInsights.slice(0, 3).map((insight) => `\u2022 ${insight}`)
          ],
          currentPhase: `Analyzing: ${currentFramework}`,
          decisionsLog: [],
          isActive: true,
          createdAt: activeJourney.createdAt,
          updatedAt: activeJourney.updatedAt
        };
        return res.json(sessionContext3);
      }
      res.json(null);
    } catch (error) {
      console.error("[Session Context] Error:", error);
      res.status(500).json({ message: "Failed to fetch session context" });
    }
  });
  app2.post("/api/session-context", requireAuth, async (req, res) => {
    try {
      const validatedData = insertSessionContextSchema.parse(req.body);
      const context = await storage.createSessionContext(validatedData);
      res.status(201).json(context);
    } catch (error) {
      res.status(400).json({ message: "Invalid session context data" });
    }
  });
  app2.patch("/api/session-context/:id", requireAuth, async (req, res) => {
    try {
      const allowedFields = ["goal", "successCriteria", "currentPhase", "decisionsLog"];
      const updates = Object.keys(req.body);
      const invalidFields = updates.filter((field) => !allowedFields.includes(field));
      if (invalidFields.length > 0) {
        return res.status(400).json({ message: `Invalid fields: ${invalidFields.join(", ")}` });
      }
      if (req.body.successCriteria && !Array.isArray(req.body.successCriteria)) {
        return res.status(400).json({ message: "successCriteria must be an array" });
      }
      const context = await storage.updateSessionContext(req.params.id, req.body);
      res.json(context);
    } catch (error) {
      res.status(400).json({ message: error.message || "Failed to update session context" });
    }
  });
  app2.post("/api/session-context/:id/decision", requireAuth, async (req, res) => {
    try {
      if (!req.body.decision || typeof req.body.decision !== "string") {
        return res.status(400).json({ message: "decision (string) is required" });
      }
      const context = await storage.addDecisionToContext(req.params.id, {
        decision: req.body.decision,
        reason: req.body.reason || ""
      });
      res.json(context);
    } catch (error) {
      res.status(400).json({ message: error.message || "Failed to add decision" });
    }
  });
  app2.post("/api/session-context/:id/deactivate", requireAuth, async (req, res) => {
    try {
      await storage.deactivateSessionContext(req.params.id);
      res.json({ success: true });
    } catch (error) {
      res.status(400).json({ message: "Failed to deactivate session context" });
    }
  });
  app2.post("/api/assessment/program", requireAuth, async (req, res) => {
    try {
      const { program, relatedData } = req.body;
      if (!program) {
        return res.status(400).json({ message: "program data required" });
      }
      const assessment = await assessmentService.assessProgram(program, relatedData);
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Failed to assess program" });
    }
  });
  app2.post("/api/assessment/task", requireAuth, async (req, res) => {
    try {
      const { task, program } = req.body;
      if (!task) {
        return res.status(400).json({ message: "task data required" });
      }
      const assessment = await assessmentService.assessTask(task, program);
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Failed to assess task" });
    }
  });
  app2.post("/api/assessment/risk", requireAuth, async (req, res) => {
    try {
      const { risk, mitigations } = req.body;
      if (!risk) {
        return res.status(400).json({ message: "risk data required" });
      }
      const assessment = await assessmentService.assessRisk(risk, mitigations);
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Failed to assess risk" });
    }
  });
  app2.post("/api/assessment/benefit", requireAuth, async (req, res) => {
    try {
      const { benefit, program } = req.body;
      if (!benefit) {
        return res.status(400).json({ message: "benefit data required" });
      }
      const assessment = await assessmentService.assessBenefit(benefit, program);
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Failed to assess benefit" });
    }
  });
  app2.post("/api/assessment/resource", requireAuth, async (req, res) => {
    try {
      const { resource } = req.body;
      if (!resource) {
        return res.status(400).json({ message: "resource data required" });
      }
      const assessment = await assessmentService.assessResource(resource);
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Failed to assess resource" });
    }
  });
  app2.post("/api/assessment/kpi", requireAuth, async (req, res) => {
    try {
      const { kpi, measurements } = req.body;
      if (!kpi) {
        return res.status(400).json({ message: "kpi data required" });
      }
      const assessment = await assessmentService.assessKpi(kpi, measurements);
      res.json(assessment);
    } catch (error) {
      res.status(500).json({ message: "Failed to assess KPI" });
    }
  });
  const orchestrator = new Orchestrator(storage);
  app2.post("/api/orchestrator/task", requireAuth, requireRole2(["Admin", "Editor"]), async (req, res) => {
    try {
      const validatedTask = orchestratorTaskSchema.parse(req.body);
      const result = await orchestrator.processTask(validatedTask);
      res.status(201).json(result);
    } catch (error) {
      res.status(400).json({
        message: "Failed to process orchestration task",
        error: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/orchestrator/task/:id", requireAuth, async (req, res) => {
    try {
      const session3 = await storage.getSessionContextById(req.params.id);
      if (!session3) {
        return res.status(404).json({ message: "Task not found" });
      }
      res.json(session3);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch task" });
    }
  });
  app2.post("/api/web-search", async (req, res) => {
    try {
      const { query } = req.body;
      if (!query || typeof query !== "string") {
        return res.status(400).json({ error: "Query parameter is required" });
      }
      const apiKey = process.env.BRAVE_SEARCH_API_KEY;
      if (!apiKey) {
        console.error("[WebSearch] BRAVE_SEARCH_API_KEY environment variable is not set");
        return res.status(503).json({
          error: "External research is unavailable",
          details: "The BRAVE_SEARCH_API_KEY is not configured in this environment. Please add it to enable web research capabilities."
        });
      }
      const searchUrl = new URL("https://api.search.brave.com/res/v1/web/search");
      searchUrl.searchParams.append("q", query);
      searchUrl.searchParams.append("count", "10");
      const response = await fetch(searchUrl.toString(), {
        method: "GET",
        headers: {
          "X-Subscription-Token": apiKey,
          "Accept": "application/json"
        }
      });
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`Brave Search API error: ${response.status} ${response.statusText}`, errorText);
        throw new Error(`Brave Search API error: ${response.status} ${response.statusText}`);
      }
      const data = await response.json();
      const transformedData = {
        organic: (data.web?.results || []).map((result, index2) => ({
          title: result.title || "",
          link: result.url || "",
          snippet: result.description || "",
          position: index2 + 1
        }))
      };
      res.json(transformedData);
    } catch (error) {
      console.error("Web search error:", error);
      res.status(500).json({
        error: "Failed to perform web search",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  });
  function extractPublicationDate(html) {
    function extractDateFromObject(obj) {
      const dateFields = ["datePublished", "publishedDate", "dateCreated", "dateModified"];
      for (const field of dateFields) {
        if (obj[field]) {
          const parsedDate = new Date(obj[field]);
          if (!isNaN(parsedDate.getTime())) {
            return parsedDate.toISOString();
          }
        }
      }
      return null;
    }
    function walkJsonLd(obj) {
      if (!obj || typeof obj !== "object") return null;
      const typeCheck = obj["@type"];
      if (typeCheck) {
        const types = Array.isArray(typeCheck) ? typeCheck : [typeCheck];
        const hasRelevantType = types.some(
          (t) => t && (t.includes("Article") || t.includes("NewsArticle") || t.includes("BlogPosting") || t.includes("ScholarlyArticle") || t.includes("CreativeWork"))
        );
        if (hasRelevantType) {
          const date2 = extractDateFromObject(obj);
          if (date2) return date2;
        }
      }
      if (Array.isArray(obj["@graph"])) {
        for (const item of obj["@graph"]) {
          const date2 = walkJsonLd(item);
          if (date2) return date2;
        }
      }
      for (const key of Object.keys(obj)) {
        if (Array.isArray(obj[key])) {
          for (const item of obj[key]) {
            const date2 = walkJsonLd(item);
            if (date2) return date2;
          }
        } else if (typeof obj[key] === "object") {
          const date2 = walkJsonLd(obj[key]);
          if (date2) return date2;
        }
      }
      return null;
    }
    const jsonLdMatches = Array.from(html.matchAll(/<script[^>]*type=["']application\/ld\+json["'][^>]*>([\s\S]*?)<\/script>/gi));
    for (const match of jsonLdMatches) {
      try {
        const jsonLd = JSON.parse(match[1]);
        const date2 = walkJsonLd(jsonLd);
        if (date2) return date2;
      } catch (e) {
      }
    }
    const metaPatterns = [
      /<meta[^>]*property=["']article:published_time["'][^>]*content=["']([^"']+)["']/i,
      /<meta[^>]*name=["'](?:publish|publication)(?:_|-)?date["'][^>]*content=["']([^"']+)["']/i,
      /<meta[^>]*name=["']date["'][^>]*content=["']([^"']+)["']/i,
      /<time[^>]*datetime=["']([^"']+)["']/i,
      /<meta[^>]*property=["']datePublished["'][^>]*content=["']([^"']+)["']/i
    ];
    for (const pattern of metaPatterns) {
      const match = html.match(pattern);
      if (match && match[1]) {
        const dateStr = match[1];
        const parsedDate = new Date(dateStr);
        if (!isNaN(parsedDate.getTime())) {
          return parsedDate.toISOString();
        }
      }
    }
    return null;
  }
  app2.post("/api/web-fetch", async (req, res) => {
    try {
      const { url } = req.body;
      if (!url || typeof url !== "string") {
        return res.status(400).json({ error: "URL parameter is required" });
      }
      const response = await fetch(url, {
        headers: {
          "User-Agent": "Mozilla/5.0 (compatible; Premisia/1.0; +https://premisia.ai)"
        }
      });
      if (!response.ok) {
        throw new Error(`Failed to fetch URL: ${response.status} ${response.statusText}`);
      }
      const content = await response.text();
      const publicationDate = extractPublicationDate(content);
      res.json({
        content,
        url,
        metadata: {
          publicationDate
        }
      });
    } catch (error) {
      console.error("Web fetch error:", error);
      res.status(500).json({
        error: "Failed to fetch URL",
        message: error instanceof Error ? error.message : String(error)
      });
    }
  });
  app2.get("/api/strategy/test", requireAuth, async (req, res) => {
    try {
      const { strategyOntologyService: strategyOntologyService2 } = await Promise.resolve().then(() => (init_strategy_ontology_service(), strategy_ontology_service_exports));
      const approachesRecord = strategyOntologyService2.getStrategicApproaches();
      const approaches = Object.entries(approachesRecord).map(([id, approach]) => ({
        id,
        name: approach.label
      }));
      const costEstimate = strategyOntologyService2.calculateCostEstimate("cost_leadership", "uae");
      console.log("Cost Estimate Result:", costEstimate);
      const workstreams2 = strategyOntologyService2.calculateWorkstreamAllocations("cost_leadership", "uae");
      console.log("Workstreams Result:", workstreams2);
      const coherence = strategyOntologyService2.validateStrategicCoherence("cost_leadership", "uae", {
        has_regulatory_requirements: true
      });
      console.log("Coherence Result:", coherence);
      const decisionOptions = strategyOntologyService2.getDecisionOptions("differentiation_service", "usa");
      console.log("Decision Options Result:", decisionOptions);
      const responseData = {
        status: "success",
        tests: {
          approaches,
          costEstimate,
          workstreams: workstreams2.slice(0, 3),
          coherence,
          decisionOptions: decisionOptions ? {
            approach: decisionOptions.approach.label,
            market: decisionOptions.market.label,
            cost: decisionOptions.cost_estimate,
            workstreamCount: decisionOptions.workstreams.length,
            coherence: decisionOptions.coherence
          } : null
        }
      };
      console.log("Full Response Data:", JSON.stringify(responseData, null, 2));
      res.json(responseData);
    } catch (error) {
      console.error("Strategy Test Error:", error);
      res.status(500).json({
        status: "error",
        message: error instanceof Error ? error.message : String(error),
        stack: error instanceof Error ? error.stack : void 0
      });
    }
  });
  app2.get("/api/background-jobs/:id", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const jobId = req.params.id;
      const userId = req.user.claims.sub;
      const job = await backgroundJobService.getJobById(jobId);
      if (!job) {
        return res.status(404).json({ error: "Job not found" });
      }
      if (job.userId !== userId) {
        return res.status(403).json({ error: "Forbidden" });
      }
      res.json({ job });
    } catch (error) {
      console.error("[Background Jobs] Error fetching job:", error);
      res.status(500).json({ error: "Failed to fetch job" });
    }
  });
  app2.get("/api/background-jobs/running", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userId = req.user.claims.sub;
      const jobs = await backgroundJobService.getRunningJobs(userId);
      res.json({ jobs });
    } catch (error) {
      console.error("[Background Jobs] Error fetching running jobs:", error);
      res.status(500).json({ error: "Failed to fetch running jobs" });
    }
  });
  app2.get("/api/background-jobs/by-session/:sessionId", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const sessionId = req.params.sessionId;
      const userId = req.user.claims.sub;
      const job = await backgroundJobService.getJobBySession(sessionId);
      if (!job) {
        return res.json({ job: null });
      }
      if (job.userId !== userId) {
        return res.status(403).json({ error: "Forbidden" });
      }
      res.json({ job });
    } catch (error) {
      console.error("[Background Jobs] Error fetching job by session:", error);
      res.status(500).json({ error: "Failed to fetch job" });
    }
  });
  app2.get("/api/background-jobs/recent", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userId = req.user.claims.sub;
      const limit = parseInt(req.query.limit) || 50;
      const jobs = await backgroundJobService.getRecentJobs(userId, limit);
      res.json({ jobs });
    } catch (error) {
      console.error("[Background Jobs] Error fetching recent jobs:", error);
      res.status(500).json({ error: "Failed to fetch recent jobs" });
    }
  });
  app2.get("/api/background-jobs/recent-completions", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userId = req.user.claims.sub;
      const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1e3);
      const jobs = await db.select().from(backgroundJobs).where(
        and24(
          eq36(backgroundJobs.userId, userId),
          or5(
            eq36(backgroundJobs.status, "completed"),
            eq36(backgroundJobs.status, "failed")
          ),
          or5(
            and24(
              eq36(backgroundJobs.status, "completed"),
              sql14`${backgroundJobs.completedAt} >= ${fiveMinutesAgo}`
            ),
            and24(
              eq36(backgroundJobs.status, "failed"),
              sql14`${backgroundJobs.failedAt} >= ${fiveMinutesAgo}`
            )
          )
        )
      ).orderBy(desc20(backgroundJobs.createdAt)).limit(5);
      res.json({ jobs });
    } catch (error) {
      console.error("Error fetching recent completions:", error);
      res.status(500).json({ error: "Failed to fetch recent completions" });
    }
  });
  app2.get("/api/background-jobs", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const userId = req.user.claims.sub;
      const status = req.query.status;
      const limit = req.query.limit ? parseInt(req.query.limit) : void 0;
      const jobs = await backgroundJobService.getJobsByUser(userId, { status, limit });
      res.json({ jobs });
    } catch (error) {
      console.error("[Background Jobs] Error fetching user jobs:", error);
      res.status(500).json({ error: "Failed to fetch jobs" });
    }
  });
  app2.delete("/api/background-jobs/:id", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const jobId = req.params.id;
      const userId = req.user.claims.sub;
      const cancelled = await backgroundJobService.cancelJob(jobId, userId);
      if (!cancelled) {
        return res.status(400).json({ error: "Unable to cancel job. Job may not exist, belong to another user, or already be completed." });
      }
      res.json({ success: true, message: "Job cancelled successfully" });
    } catch (error) {
      console.error("[Background Jobs] Error cancelling job:", error);
      res.status(500).json({ error: "Failed to cancel job" });
    }
  });
  app2.post("/api/background-jobs/cleanup", isAuthenticated, async (req, res) => {
    try {
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const daysOld = req.body.daysOld || 7;
      if (daysOld < 1 || daysOld > 365) {
        return res.status(400).json({ error: "daysOld must be between 1 and 365" });
      }
      const deletedCount = await backgroundJobService.cleanupOldJobs(daysOld);
      res.json({
        success: true,
        message: `Cleaned up ${deletedCount} old jobs`,
        deletedCount
      });
    } catch (error) {
      console.error("[Background Jobs] Error cleaning up jobs:", error);
      res.status(500).json({ error: "Failed to cleanup jobs" });
    }
  });
  app2.post("/api/admin/golden-records", requireAuth, requireRole2(["Admin"]), async (req, res) => {
    try {
      const { journeyType, notes, steps, metadata, promoteAsCurrent, parentVersion } = req.body;
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      if (!journeyType || !steps) {
        return res.status(400).json({ error: "Missing required fields: journeyType, steps" });
      }
      const record = await storage.createGoldenRecord({
        journeyType,
        notes,
        steps,
        metadata,
        createdBy: req.user.claims.sub,
        parentVersion,
        promoteAsCurrent: promoteAsCurrent || false
      });
      res.status(201).json(record);
    } catch (error) {
      console.error("[Golden Records] Error creating golden record:", error);
      res.status(500).json({ error: "Failed to create golden record" });
    }
  });
  app2.get("/api/admin/golden-records", requireAuth, requireRole2(["Admin"]), async (req, res) => {
    try {
      const journeyType = req.query.journeyType;
      const includeHistory = req.query.includeHistory === "true";
      const records = await storage.listGoldenRecords(journeyType, includeHistory);
      res.json(records);
    } catch (error) {
      console.error("[Golden Records] Error listing golden records:", error);
      res.status(500).json({ error: "Failed to list golden records" });
    }
  });
  app2.get("/api/admin/golden-records/:journeyType/:version", requireAuth, requireRole2(["Admin"]), async (req, res) => {
    try {
      const { journeyType, version } = req.params;
      const versionNumber = parseInt(version, 10);
      if (isNaN(versionNumber)) {
        return res.status(400).json({ error: "Invalid version number" });
      }
      const record = await storage.getGoldenRecord(journeyType, versionNumber);
      if (!record) {
        return res.status(404).json({ error: "Golden record not found" });
      }
      res.json(record);
    } catch (error) {
      console.error("[Golden Records] Error getting golden record:", error);
      res.status(500).json({ error: "Failed to get golden record" });
    }
  });
  app2.post("/api/admin/golden-records/:journeyType/:version/promote", requireAuth, requireRole2(["Admin"]), async (req, res) => {
    try {
      const { journeyType, version } = req.params;
      const versionNumber = parseInt(version, 10);
      if (isNaN(versionNumber)) {
        return res.status(400).json({ error: "Invalid version number" });
      }
      const promoted = await storage.promoteGoldenRecord(journeyType, versionNumber);
      if (!promoted) {
        return res.status(404).json({ error: "Golden record not found" });
      }
      res.json(promoted);
    } catch (error) {
      console.error("[Golden Records] Error promoting golden record:", error);
      res.status(500).json({ error: "Failed to promote golden record" });
    }
  });
  app2.post("/api/admin/golden-records/:journeyType/:version/compare", requireAuth, requireRole2(["Admin"]), async (req, res) => {
    try {
      const { journeyType, version } = req.params;
      const { compareToVersion } = req.body;
      const version1 = parseInt(version, 10);
      const version2 = parseInt(compareToVersion, 10);
      if (isNaN(version1) || isNaN(version2)) {
        return res.status(400).json({ error: "Invalid version numbers" });
      }
      const comparison = await storage.compareGoldenRecords(journeyType, version1, version2);
      res.json(comparison);
    } catch (error) {
      console.error("[Golden Records] Error comparing golden records:", error);
      res.status(500).json({ error: error instanceof Error ? error.message : "Failed to compare golden records" });
    }
  });
  app2.post("/api/admin/encrypt-legacy-data", requireAuth, requireRole2(["Admin"]), async (req, res) => {
    try {
      const { passphrase, dryRun = true } = req.body;
      if (!req.user?.claims?.sub) {
        return res.status(401).json({ error: "Unauthorized" });
      }
      const requiredPassphrase = process.env.ENCRYPTION_MIGRATION_PASSPHRASE;
      if (!requiredPassphrase) {
        console.error("[Encryption Migration] ENCRYPTION_MIGRATION_PASSPHRASE not set");
        return res.status(500).json({
          error: "Migration endpoint not configured. Set ENCRYPTION_MIGRATION_PASSPHRASE environment variable."
        });
      }
      if (!passphrase || passphrase !== requiredPassphrase) {
        console.warn(`[Encryption Migration] Invalid passphrase attempt by user ${req.user.claims.sub}`);
        return res.status(403).json({ error: "Invalid passphrase" });
      }
      console.log(`[Encryption Migration] Starting migration - User: ${req.user.claims.sub}, DryRun: ${dryRun}`);
      const { runEncryptionMigration: runEncryptionMigration2 } = await Promise.resolve().then(() => (init_encryption_migration(), encryption_migration_exports));
      const stats = await runEncryptionMigration2({
        dryRun,
        batchSize: 50
      });
      const response = {
        success: true,
        dryRun,
        stats: {
          totalRecords: stats.total,
          recordsEncrypted: stats.encrypted,
          recordsSkipped: stats.skipped,
          recordsFailed: stats.failed,
          durationMs: stats.duration
        },
        message: dryRun ? "Dry run completed. No data was modified." : stats.failed > 0 ? `Migration completed with ${stats.failed} failures. Check logs for details.` : "All plaintext data has been encrypted successfully!",
        executedBy: req.user.claims.sub,
        executedAt: (/* @__PURE__ */ new Date()).toISOString()
      };
      console.log("[Encryption Migration] Results:", response);
      res.json(response);
    } catch (error) {
      console.error("[Encryption Migration] Error running migration:", error);
      res.status(500).json({
        error: "Migration failed",
        details: error instanceof Error ? error.message : "Unknown error"
      });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}
var init_routes = __esm({
  "server/routes.ts"() {
    "use strict";
    init_replitAuth();
    init_storage();
    init_schema();
    init_assessment_service();
    init_orchestrator2();
    init_strategic_consultant_legacy();
    init_strategic_consultant_v22();
    init_document_enrichment();
    init_trend_analysis();
    init_statement_repository_routes();
    init_strategy_workspace();
    init_journey_builder();
    init_task_assignments();
    init_exports();
    init_knowledge();
    init_marketing_consultant();
    init_strategies_hub();
    init_epm_crud();
    init_ontology();
    init_module_registry();
    init_custom_journey_builder();
    init_initialize();
    init_background_job_service();
    init_db();
  }
});

// server/index.ts
import express2 from "express";
import { createServer as createServer2 } from "node:http";

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      ),
      await import("@replit/vite-plugin-dev-banner").then(
        (m) => m.devBanner()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server2) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server: server2 },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/index.ts
init_encryption();
init_background_job_service();

// server/journey/register-frameworks.ts
init_framework_executor_registry();

// server/journey/executors/five-whys-executor.ts
init_whys_tree_generator();
var FiveWhysExecutor = class {
  name = "five_whys";
  generator = new WhysTreeGenerator();
  async execute(context) {
    console.log("[FiveWhys Executor] Starting Five Whys analysis...");
    const whysTree = await this.generator.generateTree(
      context.userInput,
      context.sessionId
    );
    console.log(`[FiveWhys Executor] Generated tree with ${whysTree.branches.length} root branches`);
    const rootCauses = [];
    const whysPath = [];
    if (whysTree.branches && whysTree.branches.length > 0) {
      let currentLevel = whysTree.branches;
      let currentQuestion = whysTree.rootQuestion;
      while (currentLevel && currentLevel.length > 0) {
        const node = currentLevel[0];
        const answer = node.option || node.question || "";
        if (answer) {
          whysPath.push({ question: currentQuestion, answer });
        }
        if (!node.branches || node.branches.length === 0) {
          rootCauses.push(node.option || node.question);
        }
        currentQuestion = node.question || currentQuestion;
        currentLevel = node.branches || [];
      }
      for (const branch of whysTree.branches) {
        const deepestAnswer = this.findDeepestAnswer(branch);
        if (deepestAnswer && !rootCauses.includes(deepestAnswer)) {
          rootCauses.push(deepestAnswer);
        }
      }
    }
    const strategicImplications = rootCauses.map(
      (cause) => `Strategic implication: The business model must address ${cause}`
    );
    return {
      rootCauses: rootCauses.length > 0 ? rootCauses : ["No root causes identified"],
      whysPath,
      strategicImplications,
      tree: whysTree
    };
  }
  /**
   * Find the deepest answer in a branch (recursive helper)
   */
  findDeepestAnswer(branch) {
    if (!branch.branches || branch.branches.length === 0) {
      return branch.option || branch.question;
    }
    for (const childBranch of branch.branches) {
      const deepest = this.findDeepestAnswer(childBranch);
      if (deepest) return deepest;
    }
    return null;
  }
};

// server/journey/executors/bmc-executor.ts
init_bmc_researcher();
init_reference_service();
init_db();
init_schema();
import { eq as eq9 } from "drizzle-orm";
var BMCExecutor = class {
  name = "bmc";
  researcher = new BMCResearcher();
  referenceService = new ReferenceService();
  async execute(context) {
    console.log("[BMC Executor] Starting Business Model Canvas research...");
    const constraints = context.insights?.bmcDesignConstraints;
    if (constraints) {
      console.log("[BMC Executor] Using Five Whys constraints:", {
        problems: constraints.problemsToSolve?.length ?? 0,
        capabilities: constraints.mustHaveCapabilities?.length ?? 0,
        principles: constraints.designPrinciples?.length ?? 0
      });
    } else {
      console.log("[BMC Executor] No Five Whys constraints available, proceeding with standard BMC research");
    }
    const bmcResults = await this.researcher.conductBMCResearch(
      context.userInput,
      context.sessionId
    );
    console.log(`[BMC Executor] Completed - generated ${Object.keys(bmcResults.blocks || {}).length} blocks`);
    if (bmcResults.references && bmcResults.references.length > 0) {
      console.log(`[BMC Executor] Persisting ${bmcResults.references.length} references to database...`);
      const [session3] = await db.select({ userId: journeySessions.userId }).from(journeySessions).where(eq9(journeySessions.id, context.sessionId)).limit(1);
      if (!session3) {
        console.warn(`[BMC Executor] Could not find session ${context.sessionId}, skipping reference persistence`);
        return bmcResults;
      }
      const normalizedRefs = bmcResults.references.map(
        (ref) => this.referenceService.normalizeReference(
          ref,
          session3.userId,
          { component: "BMC", claim: ref.description },
          {
            understandingId: context.understandingId,
            sessionId: context.sessionId
          }
        )
      );
      const result = await this.referenceService.persistReferences(normalizedRefs, {
        understandingId: context.understandingId,
        sessionId: context.sessionId
      });
      console.log(`[BMC Executor] \u2713 Persisted references: ${result.created.length} created, ${result.updated.length} updated, ${result.skipped} skipped`);
    }
    return bmcResults;
  }
};

// server/journey/executors/segment-discovery-executor.ts
init_segment_discovery_engine();
var SegmentDiscoveryExecutor = class {
  name = "segment_discovery";
  async validate(context) {
    const errors = [];
    if (!context.userInput || context.userInput.trim().length < 10) {
      errors.push("Offering description required (minimum 10 characters)");
    }
    if (!context.marketingContext?.offeringType) {
      errors.push("Offering type classification required (e.g., b2b_saas, physical_product)");
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  async execute(context) {
    console.log("[SegmentDiscoveryExecutor] Starting segment discovery...");
    console.log(`  Input: "${context.userInput?.substring(0, 50)}..."`);
    console.log(`  Offering Type: ${context.marketingContext?.offeringType || "not set"}`);
    const discoveryContext = {
      offeringDescription: context.userInput,
      offeringType: context.marketingContext?.offeringType || "physical_product",
      stage: context.marketingContext?.stage || "idea_stage",
      gtmConstraint: context.marketingContext?.gtmConstraint || "small_team",
      salesMotion: context.marketingContext?.salesMotion || "self_serve",
      existingHypothesis: context.marketingContext?.existingHypothesis
    };
    const result = await segmentDiscoveryEngine.runDiscovery(
      discoveryContext,
      (step, progress) => {
        console.log(`[SegmentDiscoveryExecutor] ${step}: ${progress}%`);
        if (context.onProgress) {
          context.onProgress(step, progress);
        }
      }
    );
    console.log("[SegmentDiscoveryExecutor] Discovery complete");
    console.log(`  Beachhead: ${result.synthesis.beachhead?.genome?.id || "N/A"}`);
    console.log(`  Total genomes: ${result.genomes.length}`);
    return {
      geneLibrary: result.geneLibrary,
      genomes: result.genomes,
      synthesis: result.synthesis,
      metadata: {
        totalGenomes: result.genomes.length,
        topScore: result.genomes[0]?.fitness?.totalScore || 0,
        businessType: discoveryContext.offeringType
      }
    };
  }
};
var segmentDiscoveryExecutor = new SegmentDiscoveryExecutor();

// server/journey/executors/porters-executor.ts
init_porters_analyzer();
init_ai_clients();
init_json_parser();
var PortersExecutor = class {
  name = "porters";
  analyzer = new PortersAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for Porter's Five Forces analysis"]
    };
  }
  async execute(context) {
    console.log("[Porters Executor] Starting Porter's Five Forces competitive analysis...");
    const prompt = `
Perform a comprehensive Porter's Five Forces analysis for this business:

Business Context: ${context.userInput}

Analyze the five competitive forces:

1. THREAT OF NEW ENTRANTS - How easy/hard is it for new competitors to enter?
   - Barriers to entry: capital requirements, economies of scale, switching costs, brand loyalty, regulatory barriers
   - New entrant strategies that could emerge
   
2. BARGAINING POWER OF SUPPLIERS - How much power do suppliers have?
   - Supplier concentration
   - Availability of substitutes for supplier inputs
   - Cost of switching suppliers
   - Mitigation strategies
   
3. BARGAINING POWER OF BUYERS - How much power do buyers have?
   - Buyer concentration
   - Price sensitivity
   - Availability of alternatives
   - Switching costs for buyers
   
4. THREAT OF SUBSTITUTES - How likely are customers to switch to alternatives?
   - Substitute products/services
   - Relative pricing and performance
   - Customer switching costs
   
5. COMPETITIVE RIVALRY - How intense is rivalry among existing competitors?
   - Number and balance of competitors
   - Industry growth rate
   - Competitive strategies
   - Exit barriers

For each force, provide:
- Score (1-10, where 10 = very high threat)
- Analysis explanation
- Key risks from this force
- Relevant competitors/suppliers/substitutes

Synthesize into:
- Overall market attractiveness score (1-10)
- Attractiveness summary
- Strategic recommendations

Return as JSON:
{
  "threatOfNewEntrants": {"score": 6, "analysis": "", "barriers": [""], "risks": [""]},
  "bargainingPowerOfSuppliers": {"score": 5, "analysis": "", "mitigations": [""], "risks": [""]},
  "bargainingPowerOfBuyers": {"score": 6, "analysis": "", "risks": [""]},
  "threatOfSubstitutes": {"score": 7, "analysis": "", "substitutes": [""], "risks": [""]},
  "competitiveRivalry": {"score": 8, "analysis": "", "competitors": [""], "strategies": [""], "risks": [""]},
  "overallAttractiveness": {"score": 6, "summary": "", "recommendations": [""]},
  "strategicImplications": [""]
}
    `.trim();
    try {
      const response = await aiClients.callWithFallback({
        systemPrompt: "You are a strategic analyst specializing in Porter's Five Forces. Analyze competitive dynamics and return only valid JSON.",
        userMessage: prompt,
        maxTokens: 4e3
      });
      const parseResult = extractJsonFromMarkdown(response.content);
      if (!parseResult.success) {
        console.error("[Porters Executor] Failed to parse AI response:", parseResult.error);
        throw new Error(`Failed to parse Porter's analysis: ${parseResult.error}`);
      }
      const portersResults = parseResult.data;
      console.log("[Porters Executor] Porter's analysis generated");
      console.log(`  Threat of New Entrants: ${portersResults.threatOfNewEntrants?.score}/10`);
      console.log(`  Supplier Power: ${portersResults.bargainingPowerOfSuppliers?.score}/10`);
      console.log(`  Buyer Power: ${portersResults.bargainingPowerOfBuyers?.score}/10`);
      console.log(`  Threat of Substitutes: ${portersResults.threatOfSubstitutes?.score}/10`);
      console.log(`  Competitive Rivalry: ${portersResults.competitiveRivalry?.score}/10`);
      console.log(`  Overall Market Attractiveness: ${portersResults.overallAttractiveness?.score}/10`);
      console.log("[Porters Executor] Converting Porter's results to strategic insights...");
      const insights = await this.analyzer.analyze(portersResults);
      console.log("[Porters Executor] Porter's Five Forces analysis complete");
      return {
        framework: "porters",
        portersResults,
        insights,
        summary: {
          forces: 5,
          averageForceScore: ((portersResults.threatOfNewEntrants?.score || 0) + (portersResults.bargainingPowerOfSuppliers?.score || 0) + (portersResults.bargainingPowerOfBuyers?.score || 0) + (portersResults.threatOfSubstitutes?.score || 0) + (portersResults.competitiveRivalry?.score || 0)) / 5,
          marketAttractiveness: portersResults.overallAttractiveness?.score,
          attractivenessLevel: this.getAttractiveness(portersResults.overallAttractiveness?.score || 5)
        }
      };
    } catch (error) {
      console.error("[Porters Executor] Analysis failed:", error);
      throw error;
    }
  }
  getAttractiveness(score) {
    if (score >= 8) return "Very Attractive";
    if (score >= 6) return "Attractive";
    if (score >= 4) return "Moderately Attractive";
    return "Unattractive";
  }
};

// server/journey/executors/pestle-executor.ts
init_pestle_analyzer();
init_ai_clients();
init_json_parser();
var PESTLEExecutor = class {
  name = "pestle";
  analyzer = new PESTLEAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for PESTLE analysis"]
    };
  }
  async execute(context) {
    console.log("[PESTLE Executor] Starting PESTLE macro-environmental analysis...");
    const prompt = `
Perform a comprehensive PESTLE analysis for this business:

Business Context: ${context.userInput}

Analyze the macro-environmental factors:

1. POLITICAL - Government policies, regulations, political stability, trade policies
2. ECONOMIC - Economic growth, interest rates, inflation, currency exchange, market conditions
3. SOCIAL - Demographics, cultural trends, consumer attitudes, lifestyle changes
4. TECHNOLOGICAL - Innovation trends, tech adoption, digital transformation, automation
5. LEGAL - Regulations, compliance requirements, intellectual property, data protection
6. ENVIRONMENTAL - Climate change, sustainability, natural resources, environmental regulations

For each factor, provide:
- Key trends (with strength 1-10)
- Timeframe (near-term/medium-term/long-term)
- Impact on business (positive/negative)
- Opportunities for the business
- Risks to monitor
- Required actions/adaptations

Return as JSON with structure:
{
  "political": {"trends": [{"description": "", "strength": 5, "timeframe": "", "impact": ""}], "opportunities": [{"description": "", "requirements": []}], "risks": [{"description": "", "probability": 0.5, "impact": "High"}]},
  "economic": {...},
  "social": {...},
  "technological": {...},
  "legal": {...},
  "environmental": {...},
  "strategicRecommendations": [""],
  "crossFactorInsights": {"synergies": [""], "conflicts": [""]}
}
    `.trim();
    try {
      const response = await aiClients.callWithFallback({
        systemPrompt: "You are a strategic analysis expert specializing in PESTLE analysis. Analyze macro-environmental factors and return only valid JSON.",
        userMessage: prompt,
        maxTokens: 4e3
      });
      const parseResult = extractJsonFromMarkdown(response.content);
      if (!parseResult.success) {
        console.error("[PESTLE Executor] Failed to parse AI response:", parseResult.error);
        throw new Error(`Failed to parse PESTLE analysis: ${parseResult.error}`);
      }
      const pestleResults = parseResult.data;
      console.log("[PESTLE Executor] PESTLE analysis generated");
      console.log(`  Political factors: ${pestleResults.political?.trends?.length || 0} trends`);
      console.log(`  Economic factors: ${pestleResults.economic?.trends?.length || 0} trends`);
      console.log(`  Social factors: ${pestleResults.social?.trends?.length || 0} trends`);
      console.log(`  Technological factors: ${pestleResults.technological?.trends?.length || 0} trends`);
      console.log(`  Legal factors: ${pestleResults.legal?.trends?.length || 0} trends`);
      console.log(`  Environmental factors: ${pestleResults.environmental?.trends?.length || 0} trends`);
      console.log("[PESTLE Executor] Converting PESTLE results to strategic insights...");
      const insights = await this.analyzer.analyze(pestleResults);
      console.log("[PESTLE Executor] PESTLE analysis complete");
      return {
        framework: "pestle",
        pestleResults,
        insights,
        summary: {
          factors: 6,
          trends: Object.values(pestleResults).filter((f) => f.trends).reduce((sum, f) => sum + f.trends.length, 0),
          opportunities: Object.values(pestleResults).filter((f) => f.opportunities).reduce((sum, f) => sum + f.opportunities.length, 0)
        }
      };
    } catch (error) {
      console.error("[PESTLE Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/swot-executor.ts
init_swot_analyzer();
var SWOTExecutor = class {
  name = "swot";
  analyzer = new SWOTAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for SWOT analysis"]
    };
  }
  async execute(context) {
    console.log("[SWOT Executor] Starting SWOT analysis...");
    const insights = context.insights || {};
    const swotInput = {
      businessContext: context.userInput,
      // Include previous framework outputs if available
      ...insights.bmcBlocks && { bmcOutput: insights.bmcBlocks },
      ...insights.portersForces && { portersOutput: insights.portersForces },
      ...insights.trendFactors && { pestleOutput: insights.trendFactors }
    };
    try {
      console.log("[SWOT Executor] Building analysis context...");
      if (swotInput.bmcOutput) console.log("  - Including BMC insights");
      if (swotInput.portersOutput) console.log("  - Including Porter's Five Forces");
      if (swotInput.pestleOutput) console.log("  - Including PESTLE analysis");
      const swotOutput = await this.analyzer.analyze(swotInput);
      if (swotOutput.error === true) {
        console.error("[SWOT Executor] Analysis returned error structure");
        return swotOutput;
      }
      console.log("[SWOT Executor] SWOT analysis complete");
      console.log(`  Strengths: ${swotOutput.strengths?.length || 0}`);
      console.log(`  Weaknesses: ${swotOutput.weaknesses?.length || 0}`);
      console.log(`  Opportunities: ${swotOutput.opportunities?.length || 0}`);
      console.log(`  Threats: ${swotOutput.threats?.length || 0}`);
      console.log(`  Strategic Options: ${Object.values(swotOutput.strategicOptions || {}).flat().length}`);
      return {
        framework: "swot",
        output: swotOutput,
        summary: {
          totalFactors: (swotOutput.strengths?.length || 0) + (swotOutput.weaknesses?.length || 0) + (swotOutput.opportunities?.length || 0) + (swotOutput.threats?.length || 0),
          strategicGroups: {
            offensive: swotOutput.strategicOptions?.soStrategies?.length || 0,
            defensive: swotOutput.strategicOptions?.stStrategies?.length || 0,
            adaptive: swotOutput.strategicOptions?.woStrategies?.length || 0,
            mitigation: swotOutput.strategicOptions?.wtStrategies?.length || 0
          },
          analysisDepth: swotOutput.metadata?.analysisDepth,
          confidence: swotOutput.confidence
        }
      };
    } catch (error) {
      console.error("[SWOT Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/competitive-positioning-executor.ts
init_competitive_positioning_analyzer();
var CompetitivePositioningExecutor = class {
  name = "competitive_positioning";
  analyzer = new CompetitivePositioningAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for competitive positioning analysis"]
    };
  }
  async execute(context) {
    console.log("[Competitive Positioning Executor] Starting competitive positioning analysis...");
    const competitivePositioningInput = {
      businessContext: context.userInput,
      competitors: [],
      // Would be populated from context.insights if available
      targetMarket: "Target Market",
      // Would be extracted from context if available
      ...context.insights.bmcBlocks && { bmcOutput: context.insights.bmcBlocks },
      ...context.insights.portersForces && { portersOutput: context.insights.portersForces }
    };
    try {
      console.log("[Competitive Positioning Executor] Building competitive analysis context...");
      if (competitivePositioningInput.bmcOutput) console.log("  - Including Business Model Canvas");
      if (competitivePositioningInput.portersOutput) console.log("  - Including Porter's Five Forces");
      const output = await this.analyzer.analyze(competitivePositioningInput);
      console.log("[Competitive Positioning Executor] Competitive positioning analysis complete");
      console.log(`  Positioning Axes: ${output.positioningMap?.length || 0}`);
      console.log(`  Differentiation Factors: ${output.differentationFactors?.length || 0}`);
      console.log(`  Competitive Advantages: ${output.competitiveAdvantages?.length || 0}`);
      console.log(`  Competitive Threats: ${output.competitiveThreats?.length || 0}`);
      return {
        framework: "competitive_positioning",
        output,
        summary: {
          positioningAxes: output.positioningMap?.length || 0,
          differentiators: output.differentationFactors?.length || 0,
          advantages: output.competitiveAdvantages?.length || 0,
          threats: output.competitiveThreats?.length || 0,
          recommendedPosition: output.positioningRecommendation?.recommendedPosition,
          confidence: output.confidence
        }
      };
    } catch (error) {
      console.error("[Competitive Positioning Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/ansoff-executor.ts
init_ansoff_analyzer();
var AnsoffExecutor = class {
  name = "ansoff";
  analyzer = new AnsoffAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for Ansoff Matrix analysis"]
    };
  }
  async execute(context) {
    console.log("[Ansoff Executor] Starting Ansoff Matrix growth strategy analysis...");
    const ansoffInput = {
      businessContext: context.userInput,
      // Include previous framework outputs if available
      ...context.insights.bmcBlocks && { bmcOutput: context.insights.bmcBlocks },
      // If BMC has customer segments, extract as market info
      ...context.insights.bmcBlocks?.["Customer Segments"] && {
        currentMarkets: Array.isArray(context.insights.bmcBlocks["Customer Segments"]) ? context.insights.bmcBlocks["Customer Segments"].map((s) => s.segment || s) : [context.insights.bmcBlocks["Customer Segments"]]
      },
      // If BMC has products/services, extract as current offerings
      ...context.insights.bmcBlocks?.["Value Propositions"] && {
        currentProducts: Array.isArray(context.insights.bmcBlocks["Value Propositions"]) ? context.insights.bmcBlocks["Value Propositions"].map((p) => p.proposition || p) : [context.insights.bmcBlocks["Value Propositions"]]
      }
    };
    try {
      console.log("[Ansoff Executor] Building growth strategy context...");
      if (ansoffInput.bmcOutput) console.log("  - Including Business Model Canvas");
      if (ansoffInput.currentMarkets?.length) console.log(`  - Current markets: ${ansoffInput.currentMarkets.length}`);
      if (ansoffInput.currentProducts?.length) console.log(`  - Current products: ${ansoffInput.currentProducts.length}`);
      const ansoffOutput = await this.analyzer.analyze(ansoffInput);
      console.log("[Ansoff Executor] Ansoff Matrix analysis complete");
      console.log(`  Market Penetration Score: ${ansoffOutput.marketPenetration?.score}/10`);
      console.log(`  Market Development Score: ${ansoffOutput.marketDevelopment?.score}/10`);
      console.log(`  Product Development Score: ${ansoffOutput.productDevelopment?.score}/10`);
      console.log(`  Diversification Score: ${ansoffOutput.diversification?.score}/10`);
      console.log(`  Recommended: ${ansoffOutput.recommendation?.primaryStrategy}`);
      return {
        framework: "ansoff",
        output: ansoffOutput,
        summary: {
          quadrants: {
            marketPenetration: {
              score: ansoffOutput.marketPenetration?.score || 0,
              riskLevel: this.scoreToRisk(ansoffOutput.marketPenetration?.score || 0),
              timeframe: ansoffOutput.marketPenetration?.timeframe
            },
            marketDevelopment: {
              score: ansoffOutput.marketDevelopment?.score || 0,
              riskLevel: this.scoreToRisk(ansoffOutput.marketDevelopment?.score || 0),
              timeframe: ansoffOutput.marketDevelopment?.timeframe
            },
            productDevelopment: {
              score: ansoffOutput.productDevelopment?.score || 0,
              riskLevel: this.scoreToRisk(ansoffOutput.productDevelopment?.score || 0),
              timeframe: ansoffOutput.productDevelopment?.timeframe
            },
            diversification: {
              score: ansoffOutput.diversification?.score || 0,
              riskLevel: this.scoreToRisk(ansoffOutput.diversification?.score || 0),
              timeframe: ansoffOutput.diversification?.timeframe
            }
          },
          recommendation: ansoffOutput.recommendation?.primaryStrategy,
          riskLevel: ansoffOutput.recommendation?.riskLevel,
          confidence: ansoffOutput.confidence
        }
      };
    } catch (error) {
      console.error("[Ansoff Executor] Analysis failed:", error);
      throw error;
    }
  }
  scoreToRisk(score) {
    if (score >= 8) return "low";
    if (score >= 5) return "medium";
    return "high";
  }
};

// server/journey/executors/blue-ocean-executor.ts
init_blue_ocean_analyzer();
var BlueOceanExecutor = class {
  name = "blue_ocean";
  analyzer = new BlueOceanAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for Blue Ocean analysis"]
    };
  }
  async execute(context) {
    console.log("[Blue Ocean Executor] Starting Blue Ocean strategy analysis...");
    const blueOceanInput = {
      businessContext: context.userInput,
      industry: "Industry",
      // Would be extracted from context if available
      currentOffering: [],
      // Would be extracted from BMC if available
      ...context.insights.bmcBlocks && { swotOutput: context.insights.bmcBlocks },
      ...context.insights.portersForces && { portersOutput: context.insights.portersForces },
      ...context.insights.competitivePressures && { competitorsData: context.insights.competitivePressures }
    };
    try {
      console.log("[Blue Ocean Executor] Building Blue Ocean analysis context...");
      if (blueOceanInput.swotOutput) console.log("  - Including SWOT analysis");
      if (blueOceanInput.portersOutput) console.log("  - Including Porter's Five Forces");
      if (blueOceanInput.competitorsData) console.log("  - Including competitor data");
      const output = await this.analyzer.analyze(blueOceanInput);
      console.log("[Blue Ocean Executor] Blue Ocean analysis complete");
      console.log(`  ERRC Grid Factors: ${(output.ercGrid?.eliminate?.length || 0) + (output.ercGrid?.reduce?.length || 0) + (output.ercGrid?.raise?.length || 0) + (output.ercGrid?.create?.length || 0)}`);
      console.log(`  Blue Ocean Opportunities: ${output.blueOceanOpportunities?.length || 0}`);
      console.log(`  Priority Actions: ${output.priorityActions?.length || 0}`);
      return {
        framework: "blue_ocean",
        output,
        summary: {
          eliminateFactors: output.ercGrid?.eliminate?.length || 0,
          reduceFactors: output.ercGrid?.reduce?.length || 0,
          raiseFactors: output.ercGrid?.raise?.length || 0,
          createFactors: output.ercGrid?.create?.length || 0,
          opportunities: output.blueOceanOpportunities?.length || 0,
          newValueCurve: output.innovationStrategy?.newValueCurve,
          confidence: output.confidence
        }
      };
    } catch (error) {
      console.error("[Blue Ocean Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/bcg-matrix-executor.ts
init_bcg_matrix_analyzer();
var BCGMatrixExecutor = class {
  name = "bcg_matrix";
  analyzer = new BCGMatrixAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for BCG Matrix analysis"]
    };
  }
  async execute(context) {
    console.log("[BCG Matrix Executor] Starting BCG Matrix portfolio analysis...");
    const bcgMatrixInput = {
      businessContext: context.userInput,
      products: [],
      // Would be extracted from context if available
      ...context.insights.trendFactors && { industryData: context.insights.trendFactors },
      ...context.insights.portersForces && { portersOutput: context.insights.portersForces },
      ...context.insights.keyOpportunities && { ansoffOutput: { growthOpportunities: context.insights.keyOpportunities } }
    };
    try {
      console.log("[BCG Matrix Executor] Building portfolio analysis context...");
      if (bcgMatrixInput.industryData) console.log("  - Including industry data");
      if (bcgMatrixInput.portersOutput) console.log("  - Including Porter's Five Forces");
      if (bcgMatrixInput.ansoffOutput) console.log("  - Including Ansoff growth options");
      const output = await this.analyzer.analyze(bcgMatrixInput);
      console.log("[BCG Matrix Executor] BCG Matrix analysis complete");
      console.log(`  Star Units: ${output.stars?.count || 0}`);
      console.log(`  Cash Cow Units: ${output.cashCows?.count || 0}`);
      console.log(`  Question Mark Units: ${output.questionMarks?.count || 0}`);
      console.log(`  Dog Units: ${output.dogs?.count || 0}`);
      console.log(`  Portfolio Balance: ${output.portfolioBalance?.healthAssessment}`);
      return {
        framework: "bcg_matrix",
        output,
        summary: {
          stars: output.stars?.count || 0,
          cashCows: output.cashCows?.count || 0,
          questionMarks: output.questionMarks?.count || 0,
          dogs: output.dogs?.count || 0,
          portfolioHealth: output.portfolioBalance?.healthAssessment,
          shortTermActions: output.portfolioStrategy?.shortTermActions?.length || 0,
          confidence: output.confidence
        }
      };
    } catch (error) {
      console.error("[BCG Matrix Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/value-chain-executor.ts
init_value_chain_analyzer();
var ValueChainExecutor = class {
  name = "value_chain";
  analyzer = new ValueChainAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for Value Chain analysis"]
    };
  }
  async execute(context) {
    console.log("[Value Chain Executor] Starting Value Chain analysis...");
    const valueChainInput = {
      businessContext: context.userInput,
      industry: "Industry",
      // Would be extracted from context if available
      ...context.insights.portersForces && { portersOutput: context.insights.portersForces },
      ...context.insights.keyOpportunities && { competitivePositionData: context.insights.keyOpportunities },
      ...context.insights.bmcBlocks && { operationsData: context.insights.bmcBlocks }
    };
    try {
      console.log("[Value Chain Executor] Building value chain analysis context...");
      if (valueChainInput.portersOutput) console.log("  - Including Porter's Five Forces");
      if (valueChainInput.competitivePositionData) console.log("  - Including competitive position data");
      if (valueChainInput.operationsData) console.log("  - Including operations data");
      const output = await this.analyzer.analyze(valueChainInput);
      console.log("[Value Chain Executor] Value Chain analysis complete");
      console.log(`  Primary Activities Analyzed: 5`);
      console.log(`  Support Activities Analyzed: 4`);
      console.log(`  Value Drivers: ${output.valueDrivers?.length || 0}`);
      console.log(`  Cost Drivers: ${output.costDrivers?.length || 0}`);
      console.log(`  Competitive Advantages: ${output.competitiveAdvantages?.length || 0}`);
      return {
        framework: "value_chain",
        output,
        summary: {
          primaryActivitiesScore: output.primaryActivities?.summary?.valueCreationScore,
          supportActivitiesScore: output.supportActivities?.summary?.valueCreationScore,
          valueDrivers: output.valueDrivers?.length || 0,
          costDrivers: output.costDrivers?.length || 0,
          competitiveAdvantages: output.competitiveAdvantages?.length || 0,
          linkages: output.linkages?.length || 0,
          strategicOpportunities: output.strategicOpportunities?.length || 0,
          confidence: output.confidence
        }
      };
    } catch (error) {
      console.error("[Value Chain Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/vrio-executor.ts
init_vrio_analyzer();
var VRIOExecutor = class {
  name = "vrio";
  analyzer = new VRIOAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for VRIO resource evaluation"]
    };
  }
  async execute(context) {
    console.log("[VRIO Executor] Starting VRIO resource evaluation...");
    const vrioInput = {
      businessContext: context.userInput,
      resources: []
      // Would be extracted from context.insights if available
    };
    try {
      console.log("[VRIO Executor] Building resource evaluation context...");
      const output = await this.analyzer.analyze(vrioInput);
      console.log("[VRIO Executor] VRIO analysis complete");
      console.log(`  Resources Evaluated: ${output.evaluations?.length || 0}`);
      console.log(`  Sustained Advantage Resources: ${output.summary?.sustainedAdvantageResources?.length || 0}`);
      console.log(`  Temporary Advantage Resources: ${output.summary?.temporaryAdvantageResources?.length || 0}`);
      console.log(`  Parity Resources: ${output.summary?.parityResources?.length || 0}`);
      console.log(`  Disadvantage Resources: ${output.summary?.disadvantageResources?.length || 0}`);
      return {
        framework: "vrio",
        output,
        summary: {
          resourcesEvaluated: output.evaluations?.length || 0,
          sustainedAdvantage: output.summary?.sustainedAdvantageResources?.length || 0,
          temporaryAdvantage: output.summary?.temporaryAdvantageResources?.length || 0,
          parity: output.summary?.parityResources?.length || 0,
          disadvantage: output.summary?.disadvantageResources?.length || 0,
          recommendations: output.strategicRecommendations?.length || 0,
          confidence: output.confidence
        }
      };
    } catch (error) {
      console.error("[VRIO Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/scenario-planning-executor.ts
init_scenario_planning_analyzer();
var ScenarioPlanningExecutor = class {
  name = "scenario_planning";
  analyzer = new ScenarioPlanningAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for scenario planning"]
    };
  }
  async execute(context) {
    console.log("[Scenario Planning Executor] Starting scenario planning analysis...");
    const scenarioPlanningInput = {
      businessContext: context.userInput,
      timeHorizon: "3-5 years",
      // Would be extracted from context if available
      uncertainties: context.insights.externalForces || []
      // Would be extracted from PESTLE or previous frameworks
    };
    try {
      console.log("[Scenario Planning Executor] Building scenario analysis context...");
      console.log(`  Time Horizon: ${scenarioPlanningInput.timeHorizon}`);
      console.log(`  Key Uncertainties: ${scenarioPlanningInput.uncertainties.length}`);
      const output = await this.analyzer.analyze(scenarioPlanningInput);
      console.log("[Scenario Planning Executor] Scenario planning analysis complete");
      console.log(`  Scenarios Generated: ${output.scenarios?.length || 0}`);
      console.log(`  Critical Uncertainties: ${output.criticalUncertainties?.length || 0}`);
      console.log(`  Robust Strategies: ${output.robustStrategies?.length || 0}`);
      console.log(`  Strategic Options: ${output.strategicOptions?.length || 0}`);
      return {
        framework: "scenario_planning",
        output,
        summary: {
          scenarios: output.scenarios?.length || 0,
          timeHorizon: scenarioPlanningInput.timeHorizon,
          criticalUncertainties: output.criticalUncertainties?.length || 0,
          robustStrategies: output.robustStrategies?.length || 0,
          strategicOptions: output.strategicOptions?.length || 0,
          scenarioNames: output.scenarios?.map((s) => s.name) || [],
          confidence: output.confidence
        }
      };
    } catch (error) {
      console.error("[Scenario Planning Executor] Analysis failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/jtbd-executor.ts
init_jtbd_analyzer();
var JTBDExecutor = class {
  name = "jobs_to_be_done";
  analyzer = new JTBDAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for Jobs-To-Be-Done analysis"]
    };
  }
  async execute(context) {
    console.log("[JTBD Executor] Starting Jobs-To-Be-Done customer analysis...");
    const targetSegments = this.extractTargetSegments(context);
    const jtbdInput = {
      businessContext: context.userInput,
      ...targetSegments && { targetSegments },
      ...context.insights.bmcBlocks && { bmcOutput: context.insights.bmcBlocks }
    };
    try {
      console.log("[JTBD Executor] Building customer analysis context...");
      if (jtbdInput.bmcOutput) console.log("  - Including Business Model Canvas");
      if (jtbdInput.targetSegments?.length) console.log(`  - Analyzing ${jtbdInput.targetSegments.length} customer segments`);
      const jtbdOutput = await this.analyzer.analyze(jtbdInput);
      console.log("[JTBD Executor] Jobs-To-Be-Done analysis complete");
      console.log(`  Core Jobs: ${jtbdOutput.coreJobs?.length || 0}`);
      console.log(`  Related Jobs: ${jtbdOutput.relatedJobs?.length || 0}`);
      console.log(`  Underserved Jobs: ${jtbdOutput.opportunities?.underservedJobs?.length || 0}`);
      console.log(`  Top Opportunities: ${jtbdOutput.opportunities?.topOpportunities?.length || 0}`);
      return {
        framework: "jtbd",
        output: jtbdOutput,
        summary: {
          totalJobs: (jtbdOutput.coreJobs?.length || 0) + (jtbdOutput.relatedJobs?.length || 0),
          coreJobs: jtbdOutput.coreJobs?.map((j) => j.job) || [],
          opportunities: {
            underserved: jtbdOutput.opportunities?.underservedJobs?.length || 0,
            overserved: jtbdOutput.opportunities?.overservedJobs?.length || 0,
            top: jtbdOutput.opportunities?.topOpportunities?.length || 0,
            innovations: jtbdOutput.opportunities?.innovationDirections?.length || 0
          },
          alignment: {
            wellAligned: jtbdOutput.valuePropositionAlignment?.wellAligned?.length || 0,
            gaps: jtbdOutput.valuePropositionAlignment?.gaps?.length || 0
          },
          segmentsAnalyzed: jtbdOutput.metadata?.segmentsAnalyzed,
          confidence: jtbdOutput.confidence
        }
      };
    } catch (error) {
      console.error("[JTBD Executor] Analysis failed:", error);
      throw error;
    }
  }
  extractTargetSegments(context) {
    if (context.insights.bmcBlocks?.["Customer Segments"]) {
      const segments = context.insights.bmcBlocks["Customer Segments"];
      if (Array.isArray(segments)) {
        return segments.map((s) => typeof s === "string" ? { segment: s } : s);
      } else if (typeof segments === "string") {
        return [{ segment: segments }];
      }
    }
    return void 0;
  }
};

// server/journey/executors/okr-generator-executor.ts
init_okr_generator();
var OKRGeneratorExecutor = class {
  name = "okr_generator";
  generator = new OKRGenerator();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context required for OKR generation"]
    };
  }
  async execute(context) {
    console.log("[OKR Generator Executor] Starting OKR generation...");
    const okrGeneratorInput = {
      businessContext: context.userInput,
      strategicGoals: context.insights.keyOpportunities || [],
      // Would be extracted from previous frameworks
      timeframe: "12 months"
      // Would be extracted from context if available
    };
    try {
      console.log("[OKR Generator Executor] Building OKR generation context...");
      console.log(`  Strategic Goals: ${okrGeneratorInput.strategicGoals.length}`);
      console.log(`  Timeframe: ${okrGeneratorInput.timeframe}`);
      const output = await this.generator.generate(okrGeneratorInput);
      console.log("[OKR Generator Executor] OKR generation complete");
      console.log(`  OKRs Generated: ${output.okrs?.length || 0}`);
      console.log(`  Total Key Results: ${output.okrs?.reduce((sum, okr) => sum + (okr.keyResults?.length || 0), 0) || 0}`);
      console.log(`  Critical Priority OKRs: ${output.okrs?.filter((o) => o.priority === "critical").length || 0}`);
      console.log(`  Implementation Phases: ${output.implementation?.length || 0}`);
      return {
        framework: "okr_generator",
        output,
        summary: {
          okrsGenerated: output.okrs?.length || 0,
          totalKeyResults: output.okrs?.reduce((sum, okr) => sum + (okr.keyResults?.length || 0), 0) || 0,
          criticalOKRs: output.okrs?.filter((o) => o.priority === "critical").length || 0,
          highPriorityOKRs: output.okrs?.filter((o) => o.priority === "high").length || 0,
          implementationPhases: output.implementation?.length || 0,
          alignmentGoals: output.alignmentMap?.length || 0,
          successMetrics: output.successMetrics?.length || 0,
          confidence: output.confidence
        }
      };
    } catch (error) {
      console.error("[OKR Generator Executor] Generation failed:", error);
      throw error;
    }
  }
};

// server/journey/executors/ocean-strategy-executor.ts
init_ocean_strategy_analyzer();
var OceanStrategyExecutor = class {
  name = "ocean_strategy";
  analyzer = new OceanStrategyAnalyzer();
  async validate(context) {
    return {
      valid: !!context.userInput,
      errors: context.userInput ? void 0 : ["Business context is required"]
    };
  }
  async execute(context) {
    console.log("[OceanStrategy Executor] Starting Ocean Strategy analysis...");
    const insights = context.insights || {};
    const input = {
      businessContext: context.userInput,
      industry: this.extractIndustry(context),
      currentMarketPosition: this.extractMarketPosition(insights),
      competitiveLandscape: this.extractCompetitiveLandscape(insights),
      sustainabilityGoals: this.extractSustainabilityGoals(insights),
      blueOceanOutput: insights.blue_ocean,
      swotOutput: insights.swot,
      portersOutput: insights.porters
    };
    const result = await this.analyzer.analyze(input);
    console.log("[OceanStrategy Executor] Analysis complete");
    console.log(`  Recommended: ${result.recommendedOcean?.ocean} ocean`);
    console.log(`  Confidence: ${(result.confidence * 100).toFixed(0)}%`);
    return {
      ...result,
      summary: {
        currentOcean: result.currentOcean?.ocean,
        recommendedOcean: result.recommendedOcean?.ocean,
        assessmentCount: result.oceanAssessments?.length || 0,
        hasHybridStrategy: !!result.hybridStrategy,
        roadmapPhases: result.implementationRoadmap?.length || 0,
        priorityActionCount: result.priorityActions?.length || 0
      }
    };
  }
  extractIndustry(context) {
    const insights = context.insights || {};
    if (insights.bmc?.metadata?.industryAnalyzed) {
      return insights.bmc.metadata.industryAnalyzed;
    }
    if (insights.porters?.metadata?.industryAnalyzed) {
      return insights.porters.metadata.industryAnalyzed;
    }
    const industryMatch = context.userInput.match(/(?:industry|sector|market)[:\s]+([^.,\n]+)/i);
    return industryMatch?.[1]?.trim() || "General business";
  }
  extractMarketPosition(insights) {
    if (insights.competitive_positioning) {
      return JSON.stringify({
        position: insights.competitive_positioning.positioningRecommendation,
        advantages: insights.competitive_positioning.competitiveAdvantages
      });
    }
    if (insights.swot?.strengths) {
      return `Strengths: ${insights.swot.strengths.slice(0, 3).map((s) => s.factor).join(", ")}`;
    }
    return void 0;
  }
  extractCompetitiveLandscape(insights) {
    if (insights.porters) {
      return JSON.stringify({
        rivalry: insights.porters.competitiveRivalry?.score,
        newEntrants: insights.porters.threatOfNewEntrants?.score,
        attractiveness: insights.porters.overallAttractiveness?.score
      });
    }
    return void 0;
  }
  extractSustainabilityGoals(insights) {
    if (insights.pestle?.environmental) {
      return `Environmental factors: ${JSON.stringify(insights.pestle.environmental)}`;
    }
    return void 0;
  }
};

// server/journey/register-frameworks.ts
init_journey_registry();

// server/journey/startup-validator.ts
init_framework_executor_registry();
init_journey_registry();
var registeredBridges = /* @__PURE__ */ new Set();
function registerBridge(fromModule, toModule) {
  const bridgeId = `${fromModule}_to_${toModule}`;
  registeredBridges.add(bridgeId);
  console.log(`[Bridge Registry] \u2713 Registered bridge: ${bridgeId}`);
}
function hasBridge(fromModule, toModule) {
  return registeredBridges.has(`${fromModule}_to_${toModule}`);
}
var REQUIRED_BRIDGES = [
  // Market Entry Journey: PESTLE  Porter's  SWOT
  { from: "pestle", to: "porters", journeyTypes: ["market_entry", "competitive_strategy"] },
  { from: "porters", to: "swot", journeyTypes: ["market_entry", "competitive_strategy"] },
  // BMI Journey: Five Whys  BMC
  { from: "five_whys", to: "bmc", journeyTypes: ["business_model_innovation"] },
  // SWOT  Decisions (for all journeys that use SWOT)
  { from: "swot", to: "strategic_decisions", journeyTypes: ["market_entry", "competitive_strategy"] }
];
function validateJourneySystem(options = {}) {
  const { throwOnError = true, logOutput = true } = options;
  if (logOutput) {
    console.log("\n[Startup Validator] \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550");
    console.log("[Startup Validator] Validating journey system...\n");
  }
  const errors = [];
  const warnings = [];
  const missingExecutors = [];
  const missingBridges = [];
  const availableJourneys = getAvailableJourneys();
  const registeredFrameworks = new Set(frameworkRegistry2.getRegisteredFrameworks());
  if (logOutput) {
    console.log("[Startup Validator] Checking executor registration...");
  }
  for (const journey of availableJourneys) {
    for (const framework of journey.frameworks) {
      if (!registeredFrameworks.has(framework)) {
        const error = `Journey "${journey.name}" (${journey.type}) requires executor "${framework}" which is not registered`;
        errors.push(error);
        if (!missingExecutors.includes(framework)) {
          missingExecutors.push(framework);
        }
      }
    }
  }
  if (missingExecutors.length === 0 && logOutput) {
    console.log(`[Startup Validator] \u2713 All ${availableJourneys.length} journey(s) have registered executors`);
  }
  if (logOutput) {
    console.log("[Startup Validator] Checking bridge registration...");
  }
  for (const bridgeReq of REQUIRED_BRIDGES) {
    const needsBridge = availableJourneys.some(
      (j) => bridgeReq.journeyTypes.includes(j.type) && j.frameworks.includes(bridgeReq.from) && j.frameworks.includes(bridgeReq.to)
    );
    if (needsBridge && !hasBridge(bridgeReq.from, bridgeReq.to)) {
      const bridgeId = `${bridgeReq.from}_to_${bridgeReq.to}`;
      warnings.push(`Missing bridge ${bridgeId} required for journeys: ${bridgeReq.journeyTypes.join(", ")}`);
      if (!missingBridges.includes(bridgeId)) {
        missingBridges.push(bridgeId);
      }
    }
  }
  for (const journey of availableJourneys) {
    for (let i = 0; i < journey.frameworks.length - 1; i++) {
      const from = journey.frameworks[i];
      const to = journey.frameworks[i + 1];
      const dependency = journey.dependencies?.find((d) => d.from === from && d.to === to);
      if (dependency && !hasBridge(from, to)) {
        const bridgeId = `${from}_to_${to}`;
        const warning = `Journey "${journey.name}" has dependency ${from} \u2192 ${to} but no bridge registered`;
        if (!warnings.includes(warning)) {
          warnings.push(warning);
        }
        if (!missingBridges.includes(bridgeId)) {
          missingBridges.push(bridgeId);
        }
      }
    }
  }
  if (missingBridges.length === 0 && logOutput) {
    console.log(`[Startup Validator] \u2713 All required bridges registered (${registeredBridges.size} total)`);
  }
  if (logOutput) {
    console.log("[Startup Validator] Validating journey definitions...");
  }
  for (const journey of availableJourneys) {
    if (!journey.frameworks || journey.frameworks.length === 0) {
      errors.push(`Journey "${journey.name}" has no frameworks defined`);
    }
    if (journey.dependencies === void 0) {
      warnings.push(`Journey "${journey.name}" has no dependencies array defined`);
    }
    if (!journey.summaryBuilder) {
      warnings.push(`Journey "${journey.name}" has no summaryBuilder defined`);
    }
  }
  if (logOutput) {
    console.log(`[Startup Validator] \u2713 Journey definitions validated`);
  }
  const result = {
    valid: errors.length === 0,
    errors,
    warnings,
    summary: {
      journeysChecked: availableJourneys.length,
      executorsRegistered: registeredFrameworks.size,
      bridgesRegistered: registeredBridges.size,
      missingExecutors,
      missingBridges
    }
  };
  if (logOutput) {
    console.log("\n[Startup Validator] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500");
    console.log(`[Startup Validator] Summary:`);
    console.log(`  Journeys checked: ${result.summary.journeysChecked}`);
    console.log(`  Executors registered: ${result.summary.executorsRegistered}`);
    console.log(`  Bridges registered: ${result.summary.bridgesRegistered}`);
    if (warnings.length > 0) {
      console.log("\n[Startup Validator] \u26A0\uFE0F Warnings:");
      warnings.forEach((w) => console.log(`  - ${w}`));
    }
    if (errors.length > 0) {
      console.error("\n[Startup Validator] \u274C ERRORS:");
      errors.forEach((e) => console.error(`  - ${e}`));
    }
    console.log("[Startup Validator] \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n");
  }
  if (!result.valid && throwOnError) {
    throw new Error(
      `STARTUP ERROR: Journey system validation failed with ${errors.length} error(s):
` + errors.map((e) => `  - ${e}`).join("\n") + "\n\nFix these issues before the server can start."
    );
  }
  return result;
}
function registerAllBridges() {
  console.log("[Startup Validator] Registering bridges...");
  registerBridge("five_whys", "bmc");
  registerBridge("pestle", "porters");
  registerBridge("porters", "swot");
  registerBridge("five_whys", "swot");
  registerBridge("swot", "bmc");
  registerBridge("porters", "bmc");
  registerBridge("bmc", "blue_ocean");
  registerBridge("pestle", "bmc");
  registerBridge("bmc", "ansoff");
  registerBridge("pestle", "ansoff");
  registerBridge("ansoff", "bmc");
  console.log(`[Startup Validator] \u2713 Registered ${registeredBridges.size} bridge(s)`);
}

// server/journey/register-frameworks.ts
function registerFrameworkExecutors() {
  console.log("[Framework Registration] Initializing framework executor registry...");
  frameworkRegistry2.register(new FiveWhysExecutor());
  frameworkRegistry2.register(new BMCExecutor());
  frameworkRegistry2.register(new SegmentDiscoveryExecutor());
  frameworkRegistry2.register(new PortersExecutor());
  frameworkRegistry2.register(new PESTLEExecutor());
  frameworkRegistry2.register(new SWOTExecutor());
  frameworkRegistry2.register(new CompetitivePositioningExecutor());
  frameworkRegistry2.register(new AnsoffExecutor());
  frameworkRegistry2.register(new BlueOceanExecutor());
  frameworkRegistry2.register(new OceanStrategyExecutor());
  frameworkRegistry2.register(new BCGMatrixExecutor());
  frameworkRegistry2.register(new ValueChainExecutor());
  frameworkRegistry2.register(new VRIOExecutor());
  frameworkRegistry2.register(new ScenarioPlanningExecutor());
  frameworkRegistry2.register(new JTBDExecutor());
  frameworkRegistry2.register(new OKRGeneratorExecutor());
  const registered = frameworkRegistry2.getRegisteredFrameworks();
  console.log(`[Framework Registration] \u2713 Registered ${registered.length} framework executor(s):`);
  console.log(`  All implemented: ${registered.join(", ")}`);
  registerAllBridges();
  try {
    validateJourneySystem({ throwOnError: false, logOutput: true });
  } catch (error) {
    console.warn("[Framework Registration] Journey system validation warnings:", error);
  }
  validateJourneyIntegrity();
}
function validateJourneyIntegrity() {
  console.log("[Journey Validation] Checking journey executor integrity...");
  const availableJourneys = getAvailableJourneys();
  const registeredFrameworks = new Set(frameworkRegistry2.getRegisteredFrameworks());
  const errors = [];
  for (const journey of availableJourneys) {
    for (const framework of journey.frameworks) {
      if (!registeredFrameworks.has(framework)) {
        errors.push(
          `Journey "${journey.name}" (${journey.type}) requires framework "${framework}" but no executor is registered. Either register the executor or set available: false in journey-registry.ts`
        );
      }
    }
  }
  if (errors.length > 0) {
    console.error("[Journey Validation] \u274C STARTUP ERROR: Journey integrity check failed!");
    errors.forEach((err) => console.error(`  - ${err}`));
    throw new Error(
      `STARTUP ERROR: ${errors.length} journey(s) have missing framework executors. See logs above for details.`
    );
  }
  console.log(`[Journey Validation] \u2713 All ${availableJourneys.length} available journey(s) have registered executors`);
}

// server/index.ts
init_neo4j();
init_db_init();
init_auth_readiness();
init_container();

// server/modules/validate-modules.ts
init_manifests();
var MANIFEST_ID_TO_REGISTRY_KEY = {
  "swot-analyzer": "swot",
  "bmc-analyzer": "bmc",
  "porters-analyzer": "porters",
  "pestle-analyzer": "pestle",
  "five-whys-analyzer": "five_whys",
  "ansoff-analyzer": "ansoff",
  "blue-ocean-analyzer": "blue_ocean",
  "ocean-strategy-analyzer": "ocean_strategy",
  "bcg-matrix-analyzer": "bcg_matrix",
  "value-chain-analyzer": "value_chain",
  "vrio-analyzer": "vrio",
  "scenario-planning-analyzer": "scenario_planning",
  "jobs-to-be-done-analyzer": "jobs_to_be_done",
  "competitive-positioning-analyzer": "competitive_positioning",
  "segment-discovery-analyzer": "segment_discovery",
  "strategic-decisions": "strategic_decisions",
  "strategic-understanding": "strategic_understanding",
  "epm-generator": "epm",
  "okr-generator": "okr",
  "input-processor": "input_processor"
};
var MODULE_TYPE_VALID_VALUES = ["ai_analyzer", "user_input", "generator", "internal"];
function validateManifest2(manifest) {
  const errors = [];
  const warnings = [];
  if (!manifest.id) {
    errors.push("Missing manifest id");
  }
  if (!manifest.moduleType) {
    errors.push("Missing required moduleType field");
  } else if (!MODULE_TYPE_VALID_VALUES.includes(manifest.moduleType)) {
    errors.push(`Invalid moduleType: ${manifest.moduleType}. Must be one of: ${MODULE_TYPE_VALID_VALUES.join(", ")}`);
  }
  if (!manifest.type) {
    errors.push("Missing type field");
  }
  if (manifest.type === "analyzer" && manifest.moduleType !== "ai_analyzer") {
    warnings.push(`Analyzer type but moduleType is ${manifest.moduleType}, expected ai_analyzer`);
  }
  if (manifest.type === "generator" && manifest.moduleType !== "generator") {
    warnings.push(`Generator type but moduleType is ${manifest.moduleType}, expected generator`);
  }
  if (manifest.type === "user-input" && manifest.moduleType !== "user_input") {
    warnings.push(`User-input type but moduleType is ${manifest.moduleType}, expected user_input`);
  }
  if (!manifest.name) {
    errors.push("Missing name field");
  }
  if (!Array.isArray(manifest.inputs)) {
    errors.push("inputs must be an array");
  }
  if (!Array.isArray(manifest.outputs)) {
    errors.push("outputs must be an array");
  }
  if (manifest.status === "stub") {
    warnings.push("Module status is stub - not fully implemented");
  }
  if (!manifest.isActive) {
    warnings.push("Module is not active");
  }
  const registryKey = MANIFEST_ID_TO_REGISTRY_KEY[manifest.id];
  if (!registryKey) {
    warnings.push(`No registry key mapping for manifest id: ${manifest.id}`);
  }
  return {
    moduleId: manifest.id,
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function validateModuleSystem() {
  const results = [];
  const criticalErrors = [];
  if (allManifests.length === 0) {
    criticalErrors.push("No manifests found in allManifests array");
  }
  const manifestIds = /* @__PURE__ */ new Set();
  for (const manifest of allManifests) {
    if (manifestIds.has(manifest.id)) {
      criticalErrors.push(`Duplicate manifest id: ${manifest.id}`);
    }
    manifestIds.add(manifest.id);
    const result = validateManifest2(manifest);
    results.push(result);
  }
  const validModules = results.filter((r) => r.valid).length;
  const invalidModules = results.filter((r) => !r.valid).length;
  return {
    valid: criticalErrors.length === 0 && invalidModules === 0,
    totalModules: allManifests.length,
    validModules,
    invalidModules,
    results,
    criticalErrors
  };
}
function logValidationResults(validation) {
  console.log("\n=== MODULE SYSTEM VALIDATION ===");
  console.log(`Total Modules: ${validation.totalModules}`);
  console.log(`Valid: ${validation.validModules}`);
  console.log(`Invalid: ${validation.invalidModules}`);
  if (validation.criticalErrors.length > 0) {
    console.log("\n[CRITICAL ERRORS]:");
    validation.criticalErrors.forEach((e) => console.log(`  - ${e}`));
  }
  const failedModules = validation.results.filter((r) => !r.valid);
  if (failedModules.length > 0) {
    console.log("\n[FAILED MODULES]:");
    failedModules.forEach((r) => {
      console.log(`  ${r.moduleId}:`);
      r.errors.forEach((e) => console.log(`    ERROR: ${e}`));
    });
  }
  const modulesWithWarnings = validation.results.filter((r) => r.warnings.length > 0);
  if (modulesWithWarnings.length > 0) {
    console.log("\n[WARNINGS]:");
    modulesWithWarnings.forEach((r) => {
      r.warnings.forEach((w) => console.log(`  ${r.moduleId}: ${w}`));
    });
  }
  console.log(`
=== VALIDATION ${validation.valid ? "PASSED" : "FAILED"} ===
`);
}
async function validateOnStartup() {
  console.log("[Server] Validating module system...");
  const validation = validateModuleSystem();
  logValidationResults(validation);
  if (!validation.valid) {
    console.error("[Server] \u274C Module system validation FAILED");
    console.error("[Server] Fix the errors above before continuing");
  } else {
    console.log("[Server] \u2705 Module system validation passed");
  }
}

// server/index.ts
var originalExit = process.exit;
process.exit = ((code) => {
  if (code === 1 && process.env.NODE_ENV !== "production") {
    console.error("[Server] process.exit(1) was called - blocking to keep server alive");
    console.error("[Server] Stack trace:", new Error().stack);
    return void 0;
  }
  return originalExit(code);
});
process.on("unhandledRejection", (reason, promise) => {
  console.error("[Server] UNHANDLED PROMISE REJECTION:");
  console.error("[Server] Reason:", reason?.message || reason);
  console.error("[Server] Stack:", reason?.stack || "No stack trace");
});
process.on("uncaughtException", (error) => {
  console.error("[Server] UNCAUGHT EXCEPTION:");
  console.error("[Server] Error:", error.message);
  console.error("[Server] Stack:", error.stack);
});
var app = express2();
registerServices();
try {
  validateEncryptionKey();
} catch (error) {
  console.warn("[Server] WARNING: Encryption validation failed:", error.message);
  console.warn("[Server] Encrypted features may not work correctly");
}
registerFrameworkExecutors();
app.use(express2.json({
  limit: "50mb",
  verify: (req, _res, buf) => {
    req.rawBody = buf;
  }
}));
app.use(express2.urlencoded({ extended: false, limit: "50mb" }));
if (process.env.NODE_ENV === "development") {
  app.use((req, res, next) => {
    const start = Date.now();
    const path3 = req.path;
    let capturedJsonResponse = void 0;
    const originalResJson = res.json;
    res.json = function(bodyJson, ...args) {
      capturedJsonResponse = bodyJson;
      return originalResJson.apply(res, [bodyJson, ...args]);
    };
    res.on("finish", () => {
      const duration = Date.now() - start;
      if (path3.startsWith("/api")) {
        let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
        if (capturedJsonResponse) {
          logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
        }
        if (logLine.length > 80) {
          logLine = logLine.slice(0, 79) + "\u2026";
        }
        log(logLine);
      }
    });
    next();
  });
}
app.get("/health", (_req, res) => {
  res.status(200).json({ status: "ok" });
});
app.get("/health/auth", (_req, res) => {
  res.json({ ready: authReadiness.isReady() });
});
var appReady = false;
app.get("/", (req, res, next) => {
  const acceptHeader = req.get("Accept") || "";
  const isHealthProbe = acceptHeader.includes("application/json") || !acceptHeader.includes("text/html");
  if (isHealthProbe) {
    return res.status(200).json({ status: "ok", ready: appReady, timestamp: Date.now() });
  }
  next();
});
app.use((req, res, next) => {
  if (req.path.startsWith("/assets/") || req.path.match(/\.(js|css|png|jpg|jpeg|gif|svg|ico|woff|woff2|ttf|eot)$/)) {
    return next();
  }
  if (req.path.startsWith("/api/") || req.path.startsWith("/health")) {
    return next();
  }
  if (!appReady) {
    return res.status(200).send("<!DOCTYPE html><html><body><p>Application starting\u2026</p></body></html>");
  }
  next();
});
process.stdout.write("[INIT] Creating keepalive handles\n");
process.stdin.resume();
var keepalive = setInterval(() => {
  process.stdout.write("[KEEPALIVE] Tick at " + (/* @__PURE__ */ new Date()).toISOString() + "\n");
}, 1e4);
process.on("beforeExit", (code) => {
  console.log("[Server] beforeExit event fired with code:", code);
  setTimeout(() => {
    console.log("[Server] beforeExit recovery - process staying alive");
  }, 1e3);
});
process.stdout.write("[INIT] Keepalive handles created (stdin + 10s interval)\n");
process.stdout.write("[INIT] Creating HTTP server\n");
var server = createServer2(app);
var port = parseInt(process.env.PORT || "5000", 10);
process.stdout.write(`[INIT] Starting server on port ${port}
`);
server.on("error", (error) => {
  console.error("[Server] FATAL: Server error:", error);
  if (error.code === "EADDRINUSE") {
    console.error(`[Server] Port ${port} is already in use`);
  }
});
server.listen(port, process.env.HOST || "0.0.0.0", () => {
  log(`serving on port ${port}`);
  log("Server ready for health checks");
  setImmediate(() => {
    (async () => {
      try {
        log("[Server] Loading routes module...");
        const { registerRoutes: registerRoutes2 } = await Promise.resolve().then(() => (init_routes(), routes_exports));
        log("[Server] Registering application routes...");
        await registerRoutes2(app);
        log("[Server] Route registration complete (including auth)");
        await validateOnStartup();
        app.use((err, _req, res, _next) => {
          const status = err.status || err.statusCode || 500;
          const message = err.message || "Internal Server Error";
          res.status(status).json({ message });
          throw err;
        });
        if (app.get("env") === "development") {
          await setupVite(app, server);
        } else {
          serveStatic(app);
        }
        appReady = true;
        log("[Server] Static file serving configured - app ready");
      } catch (error) {
        console.error("[Server] WARNING: Route registration failed:", error.message);
        console.error("[Server] Health checks will work, but application routes are unavailable");
        console.error("[Server] Add required secrets in Replit deployment UI and redeploy");
      }
    })();
    setInterval(() => {
      backgroundJobService.processPendingJobs().catch((error) => {
        console.error("[Server] Background job dispatcher error:", error);
      });
    }, 15e3);
    log("Background job dispatcher started (polling every 15s)");
    (async () => {
      try {
        log("[Server] Starting database extension verification...");
        await initializeDatabaseExtensions();
        log("[Server] Database extension verification complete");
      } catch (error) {
        console.warn("[Server] WARNING: Extension verification failed:", error.message);
        console.warn("[Server] Knowledge Graph features will be disabled");
      }
    })();
    const hasNeo4jConfig = process.env.NEO4J_URI && process.env.NEO4J_PASSWORD;
    if (hasNeo4jConfig) {
      verifyConnection().then((connected) => {
        if (connected) {
          log("[Neo4j] Connection verified successfully");
        } else {
          console.warn("[Neo4j] WARNING: Connection failed. Knowledge Graph features may not work.");
        }
      }).catch((error) => {
        console.warn("[Neo4j] WARNING: Connection check failed:", error.message);
        console.warn("[Neo4j] Knowledge Graph features will not be available.");
      });
    } else {
      console.warn("[Neo4j] Not configured. Set NEO4J_URI and NEO4J_PASSWORD to enable Knowledge Graph features.");
    }
  });
});
