/**
   * Dependency Analyzer for EPM Synthesizer
   *
   * Analyzes function signatures to determine which operations can safely 
  run in parallel
   * by identifying what data each function reads vs writes
   */

  const fs = require('fs');
  const path = require('path');

  // Parse EPM Synthesizer to extract function signatures and parameters
  function analyzeEPMSynthesizer() {
    const filePath = path.join(__dirname,
  'server/intelligence/epm-synthesizer.ts');
    const content = fs.readFileSync(filePath, 'utf-8');

    console.log('='.repeat(80));
    console.log('EPM SYNTHESIZER DEPENDENCY ANALYSIS');
    console.log('='.repeat(80));
    console.log();

    // Extract all generate* function signatures
    const functionPattern = /async (generate\w+)\(([\s\S]*?)\):/g;
    const functions = [];
    let match;

    while ((match = functionPattern.exec(content)) !== null) {
      const funcName = match[1];
      const params = match[2]
        .split(',')
        .map(p => p.trim().split(':')[0].trim())
        .filter(p => p && !p.includes('//'));

      functions.push({ name: funcName, params });
    }

    console.log('ðŸ“Š FUNCTION PARAMETER ANALYSIS\n');
    console.log('Function Name | Reads From | Dependencies');
    console.log('-'.repeat(80));

    const dependencies = {};

    functions.forEach(func => {
      const deps = func.params.filter(p =>
        !['insights', 'userContext', 'namingContext', 'onProgress',
  'startTime', 'initiativeType'].includes(p)
      );
      dependencies[func.name] = {
        params: func.params,
        dependsOn: deps,
        readsOnly: func.params.filter(p => ['insights',
  'userContext'].includes(p)),
      };

      console.log(`${func.name.padEnd(30)} | ${func.params.join(', 
  ').substring(0, 30).padEnd(30)} | ${deps.join(', ') || 'NONE (can 
  parallelize!)'}`);
    });

    console.log();
    console.log('='.repeat(80));
    console.log('PARALLELIZATION GROUPS (functions with NO 
  cross-dependencies)');
    console.log('='.repeat(80));
    console.log();

    // Find independent groups
    const independent = functions.filter(f =>
  dependencies[f.name].dependsOn.length === 0);
    const dependent = functions.filter(f =>
  dependencies[f.name].dependsOn.length > 0);

    console.log('âœ… GROUP 1: INDEPENDENT (safe to parallelize)');
    console.log('-'.repeat(80));
    independent.forEach(f => {
      console.log(`  - ${f.name}`);
      console.log(`    Reads: ${dependencies[f.name].readsOnly.join(', ') ||
   'insights, userContext'}`);
      console.log(`    Writes: ${f.name.replace('generate', '')} 
  component`);
      console.log();
    });

    console.log('âš ï¸  GROUP 2: DEPENDENT (requires sequential or chained 
  execution)');
    console.log('-'.repeat(80));
    dependent.forEach(f => {
      console.log(`  - ${f.name}`);
      console.log(`    Reads: ${f.params.join(', ')}`);
      console.log(`    Dependencies: 
  ${dependencies[f.name].dependsOn.join(', ')}`);
      console.log();
    });

    // Build dependency chains
    console.log('='.repeat(80));
    console.log('DEPENDENCY CHAINS (must execute in order)');
    console.log('='.repeat(80));
    console.log();

    buildDependencyChains(dependencies);

    return { functions, dependencies, independent, dependent };
  }

  function buildDependencyChains(dependencies) {
    const chains = new Map();

    // Map outputs to their dependents
    Object.entries(dependencies).forEach(([funcName, info]) => {
      const output = funcName.replace('generate', '').toLowerCase();

      info.dependsOn.forEach(dep => {
        const depLower = dep.toLowerCase();
        if (!chains.has(depLower)) {
          chains.set(depLower, []);
        }
        chains.get(depLower).push(funcName);
      });
    });

    // Print chains
    const printed = new Set();

    function printChain(start, depth = 0) {
      const indent = '  '.repeat(depth);
      const arrow = depth > 0 ? 'â””â”€> ' : '';
      console.log(`${indent}${arrow}${start}`);
      printed.add(start);

      const dependents = chains.get(start.replace('generate',
  '').toLowerCase()) || [];
      dependents.forEach(dep => {
        if (!printed.has(dep)) {
          printChain(dep, depth + 1);
        }
      });
    }

    // Find root functions (those that don't depend on anything)
    const roots = Object.entries(dependencies)
      .filter(([_, info]) => info.dependsOn.length === 0)
      .map(([name, _]) => name);

    roots.forEach(root => {
      if (!printed.has(root)) {
        console.log(`\nChain starting from: ${root}`);
        printChain(root);
      }
    });

    console.log();
  }

  // Analyze BMC Analyzer
  function analyzeBMCAnalyzer() {
    const filePath = path.join(__dirname,
  'server/intelligence/bmc-analyzer.ts');
    const content = fs.readFileSync(filePath, 'utf-8');

    console.log('='.repeat(80));
    console.log('BMC ANALYZER DEPENDENCY ANALYSIS');
    console.log('='.repeat(80));
    console.log();

    // Find the analyze method
    const analyzeMethod = content.match(/async analyze\([\s\S]*?\n  \}/);
    if (analyzeMethod) {
      const calls = analyzeMethod[0].match(/await 
  this\.(extract\w+|infer\w+)\(/g) || [];

      console.log('ðŸ“Š EXTRACTION CALLS IN analyze() METHOD:\n');
      calls.forEach((call, idx) => {
        const methodName = call.replace('await this.', '').replace('(', '');
        console.log(`${idx + 1}. ${methodName}`);
      });

      console.log('\nâœ… ANALYSIS:');
      console.log('All extraction methods receive the SAME input 
  (frameworkResults)');
      console.log('None of them modify frameworkResults');
      console.log('They all return independent arrays of insights');
      console.log('â†’ SAFE TO PARALLELIZE with Promise.all\n');
    }
  }

  // Analyze Journey Orchestrator
  function analyzeJourneyOrchestrator() {
    const filePath = path.join(__dirname,
  'server/journey/journey-orchestrator.ts');
    const content = fs.readFileSync(filePath, 'utf-8');

    console.log('='.repeat(80));
    console.log('JOURNEY ORCHESTRATOR DEPENDENCY ANALYSIS');
    console.log('='.repeat(80));
    console.log();

    // Find the for loop in executeJourney
    const forLoopMatch = content.match(/for \(let i[\s\S]*?context = 
  addFrameworkResult[\s\S]*?\n\s+\}/);
    if (forLoopMatch) {
      console.log('ðŸ“Š FRAMEWORK EXECUTION PATTERN:\n');
      console.log('Current implementation:');
      console.log('  for (let i = 0; i < frameworks.length; i++) {');
      console.log('    const result = await 
  this.executeFramework(frameworkName, context);');
      console.log('    context = addFrameworkResult(context, result);  // âš ï¸
   CONTEXT MUTATION');
      console.log('  }');
      console.log();
      console.log('âš ï¸  CRITICAL FINDING:');
      console.log('  - Context is MUTATED between iterations');
      console.log('  - Each framework receives the accumulated context from 
  previous frameworks');
      console.log('  - Later frameworks may depend on earlier results');
      console.log();
      console.log('ðŸ” TO VERIFY PARALLELIZATION SAFETY:');
      console.log('  1. Check if frameworks actually READ from accumulated 
  context');
      console.log('  2. Check Five Whys â†’ BMC bridge (line 110-112)');
      console.log('  3. Trace context.insights usage in each framework');
      console.log();
    }

    // Check if context is actually used
    const executeFrameworkMethod = content.match(/private async 
  executeFramework\([\s\S]*?\n  \}/);
    if (executeFrameworkMethod) {
      const usesContext =
  executeFrameworkMethod[0].includes('context.insights') ||

  executeFrameworkMethod[0].includes('context.userInput');

      console.log('ðŸ“Š CONTEXT USAGE IN executeFramework():');
      if (executeFrameworkMethod[0].includes('context.userInput')) {
        console.log('  âœ… Uses: context.userInput (available from start)');
      }
      if (executeFrameworkMethod[0].includes('context.sessionId')) {
        console.log('  âœ… Uses: context.sessionId (available from start)');
      }
      if (executeFrameworkMethod[0].includes('context.insights')) {
        console.log('  âš ï¸  Uses: context.insights (accumulated from previous
   frameworks)');
      }

      console.log();
    }
  }

  // Main execution
  console.clear();
  console.log('\nðŸ”¬ DEPENDENCY ANALYSIS TOOL\n');

  try {
    // Analyze EPM Synthesizer
    const epmAnalysis = analyzeEPMSynthesizer();

    console.log('\n');

    // Analyze BMC Analyzer
    analyzeBMCAnalyzer();

    console.log('\n');

    // Analyze Journey Orchestrator
    analyzeJourneyOrchestrator();

    console.log('\n');
    console.log('='.repeat(80));
    console.log('SUMMARY & RECOMMENDATIONS');
    console.log('='.repeat(80));
    console.log();
    console.log('1. âœ… BMC Analyzer: SAFE to parallelize extract* methods');
    console.log('   Risk: LOW | Impact: MEDIUM | Effort: 5 minutes');
    console.log();
    console.log('2. âš ï¸  EPM Synthesizer: Need to verify Group 1 functions');
    console.log('   Risk: MEDIUM | Impact: HIGH | Effort: 2-3 hours');
    console.log('   Action: Review the independent functions list above');
    console.log();
    console.log('3. âš ï¸  Journey Orchestrator: Context mutation detected');
    console.log('   Risk: HIGH | Impact: HIGH | Effort: 4-6 hours');
    console.log('   Action: Trace if later frameworks actually use 
  accumulated context');
    console.log();

  } catch (error) {
    console.error('Error during analysis:', error.message);
  }
