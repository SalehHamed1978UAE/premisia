Please implement CPM post-processing on the multi‑agent output so we preserve
  CrewAI’s content but enforce the same schedule rigor as the legacy system:

  1. In server/services/epm-generator/multi-agent-generator.ts (where the CrewAI
     response is handled), import the CPM scheduler from the existing planning
     system:

  import { CPMScheduler } from '../../src/lib/intelligent-planning/scheduler';
  import type { Task } from '../../src/lib/intelligent-planning/types';

  2. After you get the JSON result from the CrewAI service, run it through a
     helper that converts each agent workstream into a CPM task, runs
     scheduler.schedule, and writes the calculated dates/slack back onto the
     workstreams. Example structure:

  async function postProcessWithCPM(crewOutput: EPMProgram): Promise<EPMProgram>
  {
    const tasks: Task[] = crewOutput.workstreams.map(ws => ({
      id: ws.id,
      name: ws.name,
      dependencies: ws.dependencies ?? [],
      duration: {
        optimistic: Math.max(1, (ws.endMonth - ws.startMonth) * 0.75),
        likely: ws.endMonth - ws.startMonth || ws.deliverables?.length || 2,
        pessimistic: Math.max(3, (ws.endMonth - ws.startMonth) * 1.5),
        unit: 'months',
      },
    }));

    const scheduler = new CPMScheduler();
    const schedule = scheduler.schedule(tasks);

    for (const scheduled of schedule.tasks) {
      const ws = crewOutput.workstreams.find(w => w.id === scheduled.id);
      if (ws) {
        Object.assign(ws, {
          startMonth: scheduled.earlyStart,
          endMonth: scheduled.earlyFinish,
          startDate: scheduled.startDate,
          endDate: scheduled.endDate,
          slack: scheduled.slack,
          isCritical: scheduled.isCritical,
        });
      }
    }

    crewOutput.timeline = {
      totalMonths: schedule.totalDuration,
      startDate: schedule.startDate,
      endDate: schedule.endDate,
      criticalPath: schedule.criticalPath,
      phases: buildPhasesFromSchedule(schedule),
      confidence: 0.85,
    };

    return crewOutput;
  }

  Add a simple buildPhasesFromSchedule helper (use our legacy logic: e.g.,
  Planning/Execution/Validation segments).

  3. Call this helper immediately after parsing the CrewAI response, before
     returning the EPMProgram. That way every multi-agent run gets proper CPM
     timelines, slack, and critical path info.
  4. Verify by running a multi-agent EPM job and checking the exported epm.json
     for:

  - timeline.criticalPath array
  - Each workstream has slack and isCritical
  - Dates respect dependency ordering

  This keeps the rich agent narratives but restores the mathematical scheduling
  rigor we already had.