# Intelligent Project Planning System - Modular Architecture

## Directory Structure

```
planning-system/
├── index.ts                    # Main entry point & factory functions
├── orchestrator.ts             # Coordinates all modules
├── types/
│   └── index.ts               # Core types and interfaces
├── extractors/
│   ├── interfaces.ts          # ITaskExtractor interface
│   └── llm-extractor.ts       # LLM-based task extraction
├── schedulers/
│   ├── interfaces.ts          # IScheduler interface  
│   ├── cpm.ts                 # Critical Path Method implementation
│   └── pert.ts               # PERT scheduling (alternative)
├── resources/
│   ├── interfaces.ts          # IResourceManager interface
│   ├── manager.ts            # Resource allocation & leveling
│   └── optimizer.ts          # Resource optimization algorithms
├── optimizers/
│   ├── interfaces.ts          # IOptimizer interface
│   ├── ai-optimizer.ts       # AI-powered optimization
│   ├── genetic.ts            # Genetic algorithm optimizer
│   └── simulated-annealing.ts # SA optimizer
├── validators/
│   ├── interfaces.ts          # IValidator interface
│   ├── llm-validator.ts      # LLM-based validation
│   └── rule-validator.ts     # Rule-based validation
├── llm/
│   ├── interfaces.ts          # LLMProvider interface
│   ├── openai.ts             # OpenAI implementation
│   ├── anthropic.ts          # Anthropic implementation
│   └── mock.ts               # Mock for testing
└── utils/
    ├── gantt-formatter.ts     # Convert to Gantt format
    ├── pert-calculator.ts     # PERT calculations
    └── critical-path.ts       # CPM utilities
```

## Modular Design Principles

### 1. Single Responsibility
Each module has ONE clear purpose:
- `schedulers/cpm.ts` - ONLY does CPM scheduling
- `resources/manager.ts` - ONLY handles resource allocation
- `optimizers/ai-optimizer.ts` - ONLY optimizes schedules

### 2. Interface Segregation
Every module implements a focused interface:
```typescript
interface IScheduler {
  schedule(tasks: Task[]): Schedule;
}

interface IResourceManager {
  allocate(schedule: Schedule, resources: Resource[]): ResourceAllocation;
  level(allocation: ResourceAllocation): LeveledSchedule;
}
```

### 3. Dependency Inversion
Modules depend on abstractions, not concretions:
```typescript
// orchestrator.ts depends on interfaces, not implementations
constructor(
  private extractor: ITaskExtractor,  // Interface
  private scheduler: IScheduler,      // Interface
  private optimizer: IOptimizer       // Interface
)
```

### 4. Open/Closed Principle
Add new implementations without modifying existing code:
```typescript
// Add new scheduling algorithm
export class PERTScheduler implements IScheduler { ... }

// Add new optimization method
export class GeneticOptimizer implements IOptimizer { ... }

// Use them without changing orchestrator
const orchestrator = createOrchestrator({
  scheduler: new PERTScheduler(),     // Swap implementation
  optimizer: new GeneticOptimizer()   // Swap implementation
});
```

## Usage Examples

### Basic Usage
```typescript
import { createPlanningSystem } from '@/planning-system';

const planner = createPlanningSystem({
  openaiApiKey: process.env.OPENAI_KEY
});

const result = await planner.plan({
  strategy: epmProgram,
  constraints: [...],
  resources: [...]
});
```

### Use Individual Modules
```typescript
import { createCPMScheduler } from '@/planning-system/schedulers/cpm';
import { createResourceManager } from '@/planning-system/resources/manager';

// Use scheduler independently
const scheduler = createCPMScheduler();
const schedule = scheduler.schedule(tasks);

// Use resource manager independently
const resourceManager = createResourceManager();
const allocation = resourceManager.allocate(schedule, resources);
```

### Custom Configuration
```typescript
import { createOrchestrator } from '@/planning-system/orchestrator';
import { CustomScheduler } from './my-scheduler';
import { CustomOptimizer } from './my-optimizer';

const orchestrator = createOrchestrator({
  scheduler: new CustomScheduler(),     // Your implementation
  optimizer: new CustomOptimizer(),     // Your implementation
  extractor: customExtractor,
  validator: customValidator,
  resourceManager: customResourceManager
});
```

### Testing Individual Modules
```typescript
import { CPMScheduler } from '@/planning-system/schedulers/cpm';
import { createMockTasks } from '@/planning-system/testing';

describe('CPMScheduler', () => {
  it('should calculate critical path', () => {
    const scheduler = new CPMScheduler();
    const tasks = createMockTasks();
    
    const schedule = scheduler.schedule(tasks);
    
    expect(schedule.criticalPath).toHaveLength(3);
    expect(schedule.totalDuration).toBe(12);
  });
});
```

## Integration with Your EPM System

In your EPM generation endpoint:
```typescript
// server/routes/strategy-workspace.ts

import { generateIntelligentSchedule } from '@/planning-system';

async function generateEPMProgram(req, res) {
  // ... existing EPM generation logic ...
  
  // Replace timeline generation with intelligent planning
  const planningResult = await generateIntelligentSchedule(
    epmProgram,
    businessContext,
    {
      openaiApiKey: process.env.OPENAI_KEY,
      maxDuration: 12,
      budget: 500000,
      resources: availableResources
    }
  );
  
  if (planningResult.success) {
    // Use the optimized schedule
    epmProgram.timeline = planningResult.schedule;
    epmProgram.workstreams = planningResult.schedule.tasks;
  } else {
    // Handle planning failure
    return res.json({
      success: false,
      program: epmProgram,
      warnings: planningResult.warnings,
      adjustments: planningResult.adjustments
    });
  }
  
  // ... continue with EPM generation ...
}
```

## Benefits of This Architecture

### 1. Testability
Each module can be tested in isolation:
```typescript
const mockScheduler = {
  schedule: jest.fn().mockResolvedValue(mockSchedule)
};
```

### 2. Replaceability
Swap implementations without touching other code:
```typescript
// Switch from OpenAI to Anthropic
const llm = createAnthropicProvider() // Instead of createOpenAIProvider()
```

### 3. Reusability
Use modules in different contexts:
```typescript
// Use scheduler for resource planning
const resourceSchedule = scheduler.schedule(resourceTasks);

// Use validator for quality checks
const validation = validator.validate(customSchedule);
```

### 4. Maintainability
- Clear boundaries between modules
- Easy to find and fix issues
- Can update one module without affecting others

### 5. Scalability
- Add new scheduling algorithms
- Add new optimization strategies
- Add new validation rules
- All without modifying existing code

## Key Differences from Monolithic Approach

| Monolithic | Modular |
|------------|---------|
| One 2000-line file | 15+ focused files |
| Hard to test | Each module testable |
| Changes affect everything | Isolated changes |
| One implementation | Multiple implementations |
| Tightly coupled | Loosely coupled |
| Hard to understand | Clear responsibilities |

## Next Steps

1. **Install dependencies**
```bash
npm install --save date-fns lodash
npm install --save-dev @types/node jest
```

2. **Add to your project**
```bash
cp -r planning-system src/lib/
```

3. **Configure TypeScript paths**
```json
{
  "compilerOptions": {
    "paths": {
      "@/planning-system/*": ["./src/lib/planning-system/*"]
    }
  }
}
```

4. **Use in your EPM system**
- Replace timeline generation
- Add planning step before Gantt rendering
- Show strategy adjustments when needed

This is TRUE modularity - separate files, clear interfaces, swappable implementations, and testable units.
