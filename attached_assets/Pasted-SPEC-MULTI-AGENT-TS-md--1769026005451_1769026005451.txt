SPEC_MULTI_AGENT_TS.md
  -----------------------------------------------------------------------
  # TypeScript Multi-Agent Planner Specification

  ## Goals
  - Replace CrewAI/Python with a TypeScript-only planner.
  - Run 7 agents per round (Tech, Finance, Risk, GTM, Customer Success, Platform
  Delivery, Coordinator).
  - Save every turn to DB so we can resume mid-run.
  - Output must match the structure the WBS builder expects (workstreams,
  timelines, deliverables).

  ## Architecture Overview
  - Agents and rounds are defined as config (`config/agents.ts`, `config/
  rounds.ts`) so we can add or modify without touching code.
  - Planner executes a loop: for each round, call all participating agents with
  the current context, store their outputs, then call the coordinator to
  synthesize conflicts and next steps.
  - Every agent call returns structured JSON (enforce via Zod schemas) so we can
  feed it into the WBS builder.

  ## Data Flow
  1. **Session Start**: Create `multi_agent_sessions` row with status `running`.
  2. **Round Execution**:
     - For each agent in the round:
       - Build prompt with role + business context + prior round outputs.
       - Call LLM via existing `aiClients.callWithFallback`.
       - Validate output against schema; save to `multi_agent_turns` table
  (turn_id, round, agent_id, input, output, timestamp).
     - Run coordinator synthesis over all agent outputs; save to DB.
     - Update round status in `multi_agent_rounds` table (round_id, status,
  summary).
  3. **Checkpoint**: Because each turn is appended to `multi_agent_turns`, we
  can resume any round by reloading the turn list and continuing from the next
  agent.
  4. **Finalization**: Once all rounds complete, merge the structured outputs
  into the planning context and pass to the existing WBS builder/EPMSynthesizer.
  Persist the final `epmProgram` record and mark the session `completed`.

  ## Modules
  - `planners/multi-agent/agent-manager.ts` – loads agent definitions, builds
  prompts, validates output.
  - `planners/multi-agent/round-runner.ts` – orchestrates agent calls per round;
  handles retries/timeouts; saves logs.
  - `planners/multi-agent/checkpoint-service.ts` – reads/writes to
  `multi_agent_sessions`, `multi_agent_rounds`, `multi_agent_turns`.
  - `planners/multi-agent/synthesis.ts` – prompts the coordinator to combine
  agent outputs, detect conflicts, and produce normalized workstream/resource/
  risk structures compatible with the WBS builder.
  - `planners/multi-agent/resume.ts` – loads last completed agent and round,
  rebuilds the conversation context, and resumes execution.

  ## Prompt Strategy
  - Each agent gets:
    - Role-specific system prompt (stored in `config/agents.ts`).
    - Round objectives and expected outputs (from `config/rounds.ts`).
    - Prior agent outputs (or coordinator summary) as context.
    - Strict output schema instructions (JSON with fields the coordinator can
  parse).
  - Coordinator prompt explicitly asks to list conflicts between agent outputs
  and resolve them before synthesizing.

  ## Persistence Tables
  - `multi_agent_sessions (id, journey_session_id, status, current_round,
  started_at, updated_at)`
  - `multi_agent_rounds (id, session_id, round_number, status, started_at,
  ended_at, summary)`
  - `multi_agent_turns (id, round_id, agent_id, prompt, output, created_at)`
  - Optionally `multi_agent_errors` for failed turns.

  ## Resuming
  - On start, check `multi_agent_sessions`:
    - If `status = running`, determine which round/agent was last saved.
    - Load all outputs up to that point into memory and continue with the next
  agent.
    - Since every turn is saved, the planner can rebuild context (prompts
  include the entire history or just the relevant summary from previous rounds).

  ## Output Alignment
  - Coordinator synthesis normalizes agent outputs into:
    - Workstream updates (name, description, owner, start/end months,
  deliverables)
    - Risks (description, probability, impact, mitigation)
    - Resource requirements (role, skills, allocation)
  - These structures feed into the existing `ContextBuilder` and
  `EPMSynthesizer`, so final EPM output quality matches the legacy WBS builder
  path.

  ## API Endpoints
  - `POST /api/multi-agent/generate` – start or resume generation; returns
  session/job ID immediately.
  - `GET /api/multi-agent/status/:sessionId` – returns current round, completed
  agents, and percent complete.
  - `GET /api/multi-agent/result/:sessionId` – returns the final EPM program
  once finished.

  ## Concurrency & Cost
  - Each round runs 6 “expert” agents in parallel (Promise.all) followed by the
  coordinator.
  - Configure a per-agent timeout (e.g., 90s) and retry once on failure; log
  errors and skip if a particular agent repeatedly fails.
  - Because logs are persisted, even if a process crashes, the next run reads
  the turn list and continues without re-calling finished agents.

  ## Implementation Steps
  1. Create DB tables/migrations for sessions, rounds, turns.
  2. Build `checkpoint-service.ts` to read/write session/round/turn data.
  3. Implement `agent-manager.ts` with prompt templates + schema validation.
  4. Add `round-runner.ts` to orchestrate rounds and call `agent-manager`.
  5. Create the coordinator synthesis module that outputs the normalized
  planning structures.
  6. Integrate with the existing `ContextBuilder` and `EPMSynthesizer`.
  7. Replace the CrewAI call in `multi-agent-generator.ts` with this planner.
  8. Remove Python service; all multi-agent logic now lives in TypeScript/Node.

  Once this planner is in place, we get:
  - Guaranteed resume capability (every turn logged).
  - Same quality as the WBS builder (since coordinator output is structured for
  it).
  - No external Python dependencies.
  - Clear logging and debugging per agent/round.